This is
/home/melpa/melpa/working/python-info-20130916.1420/python.info,
produced by makeinfo version 4.13 from
/home/melpa/melpa/working/python-info/python.texi.

Generated by Sphinx 1.1.3.
INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY

     Python 2.7.5, September 16, 2013

     Georg Brandl

     Copyright (C) 1990-2013, Python Software Foundation


File: python.info,  Node: Parser Objects,  Prev: Player Objects,  Up: cd --- CD-ROM access on SGI systems

5.38.3.2 Parser Objects
.......................

Parser objects (returned by *note createparser(): 28d5.) have the
following methods:

 -- Method: CD parser.addcallback(type, func, arg)
     Adds a callback for the parser.  The parser has callbacks for
     eight different types of data in the digital audio data stream.
     Constants for these types are defined at the *note cd: 5a. module
     level (see above). The callback is called as follows: `func(arg,
     type, data)', where _arg_ is the user supplied argument, _type_ is
     the particular type of callback, and _data_ is the data returned
     for this _type_ of callback.  The type of the data depends on the
     _type_ of callback as follows:

     Type              Value
     -------------------------------------------------------------------- 
     `audio'           String which can be passed unmodified to
                       `al.writesamps()'.
     `pnum'            Integer giving the program (track) number.
     `index'           Integer giving the index number.
     `ptime'           Tuple consisting of the program time in minutes,
                       seconds, and frames.
     `atime'           Tuple consisting of the absolute time in
                       minutes, seconds, and frames.
     `catalog'         String of 13 characters, giving the catalog
                       number of the CD.
     `ident'           String of 12 characters, giving the ISRC
                       identification number of the recording.  The
                       string consists of two characters country code,
                       three characters owner code, two characters
                       giving the year, and five characters giving a
                       serial number.
     `control'         Integer giving the control bits from the CD
                       subcode data


 -- Method: CD parser.deleteparser()
     Deletes the parser and frees the memory it was using.  The object
     should not be used after this call.  This call is done
     automatically when the last reference to the object is removed.

 -- Method: CD parser.parseframe(frame)
     Parses one or more frames of digital audio data from a CD such as
     returned by `readda()'.  It determines which subcodes are present
     in the data.  If these subcodes have changed since the last frame,
     then `parseframe()' executes a callback of the appropriate type
     passing to it the subcode data found in the frame. Unlike the C
     function, more than one frame of digital audio data can be passed
     to this method.

 -- Method: CD parser.removecallback(type)
     Removes the callback for the given _type_.

 -- Method: CD parser.resetparser()
     Resets the fields of the parser used for tracking subcodes to an
     initial state.  `resetparser()' should be called after the disc
     has been changed.


File: python.info,  Node: fl --- FORMS library for graphical user interfaces,  Next: FL --- Constants used with the fl module,  Prev: cd --- CD-ROM access on SGI systems,  Up: SGI IRIX Specific Services

5.38.4 `fl' -- FORMS library for graphical user interfaces
----------------------------------------------------------

Deprecated since version 2.6: The *note fl: cf. module has been removed
in Python 3.

  This module provides an interface to the FORMS Library by Mark
Overmars.  The source for the library can be retrieved by anonymous ftp
from host `ftp.cs.ruu.nl', directory `SGI/FORMS'.  It was last tested
with version 2.0b.

  Most functions are literal translations of their C equivalents,
dropping the initial `fl_' from their name.  Constants used by the
library are defined in module *note FL: ce. described below.

  The creation of objects is a little different in Python than in C:
instead of the 'current form' maintained by the library to which new
FORMS objects are added, all functions that add a FORMS object to a
form are methods of the Python object representing the form.
Consequently, there are no Python equivalents for the C functions
`fl_addto_form()' and `fl_end_form()', and the equivalent of
`fl_bgn_form()' is called *note fl.make_form(): 28ef.

  Watch out for the somewhat confusing terminology: FORMS uses the word
_object_ for the buttons, sliders etc. that you can place in a form. In
Python, 'object' means any value.  The Python interface to FORMS
introduces two new Python object types: form objects (representing an
entire form) and FORMS objects (representing one button, slider etc.).
Hopefully this isn't too confusing.

  There are no 'free objects' in the Python interface to FORMS, nor is
there an easy way to add object classes written in Python.  The FORMS
interface to GL event handling is available, though, so you can mix
FORMS with pure GL windows.

  *Please note:* importing *note fl: cf. implies a call to the GL
function `foreground()' and to the FORMS routine `fl_init()'.

* Menu:

* Functions Defined in Module fl::
* Form Objects::
* FORMS Objects::


File: python.info,  Node: Functions Defined in Module fl,  Next: Form Objects,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.1 Functions Defined in Module `fl'
.........................................

Module *note fl: cf. defines the following functions.  For more
information about what they do, see the description of the equivalent C
function in the FORMS documentation:

 -- Function: fl.make_form (type, width, height)
     Create a form with given type, width and height.  This returns a
     _form_ object, whose methods are described below.

 -- Function: fl.do_forms ()
     The standard FORMS main loop.  Returns a Python object
     representing the FORMS object needing interaction, or the special
     value `FL.EVENT'.

 -- Function: fl.check_forms ()
     Check for FORMS events.  Returns what *note do_forms(): 28f2.
     above returns, or `None' if there is no event that immediately
     needs interaction.

 -- Function: fl.set_event_call_back (function)
     Set the event callback function.

 -- Function: fl.set_graphics_mode (rgbmode, doublebuffering)
     Set the graphics modes.

 -- Function: fl.get_rgbmode ()
     Return the current rgb mode.  This is the value of the C global
     variable `fl_rgbmode'.

 -- Function: fl.show_message (str1, str2, str3)
     Show a dialog box with a three-line message and an OK button.

 -- Function: fl.show_question (str1, str2, str3)
     Show a dialog box with a three-line message and YES and NO
     buttons. It returns `1' if the user pressed YES, `0' if NO.

 -- Function: fl.show_choice (str1, str2, str3, but1[, but2[, but3]])
     Show a dialog box with a three-line message and up to three
     buttons. It returns the number of the button clicked by the user
     (`1', `2' or `3').

 -- Function: fl.show_input (prompt, default)
     Show a dialog box with a one-line prompt message and text field in
     which the user can enter a string.  The second argument is the
     default input string.  It returns the string value as edited by
     the user.

 -- Function: fl.show_file_selector (message, directory, pattern,
          default)
     Show a dialog box in which the user can select a file.  It returns
     the absolute filename selected by the user, or `None' if the user
     presses Cancel.

 -- Function: fl.get_directory ()
 -- Function: fl.get_pattern ()
 -- Function: fl.get_filename ()
     These functions return the directory, pattern and filename (the
     tail part only) selected by the user in the last *note
     show_file_selector(): 28fb. call.

 -- Function: fl.qdevice (dev)
 -- Function: fl.unqdevice (dev)
 -- Function: fl.isqueued (dev)
 -- Function: fl.qtest ()
 -- Function: fl.qread ()
 -- Function: fl.qreset ()
 -- Function: fl.qenter (dev, val)
 -- Function: fl.get_mouse ()
 -- Function: fl.tie (button, valuator1, valuator2)
     These functions are the FORMS interfaces to the corresponding GL
     functions.  Use these if you want to handle some GL events
     yourself when using `fl.do_events()'.  When a GL event is detected
     that FORMS cannot handle, *note fl.do_forms(): 28f2. returns the
     special value `FL.EVENT' and you should call *note fl.qread():
     2903. to read the event from the queue.  Don't use the equivalent
     GL functions!


 -- Function: fl.color ()
 -- Function: fl.mapcolor ()
 -- Function: fl.getmcolor ()
     See the description in the FORMS documentation of `fl_color()',
     `fl_mapcolor()' and `fl_getmcolor()'.


File: python.info,  Node: Form Objects,  Next: FORMS Objects,  Prev: Functions Defined in Module fl,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.2 Form Objects
.....................

Form objects (returned by *note make_form(): 28ef. above) have the
following methods.  Each method corresponds to a C function whose name
is prefixed with `fl_'; and whose first argument is a form pointer;
please refer to the official FORMS documentation for descriptions.

  All the `add_*()' methods return a Python object representing the
FORMS object.  Methods of FORMS objects are described below.  Most
kinds of FORMS object also have some methods specific to that kind;
these methods are listed here.

 -- Method: form.show_form (placement, bordertype, name)
     Show the form.

 -- Method: form.hide_form ()
     Hide the form.

 -- Method: form.redraw_form ()
     Redraw the form.

 -- Method: form.set_form_position (x, y)
     Set the form's position.

 -- Method: form.freeze_form ()
     Freeze the form.

 -- Method: form.unfreeze_form ()
     Unfreeze the form.

 -- Method: form.activate_form ()
     Activate the form.

 -- Method: form.deactivate_form ()
     Deactivate the form.

 -- Method: form.bgn_group ()
     Begin a new group of objects; return a group object.

 -- Method: form.end_group ()
     End the current group of objects.

 -- Method: form.find_first ()
     Find the first object in the form.

 -- Method: form.find_last ()
     Find the last object in the form.

 -- Method: form.add_box (type, x, y, w, h, name)
     Add a box object to the form. No extra methods.

 -- Method: form.add_text (type, x, y, w, h, name)
     Add a text object to the form. No extra methods.

 -- Method: form.add_clock (type, x, y, w, h, name)
     Add a clock object to the form.  --  Method: `get_clock()'.

 -- Method: form.add_button (type, x, y, w, h, name)
     Add a button object to the form.  --  Methods: `get_button()',
     `set_button()'.

 -- Method: form.add_lightbutton (type, x, y, w, h, name)
     Add a lightbutton object to the form.  --  Methods: `get_button()',
     `set_button()'.

 -- Method: form.add_roundbutton (type, x, y, w, h, name)
     Add a roundbutton object to the form.  --  Methods: `get_button()',
     `set_button()'.

 -- Method: form.add_slider (type, x, y, w, h, name)
     Add a slider object to the form.  --  Methods:
     `set_slider_value()', `get_slider_value()', `set_slider_bounds()',
     `get_slider_bounds()', `set_slider_return()', `set_slider_size()',
     `set_slider_precision()', `set_slider_step()'.

 -- Method: form.add_valslider (type, x, y, w, h, name)
     Add a valslider object to the form.  --  Methods:
     `set_slider_value()', `get_slider_value()', `set_slider_bounds()',
     `get_slider_bounds()', `set_slider_return()', `set_slider_size()',
     `set_slider_precision()', `set_slider_step()'.

 -- Method: form.add_dial (type, x, y, w, h, name)
     Add a dial object to the form.  --  Methods: `set_dial_value()',
     `get_dial_value()', `set_dial_bounds()', `get_dial_bounds()'.

 -- Method: form.add_positioner (type, x, y, w, h, name)
     Add a positioner object to the form.  --  Methods:
     `set_positioner_xvalue()', `set_positioner_yvalue()',
     `set_positioner_xbounds()', `set_positioner_ybounds()',
     `get_positioner_xvalue()', `get_positioner_yvalue()',
     `get_positioner_xbounds()', `get_positioner_ybounds()'.

 -- Method: form.add_counter (type, x, y, w, h, name)
     Add a counter object to the form.  --  Methods:
     `set_counter_value()', `get_counter_value()',
     `set_counter_bounds()', `set_counter_step()',
     `set_counter_precision()', `set_counter_return()'.

 -- Method: form.add_input (type, x, y, w, h, name)
     Add a input object to the form.  --  Methods: `set_input()',
     `get_input()', `set_input_color()', `set_input_return()'.

 -- Method: form.add_menu (type, x, y, w, h, name)
     Add a menu object to the form.  --  Methods: `set_menu()',
     `get_menu()', `addto_menu()'.

 -- Method: form.add_choice (type, x, y, w, h, name)
     Add a choice object to the form.  --  Methods: `set_choice()',
     `get_choice()', `clear_choice()', `addto_choice()',
     `replace_choice()', `delete_choice()', `get_choice_text()',
     `set_choice_fontsize()', `set_choice_fontstyle()'.

 -- Method: form.add_browser (type, x, y, w, h, name)
     Add a browser object to the form.  --  Methods:
     `set_browser_topline()', `clear_browser()', `add_browser_line()',
     `addto_browser()', `insert_browser_line()',
     `delete_browser_line()', `replace_browser_line()',
     `get_browser_line()', `load_browser()', `get_browser_maxline()',
     `select_browser_line()', `deselect_browser_line()',
     `deselect_browser()', `isselected_browser_line()', `get_browser()',
     `set_browser_fontsize()', `set_browser_fontstyle()',
     `set_browser_specialkey()'.

 -- Method: form.add_timer (type, x, y, w, h, name)
     Add a timer object to the form.  --  Methods: `set_timer()',
     `get_timer()'.

  Form objects have the following data attributes; see the FORMS
documentation:

Name                      C Type                Meaning
------------------------------------------------------------------------------------- 
`window'                  int (read-only)       GL window id
`w'                       float                 form width
`h'                       float                 form height
`x'                       float                 form x origin
`y'                       float                 form y origin
`deactivated'             int                   nonzero if form is deactivated
`visible'                 int                   nonzero if form is visible
`frozen'                  int                   nonzero if form is frozen
`doublebuf'               int                   nonzero if double buffering on


File: python.info,  Node: FORMS Objects,  Prev: Form Objects,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.3 FORMS Objects
......................

Besides methods specific to particular kinds of FORMS objects, all
FORMS objects also have the following methods:

 -- Method: FORMS object.set_call_back(function, argument)
     Set the object's callback function and argument.  When the object
     needs interaction, the callback function will be called with two
     arguments: the object, and the callback argument.  (FORMS objects
     without a callback function are returned by *note fl.do_forms():
     28f2. or *note fl.check_forms(): 28f3. when they need
     interaction.)  Call this method without arguments to remove the
     callback function.

 -- Method: FORMS object.delete_object()
     Delete the object.

 -- Method: FORMS object.show_object()
     Show the object.

 -- Method: FORMS object.hide_object()
     Hide the object.

 -- Method: FORMS object.redraw_object()
     Redraw the object.

 -- Method: FORMS object.freeze_object()
     Freeze the object.

 -- Method: FORMS object.unfreeze_object()
     Unfreeze the object.

  FORMS objects have these data attributes; see the FORMS documentation:

Name                     C Type                Meaning
---------------------------------------------------------------------- 
`objclass'               int (read-only)       object class
*note type: 487.         int (read-only)       object type
`boxtype'                int                   box type
`x'                      float                 x origin
`y'                      float                 y origin
`w'                      float                 width
`h'                      float                 height
`col1'                   int                   primary color
`col2'                   int                   secondary color
`align'                  int                   alignment
`lcol'                   int                   label color
`lsize'                  float                 label font size
`label'                  string                label string
`lstyle'                 int                   label style
`pushed'                 int (read-only)       (see FORMS docs)
`focus'                  int (read-only)       (see FORMS docs)
`belowmouse'             int (read-only)       (see FORMS docs)
`frozen'                 int (read-only)       (see FORMS docs)
`active'                 int (read-only)       (see FORMS docs)
*note input: 3b8.        int (read-only)       (see FORMS docs)
`visible'                int (read-only)       (see FORMS docs)
`radio'                  int (read-only)       (see FORMS docs)
`automatic'              int (read-only)       (see FORMS docs)


File: python.info,  Node: FL --- Constants used with the fl module,  Next: flp --- Functions for loading stored FORMS designs,  Prev: fl --- FORMS library for graphical user interfaces,  Up: SGI IRIX Specific Services

5.38.5 `FL' -- Constants used with the `fl' module
--------------------------------------------------

Deprecated since version 2.6: The *note FL: ce. module has been removed
in Python 3.

  This module defines symbolic constants needed to use the built-in
module *note fl: cf. (see above); they are equivalent to those defined
in the C header file `<forms.h>' except that the name prefix `FL_' is
omitted.  Read the module source for a complete list of the defined
names.  Suggested use:

    import fl
    from FL import *



File: python.info,  Node: flp --- Functions for loading stored FORMS designs,  Next: fm --- Font Manager interface,  Prev: FL --- Constants used with the fl module,  Up: SGI IRIX Specific Services

5.38.6 `flp' -- Functions for loading stored FORMS designs
----------------------------------------------------------

Deprecated since version 2.6: The *note flp: d0. module has been
removed in Python 3.

  This module defines functions that can read form definitions created
by the 'form designer' (*fdesign*) program that comes with the FORMS
library (see module *note fl: cf. above).

  For now, see the file `flp.doc' in the Python library source
directory for a description.

  XXX A complete description should be inserted here!


File: python.info,  Node: fm --- Font Manager interface,  Next: gl --- Graphics Library interface,  Prev: flp --- Functions for loading stored FORMS designs,  Up: SGI IRIX Specific Services

5.38.7 `fm' -- _Font Manager_ interface
---------------------------------------

Deprecated since version 2.6: The *note fm: d1. module has been removed
in Python 3.

  This module provides access to the IRIS _Font Manager_ library.   It
is available only on Silicon Graphics machines. See also: _4Sight
User's Guide_, section 1, chapter 5: "Using the IRIS Font Manager."

  This is not yet a full interface to the IRIS Font Manager. Among the
unsupported features are: matrix operations; cache operations;
character operations (use string operations instead); some details of
font info; individual glyph metrics; and printer matching.

  It supports the following operations:

 -- Function: fm.init ()
     Initialization function. Calls `fminit()'. It is normally not
     necessary to call this function, since it is called automatically
     the first time the *note fm: d1. module is imported.

 -- Function: fm.findfont (fontname)
     Return a font handle object. Calls `fmfindfont(fontname)'.

 -- Function: fm.enumerate ()
     Returns a list of available font names. This is an interface to
     `fmenumerate()'.

 -- Function: fm.prstr (string)
     Render a string using the current font (see the `setfont()' font
     handle method below). Calls `fmprstr(string)'.

 -- Function: fm.setpath (string)
     Sets the font search path. Calls `fmsetpath(string)'. (XXX Does
     not work!?!)

 -- Function: fm.fontpath ()
     Returns the current font search path.

  Font handle objects support the following operations:

 -- Method: font handle.scalefont(factor)
     Returns a handle for a scaled version of this font. Calls
     `fmscalefont(fh, factor)'.

 -- Method: font handle.setfont()
     Makes this font the current font. Note: the effect is undone
     silently when the font handle object is deleted. Calls
     `fmsetfont(fh)'.

 -- Method: font handle.getfontname()
     Returns this font's name. Calls `fmgetfontname(fh)'.

 -- Method: font handle.getcomment()
     Returns the comment string associated with this font. Raises an
     exception if there is none. Calls `fmgetcomment(fh)'.

 -- Method: font handle.getfontinfo()
     Returns a tuple giving some pertinent data about this font. This
     is an interface to `fmgetfontinfo()'. The returned tuple contains
     the following numbers: `(printermatched, fixed_width, xorig,
     yorig, xsize, ysize, height, nglyphs)'.

 -- Method: font handle.getstrwidth(string)
     Returns the width, in pixels, of _string_ when drawn in this font.
     Calls `fmgetstrwidth(fh, string)'.


File: python.info,  Node: gl --- Graphics Library interface,  Next: DEVICE --- Constants used with the gl module,  Prev: fm --- Font Manager interface,  Up: SGI IRIX Specific Services

5.38.8 `gl' -- _Graphics Library_ interface
-------------------------------------------

Deprecated since version 2.6: The *note gl: e1. module has been removed
in Python 3.

  This module provides access to the Silicon Graphics _Graphics
Library_. It is available only on Silicon Graphics machines.

     Warning: Some illegal calls to the GL library cause the Python
     interpreter to dump core.  In particular, the use of most GL calls
     is unsafe before the first window is opened.

  The module is too large to document here in its entirety, but the
following should help you to get started. The parameter conventions for
the C functions are translated to Python as follows:

   * All (short, long, unsigned) int values are represented by Python
     integers.

   * All float and double values are represented by Python floating
     point numbers.  In most cases, Python integers are also allowed.

   * All arrays are represented by one-dimensional Python lists. In
     most cases, tuples are also allowed.

   * All string and character arguments are represented by Python
     strings, for instance, `winopen('Hi There!')' and `rotate(900,
     'z')'.

   * All (short, long, unsigned) integer arguments or return values
     that are only used to specify the length of an array argument are
     omitted. For example, the C call

         lmdef(deftype, index, np, props)

     is translated to Python as

         lmdef(deftype, index, props)


   * Output arguments are omitted from the argument list; they are
     transmitted as function return values instead. If more than one
     value must be returned, the return value is a tuple. If the C
     function has both a regular return value (that is not omitted
     because of the previous rule) and an output argument, the return
     value comes first in the tuple. Examples: the C call

         getmcolor(i, &red, &green, &blue)

     is translated to Python as

         red, green, blue = getmcolor(i)



  The following functions are non-standard or have special argument
conventions:

 -- Function: gl.varray (argument)
     Equivalent to but faster than a number of `v3d()' calls. The
     _argument_ is a list (or tuple) of points. Each point must be a
     tuple of coordinates `(x, y, z)' or `(x, y)'. The points may be 2-
     or 3-dimensional but must all have the same dimension. Float and
     int values may be mixed however. The points are always converted
     to 3D double precision points by assuming `z = 0.0' if necessary
     (as indicated in the man page), and for each point `v3d()' is
     called.


 -- Function: gl.nvarray ()
     Equivalent to but faster than a number of `n3f' and `v3f' calls.
     The argument is an array (list or tuple) of pairs of normals and
     points. Each pair is a tuple of a point and a normal for that
     point. Each point or normal must be a tuple of coordinates `(x, y,
     z)'. Three coordinates must be given. Float and int values may be
     mixed. For each pair, `n3f()' is called for the normal, and then
     `v3f()' is called for the point.

 -- Function: gl.vnarray ()
     Similar to  `nvarray()' but the pairs have the point first and the
     normal second.

 -- Function: gl.nurbssurface (s_k, t_k, ctl, s_ord, t_ord, type)
     Defines a nurbs surface. The dimensions of `ctl[][]' are computed
     as follows: `[len(s_k) - s_ord]', `[len(t_k) - t_ord]'.


 -- Function: gl.nurbscurve (knots, ctlpoints, order, type)
     Defines a nurbs curve. The length of ctlpoints is `len(knots) -
     order'.

 -- Function: gl.pwlcurve (points, type)
     Defines a piecewise-linear curve. _points_ is a list of points.
     _type_ must be `N_ST'.

 -- Function: gl.pick (n)
 -- Function: gl.select (n)
     The only argument to these functions specifies the desired size of
     the pick or select buffer.

 -- Function: gl.endpick ()
 -- Function: gl.endselect ()
     These functions have no arguments. They return a list of integers
     representing the used part of the pick/select buffer. No method is
     provided to detect buffer overrun.

  Here is a tiny but complete example GL program in Python:

    import gl, GL, time

    def main():
        gl.foreground()
        gl.prefposition(500, 900, 500, 900)
        w = gl.winopen('CrissCross')
        gl.ortho2(0.0, 400.0, 0.0, 400.0)
        gl.color(GL.WHITE)
        gl.clear()
        gl.color(GL.RED)
        gl.bgnline()
        gl.v2f(0.0, 0.0)
        gl.v2f(400.0, 400.0)
        gl.endline()
        gl.bgnline()
        gl.v2f(400.0, 0.0)
        gl.v2f(0.0, 400.0)
        gl.endline()
        time.sleep(5)

    main()


See also
........

PyOpenGL: The Python OpenGL Binding(1)
     An interface to OpenGL is also available; see information about
     the *PyOpenGL* project online at
     <http://pyopengl.sourceforge.net/>.  This may be a better option
     if support for SGI hardware from before about 1996 is not required.

  ---------- Footnotes ----------

  (1) http://pyopengl.sourceforge.net/


File: python.info,  Node: DEVICE --- Constants used with the gl module,  Next: GL --- Constants used with the gl module,  Prev: gl --- Graphics Library interface,  Up: SGI IRIX Specific Services

5.38.9 `DEVICE' -- Constants used with the `gl' module
------------------------------------------------------

Deprecated since version 2.6: The *note DEVICE: 81. module has been
removed in Python 3.

  This modules defines the constants used by the Silicon Graphics
_Graphics Library_ that C programmers find in the header file
`<gl/device.h>'. Read the module source file for details.


File: python.info,  Node: GL --- Constants used with the gl module,  Next: imgfile --- Support for SGI imglib files,  Prev: DEVICE --- Constants used with the gl module,  Up: SGI IRIX Specific Services

5.38.10 `GL' -- Constants used with the `gl' module
---------------------------------------------------

Deprecated since version 2.6: The *note GL: e2. module has been removed
in Python 3.

  This module contains constants used by the Silicon Graphics _Graphics
Library_ from the C header file `<gl/gl.h>'. Read the module source
file for details.


File: python.info,  Node: imgfile --- Support for SGI imglib files,  Next: jpeg --- Read and write JPEG files,  Prev: GL --- Constants used with the gl module,  Up: SGI IRIX Specific Services

5.38.11 `imgfile' -- Support for SGI imglib files
-------------------------------------------------

Deprecated since version 2.6: The *note imgfile: f3. module has been
removed in Python 3.

  The *note imgfile: f3. module allows Python programs to access SGI
imglib image files (also known as `.rgb' files).  The module is far
from complete, but is provided anyway since the functionality that
there is enough in some cases.  Currently, colormap files are not
supported.

  The module defines the following variables and functions:

 -- Exception: imgfile.error
     This exception is raised on all errors, such as unsupported file
     type, etc.

 -- Function: imgfile.getsizes (file)
     This function returns a tuple `(x, y, z)' where _x_ and _y_ are
     the size of the image in pixels and _z_ is the number of bytes per
     pixel. Only 3 byte RGB pixels and 1 byte greyscale pixels are
     currently supported.

 -- Function: imgfile.read (file)
     This function reads and decodes the image on the specified file,
     and returns it as a Python string. The string has either 1 byte
     greyscale pixels or 4 byte RGBA pixels. The bottom left pixel is
     the first in the string. This format is suitable to pass to
     `gl.lrectwrite()', for instance.

 -- Function: imgfile.readscaled (file, x, y, filter[, blur])
     This function is identical to read but it returns an image that is
     scaled to the given _x_ and _y_ sizes. If the _filter_ and _blur_
     parameters are omitted scaling is done by simply dropping or
     duplicating pixels, so the result will be less than perfect,
     especially for computer-generated images.

     Alternatively, you can specify a filter to use to smooth the image
     after scaling. The filter forms supported are `'impulse'', `'box'',
     `'triangle'', `'quadratic'' and `'gaussian''. If a filter is
     specified _blur_ is an optional parameter specifying the
     blurriness of the filter. It defaults to `1.0'.

     *note readscaled(): 2948. makes no attempt to keep the aspect
     ratio correct, so that is the users' responsibility.

 -- Function: imgfile.ttob (flag)
     This function sets a global flag which defines whether the scan
     lines of the image are read or written from bottom to top (flag is
     zero, compatible with SGI GL) or from top to bottom(flag is one,
     compatible with X).  The default is zero.

 -- Function: imgfile.write (file, data, x, y, z)
     This function writes the RGB or greyscale data in _data_ to image
     file _file_.  _x_ and _y_ give the size of the image, _z_ is 1 for
     1 byte greyscale images or 3 for RGB images (which are stored as 4
     byte values of which only the lower three bytes are used). These
     are the formats returned by `gl.lrectread()'.


File: python.info,  Node: jpeg --- Read and write JPEG files,  Prev: imgfile --- Support for SGI imglib files,  Up: SGI IRIX Specific Services

5.38.12 `jpeg' -- Read and write JPEG files
-------------------------------------------

Deprecated since version 2.6: The *note jpeg: fb. module has been
removed in Python 3.

  The module *note jpeg: fb. provides access to the jpeg compressor and
decompressor written by the Independent JPEG Group (IJG). JPEG is a
standard for compressing pictures; it is defined in ISO 10918.  For
details on JPEG or the Independent JPEG Group software refer to the
JPEG standard or the documentation provided with the software.

  A portable interface to JPEG image files is available with the Python
Imaging Library (PIL) by Fredrik Lundh.  Information on PIL is
available at <http://www.pythonware.com/products/pil/>.

  The *note jpeg: fb. module defines an exception and some functions.

 -- Exception: jpeg.error
     Exception raised by *note compress(): 294e. and *note
     decompress(): 294f. in case of errors.

 -- Function: jpeg.compress (data, w, h, b)
     Treat data as a pixmap of width _w_ and height _h_, with _b_ bytes
     per pixel.  The data is in SGI GL order, so the first pixel is in
     the lower-left corner.  This means that `gl.lrectread()' return
     data can immediately be passed to *note compress(): 294e.
     Currently only 1 byte and 4 byte pixels are allowed, the former
     being treated as greyscale and the latter as RGB color. *note
     compress(): 294e.  returns a string that contains the compressed
     picture, in JFIF format.

 -- Function: jpeg.decompress (data)
     Data is a string containing a picture in JFIF format. It returns a
     tuple `(data, width, height, bytesperpixel)'.  Again, the data is
     suitable to pass to `gl.lrectwrite()'.

 -- Function: jpeg.setoption (name, value)
     Set various options.  Subsequent *note compress(): 294e. and *note
     decompress(): 294f. calls will use these options.  The following
     options are available:

     Option                Effect
     ------------------------------------------------------------------------ 
     `'forcegray''         Force output to be grayscale, even if input is
                           RGB.
     `'quality''           Set the quality of the compressed image to a
                           value between `0' and `100' (default is `75').
                           This only affects compression.
     `'optimize''          Perform Huffman table optimization.  Takes
                           longer, but results in smaller compressed image.
                           This only affects compression.
     `'smooth''            Perform inter-block smoothing on uncompressed
                           image.  Only useful for low- quality images.
                           This only affects decompression.


See also
........

JPEG Still Image Data Compression Standard
     The canonical reference for the JPEG image format, by Pennebaker
     and Mitchell.

Information Technology - Digital Compression and Coding of Continuous-tone Still Images - Requirements and Guidelines(1)
     The ISO standard for JPEG is also published as ITU T.81.  This is
     available online in PDF form.

  ---------- Footnotes ----------

  (1) http://www.w3.org/Graphics/JPEG/itu-t81.pdf


File: python.info,  Node: SunOS Specific Services,  Next: Undocumented Modules,  Prev: SGI IRIX Specific Services,  Up: The Python Standard Library

5.39 SunOS Specific Services
============================

The modules described in this chapter provide interfaces to features
that are unique to SunOS 5 (also known as Solaris version 2).

* Menu:

* sunaudiodev: sunaudiodev --- Access to Sun audio hardware. Access to Sun audio hardware
* SUNAUDIODEV: SUNAUDIODEV --- Constants used with sunaudiodev. Constants used with sunaudiodev

sunaudiodev --- Access to Sun audio hardware

* Audio Device Objects: Audio Device Objects<2>.


File: python.info,  Node: sunaudiodev --- Access to Sun audio hardware,  Next: SUNAUDIODEV --- Constants used with sunaudiodev,  Up: SunOS Specific Services

5.39.1 `sunaudiodev' -- Access to Sun audio hardware
----------------------------------------------------

Deprecated since version 2.6: The *note sunaudiodev: 169. module has
been removed in Python 3.

  This module allows you to access the Sun audio interface. The Sun
audio hardware is capable of recording and playing back audio data in
u-LAW format with a sample rate of 8K per second. A full description
can be found in the `audio(7I)' manual page.

  The module *note SUNAUDIODEV: 16a.  defines constants which may be
used with this module.

  This module defines the following variables and functions:

 -- Exception: sunaudiodev.error
     This exception is raised on all errors. The argument is a string
     describing what went wrong.

 -- Function: sunaudiodev.open (mode)
     This function opens the audio device and returns a Sun audio
     device object. This object can then be used to do I/O on. The
     _mode_ parameter is one of `'r'' for record-only access, `'w'' for
     play-only access, `'rw'' for both and `'control'' for access to
     the control device. Since only one process is allowed to have the
     recorder or player open at the same time it is a good idea to open
     the device only for the activity needed. See `audio(7I)' for
     details.

     As per the manpage, this module first looks in the environment
     variable `AUDIODEV' for the base audio device filename.  If not
     found, it falls back to `/dev/audio'.  The control device is
     calculated by appending "ctl" to the base audio device.

* Menu:

* Audio Device Objects: Audio Device Objects<2>.


File: python.info,  Node: Audio Device Objects<2>,  Up: sunaudiodev --- Access to Sun audio hardware

5.39.1.1 Audio Device Objects
.............................

The audio device objects are returned by *note open(): 2957. define the
following methods (except `control' objects which only provide
`getinfo()', `setinfo()', `fileno()', and `drain()'):

 -- Method: audio device.close()
     This method explicitly closes the device. It is useful in
     situations where deleting the object does not immediately close it
     since there are other references to it. A closed device should not
     be used again.

 -- Method: audio device.fileno()
     Returns the file descriptor associated with the device.  This can
     be used to set up `SIGPOLL' notification, as described below.

 -- Method: audio device.drain()
     This method waits until all pending output is processed and then
     returns.  Calling this method is often not necessary: destroying
     the object will automatically close the audio device and this will
     do an implicit drain.

 -- Method: audio device.flush()
     This method discards all pending output. It can be used avoid the
     slow response to a user's stop request (due to buffering of up to
     one second of sound).

 -- Method: audio device.getinfo()
     This method retrieves status information like input and output
     volume, etc. and returns it in the form of an audio status object.
     This object has no methods but it contains a number of attributes
     describing the current device status. The names and meanings of
     the attributes are described in `<sun/audioio.h>' and in the
     `audio(7I)' manual page.  Member names are slightly different from
     their C counterparts: a status object is only a single structure.
     Members of the `play' substructure have `o_' prepended to their
     name and members of the `record' structure have `i_'. So, the C
     member `play.sample_rate' is accessed as `o_sample_rate',
     `record.gain' as `i_gain' and `monitor_gain' plainly as
     `monitor_gain'.

 -- Method: audio device.ibufcount()
     This method returns the number of samples that are buffered on the
     recording side, i.e. the program will not block on a `read()' call
     of so many samples.

 -- Method: audio device.obufcount()
     This method returns the number of samples buffered on the playback
     side.  Unfortunately, this number cannot be used to determine a
     number of samples that can be written without blocking since the
     kernel output queue length seems to be variable.

 -- Method: audio device.read(size)
     This method reads _size_ samples from the audio input and returns
     them as a Python string. The function blocks until enough data is
     available.

 -- Method: audio device.setinfo(status)
     This method sets the audio device status parameters. The _status_
     parameter is an device status object as returned by `getinfo()'
     and possibly modified by the program.

 -- Method: audio device.write(samples)
     Write is passed a Python string containing audio samples to be
     played. If there is enough buffer space free it will immediately
     return, otherwise it will block.

  The audio device supports asynchronous notification of various
events, through the SIGPOLL signal.  Here's an example of how you might
enable this in Python:

    def handle_sigpoll(signum, frame):
        print 'I got a SIGPOLL update'

    import fcntl, signal, STROPTS

    signal.signal(signal.SIGPOLL, handle_sigpoll)
    fcntl.ioctl(audio_obj.fileno(), STROPTS.I_SETSIG, STROPTS.S_MSG)



File: python.info,  Node: SUNAUDIODEV --- Constants used with sunaudiodev,  Prev: sunaudiodev --- Access to Sun audio hardware,  Up: SunOS Specific Services

5.39.2 `SUNAUDIODEV' -- Constants used with `sunaudiodev'
---------------------------------------------------------

Deprecated since version 2.6: The *note SUNAUDIODEV: 16a. module has
been removed in Python 3.

  This is a companion module to *note sunaudiodev: 169. which defines
useful symbolic constants like `MIN_GAIN', `MAX_GAIN', `SPEAKER', etc.
The names of the constants are the same names as used in the C include
file `<sun/audioio.h>', with the leading string `AUDIO_' stripped.


File: python.info,  Node: Undocumented Modules,  Prev: SunOS Specific Services,  Up: The Python Standard Library

5.40 Undocumented Modules
=========================

Here's a quick listing of modules that are currently undocumented, but
that should be documented.  Feel free to contribute documentation for
them!  (Send via email to <docs@python.org>.)

  The idea and original contents for this chapter were taken from a
posting by Fredrik Lundh; the specific contents of this chapter have
been substantially revised.

* Menu:

* Miscellaneous useful utilities::
* Platform specific modules::
* Multimedia::
* Undocumented Mac OS modules::
* Obsolete::
* SGI-specific Extension modules::


File: python.info,  Node: Miscellaneous useful utilities,  Next: Platform specific modules,  Up: Undocumented Modules

5.40.1 Miscellaneous useful utilities
-------------------------------------

Some of these are very old and/or not very robust; marked with "hmm."

`ihooks'
     -- Import hook support (for *note rexec: 147.; may become
     obsolete).  Removed in Python 3.x.


File: python.info,  Node: Platform specific modules,  Next: Multimedia,  Prev: Miscellaneous useful utilities,  Up: Undocumented Modules

5.40.2 Platform specific modules
--------------------------------

These modules are used to implement the *note os.path: 129. module, and
are not documented beyond this mention.  There's little need to
document these.

`ntpath'
     -- Implementation of *note os.path: 129. on Win32, Win64, WinCE,
     and OS/2 platforms.

`posixpath'
     -- Implementation of *note os.path: 129. on POSIX.

`bsddb185'
     -- Backwards compatibility module for systems which still use the
     Berkeley DB 1.85 module.  It is normally only available on certain
     BSD Unix-based systems.  It should never be used directly.


File: python.info,  Node: Multimedia,  Next: Undocumented Mac OS modules,  Prev: Platform specific modules,  Up: Undocumented Modules

5.40.3 Multimedia
-----------------

`audiodev'
     -- Platform-independent API for playing audio data.  Removed in
     Python 3.x.

`linuxaudiodev'
     -- Play audio data on the Linux audio device.  Replaced in Python
     2.3 by the *note ossaudiodev: 12a. module.  Removed in Python 3.x.

`sunaudio'
     -- Interpret Sun audio headers (may become obsolete or a
     tool/demo).  Removed in Python 3.x.

`toaiff'
     -- Convert "arbitrary" sound files to AIFF files; should probably
     become a tool or demo.  Requires the external program *sox*.
     Removed in Python 3.x.


File: python.info,  Node: Undocumented Mac OS modules,  Next: Obsolete,  Prev: Multimedia,  Up: Undocumented Modules

5.40.4 Undocumented Mac OS modules
----------------------------------

* Menu:

* applesingle: applesingle --- AppleSingle decoder. AppleSingle decoder
* buildtools: buildtools --- Helper module for BuildApplet and Friends. Helper module for BuildApplet and Friends
* cfmfile: cfmfile --- Code Fragment Resource module. Code Fragment Resource module
* icopen: icopen --- Internet Config replacement for open. Internet Config replacement for open()
* macerrors: macerrors --- Mac OS Errors. Mac OS Errors
* macresource: macresource --- Locate script resources. Locate script resources
* Nav: Nav --- NavServices calls. NavServices calls
* PixMapWrapper: PixMapWrapper --- Wrapper for PixMap objects. Wrapper for PixMap objects
* videoreader: videoreader --- Read QuickTime movies. Read QuickTime movies
* W: W --- Widgets built on FrameWork. Widgets built on FrameWork


File: python.info,  Node: applesingle --- AppleSingle decoder,  Next: buildtools --- Helper module for BuildApplet and Friends,  Up: Undocumented Mac OS modules

5.40.4.1 `applesingle' -- AppleSingle decoder
.............................................

Deprecated since version 2.6.


File: python.info,  Node: buildtools --- Helper module for BuildApplet and Friends,  Next: cfmfile --- Code Fragment Resource module,  Prev: applesingle --- AppleSingle decoder,  Up: Undocumented Mac OS modules

5.40.4.2 `buildtools' -- Helper module for BuildApplet and Friends
..................................................................

Deprecated since version 2.4.


File: python.info,  Node: cfmfile --- Code Fragment Resource module,  Next: icopen --- Internet Config replacement for open,  Prev: buildtools --- Helper module for BuildApplet and Friends,  Up: Undocumented Mac OS modules

5.40.4.3 `cfmfile' -- Code Fragment Resource module
...................................................

*note cfmfile: 5b. is a module that understands Code Fragments and the
accompanying "cfrg" resources. It can parse them and merge them, and is
used by BuildApplication to combine all plugin modules to a single
executable.

  Deprecated since version 2.4.


File: python.info,  Node: icopen --- Internet Config replacement for open,  Next: macerrors --- Mac OS Errors,  Prev: cfmfile --- Code Fragment Resource module,  Up: Undocumented Mac OS modules

5.40.4.4 `icopen' -- Internet Config replacement for `open()'
.............................................................

Importing *note icopen: f0. will replace the built-in *note open():
2d3. with a version that uses Internet Config to set file type and
creator for new files.

  Deprecated since version 2.6.


File: python.info,  Node: macerrors --- Mac OS Errors,  Next: macresource --- Locate script resources,  Prev: icopen --- Internet Config replacement for open,  Up: Undocumented Mac OS modules

5.40.4.5 `macerrors' -- Mac OS Errors
.....................................

*note macerrors: 104. contains constant definitions for many Mac OS
error codes.

  Deprecated since version 2.6.


File: python.info,  Node: macresource --- Locate script resources,  Next: Nav --- NavServices calls,  Prev: macerrors --- Mac OS Errors,  Up: Undocumented Mac OS modules

5.40.4.6 `macresource' -- Locate script resources
.................................................

*note macresource: 108. helps scripts finding their resources, such as
dialogs and menus, without requiring special case code for when the
script is run under MacPython, as a MacPython applet or under OSX
Python.

  Deprecated since version 2.6.


File: python.info,  Node: Nav --- NavServices calls,  Next: PixMapWrapper --- Wrapper for PixMap objects,  Prev: macresource --- Locate script resources,  Up: Undocumented Mac OS modules

5.40.4.7 `Nav' -- NavServices calls
...................................

A low-level interface to Navigation Services.

  Deprecated since version 2.6.


File: python.info,  Node: PixMapWrapper --- Wrapper for PixMap objects,  Next: videoreader --- Read QuickTime movies,  Prev: Nav --- NavServices calls,  Up: Undocumented Mac OS modules

5.40.4.8 `PixMapWrapper' -- Wrapper for PixMap objects
......................................................

*note PixMapWrapper: 130. wraps a PixMap object with a Python object
that allows access to the fields by name. It also has methods to
convert to and from `PIL' images.

  Deprecated since version 2.6.


File: python.info,  Node: videoreader --- Read QuickTime movies,  Next: W --- Widgets built on FrameWork,  Prev: PixMapWrapper --- Wrapper for PixMap objects,  Up: Undocumented Mac OS modules

5.40.4.9 `videoreader' -- Read QuickTime movies
...............................................

*note videoreader: 191. reads and decodes QuickTime movies and passes a
stream of images to your program. It also provides some support for
audio tracks.

  Deprecated since version 2.6.


File: python.info,  Node: W --- Widgets built on FrameWork,  Prev: videoreader --- Read QuickTime movies,  Up: Undocumented Mac OS modules

5.40.4.10 `W' -- Widgets built on `FrameWork'
.............................................

The *note W: 192. widgets are used extensively in the *IDE*.

  Deprecated since version 2.6.


File: python.info,  Node: Obsolete,  Next: SGI-specific Extension modules,  Prev: Undocumented Mac OS modules,  Up: Undocumented Modules

5.40.5 Obsolete
---------------

These modules are not normally available for import; additional work
must be done to make them available.

  These extension modules written in C are not built by default. Under
Unix, these must be enabled by uncommenting the appropriate lines in
`Modules/Setup' in the build tree and either rebuilding Python if the
modules are statically linked, or building and installing the shared
object if using dynamically-loaded extensions.

`timing'
     -- Measure time intervals to high resolution (use *note
     time.clock(): 11d4.  instead).  Removed in Python 3.x.


File: python.info,  Node: SGI-specific Extension modules,  Prev: Obsolete,  Up: Undocumented Modules

5.40.6 SGI-specific Extension modules
-------------------------------------

The following are SGI specific, and may be out of touch with the
current version of reality.

`cl'
     -- Interface to the SGI compression library.

`sv'
     -- Interface to the "simple video" board on SGI Indigo (obsolete
     hardware).  Removed in Python 3.x.


File: python.info,  Node: Extending and Embedding the Python Interpreter,  Next: Python/C API Reference Manual,  Prev: The Python Standard Library,  Up: Top

6 Extending and Embedding the Python Interpreter
************************************************

This document describes how to write modules in C or C++ to extend the
Python interpreter with new modules.  Those modules can define new
functions but also new object types and their methods.  The document
also describes how to embed the Python interpreter in another
application, for use as an extension language.  Finally, it shows how
to compile and link extension modules so that they can be loaded
dynamically (at run time) into the interpreter, if the underlying
operating system supports this feature.

  This document assumes basic knowledge about Python.  For an informal
introduction to the language, see *note The Python Tutorial: 4ee.
*note The Python Language Reference: 4f0.  gives a more formal
definition of the language.  *note The Python Standard Library: 4ef.
documents the existing object types, functions and modules (both
built-in and written in Python) that give the language its wide
application range.

  For a detailed description of the whole Python/C API, see the separate
*note Python/C API Reference Manual: 4f2.

* Menu:

* Extending Python with C or C++::
* Defining New Types::
* Building C and C++ Extensions with distutils::
* Building C and C++ Extensions on Windows::
* Embedding Python in Another Application::

Extending Python with C or C++

* A Simple Example::
* Intermezzo; Errors and Exceptions: Intermezzo Errors and Exceptions.
* Back to the Example::
* The Module's Method Table and Initialization Function::
* Compilation and Linkage::
* Calling Python Functions from C::
* Extracting Parameters in Extension Functions::
* Keyword Parameters for Extension Functions::
* Building Arbitrary Values::
* Reference Counts::
* Writing Extensions in C++::
* Providing a C API for an Extension Module::

Reference Counts

* Reference Counting in Python::
* Ownership Rules::
* Thin Ice::
* NULL Pointers::

Defining New Types

* The Basics::
* Type Methods::

The Basics

* Adding data and methods to the Basic example::
* Providing finer control over data attributes::
* Supporting cyclic garbage collection::
* Subclassing other types::

Type Methods

* Finalization and De-allocation::
* Object Presentation::
* Attribute Management::
* Object Comparison::
* Abstract Protocol Support::
* Weak Reference Support::
* More Suggestions::

Attribute Management

* Generic Attribute Management::
* Type-specific Attribute Management::

Building C and C++ Extensions with distutils

* Distributing your extension modules::

Building C and C++ Extensions on Windows

* A Cookbook Approach::
* Differences Between Unix and Windows::
* Using DLLs in Practice::

Embedding Python in Another Application

* Very High Level Embedding::
* Beyond Very High Level Embedding; An overview: Beyond Very High Level Embedding An overview.
* Pure Embedding::
* Extending Embedded Python::
* Embedding Python in C++::
* Linking Requirements::


File: python.info,  Node: Extending Python with C or C++,  Next: Defining New Types,  Up: Extending and Embedding the Python Interpreter

6.1 Extending Python with C or C++
==================================

It is quite easy to add new built-in modules to Python, if you know how
to program in C.  Such _extension modules_ can do two things that can't
be done directly in Python: they can implement new built-in object
types, and they can call C library functions and system calls.

  To support extensions, the Python API (Application Programmers
Interface) defines a set of functions, macros and variables that
provide access to most aspects of the Python run-time system.  The
Python API is incorporated in a C source file by including the header
`"Python.h"'.

  The compilation of an extension module depends on its intended use as
well as on your system setup; details are given in later chapters.

  Do note that if your use case is calling C library functions or
system calls, you should consider using the *note ctypes: 78. module
rather than writing custom C code. Not only does *note ctypes: 78. let
you write Python code to interface with C code, but it is more portable
between implementations of Python than writing and compiling an
extension module which typically ties you to CPython.

* Menu:

* A Simple Example::
* Intermezzo; Errors and Exceptions: Intermezzo Errors and Exceptions.
* Back to the Example::
* The Module's Method Table and Initialization Function::
* Compilation and Linkage::
* Calling Python Functions from C::
* Extracting Parameters in Extension Functions::
* Keyword Parameters for Extension Functions::
* Building Arbitrary Values::
* Reference Counts::
* Writing Extensions in C++::
* Providing a C API for an Extension Module::


File: python.info,  Node: A Simple Example,  Next: Intermezzo Errors and Exceptions,  Up: Extending Python with C or C++

6.1.1 A Simple Example
----------------------

Let's create an extension module called `spam' (the favorite food of
Monty Python fans...) and let's say we want to create a Python
interface to the C library function `system()'. (1) This function takes
a null-terminated character string as argument and returns an integer.
We want this function to be callable from Python as follows:

    >>> import spam
    >>> status = spam.system("ls -l")

Begin by creating a file `spammodule.c'.  (Historically, if a module is
called `spam', the C file containing its implementation is called
`spammodule.c'; if the module name is very long, like `spammify', the
module name can be just `spammify.c'.)

  The first line of our file can be:

    #include <Python.h>

which pulls in the Python API (you can add a comment describing the
purpose of the module and a copyright notice if you like).

     Note: Since Python may define some pre-processor definitions which
     affect the standard headers on some systems, you _must_ include
     `Python.h' before any standard headers are included.

  All user-visible symbols defined by `Python.h' have a prefix of `Py'
or `PY', except those defined in standard header files. For
convenience, and since they are used extensively by the Python
interpreter, `"Python.h"' includes a few standard header files:
`<stdio.h>', `<string.h>', `<errno.h>', and `<stdlib.h>'.  If the
latter header file does not exist on your system, it declares the
functions `malloc()', `free()' and `realloc()' directly.

  The next thing we add to our module file is the C function that will
be called when the Python expression `spam.system(string)' is evaluated
(we'll see shortly how it ends up being called):

    static PyObject *
    spam_system(PyObject *self, PyObject *args)
    {
        const char *command;
        int sts;

        if (!PyArg_ParseTuple(args, "s", &command))
            return NULL;
        sts = system(command);
        return Py_BuildValue("i", sts);
    }

There is a straightforward translation from the argument list in Python
(for example, the single expression `"ls -l"') to the arguments passed
to the C function.  The C function always has two arguments,
conventionally named _self_ and _args_.

  The _self_ argument points to the module object for module-level
functions; for a method it would point to the object instance.

  The _args_ argument will be a pointer to a Python tuple object
containing the arguments.  Each item of the tuple corresponds to an
argument in the call's argument list.  The arguments are Python objects
-- in order to do anything with them in our C function we have to
convert them to C values.  The function *note PyArg_ParseTuple(): 314.
in the Python API checks the argument types and converts them to C
values.  It uses a template string to determine the required types of
the arguments as well as the types of the C variables into which to
store the converted values.  More about this later.

  *note PyArg_ParseTuple(): 314. returns true (nonzero) if all
arguments have the right type and its components have been stored in
the variables whose addresses are passed.  It returns false (zero) if
an invalid argument list was passed.  In the latter case it also raises
an appropriate exception so the calling function can return _NULL_
immediately (as we saw in the example).

  ---------- Footnotes ----------

  (1) An interface for this function already exists in the standard
module *note os: 128.  -- it was chosen as a simple and straightforward
example.


File: python.info,  Node: Intermezzo Errors and Exceptions,  Next: Back to the Example,  Prev: A Simple Example,  Up: Extending Python with C or C++

6.1.2 Intermezzo: Errors and Exceptions
---------------------------------------

An important convention throughout the Python interpreter is the
following: when a function fails, it should set an exception condition
and return an error value (usually a _NULL_ pointer).  Exceptions are
stored in a static global variable inside the interpreter; if this
variable is _NULL_ no exception has occurred.  A second global variable
stores the "associated value" of the exception (the second argument to
*note raise: 5a5.).  A third variable contains the stack traceback in
case the error originated in Python code.  These three variables are
the C equivalents of the Python variables `sys.exc_type',
`sys.exc_value' and `sys.exc_traceback' (see the section on module
*note sys: 16d. in the Python Library Reference).  It is important to
know about them to understand how errors are passed around.

  The Python API defines a number of functions to set various types of
exceptions.

  The most common one is *note PyErr_SetString(): 2978.  Its arguments
are an exception object and a C string.  The exception object is
usually a predefined object like `PyExc_ZeroDivisionError'.  The C
string indicates the cause of the error and is converted to a Python
string object and stored as the "associated value" of the exception.

  Another useful function is *note PyErr_SetFromErrno(): 2979, which
only takes an exception argument and constructs the associated value by
inspection of the global variable `errno'.  The most general function is
*note PyErr_SetObject(): 297a, which takes two object arguments, the
exception and its associated value.  You don't need to *note
Py_INCREF(): 297b. the objects passed to any of these functions.

  You can test non-destructively whether an exception has been set with
*note PyErr_Occurred(): 297c.  This returns the current exception
object, or _NULL_ if no exception has occurred.  You normally don't
need to call *note PyErr_Occurred(): 297c. to see whether an error
occurred in a function call, since you should be able to tell from the
return value.

  When a function _f_ that calls another function _g_ detects that the
latter fails, _f_ should itself return an error value (usually _NULL_
or `-1').  It should _not_ call one of the `PyErr_*()' functions -- one
has already been called by _g_. _f_'s caller is then supposed to also
return an error indication to _its_ caller, again _without_ calling
`PyErr_*()', and so on -- the most detailed cause of the error was
already reported by the function that first detected it.  Once the
error reaches the Python interpreter's main loop, this aborts the
currently executing Python code and tries to find an exception handler
specified by the Python programmer.

  (There are situations where a module can actually give a more
detailed error message by calling another `PyErr_*()' function, and in
such cases it is fine to do so.  As a general rule, however, this is
not necessary, and can cause information about the cause of the error
to be lost: most operations can fail for a variety of reasons.)

  To ignore an exception set by a function call that failed, the
exception condition must be cleared explicitly by calling *note
PyErr_Clear(): 297d.  The only time C code should call *note
PyErr_Clear(): 297d. is if it doesn't want to pass the error on to the
interpreter but wants to handle it completely by itself (possibly by
trying something else, or pretending nothing went wrong).

  Every failing `malloc()' call must be turned into an exception -- the
direct caller of `malloc()' (or `realloc()') must call *note
PyErr_NoMemory(): 297e. and return a failure indicator itself.  All the
object-creating functions (for example, *note PyInt_FromLong(): 297f.)
already do this, so this note is only relevant to those who call
`malloc()' directly.

  Also note that, with the important exception of *note
PyArg_ParseTuple(): 314. and friends, functions that return an integer
status usually return a positive value or zero for success and `-1' for
failure, like Unix system calls.

  Finally, be careful to clean up garbage (by making *note
Py_XDECREF(): 2980. or *note Py_DECREF(): 2981. calls for objects you
have already created) when you return an error indicator!

  The choice of which exception to raise is entirely yours.  There are
predeclared C objects corresponding to all built-in Python exceptions,
such as `PyExc_ZeroDivisionError', which you can use directly. Of
course, you should choose exceptions wisely -- don't use
`PyExc_TypeError' to mean that a file couldn't be opened (that should
probably be `PyExc_IOError').  If something's wrong with the argument
list, the *note PyArg_ParseTuple(): 314.  function usually raises
`PyExc_TypeError'.  If you have an argument whose value must be in a
particular range or must satisfy other conditions, `PyExc_ValueError'
is appropriate.

  You can also define a new exception that is unique to your module.
For this, you usually declare a static object variable at the beginning
of your file:

    static PyObject *SpamError;

and initialize it in your module's initialization function
(`initspam()') with an exception object (leaving out the error checking
for now):

    PyMODINIT_FUNC
    initspam(void)
    {
        PyObject *m;

        m = Py_InitModule("spam", SpamMethods);
        if (m == NULL)
            return;

        SpamError = PyErr_NewException("spam.error", NULL, NULL);
        Py_INCREF(SpamError);
        PyModule_AddObject(m, "error", SpamError);
    }

Note that the Python name for the exception object is `spam.error'.  The
*note PyErr_NewException(): 2b7. function may create a class with the
base class being *note Exception: 332. (unless another class is passed
in instead of _NULL_), described in *note Built-in Exceptions: 5a1.

  Note also that the `SpamError' variable retains a reference to the
newly created exception class; this is intentional!  Since the
exception could be removed from the module by external code, an owned
reference to the class is needed to ensure that it will not be
discarded, causing `SpamError' to become a dangling pointer. Should it
become a dangling pointer, C code which raises the exception could
cause a core dump or other unintended side effects.

  We discuss the use of `PyMODINIT_FUNC' as a function return type
later in this sample.

  The `spam.error' exception can be raised in your extension module
using a call to *note PyErr_SetString(): 2978. as shown below:

    static PyObject *
    spam_system(PyObject *self, PyObject *args)
    {
        const char *command;
        int sts;

        if (!PyArg_ParseTuple(args, "s", &command))
            return NULL;
        sts = system(command);
        if (sts < 0) {
            PyErr_SetString(SpamError, "System command failed");
            return NULL;
        }
        return PyLong_FromLong(sts);
    }



File: python.info,  Node: Back to the Example,  Next: The Module's Method Table and Initialization Function,  Prev: Intermezzo Errors and Exceptions,  Up: Extending Python with C or C++

6.1.3 Back to the Example
-------------------------

Going back to our example function, you should now be able to
understand this statement:

    if (!PyArg_ParseTuple(args, "s", &command))
        return NULL;

It returns _NULL_ (the error indicator for functions returning object
pointers) if an error is detected in the argument list, relying on the
exception set by *note PyArg_ParseTuple(): 314.  Otherwise the string
value of the argument has been copied to the local variable `command'.
This is a pointer assignment and you are not supposed to modify the
string to which it points (so in Standard C, the variable `command'
should properly be declared as `const char *command').

  The next statement is a call to the Unix function `system()', passing
it the string we just got from *note PyArg_ParseTuple(): 314.:

    sts = system(command);

Our `spam.system()' function must return the value of `sts' as a Python
object.  This is done using the function *note Py_BuildValue(): 3a1,
which is something like the inverse of *note PyArg_ParseTuple(): 314.:
it takes a format string and an arbitrary number of C values, and
returns a new Python object.  More info on *note Py_BuildValue(): 3a1.
is given later.

    return Py_BuildValue("i", sts);

In this case, it will return an integer object.  (Yes, even integers
are objects on the heap in Python!)

  If you have a C function that returns no useful argument (a function
returning `void'), the corresponding Python function must return
`None'.   You need this idiom to do so (which is implemented by the
*note Py_RETURN_NONE: 410.  macro):

    Py_INCREF(Py_None);
    return Py_None;

*note Py_None: 2984. is the C name for the special Python object
`None'.  It is a genuine Python object rather than a _NULL_ pointer,
which means "error" in most contexts, as we have seen.


File: python.info,  Node: The Module's Method Table and Initialization Function,  Next: Compilation and Linkage,  Prev: Back to the Example,  Up: Extending Python with C or C++

6.1.4 The Module's Method Table and Initialization Function
-----------------------------------------------------------

I promised to show how `spam_system()' is called from Python programs.
First, we need to list its name and address in a "method table":

    static PyMethodDef SpamMethods[] = {
        ...
        {"system",  spam_system, METH_VARARGS,
         "Execute a shell command."},
        ...
        {NULL, NULL, 0, NULL}        /* Sentinel */
    };

Note the third entry (`METH_VARARGS').  This is a flag telling the
interpreter the calling convention to be used for the C function.  It
should normally always be `METH_VARARGS' or `METH_VARARGS |
METH_KEYWORDS'; a value of `0' means that an obsolete variant of *note
PyArg_ParseTuple(): 314. is used.

  When using only `METH_VARARGS', the function should expect the
Python-level parameters to be passed in as a tuple acceptable for
parsing via *note PyArg_ParseTuple(): 314.; more information on this
function is provided below.

  The *note METH_KEYWORDS: 2987. bit may be set in the third field if
keyword arguments should be passed to the function.  In this case, the
C function should accept a third `PyObject *' parameter which will be a
dictionary of keywords.  Use *note PyArg_ParseTupleAndKeywords(): 415.
to parse the arguments to such a function.

  The method table must be passed to the interpreter in the module's
initialization function.  The initialization function must be named
`initname()', where _name_ is the name of the module, and should be the
only non-`static' item defined in the module file:

    PyMODINIT_FUNC
    initspam(void)
    {
        (void) Py_InitModule("spam", SpamMethods);
    }

Note that PyMODINIT_FUNC declares the function as `void' return type,
declares any special linkage declarations required by the platform, and
for  C++ declares the function as `extern "C"'.

  When the Python program imports module `spam' for the first time,
`initspam()' is called. (See below for comments about embedding Python.)
It calls *note Py_InitModule(): 2988, which creates a "module object"
(which is inserted in the dictionary `sys.modules' under the key
`"spam"'), and inserts built-in function objects into the newly created
module based upon the table (an array of *note PyMethodDef: 46b.
structures) that was passed as its second argument. *note
Py_InitModule(): 2988. returns a pointer to the module object that it
creates (which is unused here).  It may abort with a fatal error for
certain errors, or return _NULL_ if the module could not be initialized
satisfactorily.

  When embedding Python, the `initspam()' function is not called
automatically unless there's an entry in the `_PyImport_Inittab' table.
The easiest way to handle this is to statically initialize your
statically-linked modules by directly calling `initspam()' after the
call to *note Py_Initialize(): 2989.:

    int
    main(int argc, char *argv[])
    {
        /* Pass argv[0] to the Python interpreter */
        Py_SetProgramName(argv[0]);

        /* Initialize the Python interpreter.  Required. */
        Py_Initialize();

        /* Add a static module */
        initspam();

An example may be found in the file `Demo/embed/demo.c' in the Python
source distribution.

     Note: Removing entries from `sys.modules' or importing compiled
     modules into multiple interpreters within a process (or following
     a `fork()' without an intervening `exec()') can create problems
     for some extension modules.  Extension module authors should
     exercise caution when initializing internal data structures. Note
     also that the *note reload(): 571. function can be used with
     extension modules, and will call the module initialization function
     (`initspam()' in the example), but will not load the module again
     if it was loaded from a dynamically loadable object file (`.so' on
     Unix, `.dll' on Windows).

  A more substantial example module is included in the Python source
distribution as `Modules/xxmodule.c'.  This file may be used as a
template or simply read as an example.


File: python.info,  Node: Compilation and Linkage,  Next: Calling Python Functions from C,  Prev: The Module's Method Table and Initialization Function,  Up: Extending Python with C or C++

6.1.5 Compilation and Linkage
-----------------------------

There are two more things to do before you can use your new extension:
compiling and linking it with the Python system.  If you use dynamic
loading, the details may depend on the style of dynamic loading your
system uses; see the chapters about building extension modules (chapter
*note Building C and C++ Extensions with distutils: 298c.) and
additional information that pertains only to building on Windows
(chapter *note Building C and C++ Extensions on Windows: 668.) for more
information about this.

  If you can't use dynamic loading, or if you want to make your module
a permanent part of the Python interpreter, you will have to change the
configuration setup and rebuild the interpreter.  Luckily, this is very
simple on Unix: just place your file (`spammodule.c' for example) in
the `Modules/' directory of an unpacked source distribution, add a line
to the file `Modules/Setup.local' describing your file:

    spam spammodule.o

and rebuild the interpreter by running *make* in the toplevel
directory.  You can also run *make* in the `Modules/' subdirectory, but
then you must first rebuild `Makefile' there by running '*make*
Makefile'.  (This is necessary each time you change the `Setup' file.)

  If your module requires additional libraries to link with, these can
be listed on the line in the configuration file as well, for instance:

    spam spammodule.o -lX11



File: python.info,  Node: Calling Python Functions from C,  Next: Extracting Parameters in Extension Functions,  Prev: Compilation and Linkage,  Up: Extending Python with C or C++

6.1.6 Calling Python Functions from C
-------------------------------------

So far we have concentrated on making C functions callable from Python.
The reverse is also useful: calling Python functions from C. This is
especially the case for libraries that support so-called "callback"
functions.  If a C interface makes use of callbacks, the equivalent
Python often needs to provide a callback mechanism to the Python
programmer; the implementation will require calling the Python callback
functions from a C callback.  Other uses are also imaginable.

  Fortunately, the Python interpreter is easily called recursively, and
there is a standard interface to call a Python function.  (I won't
dwell on how to call the Python parser with a particular string as
input -- if you're interested, have a look at the implementation of the
*note -c: 278. command line option in `Modules/main.c' from the Python
source code.)

  Calling a Python function is easy.  First, the Python program must
somehow pass you the Python function object.  You should provide a
function (or some other interface) to do this.  When this function is
called, save a pointer to the Python function object (be careful to
*note Py_INCREF(): 297b. it!) in a global variable -- or wherever you
see fit. For example, the following function might be part of a module
definition:

    static PyObject *my_callback = NULL;

    static PyObject *
    my_set_callback(PyObject *dummy, PyObject *args)
    {
        PyObject *result = NULL;
        PyObject *temp;

        if (PyArg_ParseTuple(args, "O:set_callback", &temp)) {
            if (!PyCallable_Check(temp)) {
                PyErr_SetString(PyExc_TypeError, "parameter must be callable");
                return NULL;
            }
            Py_XINCREF(temp);         /* Add a reference to new callback */
            Py_XDECREF(my_callback);  /* Dispose of previous callback */
            my_callback = temp;       /* Remember new callback */
            /* Boilerplate to return "None" */
            Py_INCREF(Py_None);
            result = Py_None;
        }
        return result;
    }

This function must be registered with the interpreter using the *note
METH_VARARGS: 4a3. flag; this is described in section *note The
Module's Method Table and Initialization Function: 2986.  The *note
PyArg_ParseTuple(): 314. function and its arguments are documented in
section *note Extracting Parameters in Extension Functions: 298f.

  The macros *note Py_XINCREF(): 2990. and *note Py_XDECREF(): 2980.
increment/decrement the reference count of an object and are safe in
the presence of _NULL_ pointers (but note that _temp_ will not be
_NULL_ in this context).  More info on them in section *note Reference
Counts: 2991.

  Later, when it is time to call the function, you call the C function
*note PyObject_CallObject(): 2992.  This function has two arguments,
both pointers to arbitrary Python objects: the Python function, and the
argument list.  The argument list must always be a tuple object, whose
length is the number of arguments.  To call the Python function with no
arguments, pass in NULL, or an empty tuple; to call it with one
argument, pass a singleton tuple.  *note Py_BuildValue(): 3a1. returns
a tuple when its format string consists of zero or more format codes
between parentheses.  For example:

    int arg;
    PyObject *arglist;
    PyObject *result;
    ...
    arg = 123;
    ...
    /* Time to call the callback */
    arglist = Py_BuildValue("(i)", arg);
    result = PyObject_CallObject(my_callback, arglist);
    Py_DECREF(arglist);

*note PyObject_CallObject(): 2992. returns a Python object pointer:
this is the return value of the Python function.  *note
PyObject_CallObject(): 2992. is "reference-count-neutral" with respect
to its arguments.  In the example a new tuple was created to serve as
the argument list, which is *note Py_DECREF(): 2981.-ed immediately
after the call.

  The return value of *note PyObject_CallObject(): 2992. is "new":
either it is a brand new object, or it is an existing object whose
reference count has been incremented.  So, unless you want to save it
in a global variable, you should somehow *note Py_DECREF(): 2981. the
result, even (especially!) if you are not interested in its value.

  Before you do this, however, it is important to check that the return
value isn't _NULL_.  If it is, the Python function terminated by
raising an exception.  If the C code that called *note
PyObject_CallObject(): 2992. is called from Python, it should now
return an error indication to its Python caller, so the interpreter can
print a stack trace, or the calling Python code can handle the
exception.  If this is not possible or desirable, the exception should
be cleared by calling *note PyErr_Clear(): 297d.  For example:

    if (result == NULL)
        return NULL; /* Pass error back */
    ...use result...
    Py_DECREF(result);

Depending on the desired interface to the Python callback function, you
may also have to provide an argument list to *note
PyObject_CallObject(): 2992.  In some cases the argument list is also
provided by the Python program, through the same interface that
specified the callback function.  It can then be saved and used in the
same manner as the function object.  In other cases, you may have to
construct a new tuple to pass as the argument list.  The simplest way
to do this is to call *note Py_BuildValue(): 3a1.  For example, if you
want to pass an integral event code, you might use the following code:

    PyObject *arglist;
    ...
    arglist = Py_BuildValue("(l)", eventcode);
    result = PyObject_CallObject(my_callback, arglist);
    Py_DECREF(arglist);
    if (result == NULL)
        return NULL; /* Pass error back */
    /* Here maybe use the result */
    Py_DECREF(result);

Note the placement of `Py_DECREF(arglist)' immediately after the call,
before the error check!  Also note that strictly speaking this code is
not complete: *note Py_BuildValue(): 3a1. may run out of memory, and
this should be checked.

  You may also call a function with keyword arguments by using *note
PyObject_Call(): 2993, which supports arguments and keyword arguments.
As in the above example, we use *note Py_BuildValue(): 3a1. to
construct the dictionary.

    PyObject *dict;
    ...
    dict = Py_BuildValue("{s:i}", "name", val);
    result = PyObject_Call(my_callback, NULL, dict);
    Py_DECREF(dict);
    if (result == NULL)
        return NULL; /* Pass error back */
    /* Here maybe use the result */
    Py_DECREF(result);



File: python.info,  Node: Extracting Parameters in Extension Functions,  Next: Keyword Parameters for Extension Functions,  Prev: Calling Python Functions from C,  Up: Extending Python with C or C++

6.1.7 Extracting Parameters in Extension Functions
--------------------------------------------------

The *note PyArg_ParseTuple(): 314. function is declared as follows:

    int PyArg_ParseTuple(PyObject *arg, char *format, ...);

The _arg_ argument must be a tuple object containing an argument list
passed from Python to a C function.  The _format_ argument must be a
format string, whose syntax is explained in *note Parsing arguments and
building values: 2995. in the Python/C API Reference Manual.  The
remaining arguments must be addresses of variables whose type is
determined by the format string.

  Note that while *note PyArg_ParseTuple(): 314. checks that the Python
arguments have the required types, it cannot check the validity of the
addresses of C variables passed to the call: if you make mistakes
there, your code will probably crash or at least overwrite random bits
in memory.  So be careful!

  Note that any Python object references which are provided to the
caller are _borrowed_ references; do not decrement their reference
count!

  Some example calls:

    int ok;
    int i, j;
    long k, l;
    const char *s;
    int size;

    ok = PyArg_ParseTuple(args, ""); /* No arguments */
        /* Python call: f() */


    ok = PyArg_ParseTuple(args, "s", &s); /* A string */
        /* Possible Python call: f('whoops!') */


    ok = PyArg_ParseTuple(args, "lls", &k, &l, &s); /* Two longs and a string */
        /* Possible Python call: f(1, 2, 'three') */


    ok = PyArg_ParseTuple(args, "(ii)s#", &i, &j, &s, &size);
        /* A pair of ints and a string, whose size is also returned */
        /* Possible Python call: f((1, 2), 'three') */


    {
        const char *file;
        const char *mode = "r";
        int bufsize = 0;
        ok = PyArg_ParseTuple(args, "s|si", &file, &mode, &bufsize);
        /* A string, and optionally another string and an integer */
        /* Possible Python calls:
           f('spam')
           f('spam', 'w')
           f('spam', 'wb', 100000) */
    }


    {
        int left, top, right, bottom, h, v;
        ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",
                 &left, &top, &right, &bottom, &h, &v);
        /* A rectangle and a point */
        /* Possible Python call:
           f(((0, 0), (400, 300)), (10, 10)) */
    }


    {
        Py_complex c;
        ok = PyArg_ParseTuple(args, "D:myfunction", &c);
        /* a complex, also providing a function name for errors */
        /* Possible Python call: myfunction(1+2j) */
    }



File: python.info,  Node: Keyword Parameters for Extension Functions,  Next: Building Arbitrary Values,  Prev: Extracting Parameters in Extension Functions,  Up: Extending Python with C or C++

6.1.8 Keyword Parameters for Extension Functions
------------------------------------------------

The *note PyArg_ParseTupleAndKeywords(): 415. function is declared as
follows:

    int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,
                                    char *format, char *kwlist[], ...);

The _arg_ and _format_ parameters are identical to those of the *note
PyArg_ParseTuple(): 314. function.  The _kwdict_ parameter is the
dictionary of keywords received as the third parameter from the Python
runtime.  The _kwlist_ parameter is a _NULL_-terminated list of strings
which identify the parameters; the names are matched with the type
information from _format_ from left to right.  On success, *note
PyArg_ParseTupleAndKeywords(): 415. returns true, otherwise it returns
false and raises an appropriate exception.

     Note: Nested tuples cannot be parsed when using keyword arguments!
     Keyword parameters passed in which are not present in the _kwlist_
     will cause *note TypeError: 215. to be raised.

  Here is an example module which uses keywords, based on an example by
Geoff Philbrick (<philbrick@hks.com>):

    #include "Python.h"

    static PyObject *
    keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)
    {
        int voltage;
        char *state = "a stiff";
        char *action = "voom";
        char *type = "Norwegian Blue";

        static char *kwlist[] = {"voltage", "state", "action", "type", NULL};

        if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,
                                         &voltage, &state, &action, &type))
            return NULL;

        printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",
               action, voltage);
        printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);

        Py_INCREF(Py_None);

        return Py_None;
    }

    static PyMethodDef keywdarg_methods[] = {
        /* The cast of the function is necessary since PyCFunction values
         * only take two PyObject* parameters, and keywdarg_parrot() takes
         * three.
         */
        {"parrot", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,
         "Print a lovely skit to standard output."},
        {NULL, NULL, 0, NULL}   /* sentinel */
    };


    void
    initkeywdarg(void)
    {
      /* Create the module and add the functions */
      Py_InitModule("keywdarg", keywdarg_methods);
    }



File: python.info,  Node: Building Arbitrary Values,  Next: Reference Counts,  Prev: Keyword Parameters for Extension Functions,  Up: Extending Python with C or C++

6.1.9 Building Arbitrary Values
-------------------------------

This function is the counterpart to *note PyArg_ParseTuple(): 314.  It
is declared as follows:

    PyObject *Py_BuildValue(char *format, ...);

It recognizes a set of format units similar to the ones recognized by
*note PyArg_ParseTuple(): 314, but the arguments (which are input to
the function, not output) must not be pointers, just values.  It
returns a new Python object, suitable for returning from a C function
called from Python.

  One difference with *note PyArg_ParseTuple(): 314.: while the latter
requires its first argument to be a tuple (since Python argument lists
are always represented as tuples internally), *note Py_BuildValue():
3a1. does not always build a tuple.  It builds a tuple only if its
format string contains two or more format units. If the format string
is empty, it returns `None'; if it contains exactly one format unit, it
returns whatever object is described by that format unit.  To force it
to return a tuple of size 0 or one, parenthesize the format string.

  Examples (to the left the call, to the right the resulting Python
value):

    Py_BuildValue("")                        None
    Py_BuildValue("i", 123)                  123
    Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789)
    Py_BuildValue("s", "hello")              'hello'
    Py_BuildValue("ss", "hello", "world")    ('hello', 'world')
    Py_BuildValue("s#", "hello", 4)          'hell'
    Py_BuildValue("()")                      ()
    Py_BuildValue("(i)", 123)                (123,)
    Py_BuildValue("(ii)", 123, 456)          (123, 456)
    Py_BuildValue("(i,i)", 123, 456)         (123, 456)
    Py_BuildValue("[i,i]", 123, 456)         [123, 456]
    Py_BuildValue("{s:i,s:i}",
                  "abc", 123, "def", 456)    {'abc': 123, 'def': 456}
    Py_BuildValue("((ii)(ii)) (ii)",
                  1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))



File: python.info,  Node: Reference Counts,  Next: Writing Extensions in C++,  Prev: Building Arbitrary Values,  Up: Extending Python with C or C++

6.1.10 Reference Counts
-----------------------

In languages like C or C++, the programmer is responsible for dynamic
allocation and deallocation of memory on the heap.  In C, this is done
using the functions `malloc()' and `free()'.  In C++, the operators
`new' and `delete' are used with essentially the same meaning and we'll
restrict the following discussion to the C case.

  Every block of memory allocated with `malloc()' should eventually be
returned to the pool of available memory by exactly one call to
`free()'.  It is important to call `free()' at the right time.  If a
block's address is forgotten but `free()' is not called for it, the
memory it occupies cannot be reused until the program terminates.  This
is called a _memory leak_.  On the other hand, if a program calls
`free()' for a block and then continues to use the block, it creates a
conflict with re-use of the block through another `malloc()' call.
This is called _using freed memory_.  It has the same bad consequences
as referencing uninitialized data -- core dumps, wrong results,
mysterious crashes.

  Common causes of memory leaks are unusual paths through the code.
For instance, a function may allocate a block of memory, do some
calculation, and then free the block again.  Now a change in the
requirements for the function may add a test to the calculation that
detects an error condition and can return prematurely from the
function.  It's easy to forget to free the allocated memory block when
taking this premature exit, especially when it is added later to the
code.  Such leaks, once introduced, often go undetected for a long
time: the error exit is taken only in a small fraction of all calls,
and most modern machines have plenty of virtual memory, so the leak
only becomes apparent in a long-running process that uses the leaking
function frequently.  Therefore, it's important to prevent leaks from
happening by having a coding convention or strategy that minimizes this
kind of errors.

  Since Python makes heavy use of `malloc()' and `free()', it needs a
strategy to avoid memory leaks as well as the use of freed memory.  The
chosen method is called _reference counting_.  The principle is simple:
every object contains a counter, which is incremented when a reference
to the object is stored somewhere, and which is decremented when a
reference to it is deleted.  When the counter reaches zero, the last
reference to the object has been deleted and the object is freed.

  An alternative strategy is called _automatic garbage collection_.
(Sometimes, reference counting is also referred to as a garbage
collection strategy, hence my use of "automatic" to distinguish the
two.)  The big advantage of automatic garbage collection is that the
user doesn't need to call `free()' explicitly.  (Another claimed
advantage is an improvement in speed or memory usage -- this is no hard
fact however.)  The disadvantage is that for C, there is no truly
portable automatic garbage collector, while reference counting can be
implemented portably (as long as the functions `malloc()' and `free()'
are available -- which the C Standard guarantees). Maybe some day a
sufficiently portable automatic garbage collector will be available for
C.  Until then, we'll have to live with reference counts.

  While Python uses the traditional reference counting implementation,
it also offers a cycle detector that works to detect reference cycles.
This allows applications to not worry about creating direct or indirect
circular references; these are the weakness of garbage collection
implemented using only reference counting.  Reference cycles consist of
objects which contain (possibly indirect) references to themselves, so
that each object in the cycle has a reference count which is non-zero.
Typical reference counting implementations are not able to reclaim the
memory belonging to any objects in a reference cycle, or referenced
from the objects in the cycle, even though there are no further
references to the cycle itself.

  The cycle detector is able to detect garbage cycles and can reclaim
them so long as there are no finalizers implemented in Python (*note
__del__(): 6f6. methods).  When there are such finalizers, the detector
exposes the cycles through the *note gc: db. module (specifically, the
`garbage' variable in that module).  The *note gc: db. module also
exposes a way to run the detector (the `collect()' function), as well
as configuration interfaces and the ability to disable the detector at
runtime.  The cycle detector is considered an optional component;
though it is included by default, it can be disabled at build time
using the `--without-cycle-gc' option to the *configure* script on Unix
platforms (including Mac OS X) or by removing the definition of
`WITH_CYCLE_GC' in the `pyconfig.h' header on other platforms.  If the
cycle detector is disabled in this way, the *note gc: db.  module will
not be available.

* Menu:

* Reference Counting in Python::
* Ownership Rules::
* Thin Ice::
* NULL Pointers::


File: python.info,  Node: Reference Counting in Python,  Next: Ownership Rules,  Up: Reference Counts

6.1.10.1 Reference Counting in Python
.....................................

There are two macros, `Py_INCREF(x)' and `Py_DECREF(x)', which handle
the incrementing and decrementing of the reference count. *note
Py_DECREF(): 2981. also frees the object when the count reaches zero.
For flexibility, it doesn't call `free()' directly -- rather, it makes
a call through a function pointer in the object's _type object_.  For
this purpose (and others), every object also contains a pointer to its
type object.

  The big question now remains: when to use `Py_INCREF(x)' and
`Py_DECREF(x)'?  Let's first introduce some terms.  Nobody "owns" an
object; however, you can _own a reference_ to an object.  An object's
reference count is now defined as the number of owned references to it.
The owner of a reference is responsible for calling *note Py_DECREF():
2981. when the reference is no longer needed.  Ownership of a reference
can be transferred.  There are three ways to dispose of an owned
reference: pass it on, store it, or call *note Py_DECREF(): 2981.
Forgetting to dispose of an owned reference creates a memory leak.

  It is also possible to _borrow_ (1) a reference to an object.  The
borrower of a reference should not call *note Py_DECREF(): 2981.  The
borrower must not hold on to the object longer than the owner from
which it was borrowed.  Using a borrowed reference after the owner has
disposed of it risks using freed memory and should be avoided
completely. (2)

  The advantage of borrowing over owning a reference is that you don't
need to take care of disposing of the reference on all possible paths
through the code -- in other words, with a borrowed reference you don't
run the risk of leaking when a premature exit is taken.  The
disadvantage of borrowing over owning is that there are some subtle
situations where in seemingly correct code a borrowed reference can be
used after the owner from which it was borrowed has in fact disposed of
it.

  A borrowed reference can be changed into an owned reference by calling
*note Py_INCREF(): 297b.  This does not affect the status of the owner
from which the reference was borrowed -- it creates a new owned
reference, and gives full owner responsibilities (the new owner must
dispose of the reference properly, as well as the previous owner).

  ---------- Footnotes ----------

  (1) The metaphor of "borrowing" a reference is not completely
correct: the owner still has a copy of the reference.

  (2) Checking that the reference count is at least 1 *does not work*
-- the reference count itself could be in freed memory and may thus be
reused for another object!


File: python.info,  Node: Ownership Rules,  Next: Thin Ice,  Prev: Reference Counting in Python,  Up: Reference Counts

6.1.10.2 Ownership Rules
........................

Whenever an object reference is passed into or out of a function, it is
part of the function's interface specification whether ownership is
transferred with the reference or not.

  Most functions that return a reference to an object pass on ownership
with the reference.  In particular, all functions whose function it is
to create a new object, such as *note PyInt_FromLong(): 297f. and *note
Py_BuildValue(): 3a1, pass ownership to the receiver.  Even if the
object is not actually new, you still receive ownership of a new
reference to that object.  For instance, *note PyInt_FromLong(): 297f.
maintains a cache of popular values and can return a reference to a
cached item.

  Many functions that extract objects from other objects also transfer
ownership with the reference, for instance *note
PyObject_GetAttrString(): 299f.  The picture is less clear, here,
however, since a few common routines are exceptions: *note
PyTuple_GetItem(): 29a0, *note PyList_GetItem(): 29a1, *note
PyDict_GetItem(): 29a2, and *note PyDict_GetItemString(): 29a3. all
return references that you borrow from the tuple, list or dictionary.

  The function *note PyImport_AddModule(): 29a4. also returns a
borrowed reference, even though it may actually create the object it
returns: this is possible because an owned reference to the object is
stored in `sys.modules'.

  When you pass an object reference into another function, in general,
the function borrows the reference from you -- if it needs to store it,
it will use *note Py_INCREF(): 297b. to become an independent owner.
There are exactly two important exceptions to this rule: *note
PyTuple_SetItem(): 29a5. and *note PyList_SetItem(): 29a6.  These
functions take over ownership of the item passed to them -- even if
they fail!  (Note that *note PyDict_SetItem(): 29a7. and friends don't
take over ownership -- they are "normal.")

  When a C function is called from Python, it borrows references to its
arguments from the caller.  The caller owns a reference to the object,
so the borrowed reference's lifetime is guaranteed until the function
returns.  Only when such a borrowed reference must be stored or passed
on, it must be turned into an owned reference by calling *note
Py_INCREF(): 297b.

  The object reference returned from a C function that is called from
Python must be an owned reference -- ownership is transferred from the
function to its caller.


File: python.info,  Node: Thin Ice,  Next: NULL Pointers,  Prev: Ownership Rules,  Up: Reference Counts

6.1.10.3 Thin Ice
.................

There are a few situations where seemingly harmless use of a borrowed
reference can lead to problems.  These all have to do with implicit
invocations of the interpreter, which can cause the owner of a
reference to dispose of it.

  The first and most important case to know about is using *note
Py_DECREF(): 2981. on an unrelated object while borrowing a reference
to a list item.  For instance:

    void
    bug(PyObject *list)
    {
        PyObject *item = PyList_GetItem(list, 0);

        PyList_SetItem(list, 1, PyInt_FromLong(0L));
        PyObject_Print(item, stdout, 0); /* BUG! */
    }

This function first borrows a reference to `list[0]', then replaces
`list[1]' with the value `0', and finally prints the borrowed reference.
Looks harmless, right?  But it's not!

  Let's follow the control flow into *note PyList_SetItem(): 29a6.  The
list owns references to all its items, so when item 1 is replaced, it
has to dispose of the original item 1.  Now let's suppose the original
item 1 was an instance of a user-defined class, and let's further
suppose that the class defined a *note __del__(): 6f6. method.  If this
class instance has a reference count of 1, disposing of it will call
its *note __del__(): 6f6. method.

  Since it is written in Python, the *note __del__(): 6f6. method can
execute arbitrary Python code.  Could it perhaps do something to
invalidate the reference to `item' in `bug()'?  You bet!  Assuming that
the list passed into `bug()' is accessible to the *note __del__(): 6f6.
method, it could execute a statement to the effect of `del list[0]',
and assuming this was the last reference to that object, it would free
the memory associated with it, thereby invalidating `item'.

  The solution, once you know the source of the problem, is easy:
temporarily increment the reference count.  The correct version of the
function reads:

    void
    no_bug(PyObject *list)
    {
        PyObject *item = PyList_GetItem(list, 0);

        Py_INCREF(item);
        PyList_SetItem(list, 1, PyInt_FromLong(0L));
        PyObject_Print(item, stdout, 0);
        Py_DECREF(item);
    }

This is a true story.  An older version of Python contained variants of
this bug and someone spent a considerable amount of time in a C
debugger to figure out why his *note __del__(): 6f6. methods would
fail...

  The second case of problems with a borrowed reference is a variant
involving threads.  Normally, multiple threads in the Python
interpreter can't get in each other's way, because there is a global
lock protecting Python's entire object space.  However, it is possible
to temporarily release this lock using the macro *note
Py_BEGIN_ALLOW_THREADS: 29aa, and to re-acquire it using *note
Py_END_ALLOW_THREADS: 29ab.  This is common around blocking I/O calls,
to let other threads use the processor while waiting for the I/O to
complete.  Obviously, the following function has the same problem as
the previous one:

    void
    bug(PyObject *list)
    {
        PyObject *item = PyList_GetItem(list, 0);
        Py_BEGIN_ALLOW_THREADS
        ...some blocking I/O call...
        Py_END_ALLOW_THREADS
        PyObject_Print(item, stdout, 0); /* BUG! */
    }



File: python.info,  Node: NULL Pointers,  Prev: Thin Ice,  Up: Reference Counts

6.1.10.4 NULL Pointers
......................

In general, functions that take object references as arguments do not
expect you to pass them _NULL_ pointers, and will dump core (or cause
later core dumps) if you do so.  Functions that return object
references generally return _NULL_ only to indicate that an exception
occurred.  The reason for not testing for _NULL_ arguments is that
functions often pass the objects they receive on to other function --
if each function were to test for _NULL_, there would be a lot of
redundant tests and the code would run more slowly.

  It is better to test for _NULL_ only at the "source:" when a pointer
that may be _NULL_ is received, for example, from `malloc()' or from a
function that may raise an exception.

  The macros *note Py_INCREF(): 297b. and *note Py_DECREF(): 2981. do
not check for _NULL_ pointers -- however, their variants *note
Py_XINCREF(): 2990. and *note Py_XDECREF(): 2980.  do.

  The macros for checking for a particular object type
(`Pytype_Check()') don't check for _NULL_ pointers -- again, there is
much code that calls several of these in a row to test an object
against various different expected types, and this would generate
redundant tests.  There are no variants with _NULL_ checking.

  The C function calling mechanism guarantees that the argument list
passed to C functions (`args' in the examples) is never _NULL_ -- in
fact it guarantees that it is always a tuple. (1)

  It is a severe error to ever let a _NULL_ pointer "escape" to the
Python user.

  ---------- Footnotes ----------

  (1) These guarantees don't hold when you use the "old" style calling
convention -- this is still found in much existing code.


File: python.info,  Node: Writing Extensions in C++,  Next: Providing a C API for an Extension Module,  Prev: Reference Counts,  Up: Extending Python with C or C++

6.1.11 Writing Extensions in C++
--------------------------------

It is possible to write extension modules in C++.  Some restrictions
apply.  If the main program (the Python interpreter) is compiled and
linked by the C compiler, global or static objects with constructors
cannot be used.  This is not a problem if the main program is linked by
the C++ compiler.  Functions that will be called by the Python
interpreter (in particular, module initialization functions) have to be
declared using `extern "C"'. It is unnecessary to enclose the Python
header files in `extern "C" {...}' -- they use this form already if the
symbol `__cplusplus' is defined (all recent C++ compilers define this
symbol).


File: python.info,  Node: Providing a C API for an Extension Module,  Prev: Writing Extensions in C++,  Up: Extending Python with C or C++

6.1.12 Providing a C API for an Extension Module
------------------------------------------------

Many extension modules just provide new functions and types to be used
from Python, but sometimes the code in an extension module can be
useful for other extension modules. For example, an extension module
could implement a type "collection" which works like lists without
order. Just like the standard Python list type has a C API which
permits extension modules to create and manipulate lists, this new
collection type should have a set of C functions for direct
manipulation from other extension modules.

  At first sight this seems easy: just write the functions (without
declaring them `static', of course), provide an appropriate header
file, and document the C API. And in fact this would work if all
extension modules were always linked statically with the Python
interpreter. When modules are used as shared libraries, however, the
symbols defined in one module may not be visible to another module. The
details of visibility depend on the operating system; some systems use
one global namespace for the Python interpreter and all extension
modules (Windows, for example), whereas others require an explicit list
of imported symbols at module link time (AIX is one example), or offer
a choice of different strategies (most Unices). And even if symbols are
globally visible, the module whose functions one wishes to call might
not have been loaded yet!

  Portability therefore requires not to make any assumptions about
symbol visibility. This means that all symbols in extension modules
should be declared `static', except for the module's initialization
function, in order to avoid name clashes with other extension modules
(as discussed in section *note The Module's Method Table and
Initialization Function: 2986.). And it means that symbols that
_should_ be accessible from other extension modules must be exported in
a different way.

  Python provides a special mechanism to pass C-level information
(pointers) from one extension module to another one: Capsules. A
Capsule is a Python data type which stores a pointer (`void *').
Capsules can only be created and accessed via their C API, but they can
be passed around like any other Python object. In particular,  they can
be assigned to a name in an extension module's namespace. Other
extension modules can then import this module, retrieve the value of
this name, and then retrieve the pointer from the Capsule.

  There are many ways in which Capsules can be used to export the C API
of an extension module. Each function could get its own Capsule, or all
C API pointers could be stored in an array whose address is published
in a Capsule. And the various tasks of storing and retrieving the
pointers can be distributed in different ways between the module
providing the code and the client modules.

  Whichever method you choose, it's important to name your Capsules
properly.  The function *note PyCapsule_New(): 29b1. takes a name
parameter (`const char *'); you're permitted to pass in a _NULL_ name,
but we strongly encourage you to specify a name.  Properly named
Capsules provide a degree of runtime type-safety; there is no feasible
way to tell one unnamed Capsule from another.

  In particular, Capsules used to expose C APIs should be given a name
following this convention:

    modulename.attributename

The convenience function *note PyCapsule_Import(): 29b2. makes it easy
to load a C API provided via a Capsule, but only if the Capsule's name
matches this convention.  This behavior gives C API users a high degree
of certainty that the Capsule they load contains the correct C API.

  The following example demonstrates an approach that puts most of the
burden on the writer of the exporting module, which is appropriate for
commonly used library modules. It stores all C API pointers (just one
in the example!) in an array of `void' pointers which becomes the value
of a Capsule. The header file corresponding to the module provides a
macro that takes care of importing the module and retrieving its C API
pointers; client modules only have to call this macro before accessing
the C API.

  The exporting module is a modification of the `spam' module from
section *note A Simple Example: 2974. The function `spam.system()' does
not call the C library function `system()' directly, but a function
`PySpam_System()', which would of course do something more complicated
in reality (such as adding "spam" to every command). This function
`PySpam_System()' is also exported to other extension modules.

  The function `PySpam_System()' is a plain C function, declared
`static' like everything else:

    static int
    PySpam_System(const char *command)
    {
        return system(command);
    }

The function `spam_system()' is modified in a trivial way:

    static PyObject *
    spam_system(PyObject *self, PyObject *args)
    {
        const char *command;
        int sts;

        if (!PyArg_ParseTuple(args, "s", &command))
            return NULL;
        sts = PySpam_System(command);
        return Py_BuildValue("i", sts);
    }

In the beginning of the module, right after the line

    #include "Python.h"

two more lines must be added:

    #define SPAM_MODULE
    #include "spammodule.h"

The `#define' is used to tell the header file that it is being included
in the exporting module, not a client module. Finally, the module's
initialization function must take care of initializing the C API
pointer array:

    PyMODINIT_FUNC
    initspam(void)
    {
        PyObject *m;
        static void *PySpam_API[PySpam_API_pointers];
        PyObject *c_api_object;

        m = Py_InitModule("spam", SpamMethods);
        if (m == NULL)
            return;

        /* Initialize the C API pointer array */
        PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;

        /* Create a Capsule containing the API pointer array's address */
        c_api_object = PyCapsule_New((void *)PySpam_API, "spam._C_API", NULL);

        if (c_api_object != NULL)
            PyModule_AddObject(m, "_C_API", c_api_object);
    }

Note that `PySpam_API' is declared `static'; otherwise the pointer
array would disappear when `initspam()' terminates!

  The bulk of the work is in the header file `spammodule.h', which looks
like this:

    #ifndef Py_SPAMMODULE_H
    #define Py_SPAMMODULE_H
    #ifdef __cplusplus
    extern "C" {
    #endif

    /* Header file for spammodule */

    /* C API functions */
    #define PySpam_System_NUM 0
    #define PySpam_System_RETURN int
    #define PySpam_System_PROTO (const char *command)

    /* Total number of C API pointers */
    #define PySpam_API_pointers 1


    #ifdef SPAM_MODULE
    /* This section is used when compiling spammodule.c */

    static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;

    #else
    /* This section is used in modules that use spammodule's API */

    static void **PySpam_API;

    #define PySpam_System \
     (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])

    /* Return -1 on error, 0 on success.
     * PyCapsule_Import will set an exception if there's an error.
     */
    static int
    import_spam(void)
    {
        PySpam_API = (void **)PyCapsule_Import("spam._C_API", 0);
        return (PySpam_API != NULL) ? 0 : -1;
    }

    #endif

    #ifdef __cplusplus
    }
    #endif

    #endif /* !defined(Py_SPAMMODULE_H) */

All that a client module must do in order to have access to the function
`PySpam_System()' is to call the function (or rather macro)
`import_spam()' in its initialization function:

    PyMODINIT_FUNC
    initclient(void)
    {
        PyObject *m;

        m = Py_InitModule("client", ClientMethods);
        if (m == NULL)
            return;
        if (import_spam() < 0)
            return;
        /* additional initialization can happen here */
    }

The main disadvantage of this approach is that the file `spammodule.h'
is rather complicated. However, the basic structure is the same for
each function that is exported, so it has to be learned only once.

  Finally it should be mentioned that Capsules offer additional
functionality, which is especially useful for memory allocation and
deallocation of the pointer stored in a Capsule. The details are
described in the Python/C API Reference Manual in the section *note
Capsules: 29b3. and in the implementation of Capsules (files
`Include/pycapsule.h' and `Objects/pycapsule.c' in the Python source
code distribution).


File: python.info,  Node: Defining New Types,  Next: Building C and C++ Extensions with distutils,  Prev: Extending Python with C or C++,  Up: Extending and Embedding the Python Interpreter

6.2 Defining New Types
======================

As mentioned in the last chapter, Python allows the writer of an
extension module to define new types that can be manipulated from
Python code, much like strings and lists in core Python.

  This is not hard; the code for all extension types follows a pattern,
but there are some details that you need to understand before you can
get started.

     Note: The way new types are defined changed dramatically (and for
     the better) in Python 2.2.  This document documents how to define
     new types for Python 2.2 and later.  If you need to support older
     versions of Python, you will need to refer to older versions of
     this documentation(1).

* Menu:

* The Basics::
* Type Methods::

The Basics

* Adding data and methods to the Basic example::
* Providing finer control over data attributes::
* Supporting cyclic garbage collection::
* Subclassing other types::

Type Methods

* Finalization and De-allocation::
* Object Presentation::
* Attribute Management::
* Object Comparison::
* Abstract Protocol Support::
* Weak Reference Support::
* More Suggestions::

Attribute Management

* Generic Attribute Management::
* Type-specific Attribute Management::

  ---------- Footnotes ----------

  (1) http://www.python.org/doc/versions/


File: python.info,  Node: The Basics,  Next: Type Methods,  Up: Defining New Types

6.2.1 The Basics
----------------

The Python runtime sees all Python objects as variables of type *note
PyObject*: 39f.  A *note PyObject: 39f. is not a very magnificent
object - it just contains the refcount and a pointer to the object's
"type object".  This is where the action is; the type object determines
which (C) functions get called when, for instance, an attribute gets
looked up on an object or it is multiplied by another object.  These C
functions are called "type methods".

  So, if you want to define a new object type, you need to create a new
type object.

  This sort of thing can only be explained by example, so here's a
minimal, but complete, module that defines a new type:

    #include <Python.h>

    typedef struct {
        PyObject_HEAD
        /* Type-specific fields go here. */
    } noddy_NoddyObject;

    static PyTypeObject noddy_NoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                         /*ob_size*/
        "noddy.Noddy",             /*tp_name*/
        sizeof(noddy_NoddyObject), /*tp_basicsize*/
        0,                         /*tp_itemsize*/
        0,                         /*tp_dealloc*/
        0,                         /*tp_print*/
        0,                         /*tp_getattr*/
        0,                         /*tp_setattr*/
        0,                         /*tp_compare*/
        0,                         /*tp_repr*/
        0,                         /*tp_as_number*/
        0,                         /*tp_as_sequence*/
        0,                         /*tp_as_mapping*/
        0,                         /*tp_hash */
        0,                         /*tp_call*/
        0,                         /*tp_str*/
        0,                         /*tp_getattro*/
        0,                         /*tp_setattro*/
        0,                         /*tp_as_buffer*/
        Py_TPFLAGS_DEFAULT,        /*tp_flags*/
        "Noddy objects",           /* tp_doc */
    };

    static PyMethodDef noddy_methods[] = {
        {NULL}  /* Sentinel */
    };

    #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
    #define PyMODINIT_FUNC void
    #endif
    PyMODINIT_FUNC
    initnoddy(void)
    {
        PyObject* m;

        noddy_NoddyType.tp_new = PyType_GenericNew;
        if (PyType_Ready(&noddy_NoddyType) < 0)
            return;

        m = Py_InitModule3("noddy", noddy_methods,
                           "Example module that creates an extension type.");

        Py_INCREF(&noddy_NoddyType);
        PyModule_AddObject(m, "Noddy", (PyObject *)&noddy_NoddyType);
    }

Now that's quite a bit to take in at once, but hopefully bits will seem
familiar from the last chapter.

  The first bit that will be new is:

    typedef struct {
        PyObject_HEAD
    } noddy_NoddyObject;

This is what a Noddy object will contain--in this case, nothing more
than every Python object contains, namely a refcount and a pointer to a
type object.  These are the fields the `PyObject_HEAD' macro brings in.
The reason for the macro is to standardize the layout and to enable
special debugging fields in debug builds.  Note that there is no
semicolon after the `PyObject_HEAD' macro; one is included in the macro
definition.  Be wary of adding one by accident; it's easy to do from
habit, and your compiler might not complain, but someone else's
probably will!  (On Windows, MSVC is known to call this an error and
refuse to compile the code.)

  For contrast, let's take a look at the corresponding definition for
standard Python integers:

    typedef struct {
        PyObject_HEAD
        long ob_ival;
    } PyIntObject;

Moving on, we come to the crunch -- the type object.

    static PyTypeObject noddy_NoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                         /*ob_size*/
        "noddy.Noddy",             /*tp_name*/
        sizeof(noddy_NoddyObject), /*tp_basicsize*/
        0,                         /*tp_itemsize*/
        0,                         /*tp_dealloc*/
        0,                         /*tp_print*/
        0,                         /*tp_getattr*/
        0,                         /*tp_setattr*/
        0,                         /*tp_compare*/
        0,                         /*tp_repr*/
        0,                         /*tp_as_number*/
        0,                         /*tp_as_sequence*/
        0,                         /*tp_as_mapping*/
        0,                         /*tp_hash */
        0,                         /*tp_call*/
        0,                         /*tp_str*/
        0,                         /*tp_getattro*/
        0,                         /*tp_setattro*/
        0,                         /*tp_as_buffer*/
        Py_TPFLAGS_DEFAULT,        /*tp_flags*/
        "Noddy objects",           /* tp_doc */
    };

Now if you go and look up the definition of *note PyTypeObject: 29b9. in
`object.h' you'll see that it has many more fields that the definition
above.  The remaining fields will be filled with zeros by the C
compiler, and it's common practice to not specify them explicitly
unless you need them.

  This is so important that we're going to pick the top of it apart
still further:

    PyObject_HEAD_INIT(NULL)

This line is a bit of a wart; what we'd like to write is:

    PyObject_HEAD_INIT(&PyType_Type)

as the type of a type object is "type", but this isn't strictly
conforming C and some compilers complain.  Fortunately, this member
will be filled in for us by *note PyType_Ready(): 29ba.

    0,                          /* ob_size */

The `ob_size' field of the header is not used; its presence in the type
structure is a historical artifact that is maintained for binary
compatibility with extension modules compiled for older versions of
Python.  Always set this field to zero.

    "noddy.Noddy",              /* tp_name */

The name of our type.  This will appear in the default textual
representation of our objects and in some error messages, for example:

    >>> "" + noddy.new_noddy()
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: cannot add type "noddy.Noddy" to string

Note that the name is a dotted name that includes both the module name
and the name of the type within the module. The module in this case is
`noddy' and the type is `Noddy', so we set the type name to
`noddy.Noddy'.

    sizeof(noddy_NoddyObject),  /* tp_basicsize */

This is so that Python knows how much memory to allocate when you call
*note PyObject_New(): 464.

     Note: If you want your type to be subclassable from Python, and
     your type has the same `tp_basicsize' as its base type, you may
     have problems with multiple inheritance.  A Python subclass of
     your type will have to list your type first in its `__bases__', or
     else it will not be able to call your type's *note __new__(): 6e9.
     method without getting an error.  You can avoid this problem by
     ensuring that your type has a larger value for `tp_basicsize' than
     its base type does.  Most of the time, this will be true anyway,
     because either your base type will be *note object: 1ee, or else
     you will be adding data members to your base type, and therefore
     increasing its size.

    0,                          /* tp_itemsize */

This has to do with variable length objects like lists and strings.
Ignore this for now.

  Skipping a number of type methods that we don't provide, we set the
class flags to *note Py_TPFLAGS_DEFAULT: 29bb.

    Py_TPFLAGS_DEFAULT,        /*tp_flags*/

All types should include this constant in their flags.  It enables all
of the members defined by the current version of Python.

  We provide a doc string for the type in `tp_doc'.

    "Noddy objects",           /* tp_doc */

Now we get into the type methods, the things that make your objects
different from the others.  We aren't going to implement any of these
in this version of the module.  We'll expand this example later to have
more interesting behavior.

  For now, all we want to be able to do is to create new `Noddy'
objects.  To enable object creation, we have to provide a `tp_new'
implementation.  In this case, we can just use the default
implementation provided by the API function *note PyType_GenericNew():
29bc.  We'd like to just assign this to the `tp_new' slot, but we
can't, for portability sake, On some platforms or compilers, we can't
statically initialize a structure member with a function defined in
another C module, so, instead, we'll assign the `tp_new' slot in the
module initialization function just before calling *note
PyType_Ready(): 29ba.:

    noddy_NoddyType.tp_new = PyType_GenericNew;
    if (PyType_Ready(&noddy_NoddyType) < 0)
        return;

All the other type methods are _NULL_, so we'll go over them later --
that's for a later section!

  Everything else in the file should be familiar, except for some code
in `initnoddy()':

    if (PyType_Ready(&noddy_NoddyType) < 0)
        return;

This initializes the `Noddy' type, filing in a number of members,
including `ob_type' that we initially set to _NULL_.

    PyModule_AddObject(m, "Noddy", (PyObject *)&noddy_NoddyType);

This adds the type to the module dictionary.  This allows us to create
`Noddy' instances by calling the `Noddy' class:

    >>> import noddy
    >>> mynoddy = noddy.Noddy()

That's it!  All that remains is to build it; put the above code in a
file called `noddy.c' and

    from distutils.core import setup, Extension
    setup(name="noddy", version="1.0",
          ext_modules=[Extension("noddy", ["noddy.c"])])

in a file called `setup.py'; then typing

    $ python setup.py build

at a shell should produce a file `noddy.so' in a subdirectory; move to
that directory and fire up Python -- you should be able to `import
noddy' and play around with Noddy objects.

  That wasn't so hard, was it?

  Of course, the current Noddy type is pretty uninteresting. It has no
data and doesn't do anything. It can't even be subclassed.

* Menu:

* Adding data and methods to the Basic example::
* Providing finer control over data attributes::
* Supporting cyclic garbage collection::
* Subclassing other types::


File: python.info,  Node: Adding data and methods to the Basic example,  Next: Providing finer control over data attributes,  Up: The Basics

6.2.1.1 Adding data and methods to the Basic example
....................................................

Let's expend the basic example to add some data and methods.  Let's
also make the type usable as a base class. We'll create a new module,
`noddy2' that adds these capabilities:

    #include <Python.h>
    #include "structmember.h"

    typedef struct {
        PyObject_HEAD
        PyObject *first; /* first name */
        PyObject *last;  /* last name */
        int number;
    } Noddy;

    static void
    Noddy_dealloc(Noddy* self)
    {
        Py_XDECREF(self->first);
        Py_XDECREF(self->last);
        self->ob_type->tp_free((PyObject*)self);
    }

    static PyObject *
    Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
    {
        Noddy *self;

        self = (Noddy *)type->tp_alloc(type, 0);
        if (self != NULL) {
            self->first = PyString_FromString("");
            if (self->first == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->last = PyString_FromString("");
            if (self->last == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->number = 0;
        }

        return (PyObject *)self;
    }

    static int
    Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
    {
        PyObject *first=NULL, *last=NULL, *tmp;

        static char *kwlist[] = {"first", "last", "number", NULL};

        if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                          &first, &last,
                                          &self->number))
            return -1;

        if (first) {
            tmp = self->first;
            Py_INCREF(first);
            self->first = first;
            Py_XDECREF(tmp);
        }

        if (last) {
            tmp = self->last;
            Py_INCREF(last);
            self->last = last;
            Py_XDECREF(tmp);
        }

        return 0;
    }


    static PyMemberDef Noddy_members[] = {
        {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
         "first name"},
        {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
         "last name"},
        {"number", T_INT, offsetof(Noddy, number), 0,
         "noddy number"},
        {NULL}  /* Sentinel */
    };

    static PyObject *
    Noddy_name(Noddy* self)
    {
        static PyObject *format = NULL;
        PyObject *args, *result;

        if (format == NULL) {
            format = PyString_FromString("%s %s");
            if (format == NULL)
                return NULL;
        }

        if (self->first == NULL) {
            PyErr_SetString(PyExc_AttributeError, "first");
            return NULL;
        }

        if (self->last == NULL) {
            PyErr_SetString(PyExc_AttributeError, "last");
            return NULL;
        }

        args = Py_BuildValue("OO", self->first, self->last);
        if (args == NULL)
            return NULL;

        result = PyString_Format(format, args);
        Py_DECREF(args);

        return result;
    }

    static PyMethodDef Noddy_methods[] = {
        {"name", (PyCFunction)Noddy_name, METH_NOARGS,
         "Return the name, combining the first and last name"
        },
        {NULL}  /* Sentinel */
    };

    static PyTypeObject NoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                         /*ob_size*/
        "noddy.Noddy",             /*tp_name*/
        sizeof(Noddy),             /*tp_basicsize*/
        0,                         /*tp_itemsize*/
        (destructor)Noddy_dealloc, /*tp_dealloc*/
        0,                         /*tp_print*/
        0,                         /*tp_getattr*/
        0,                         /*tp_setattr*/
        0,                         /*tp_compare*/
        0,                         /*tp_repr*/
        0,                         /*tp_as_number*/
        0,                         /*tp_as_sequence*/
        0,                         /*tp_as_mapping*/
        0,                         /*tp_hash */
        0,                         /*tp_call*/
        0,                         /*tp_str*/
        0,                         /*tp_getattro*/
        0,                         /*tp_setattro*/
        0,                         /*tp_as_buffer*/
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
        "Noddy objects",           /* tp_doc */
        0,		               /* tp_traverse */
        0,		               /* tp_clear */
        0,		               /* tp_richcompare */
        0,		               /* tp_weaklistoffset */
        0,		               /* tp_iter */
        0,		               /* tp_iternext */
        Noddy_methods,             /* tp_methods */
        Noddy_members,             /* tp_members */
        0,                         /* tp_getset */
        0,                         /* tp_base */
        0,                         /* tp_dict */
        0,                         /* tp_descr_get */
        0,                         /* tp_descr_set */
        0,                         /* tp_dictoffset */
        (initproc)Noddy_init,      /* tp_init */
        0,                         /* tp_alloc */
        Noddy_new,                 /* tp_new */
    };

    static PyMethodDef module_methods[] = {
        {NULL}  /* Sentinel */
    };

    #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
    #define PyMODINIT_FUNC void
    #endif
    PyMODINIT_FUNC
    initnoddy2(void)
    {
        PyObject* m;

        if (PyType_Ready(&NoddyType) < 0)
            return;

        m = Py_InitModule3("noddy2", module_methods,
                           "Example module that creates an extension type.");

        if (m == NULL)
          return;

        Py_INCREF(&NoddyType);
        PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
    }

This version of the module has a number of changes.

  We've added an extra include:

    #include <structmember.h>

This include provides declarations that we use to handle attributes, as
described a bit later.

  The name of the `Noddy' object structure has been shortened to
`Noddy'.  The type object name has been shortened to `NoddyType'.

  The  `Noddy' type now has three data attributes, _first_, _last_, and
_number_.  The _first_ and _last_ variables are Python strings
containing first and last names. The _number_ attribute is an integer.

  The object structure is updated accordingly:

    typedef struct {
        PyObject_HEAD
        PyObject *first;
        PyObject *last;
        int number;
    } Noddy;

Because we now have data to manage, we have to be more careful about
object allocation and deallocation.  At a minimum, we need a
deallocation method:

    static void
    Noddy_dealloc(Noddy* self)
    {
        Py_XDECREF(self->first);
        Py_XDECREF(self->last);
        self->ob_type->tp_free((PyObject*)self);
    }

which is assigned to the `tp_dealloc' member:

    (destructor)Noddy_dealloc, /*tp_dealloc*/

This method decrements the reference counts of the two Python
attributes. We use *note Py_XDECREF(): 2980. here because the `first'
and `last' members could be _NULL_.  It then calls the `tp_free' member
of the object's type to free the object's memory.  Note that the
object's type might not be `NoddyType', because the object may be an
instance of a subclass.

  We want to make sure that the first and last names are initialized to
empty strings, so we provide a new method:

    static PyObject *
    Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
    {
        Noddy *self;

        self = (Noddy *)type->tp_alloc(type, 0);
        if (self != NULL) {
            self->first = PyString_FromString("");
            if (self->first == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->last = PyString_FromString("");
            if (self->last == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->number = 0;
        }

        return (PyObject *)self;
    }

and install it in the `tp_new' member:

    Noddy_new,                 /* tp_new */

The new member is responsible for creating (as opposed to initializing)
objects of the type.  It is exposed in Python as the *note __new__():
6e9. method.  See the paper titled "Unifying types and classes in
Python" for a detailed discussion of the *note __new__(): 6e9. method.
One reason to implement a new method is to assure the initial values of
instance variables.  In this case, we use the new method to make sure
that the initial values of the members `first' and `last' are not
_NULL_. If we didn't care whether the initial values were _NULL_, we
could have used *note PyType_GenericNew(): 29bc. as our new method, as
we did before.  *note PyType_GenericNew(): 29bc. initializes all of the
instance variable members to _NULL_.

  The new method is a static method that is passed the type being
instantiated and any arguments passed when the type was called, and
that returns the new object created. New methods always accept
positional and keyword arguments, but they often ignore the arguments,
leaving the argument handling to initializer methods. Note that if the
type supports subclassing, the type passed may not be the type being
defined.  The new method calls the tp_alloc slot to allocate memory. We
don't fill the `tp_alloc' slot ourselves. Rather *note PyType_Ready():
29ba. fills it for us by inheriting it from our base class, which is
*note object: 1ee. by default.  Most types use the default allocation.

     Note: If you are creating a co-operative `tp_new' (one that calls
     a base type's `tp_new' or *note __new__(): 6e9.), you must _not_
     try to determine what method to call using method resolution order
     at runtime.  Always statically determine what type you are going
     to call, and call its `tp_new' directly, or via
     `type->tp_base->tp_new'.  If you do not do this, Python subclasses
     of your type that also inherit from other Python-defined classes
     may not work correctly.  (Specifically, you may not be able to
     create instances of such subclasses without getting a *note
     TypeError: 215.)

  We provide an initialization function:

    static int
    Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
    {
        PyObject *first=NULL, *last=NULL, *tmp;

        static char *kwlist[] = {"first", "last", "number", NULL};

        if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                          &first, &last,
                                          &self->number))
            return -1;

        if (first) {
            tmp = self->first;
            Py_INCREF(first);
            self->first = first;
            Py_XDECREF(tmp);
        }

        if (last) {
            tmp = self->last;
            Py_INCREF(last);
            self->last = last;
            Py_XDECREF(tmp);
        }

        return 0;
    }

by filling the `tp_init' slot.

    (initproc)Noddy_init,         /* tp_init */

The `tp_init' slot is exposed in Python as the *note __init__(): 375.
method. It is used to initialize an object after it's created. Unlike
the new method, we can't guarantee that the initializer is called.  The
initializer isn't called when unpickling objects and it can be
overridden.  Our initializer accepts arguments to provide initial
values for our instance. Initializers always accept positional and
keyword arguments.

  Initializers can be called multiple times.  Anyone can call the *note
__init__(): 375.  method on our objects.  For this reason, we have to
be extra careful when assigning the new values.  We might be tempted,
for example to assign the `first' member like this:

    if (first) {
        Py_XDECREF(self->first);
        Py_INCREF(first);
        self->first = first;
    }

But this would be risky.  Our type doesn't restrict the type of the
`first' member, so it could be any kind of object.  It could have a
destructor that causes code to be executed that tries to access the
`first' member.  To be paranoid and protect ourselves against this
possibility, we almost always reassign members before decrementing their
reference counts.  When don't we have to do this?

   * when we absolutely know that the reference count is greater than 1

   * when we know that deallocation of the object (1) will not cause
     any calls back into our type's code

   * when decrementing a reference count in a `tp_dealloc' handler when
     garbage-collections is not supported (2)

  We want to expose our instance variables as attributes. There are a
number of ways to do that. The simplest way is to define member
definitions:

    static PyMemberDef Noddy_members[] = {
        {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
         "first name"},
        {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
         "last name"},
        {"number", T_INT, offsetof(Noddy, number), 0,
         "noddy number"},
        {NULL}  /* Sentinel */
    };

and put the definitions in the `tp_members' slot:

    Noddy_members,             /* tp_members */

Each member definition has a member name, type, offset, access flags and
documentation string. See the *note Generic Attribute Management: 29be.
section below for details.

  A disadvantage of this approach is that it doesn't provide a way to
restrict the types of objects that can be assigned to the Python
attributes.  We expect the first and last names to be strings, but any
Python objects can be assigned.  Further, the attributes can be
deleted, setting the C pointers to _NULL_.  Even though we can make
sure the members are initialized to non-_NULL_ values, the members can
be set to _NULL_ if the attributes are deleted.

  We define a single method, `name()', that outputs the objects name as
the concatenation of the first and last names.

    static PyObject *
    Noddy_name(Noddy* self)
    {
        static PyObject *format = NULL;
        PyObject *args, *result;

        if (format == NULL) {
            format = PyString_FromString("%s %s");
            if (format == NULL)
                return NULL;
        }

        if (self->first == NULL) {
            PyErr_SetString(PyExc_AttributeError, "first");
            return NULL;
        }

        if (self->last == NULL) {
            PyErr_SetString(PyExc_AttributeError, "last");
            return NULL;
        }

        args = Py_BuildValue("OO", self->first, self->last);
        if (args == NULL)
            return NULL;

        result = PyString_Format(format, args);
        Py_DECREF(args);

        return result;
    }

The method is implemented as a C function that takes a `Noddy' (or
`Noddy' subclass) instance as the first argument.  Methods always take
an instance as the first argument. Methods often take positional and
keyword arguments as well, but in this cased we don't take any and
don't need to accept a positional argument tuple or keyword argument
dictionary. This method is equivalent to the Python method:

    def name(self):
       return "%s %s" % (self.first, self.last)

Note that we have to check for the possibility that our `first' and
`last' members are _NULL_.  This is because they can be deleted, in
which case they are set to _NULL_.  It would be better to prevent
deletion of these attributes and to restrict the attribute values to be
strings.  We'll see how to do that in the next section.

  Now that we've defined the method, we need to create an array of
method definitions:

    static PyMethodDef Noddy_methods[] = {
        {"name", (PyCFunction)Noddy_name, METH_NOARGS,
         "Return the name, combining the first and last name"
        },
        {NULL}  /* Sentinel */
    };

and assign them to the `tp_methods' slot:

    Noddy_methods,             /* tp_methods */

Note that we used the *note METH_NOARGS: 468. flag to indicate that the
method is passed no arguments.

  Finally, we'll make our type usable as a base class.  We've written
our methods carefully so far so that they don't make any assumptions
about the type of the object being created or used, so all we need to
do is to add the *note Py_TPFLAGS_BASETYPE: 29bf. to our class flag
definition:

    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/

We rename `initnoddy()' to `initnoddy2()' and update the module name
passed to *note Py_InitModule3(): 29c0.

  Finally, we update our `setup.py' file to build the new module:

    from distutils.core import setup, Extension
    setup(name="noddy", version="1.0",
          ext_modules=[
             Extension("noddy", ["noddy.c"]),
             Extension("noddy2", ["noddy2.c"]),
             ])


  ---------- Footnotes ----------

  (1) This is true when we know that the object is a basic type, like a
string or a float.

  (2) We relied on this in the `tp_dealloc' handler in this example,
because our type doesn't support garbage collection. Even if a type
supports garbage collection, there are calls that can be made to
"untrack" the object from garbage collection, however, these calls are
advanced and not covered here.


File: python.info,  Node: Providing finer control over data attributes,  Next: Supporting cyclic garbage collection,  Prev: Adding data and methods to the Basic example,  Up: The Basics

6.2.1.2 Providing finer control over data attributes
....................................................

In this section, we'll provide finer control over how the `first' and
`last' attributes are set in the `Noddy' example. In the previous
version of our module, the instance variables `first' and `last' could
be set to non-string values or even deleted. We want to make sure that
these attributes always contain strings.

    #include <Python.h>
    #include "structmember.h"

    typedef struct {
        PyObject_HEAD
        PyObject *first;
        PyObject *last;
        int number;
    } Noddy;

    static void
    Noddy_dealloc(Noddy* self)
    {
        Py_XDECREF(self->first);
        Py_XDECREF(self->last);
        self->ob_type->tp_free((PyObject*)self);
    }

    static PyObject *
    Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
    {
        Noddy *self;

        self = (Noddy *)type->tp_alloc(type, 0);
        if (self != NULL) {
            self->first = PyString_FromString("");
            if (self->first == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->last = PyString_FromString("");
            if (self->last == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->number = 0;
        }

        return (PyObject *)self;
    }

    static int
    Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
    {
        PyObject *first=NULL, *last=NULL, *tmp;

        static char *kwlist[] = {"first", "last", "number", NULL};

        if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,
                                          &first, &last,
                                          &self->number))
            return -1;

        if (first) {
            tmp = self->first;
            Py_INCREF(first);
            self->first = first;
            Py_DECREF(tmp);
        }

        if (last) {
            tmp = self->last;
            Py_INCREF(last);
            self->last = last;
            Py_DECREF(tmp);
        }

        return 0;
    }

    static PyMemberDef Noddy_members[] = {
        {"number", T_INT, offsetof(Noddy, number), 0,
         "noddy number"},
        {NULL}  /* Sentinel */
    };

    static PyObject *
    Noddy_getfirst(Noddy *self, void *closure)
    {
        Py_INCREF(self->first);
        return self->first;
    }

    static int
    Noddy_setfirst(Noddy *self, PyObject *value, void *closure)
    {
      if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
        return -1;
      }

      if (! PyString_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The first attribute value must be a string");
        return -1;
      }

      Py_DECREF(self->first);
      Py_INCREF(value);
      self->first = value;

      return 0;
    }

    static PyObject *
    Noddy_getlast(Noddy *self, void *closure)
    {
        Py_INCREF(self->last);
        return self->last;
    }

    static int
    Noddy_setlast(Noddy *self, PyObject *value, void *closure)
    {
      if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");
        return -1;
      }

      if (! PyString_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The last attribute value must be a string");
        return -1;
      }

      Py_DECREF(self->last);
      Py_INCREF(value);
      self->last = value;

      return 0;
    }

    static PyGetSetDef Noddy_getseters[] = {
        {"first",
         (getter)Noddy_getfirst, (setter)Noddy_setfirst,
         "first name",
         NULL},
        {"last",
         (getter)Noddy_getlast, (setter)Noddy_setlast,
         "last name",
         NULL},
        {NULL}  /* Sentinel */
    };

    static PyObject *
    Noddy_name(Noddy* self)
    {
        static PyObject *format = NULL;
        PyObject *args, *result;

        if (format == NULL) {
            format = PyString_FromString("%s %s");
            if (format == NULL)
                return NULL;
        }

        args = Py_BuildValue("OO", self->first, self->last);
        if (args == NULL)
            return NULL;

        result = PyString_Format(format, args);
        Py_DECREF(args);

        return result;
    }

    static PyMethodDef Noddy_methods[] = {
        {"name", (PyCFunction)Noddy_name, METH_NOARGS,
         "Return the name, combining the first and last name"
        },
        {NULL}  /* Sentinel */
    };

    static PyTypeObject NoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                         /*ob_size*/
        "noddy.Noddy",             /*tp_name*/
        sizeof(Noddy),             /*tp_basicsize*/
        0,                         /*tp_itemsize*/
        (destructor)Noddy_dealloc, /*tp_dealloc*/
        0,                         /*tp_print*/
        0,                         /*tp_getattr*/
        0,                         /*tp_setattr*/
        0,                         /*tp_compare*/
        0,                         /*tp_repr*/
        0,                         /*tp_as_number*/
        0,                         /*tp_as_sequence*/
        0,                         /*tp_as_mapping*/
        0,                         /*tp_hash */
        0,                         /*tp_call*/
        0,                         /*tp_str*/
        0,                         /*tp_getattro*/
        0,                         /*tp_setattro*/
        0,                         /*tp_as_buffer*/
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
        "Noddy objects",           /* tp_doc */
        0,		               /* tp_traverse */
        0,		               /* tp_clear */
        0,		               /* tp_richcompare */
        0,		               /* tp_weaklistoffset */
        0,		               /* tp_iter */
        0,		               /* tp_iternext */
        Noddy_methods,             /* tp_methods */
        Noddy_members,             /* tp_members */
        Noddy_getseters,           /* tp_getset */
        0,                         /* tp_base */
        0,                         /* tp_dict */
        0,                         /* tp_descr_get */
        0,                         /* tp_descr_set */
        0,                         /* tp_dictoffset */
        (initproc)Noddy_init,      /* tp_init */
        0,                         /* tp_alloc */
        Noddy_new,                 /* tp_new */
    };

    static PyMethodDef module_methods[] = {
        {NULL}  /* Sentinel */
    };

    #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
    #define PyMODINIT_FUNC void
    #endif
    PyMODINIT_FUNC
    initnoddy3(void)
    {
        PyObject* m;

        if (PyType_Ready(&NoddyType) < 0)
            return;

        m = Py_InitModule3("noddy3", module_methods,
                           "Example module that creates an extension type.");

        if (m == NULL)
          return;

        Py_INCREF(&NoddyType);
        PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
    }

To provide greater control, over the `first' and `last' attributes,
we'll use custom getter and setter functions.  Here are the functions
for getting and setting the `first' attribute:

    Noddy_getfirst(Noddy *self, void *closure)
    {
        Py_INCREF(self->first);
        return self->first;
    }

    static int
    Noddy_setfirst(Noddy *self, PyObject *value, void *closure)
    {
      if (value == NULL) {
        PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
        return -1;
      }

      if (! PyString_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "The first attribute value must be a string");
        return -1;
      }

      Py_DECREF(self->first);
      Py_INCREF(value);
      self->first = value;

      return 0;
    }

The getter function is passed a `Noddy' object and a "closure", which is
void pointer. In this case, the closure is ignored. (The closure
supports an advanced usage in which definition data is passed to the
getter and setter. This could, for example, be used to allow a single
set of getter and setter functions that decide the attribute to get or
set based on data in the closure.)

  The setter function is passed the `Noddy' object, the new value, and
the closure. The new value may be _NULL_, in which case the attribute
is being deleted.  In our setter, we raise an error if the attribute is
deleted or if the attribute value is not a string.

  We create an array of `PyGetSetDef' structures:

    static PyGetSetDef Noddy_getseters[] = {
        {"first",
         (getter)Noddy_getfirst, (setter)Noddy_setfirst,
         "first name",
         NULL},
        {"last",
         (getter)Noddy_getlast, (setter)Noddy_setlast,
         "last name",
         NULL},
        {NULL}  /* Sentinel */
    };

and register it in the `tp_getset' slot:

    Noddy_getseters,           /* tp_getset */

to register our attribute getters and setters.

  The last item in a `PyGetSetDef' structure is the closure mentioned
above. In this case, we aren't using the closure, so we just pass
_NULL_.

  We also remove the member definitions for these attributes:

    static PyMemberDef Noddy_members[] = {
        {"number", T_INT, offsetof(Noddy, number), 0,
         "noddy number"},
        {NULL}  /* Sentinel */
    };

We also need to update the `tp_init' handler to only allow strings (1)
to be passed:

    static int
    Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
    {
        PyObject *first=NULL, *last=NULL, *tmp;

        static char *kwlist[] = {"first", "last", "number", NULL};

        if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,
                                          &first, &last,
                                          &self->number))
            return -1;

        if (first) {
            tmp = self->first;
            Py_INCREF(first);
            self->first = first;
            Py_DECREF(tmp);
        }

        if (last) {
            tmp = self->last;
            Py_INCREF(last);
            self->last = last;
            Py_DECREF(tmp);
        }

        return 0;
    }

With these changes, we can assure that the `first' and `last' members
are never _NULL_ so we can remove checks for _NULL_ values in almost all
cases. This means that most of the *note Py_XDECREF(): 2980. calls can
be converted to *note Py_DECREF(): 2981. calls. The only place we can't
change these calls is in the deallocator, where there is the
possibility that the initialization of these members failed in the
constructor.

  We also rename the module initialization function and module name in
the initialization function, as we did before, and we add an extra
definition to the `setup.py' file.

  ---------- Footnotes ----------

  (1) We now know that the first and last members are strings, so
perhaps we could be less careful about decrementing their reference
counts, however, we accept instances of string subclasses. Even though
deallocating normal strings won't call back into our objects, we can't
guarantee that deallocating an instance of a string subclass won't call
back into our objects.


File: python.info,  Node: Supporting cyclic garbage collection,  Next: Subclassing other types,  Prev: Providing finer control over data attributes,  Up: The Basics

6.2.1.3 Supporting cyclic garbage collection
............................................

Python has a cyclic-garbage collector that can identify unneeded
objects even when their reference counts are not zero. This can happen
when objects are involved in cycles.  For example, consider:

    >>> l = []
    >>> l.append(l)
    >>> del l

In this example, we create a list that contains itself. When we delete
it, it still has a reference from itself. Its reference count doesn't
drop to zero.  Fortunately, Python's cyclic-garbage collector will
eventually figure out that the list is garbage and free it.

  In the second version of the `Noddy' example, we allowed any kind of
object to be stored in the `first' or `last' attributes. (1) This means
that `Noddy' objects can participate in cycles:

    >>> import noddy2
    >>> n = noddy2.Noddy()
    >>> l = [n]
    >>> n.first = l

This is pretty silly, but it gives us an excuse to add support for the
cyclic-garbage collector to the `Noddy' example.  To support cyclic
garbage collection, types need to fill two slots and set a class flag
that enables these slots:

    #include <Python.h>
    #include "structmember.h"

    typedef struct {
        PyObject_HEAD
        PyObject *first;
        PyObject *last;
        int number;
    } Noddy;

    static int
    Noddy_traverse(Noddy *self, visitproc visit, void *arg)
    {
        int vret;

        if (self->first) {
            vret = visit(self->first, arg);
            if (vret != 0)
                return vret;
        }
        if (self->last) {
            vret = visit(self->last, arg);
            if (vret != 0)
                return vret;
        }

        return 0;
    }

    static int
    Noddy_clear(Noddy *self)
    {
        PyObject *tmp;

        tmp = self->first;
        self->first = NULL;
        Py_XDECREF(tmp);

        tmp = self->last;
        self->last = NULL;
        Py_XDECREF(tmp);

        return 0;
    }

    static void
    Noddy_dealloc(Noddy* self)
    {
        Noddy_clear(self);
        self->ob_type->tp_free((PyObject*)self);
    }

    static PyObject *
    Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
    {
        Noddy *self;

        self = (Noddy *)type->tp_alloc(type, 0);
        if (self != NULL) {
            self->first = PyString_FromString("");
            if (self->first == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->last = PyString_FromString("");
            if (self->last == NULL)
              {
                Py_DECREF(self);
                return NULL;
              }

            self->number = 0;
        }

        return (PyObject *)self;
    }

    static int
    Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
    {
        PyObject *first=NULL, *last=NULL, *tmp;

        static char *kwlist[] = {"first", "last", "number", NULL};

        if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                          &first, &last,
                                          &self->number))
            return -1;

        if (first) {
            tmp = self->first;
            Py_INCREF(first);
            self->first = first;
            Py_XDECREF(tmp);
        }

        if (last) {
            tmp = self->last;
            Py_INCREF(last);
            self->last = last;
            Py_XDECREF(tmp);
        }

        return 0;
    }


    static PyMemberDef Noddy_members[] = {
        {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
         "first name"},
        {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
         "last name"},
        {"number", T_INT, offsetof(Noddy, number), 0,
         "noddy number"},
        {NULL}  /* Sentinel */
    };

    static PyObject *
    Noddy_name(Noddy* self)
    {
        static PyObject *format = NULL;
        PyObject *args, *result;

        if (format == NULL) {
            format = PyString_FromString("%s %s");
            if (format == NULL)
                return NULL;
        }

        if (self->first == NULL) {
            PyErr_SetString(PyExc_AttributeError, "first");
            return NULL;
        }

        if (self->last == NULL) {
            PyErr_SetString(PyExc_AttributeError, "last");
            return NULL;
        }

        args = Py_BuildValue("OO", self->first, self->last);
        if (args == NULL)
            return NULL;

        result = PyString_Format(format, args);
        Py_DECREF(args);

        return result;
    }

    static PyMethodDef Noddy_methods[] = {
        {"name", (PyCFunction)Noddy_name, METH_NOARGS,
         "Return the name, combining the first and last name"
        },
        {NULL}  /* Sentinel */
    };

    static PyTypeObject NoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                         /*ob_size*/
        "noddy.Noddy",             /*tp_name*/
        sizeof(Noddy),             /*tp_basicsize*/
        0,                         /*tp_itemsize*/
        (destructor)Noddy_dealloc, /*tp_dealloc*/
        0,                         /*tp_print*/
        0,                         /*tp_getattr*/
        0,                         /*tp_setattr*/
        0,                         /*tp_compare*/
        0,                         /*tp_repr*/
        0,                         /*tp_as_number*/
        0,                         /*tp_as_sequence*/
        0,                         /*tp_as_mapping*/
        0,                         /*tp_hash */
        0,                         /*tp_call*/
        0,                         /*tp_str*/
        0,                         /*tp_getattro*/
        0,                         /*tp_setattro*/
        0,                         /*tp_as_buffer*/
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
        "Noddy objects",           /* tp_doc */
        (traverseproc)Noddy_traverse,   /* tp_traverse */
        (inquiry)Noddy_clear,           /* tp_clear */
        0,		               /* tp_richcompare */
        0,		               /* tp_weaklistoffset */
        0,		               /* tp_iter */
        0,		               /* tp_iternext */
        Noddy_methods,             /* tp_methods */
        Noddy_members,             /* tp_members */
        0,                         /* tp_getset */
        0,                         /* tp_base */
        0,                         /* tp_dict */
        0,                         /* tp_descr_get */
        0,                         /* tp_descr_set */
        0,                         /* tp_dictoffset */
        (initproc)Noddy_init,      /* tp_init */
        0,                         /* tp_alloc */
        Noddy_new,                 /* tp_new */
    };

    static PyMethodDef module_methods[] = {
        {NULL}  /* Sentinel */
    };

    #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
    #define PyMODINIT_FUNC void
    #endif
    PyMODINIT_FUNC
    initnoddy4(void)
    {
        PyObject* m;

        if (PyType_Ready(&NoddyType) < 0)
            return;

        m = Py_InitModule3("noddy4", module_methods,
                           "Example module that creates an extension type.");

        if (m == NULL)
          return;

        Py_INCREF(&NoddyType);
        PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
    }

The traversal method provides access to subobjects that could
participate in cycles:

    static int
    Noddy_traverse(Noddy *self, visitproc visit, void *arg)
    {
        int vret;

        if (self->first) {
            vret = visit(self->first, arg);
            if (vret != 0)
                return vret;
        }
        if (self->last) {
            vret = visit(self->last, arg);
            if (vret != 0)
                return vret;
        }

        return 0;
    }

For each subobject that can participate in cycles, we need to call the
`visit()' function, which is passed to the traversal method. The
`visit()' function takes as arguments the subobject and the extra
argument _arg_ passed to the traversal method.  It returns an integer
value that must be returned if it is non-zero.

  Python 2.4 and higher provide a *note Py_VISIT(): 29c3. macro that
automates calling visit functions.  With *note Py_VISIT(): 29c3,
`Noddy_traverse()' can be simplified:

    static int
    Noddy_traverse(Noddy *self, visitproc visit, void *arg)
    {
        Py_VISIT(self->first);
        Py_VISIT(self->last);
        return 0;
    }


     Note: Note that the `tp_traverse' implementation must name its
     arguments exactly _visit_ and _arg_ in order to use *note
     Py_VISIT(): 29c3.  This is to encourage uniformity across these
     boring implementations.

  We also need to provide a method for clearing any subobjects that can
participate in cycles.  We implement the method and reimplement the
deallocator to use it:

    static int
    Noddy_clear(Noddy *self)
    {
        PyObject *tmp;

        tmp = self->first;
        self->first = NULL;
        Py_XDECREF(tmp);

        tmp = self->last;
        self->last = NULL;
        Py_XDECREF(tmp);

        return 0;
    }

    static void
    Noddy_dealloc(Noddy* self)
    {
        Noddy_clear(self);
        self->ob_type->tp_free((PyObject*)self);
    }

Notice the use of a temporary variable in `Noddy_clear()'. We use the
temporary variable so that we can set each member to _NULL_ before
decrementing its reference count.  We do this because, as was discussed
earlier, if the reference count drops to zero, we might cause code to
run that calls back into the object.  In addition, because we now
support garbage collection, we also have to worry about code being run
that triggers garbage collection.  If garbage collection is run, our
`tp_traverse' handler could get called. We can't take a chance of
having `Noddy_traverse()' called when a member's reference count has
dropped to zero and its value hasn't been set to _NULL_.

  Python 2.4 and higher provide a *note Py_CLEAR(): 29c4. that
automates the careful decrementing of reference counts.  With *note
Py_CLEAR(): 29c4, the `Noddy_clear()' function can be simplified:

    static int
    Noddy_clear(Noddy *self)
    {
        Py_CLEAR(self->first);
        Py_CLEAR(self->last);
        return 0;
    }

Finally, we add the *note Py_TPFLAGS_HAVE_GC: 29c5. flag to the class
flags:

    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /*tp_flags*/

That's pretty much it.  If we had written custom `tp_alloc' or
`tp_free' slots, we'd need to modify them for cyclic-garbage collection.
Most extensions will use the versions automatically provided.

  ---------- Footnotes ----------

  (1) Even in the third version, we aren't guaranteed to avoid cycles.
Instances of string subclasses are allowed and string subclasses could
allow cycles even if normal strings don't.


File: python.info,  Node: Subclassing other types,  Prev: Supporting cyclic garbage collection,  Up: The Basics

6.2.1.4 Subclassing other types
...............................

It is possible to create new extension types that are derived from
existing types. It is easiest to inherit from the built in types, since
an extension can easily use the `PyTypeObject' it needs. It can be
difficult to share these `PyTypeObject' structures between extension
modules.

  In this example we will create a `Shoddy' type that inherits from the
built-in *note list: 3b5. type. The new type will be completely
compatible with regular lists, but will have an additional
`increment()' method that increases an internal counter.

    >>> import shoddy
    >>> s = shoddy.Shoddy(range(3))
    >>> s.extend(s)
    >>> print len(s)
    6
    >>> print s.increment()
    1
    >>> print s.increment()
    2


    #include <Python.h>

    typedef struct {
        PyListObject list;
        int state;
    } Shoddy;


    static PyObject *
    Shoddy_increment(Shoddy *self, PyObject *unused)
    {
        self->state++;
        return PyInt_FromLong(self->state);
    }


    static PyMethodDef Shoddy_methods[] = {
        {"increment", (PyCFunction)Shoddy_increment, METH_NOARGS,
         PyDoc_STR("increment state counter")},
        {NULL,	NULL},
    };

    static int
    Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds)
    {
        if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)
            return -1;
        self->state = 0;
        return 0;
    }


    static PyTypeObject ShoddyType = {
        PyObject_HEAD_INIT(NULL)
        0,                       /* ob_size */
        "shoddy.Shoddy",         /* tp_name */
        sizeof(Shoddy),          /* tp_basicsize */
        0,                       /* tp_itemsize */
        0,                       /* tp_dealloc */
        0,                       /* tp_print */
        0,                       /* tp_getattr */
        0,                       /* tp_setattr */
        0,                       /* tp_compare */
        0,                       /* tp_repr */
        0,                       /* tp_as_number */
        0,                       /* tp_as_sequence */
        0,                       /* tp_as_mapping */
        0,                       /* tp_hash */
        0,                       /* tp_call */
        0,                       /* tp_str */
        0,                       /* tp_getattro */
        0,                       /* tp_setattro */
        0,                       /* tp_as_buffer */
        Py_TPFLAGS_DEFAULT |
          Py_TPFLAGS_BASETYPE,   /* tp_flags */
        0,                       /* tp_doc */
        0,                       /* tp_traverse */
        0,                       /* tp_clear */
        0,                       /* tp_richcompare */
        0,                       /* tp_weaklistoffset */
        0,                       /* tp_iter */
        0,                       /* tp_iternext */
        Shoddy_methods,          /* tp_methods */
        0,                       /* tp_members */
        0,                       /* tp_getset */
        0,                       /* tp_base */
        0,                       /* tp_dict */
        0,                       /* tp_descr_get */
        0,                       /* tp_descr_set */
        0,                       /* tp_dictoffset */
        (initproc)Shoddy_init,   /* tp_init */
        0,                       /* tp_alloc */
        0,                       /* tp_new */
    };

    PyMODINIT_FUNC
    initshoddy(void)
    {
        PyObject *m;

        ShoddyType.tp_base = &PyList_Type;
        if (PyType_Ready(&ShoddyType) < 0)
            return;

        m = Py_InitModule3("shoddy", NULL, "Shoddy module");
        if (m == NULL)
            return;

        Py_INCREF(&ShoddyType);
        PyModule_AddObject(m, "Shoddy", (PyObject *) &ShoddyType);
    }

As you can see, the source code closely resembles the `Noddy' examples
in previous sections. We will break down the main differences between
them.

    typedef struct {
        PyListObject list;
        int state;
    } Shoddy;

The primary difference for derived type objects is that the base type's
object structure must be the first value. The base type will already
include the *note PyObject_HEAD(): 29c7. at the beginning of its
structure.

  When a Python object is a `Shoddy' instance, its _PyObject*_ pointer
can be safely cast to both _PyListObject*_ and _Shoddy*_.

    static int
    Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds)
    {
        if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)
           return -1;
        self->state = 0;
        return 0;
    }

In the `__init__' method for our type, we can see how to call through to
the `__init__' method of the base type.

  This pattern is important when writing a type with custom *note new:
122. and `dealloc' methods. The *note new: 122. method should not
actually create the memory for the object with `tp_alloc', that will be
handled by the base class when calling its `tp_new'.

  When filling out the *note PyTypeObject(): 29b9. for the `Shoddy'
type, you see a slot for `tp_base()'. Due to cross platform compiler
issues, you can't fill that field directly with the *note
PyList_Type(): 29c8.; it can be done later in the module's `init()'
function.

    PyMODINIT_FUNC
    initshoddy(void)
    {
        PyObject *m;

        ShoddyType.tp_base = &PyList_Type;
        if (PyType_Ready(&ShoddyType) < 0)
            return;

        m = Py_InitModule3("shoddy", NULL, "Shoddy module");
        if (m == NULL)
            return;

        Py_INCREF(&ShoddyType);
        PyModule_AddObject(m, "Shoddy", (PyObject *) &ShoddyType);
    }

Before calling *note PyType_Ready(): 29ba, the type structure must have
the `tp_base' slot filled in. When we are deriving a new type, it is not
necessary to fill out the `tp_alloc' slot with *note
PyType_GenericNew(): 29bc.  - the allocate function from the base type
will be inherited.

  After that, calling *note PyType_Ready(): 29ba. and adding the type
object to the module is the same as with the basic `Noddy' examples.


File: python.info,  Node: Type Methods,  Prev: The Basics,  Up: Defining New Types

6.2.2 Type Methods
------------------

This section aims to give a quick fly-by on the various type methods
you can implement and what they do.

  Here is the definition of *note PyTypeObject: 29b9, with some fields
only used in debug builds omitted:

    typedef struct _typeobject {
        PyObject_VAR_HEAD
        char *tp_name; /* For printing, in format "<module>.<name>" */
        int tp_basicsize, tp_itemsize; /* For allocation */

        /* Methods to implement standard operations */

        destructor tp_dealloc;
        printfunc tp_print;
        getattrfunc tp_getattr;
        setattrfunc tp_setattr;
        cmpfunc tp_compare;
        reprfunc tp_repr;

        /* Method suites for standard classes */

        PyNumberMethods *tp_as_number;
        PySequenceMethods *tp_as_sequence;
        PyMappingMethods *tp_as_mapping;

        /* More standard operations (here for binary compatibility) */

        hashfunc tp_hash;
        ternaryfunc tp_call;
        reprfunc tp_str;
        getattrofunc tp_getattro;
        setattrofunc tp_setattro;

        /* Functions to access object as input/output buffer */
        PyBufferProcs *tp_as_buffer;

        /* Flags to define presence of optional/expanded features */
        long tp_flags;

        char *tp_doc; /* Documentation string */

        /* Assigned meaning in release 2.0 */
        /* call function for all accessible objects */
        traverseproc tp_traverse;

        /* delete references to contained objects */
        inquiry tp_clear;

        /* Assigned meaning in release 2.1 */
        /* rich comparisons */
        richcmpfunc tp_richcompare;

        /* weak reference enabler */
        long tp_weaklistoffset;

        /* Added in release 2.2 */
        /* Iterators */
        getiterfunc tp_iter;
        iternextfunc tp_iternext;

        /* Attribute descriptor and subclassing stuff */
        struct PyMethodDef *tp_methods;
        struct PyMemberDef *tp_members;
        struct PyGetSetDef *tp_getset;
        struct _typeobject *tp_base;
        PyObject *tp_dict;
        descrgetfunc tp_descr_get;
        descrsetfunc tp_descr_set;
        long tp_dictoffset;
        initproc tp_init;
        allocfunc tp_alloc;
        newfunc tp_new;
        freefunc tp_free; /* Low-level free-memory routine */
        inquiry tp_is_gc; /* For PyObject_IS_GC */
        PyObject *tp_bases;
        PyObject *tp_mro; /* method resolution order */
        PyObject *tp_cache;
        PyObject *tp_subclasses;
        PyObject *tp_weaklist;

    } PyTypeObject;

Now that's a _lot_ of methods.  Don't worry too much though - if you
have a type you want to define, the chances are very good that you will
only implement a handful of these.

  As you probably expect by now, we're going to go over this and give
more information about the various handlers.  We won't go in the order
they are defined in the structure, because there is a lot of historical
baggage that impacts the ordering of the fields; be sure your type
initialization keeps the fields in the right order!  It's often easiest
to find an example that includes all the fields you need (even if
they're initialized to `0') and then change the values to suit your new
type.

    char *tp_name; /* For printing */

The name of the type - as mentioned in the last section, this will
appear in various places, almost entirely for diagnostic purposes. Try
to choose something that will be helpful in such a situation!

    int tp_basicsize, tp_itemsize; /* For allocation */

These fields tell the runtime how much memory to allocate when new
objects of this type are created.  Python has some built-in support for
variable length structures (think: strings, lists) which is where the
`tp_itemsize' field comes in.  This will be dealt with later.

    char *tp_doc;

Here you can put a string (or its address) that you want returned when
the Python script references `obj.__doc__' to retrieve the doc string.

  Now we come to the basic type methods--the ones most extension types
will implement.

* Menu:

* Finalization and De-allocation::
* Object Presentation::
* Attribute Management::
* Object Comparison::
* Abstract Protocol Support::
* Weak Reference Support::
* More Suggestions::


File: python.info,  Node: Finalization and De-allocation,  Next: Object Presentation,  Up: Type Methods

6.2.2.1 Finalization and De-allocation
......................................

    destructor tp_dealloc;

This function is called when the reference count of the instance of
your type is reduced to zero and the Python interpreter wants to
reclaim it.  If your type has memory to free or other clean-up to
perform, put it here.  The object itself needs to be freed here as
well.  Here is an example of this function:

    static void
    newdatatype_dealloc(newdatatypeobject * obj)
    {
        free(obj->obj_UnderlyingDatatypePtr);
        obj->ob_type->tp_free(obj);
    }


  One important requirement of the deallocator function is that it
leaves any pending exceptions alone.  This is important since
deallocators are frequently called as the interpreter unwinds the
Python stack; when the stack is unwound due to an exception (rather
than normal returns), nothing is done to protect the deallocators from
seeing that an exception has already been set.  Any actions which a
deallocator performs which may cause additional Python code to be
executed may detect that an exception has been set.  This can lead to
misleading errors from the interpreter.  The proper way to protect
against this is to save a pending exception before performing the
unsafe action, and restoring it when done.  This can be done using the
*note PyErr_Fetch(): 29cc. and *note PyErr_Restore(): 29cd. functions:

    static void
    my_dealloc(PyObject *obj)
    {
        MyObject *self = (MyObject *) obj;
        PyObject *cbresult;

        if (self->my_callback != NULL) {
            PyObject *err_type, *err_value, *err_traceback;
            int have_error = PyErr_Occurred() ? 1 : 0;

            if (have_error)
                PyErr_Fetch(&err_type, &err_value, &err_traceback);

            cbresult = PyObject_CallObject(self->my_callback, NULL);
            if (cbresult == NULL)
                PyErr_WriteUnraisable(self->my_callback);
            else
                Py_DECREF(cbresult);

            if (have_error)
                PyErr_Restore(err_type, err_value, err_traceback);

            Py_DECREF(self->my_callback);
        }
        obj->ob_type->tp_free((PyObject*)self);
    }



File: python.info,  Node: Object Presentation,  Next: Attribute Management,  Prev: Finalization and De-allocation,  Up: Type Methods

6.2.2.2 Object Presentation
...........................

In Python, there are three ways to generate a textual representation of
an object: the *note repr(): 145. function (or equivalent back-tick
syntax), the *note str(): 1e7. function, and the *note print: 4d7.
statement.  For most objects, the *note print: 4d7. statement is
equivalent to the *note str(): 1e7. function, but it is possible to
special-case printing to a `FILE*' if necessary; this should only be
done if efficiency is identified as a problem and profiling suggests
that creating a temporary string object to be written to a file is too
expensive.

  These handlers are all optional, and most types at most need to
implement the `tp_str' and `tp_repr' handlers.

    reprfunc tp_repr;
    reprfunc tp_str;
    printfunc tp_print;

The `tp_repr' handler should return a string object containing a
representation of the instance for which it is called.  Here is a simple
example:

    static PyObject *
    newdatatype_repr(newdatatypeobject * obj)
    {
        return PyString_FromFormat("Repr-ified_newdatatype{{size:\%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
    }

If no `tp_repr' handler is specified, the interpreter will supply a
representation that uses the type's `tp_name' and a uniquely-identifying
value for the object.

  The `tp_str' handler is to *note str(): 1e7. what the `tp_repr'
handler described above is to *note repr(): 145.; that is, it is called
when Python code calls *note str(): 1e7. on an instance of your object.
Its implementation is very similar to the `tp_repr' function, but the
resulting string is intended for human consumption.  If `tp_str' is not
specified, the `tp_repr' handler is used instead.

  Here is a simple example:

    static PyObject *
    newdatatype_str(newdatatypeobject * obj)
    {
        return PyString_FromFormat("Stringified_newdatatype{{size:\%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
    }

The print function will be called whenever Python needs to "print" an
instance of the type.  For example, if 'node' is an instance of type
TreeNode, then the print function is called when Python code calls:

    print node

There is a flags argument and one flag, `Py_PRINT_RAW', and it suggests
that you print without string quotes and possibly without interpreting
escape sequences.

  The print function receives a file object as an argument. You will
likely want to write to that file object.

  Here is a sample print function:

    static int
    newdatatype_print(newdatatypeobject *obj, FILE *fp, int flags)
    {
        if (flags & Py_PRINT_RAW) {
            fprintf(fp, "<{newdatatype object--size: %d}>",
                    obj->obj_UnderlyingDatatypePtr->size);
        }
        else {
            fprintf(fp, "\"<{newdatatype object--size: %d}>\"",
                    obj->obj_UnderlyingDatatypePtr->size);
        }
        return 0;
    }



File: python.info,  Node: Attribute Management,  Next: Object Comparison,  Prev: Object Presentation,  Up: Type Methods

6.2.2.3 Attribute Management
............................

For every object which can support attributes, the corresponding type
must provide the functions that control how the attributes are
resolved.  There needs to be a function which can retrieve attributes
(if any are defined), and another to set attributes (if setting
attributes is allowed).  Removing an attribute is a special case, for
which the new value passed to the handler is _NULL_.

  Python supports two pairs of attribute handlers; a type that supports
attributes only needs to implement the functions for one pair.  The
difference is that one pair takes the name of the attribute as a
`char*', while the other accepts a *note PyObject*: 39f.  Each type can
use whichever pair makes more sense for the implementation's
convenience.

    getattrfunc  tp_getattr;        /* char * version */
    setattrfunc  tp_setattr;
    /* ... */
    getattrofunc tp_getattrofunc;   /* PyObject * version */
    setattrofunc tp_setattrofunc;

If accessing attributes of an object is always a simple operation (this
will be explained shortly), there are generic implementations which can
be used to provide the *note PyObject*: 39f. version of the attribute
management functions.  The actual need for type-specific attribute
handlers almost completely disappeared starting with Python 2.2, though
there are many examples which have not been updated to use some of the
new generic mechanism that is available.

* Menu:

* Generic Attribute Management::
* Type-specific Attribute Management::


File: python.info,  Node: Generic Attribute Management,  Next: Type-specific Attribute Management,  Up: Attribute Management

6.2.2.4 Generic Attribute Management
....................................

New in version 2.2.

  Most extension types only use _simple_ attributes.  So, what makes the
attributes simple?  There are only a couple of conditions that must be
met:

  1. The name of the attributes must be known when *note
     PyType_Ready(): 29ba. is called.

  2. No special processing is needed to record that an attribute was
     looked up or set, nor do actions need to be taken based on the
     value.

  Note that this list does not place any restrictions on the values of
the attributes, when the values are computed, or how relevant data is
stored.

  When *note PyType_Ready(): 29ba. is called, it uses three tables
referenced by the type object to create *note descriptor: 14ff.s which
are placed in the dictionary of the type object.  Each descriptor
controls access to one attribute of the instance object.  Each of the
tables is optional; if all three are _NULL_, instances of the type will
only have attributes that are inherited from their base type, and
should leave the `tp_getattro' and `tp_setattro' fields _NULL_ as well,
allowing the base type to handle attributes.

  The tables are declared as three fields of the type object:

    struct PyMethodDef *tp_methods;
    struct PyMemberDef *tp_members;
    struct PyGetSetDef *tp_getset;

If `tp_methods' is not _NULL_, it must refer to an array of *note
PyMethodDef: 46b. structures.  Each entry in the table is an instance
of this structure:

    typedef struct PyMethodDef {
        char        *ml_name;       /* method name */
        PyCFunction  ml_meth;       /* implementation function */
        int          ml_flags;      /* flags */
        char        *ml_doc;        /* docstring */
    } PyMethodDef;

One entry should be defined for each method provided by the type; no
entries are needed for methods inherited from a base type.  One
additional entry is needed at the end; it is a sentinel that marks the
end of the array.  The `ml_name' field of the sentinel must be _NULL_.

  XXX Need to refer to some unified discussion of the structure fields,
shared with the next section.

  The second table is used to define attributes which map directly to
data stored in the instance.  A variety of primitive C types are
supported, and access may be read-only or read-write.  The structures
in the table are defined as:

    typedef struct PyMemberDef {
        char *name;
        int   type;
        int   offset;
        int   flags;
        char *doc;
    } PyMemberDef;

For each entry in the table, a *note descriptor: 14ff. will be
constructed and added to the type which will be able to extract a value
from the instance structure.  The *note type: 487. field should contain
one of the type codes defined in the `structmember.h' header; the value
will be used to determine how to convert Python values to and from C
values.  The `flags' field is used to store flags which control how the
attribute can be accessed.

  XXX Need to move some of this to a shared section!

  The following flag constants are defined in `structmember.h'; they
may be combined using bitwise-OR.

Constant                        Meaning
----------------------------------------------------------------------------------- 
`READONLY'                      Never writable.
`RO'                            Shorthand for `READONLY'.
`READ_RESTRICTED'               Not readable in restricted mode.
`WRITE_RESTRICTED'              Not writable in restricted mode.
`RESTRICTED'                    Not readable or writable in restricted mode.

  An interesting advantage of using the `tp_members' table to build
descriptors that are used at runtime is that any attribute defined this
way can have an associated doc string simply by providing the text in
the table.  An application can use the introspection API to retrieve
the descriptor from the class object, and get the doc string using its
`__doc__' attribute.

  As with the `tp_methods' table, a sentinel entry with a `name' value
of _NULL_ is required.


File: python.info,  Node: Type-specific Attribute Management,  Prev: Generic Attribute Management,  Up: Attribute Management

6.2.2.5 Type-specific Attribute Management
..........................................

For simplicity, only the `char*' version will be demonstrated here; the
type of the name parameter is the only difference between the `char*'
and *note PyObject*: 39f. flavors of the interface. This example
effectively does the same thing as the generic example above, but does
not use the generic support added in Python 2.2.  The value in showing
this is two-fold: it demonstrates how basic attribute management can be
done in a way that is portable to older versions of Python, and
explains how the handler functions are called, so that if you do need
to extend their functionality, you'll understand what needs to be done.

  The `tp_getattr' handler is called when the object requires an
attribute look-up.  It is called in the same situations where the *note
__getattr__(): 32a.  method of a class would be called.

  A likely way to handle this is (1) to implement a set of functions
(such as `newdatatype_getSize()' and `newdatatype_setSize()' in the
example below), (2) provide a method table listing these functions, and
(3) provide a getattr function that returns the result of a lookup in
that table.  The method table uses the same structure as the
`tp_methods' field of the type object.

  Here is an example:

    static PyMethodDef newdatatype_methods[] = {
        {"getSize", (PyCFunction)newdatatype_getSize, METH_VARARGS,
         "Return the current size."},
        {"setSize", (PyCFunction)newdatatype_setSize, METH_VARARGS,
         "Set the size."},
        {NULL, NULL, 0, NULL}           /* sentinel */
    };

    static PyObject *
    newdatatype_getattr(newdatatypeobject *obj, char *name)
    {
        return Py_FindMethod(newdatatype_methods, (PyObject *)obj, name);
    }

The `tp_setattr' handler is called when the *note __setattr__(): 481. or
*note __delattr__(): 6ec. method of a class instance would be called.
When an attribute should be deleted, the third parameter will be
_NULL_.  Here is an example that simply raises an exception; if this
were really all you wanted, the `tp_setattr' handler should be set to
_NULL_.

    static int
    newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)
    {
        (void)PyErr_Format(PyExc_RuntimeError, "Read-only attribute: \%s", name);
        return -1;
    }



File: python.info,  Node: Object Comparison,  Next: Abstract Protocol Support,  Prev: Attribute Management,  Up: Type Methods

6.2.2.6 Object Comparison
.........................

    cmpfunc tp_compare;

The `tp_compare' handler is called when comparisons are needed and the
object does not implement the specific rich comparison method which
matches the requested comparison.  (It is always used if defined and the
*note PyObject_Compare(): 29d3. or *note PyObject_Cmp(): 29d4.
functions are used, or if *note cmp(): 4b5. is used from Python.) It is
analogous to the *note __cmp__(): 21e. method.  This function should
return `-1' if _obj1_ is less than _obj2_, `0' if they are equal, and
`1' if _obj1_ is greater than _obj2_. (It was previously allowed to
return arbitrary negative or positive integers for less than and
greater than, respectively; as of Python 2.2, this is no longer
allowed.  In the future, other return values may be assigned a
different meaning.)

  A `tp_compare' handler may raise an exception.  In this case it should
return a negative value.  The caller has to test for the exception using
*note PyErr_Occurred(): 297c.

  Here is a sample implementation:

    static int
    newdatatype_compare(newdatatypeobject * obj1, newdatatypeobject * obj2)
    {
        long result;

        if (obj1->obj_UnderlyingDatatypePtr->size <
            obj2->obj_UnderlyingDatatypePtr->size) {
            result = -1;
        }
        else if (obj1->obj_UnderlyingDatatypePtr->size >
                 obj2->obj_UnderlyingDatatypePtr->size) {
            result = 1;
        }
        else {
            result = 0;
        }
        return result;
    }



File: python.info,  Node: Abstract Protocol Support,  Next: Weak Reference Support,  Prev: Object Comparison,  Up: Type Methods

6.2.2.7 Abstract Protocol Support
.................................

Python supports a variety of _abstract_ 'protocols;' the specific
interfaces provided to use these interfaces are documented in *note
Abstract Objects Layer: 29d6.

  A number of these abstract interfaces were defined early in the
development of the Python implementation.  In particular, the number,
mapping, and sequence protocols have been part of Python since the
beginning.  Other protocols have been added over time.  For protocols
which depend on several handler routines from the type implementation,
the older protocols have been defined as optional blocks of handlers
referenced by the type object.  For newer protocols there are
additional slots in the main type object, with a flag bit being set to
indicate that the slots are present and should be checked by the
interpreter.  (The flag bit does not indicate that the slot values are
non-_NULL_. The flag may be set to indicate the presence of a slot, but
a slot may still be unfilled.)

    PyNumberMethods   *tp_as_number;
    PySequenceMethods *tp_as_sequence;
    PyMappingMethods  *tp_as_mapping;

If you wish your object to be able to act like a number, a sequence, or
a mapping object, then you place the address of a structure that
implements the C type *note PyNumberMethods: 3a4, *note
PySequenceMethods: 29d7, or *note PyMappingMethods: 29d8, respectively.
It is up to you to fill in this structure with appropriate values. You
can find examples of the use of each of these in the `Objects'
directory of the Python source distribution.

    hashfunc tp_hash;

This function, if you choose to provide it, should return a hash number
for an instance of your data type. Here is a moderately pointless
example:

    static long
    newdatatype_hash(newdatatypeobject *obj)
    {
        long result;
        result = obj->obj_UnderlyingDatatypePtr->size;
        result = result * 3;
        return result;
    }


    ternaryfunc tp_call;

This function is called when an instance of your data type is "called",
for example, if `obj1' is an instance of your data type and the Python
script contains `obj1('hello')', the `tp_call' handler is invoked.

  This function takes three arguments:

  1. _arg1_ is the instance of the data type which is the subject of
     the call. If the call is `obj1('hello')', then _arg1_ is `obj1'.

  2. _arg2_ is a tuple containing the arguments to the call.  You can
     use *note PyArg_ParseTuple(): 314. to extract the arguments.

  3. _arg3_ is a dictionary of keyword arguments that were passed. If
     this is non-_NULL_ and you support keyword arguments, use *note
     PyArg_ParseTupleAndKeywords(): 415. to extract the arguments.  If
     you do not want to support keyword arguments and this is
     non-_NULL_, raise a *note TypeError: 215. with a message saying
     that keyword arguments are not supported.

  Here is a desultory example of the implementation of the call
function.

    /* Implement the call function.
     *    obj1 is the instance receiving the call.
     *    obj2 is a tuple containing the arguments to the call, in this
     *         case 3 strings.
     */
    static PyObject *
    newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *other)
    {
        PyObject *result;
        char *arg1;
        char *arg2;
        char *arg3;

        if (!PyArg_ParseTuple(args, "sss:call", &arg1, &arg2, &arg3)) {
            return NULL;
        }
        result = PyString_FromFormat(
            "Returning -- value: [\%d] arg1: [\%s] arg2: [\%s] arg3: [\%s]\n",
            obj->obj_UnderlyingDatatypePtr->size,
            arg1, arg2, arg3);
        printf("\%s", PyString_AS_STRING(result));
        return result;
    }

XXX some fields need to be added here...

    /* Added in release 2.2 */
    /* Iterators */
    getiterfunc tp_iter;
    iternextfunc tp_iternext;

These functions provide support for the iterator protocol.  Any object
which wishes to support iteration over its contents (which may be
generated during iteration) must implement the `tp_iter' handler.
Objects which are returned by a `tp_iter' handler must implement both
the `tp_iter' and `tp_iternext' handlers. Both handlers take exactly
one parameter, the instance for which they are being called, and return
a new reference.  In the case of an error, they should set an exception
and return _NULL_.

  For an object which represents an iterable collection, the `tp_iter'
handler must return an iterator object.  The iterator object is
responsible for maintaining the state of the iteration.  For
collections which can support multiple iterators which do not interfere
with each other (as lists and tuples do), a new iterator should be
created and returned.  Objects which can only be iterated over once
(usually due to side effects of iteration) should implement this
handler by returning a new reference to themselves, and should also
implement the `tp_iternext' handler.  File objects are an example of
such an iterator.

  Iterator objects should implement both handlers.  The `tp_iter'
handler should return a new reference to the iterator (this is the same
as the `tp_iter' handler for objects which can only be iterated over
destructively).  The `tp_iternext' handler should return a new
reference to the next object in the iteration if there is one.  If the
iteration has reached the end, it may return _NULL_ without setting an
exception or it may set *note StopIteration: 32c.; avoiding the
exception can yield slightly better performance.  If an actual error
occurs, it should set an exception and return _NULL_.


File: python.info,  Node: Weak Reference Support,  Next: More Suggestions,  Prev: Abstract Protocol Support,  Up: Type Methods

6.2.2.8 Weak Reference Support
..............................

One of the goals of Python's weak-reference implementation is to allow
any type to participate in the weak reference mechanism without
incurring the overhead on those objects which do not benefit by weak
referencing (such as numbers).

  For an object to be weakly referencable, the extension must include a
*note PyObject*: 39f. field in the instance structure for the use of
the weak reference mechanism; it must be initialized to _NULL_ by the
object's constructor.  It must also set the `tp_weaklistoffset' field
of the corresponding type object to the offset of the field. For
example, the instance type is defined with the following structure:

    typedef struct {
        PyObject_HEAD
        PyClassObject *in_class;       /* The class object */
        PyObject      *in_dict;        /* A dictionary */
        PyObject      *in_weakreflist; /* List of weak references */
    } PyInstanceObject;

The statically-declared type object for instances is defined this way:

    PyTypeObject PyInstance_Type = {
        PyObject_HEAD_INIT(&PyType_Type)
        0,
        "module.instance",

        /* Lots of stuff omitted for brevity... */

        Py_TPFLAGS_DEFAULT,                         /* tp_flags */
        0,                                          /* tp_doc */
        0,                                          /* tp_traverse */
        0,                                          /* tp_clear */
        0,                                          /* tp_richcompare */
        offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */
    };

The type constructor is responsible for initializing the weak reference
list to _NULL_:

    static PyObject *
    instance_new() {
        /* Other initialization stuff omitted for brevity */

        self->in_weakreflist = NULL;

        return (PyObject *) self;
    }

The only further addition is that the destructor needs to call the weak
reference manager to clear any weak references.  This is only required
if the weak reference list is non-_NULL_:

    static void
    instance_dealloc(PyInstanceObject *inst)
    {
        /* Allocate temporaries if needed, but do not begin
           destruction just yet.
         */

        if (inst->in_weakreflist != NULL)
            PyObject_ClearWeakRefs((PyObject *) inst);

        /* Proceed with object destruction normally. */
    }



File: python.info,  Node: More Suggestions,  Prev: Weak Reference Support,  Up: Type Methods

6.2.2.9 More Suggestions
........................

Remember that you can omit most of these functions, in which case you
provide `0' as a value.  There are type definitions for each of the
functions you must provide.  They are in `object.h' in the Python
include directory that comes with the source distribution of Python.

  In order to learn how to implement any specific method for your new
data type, do the following: Download and unpack the Python source
distribution.  Go the `Objects' directory, then search the C source
files for `tp_' plus the function you want (for example, `tp_print' or
`tp_compare').  You will find examples of the function you want to
implement.

  When you need to verify that an object is an instance of the type you
are implementing, use the *note PyObject_TypeCheck(): 29db. function. A
sample of its use might be something like the following:

    if (! PyObject_TypeCheck(some_object, &MyType)) {
        PyErr_SetString(PyExc_TypeError, "arg #1 not a mything");
        return NULL;
    }



File: python.info,  Node: Building C and C++ Extensions with distutils,  Next: Building C and C++ Extensions on Windows,  Prev: Defining New Types,  Up: Extending and Embedding the Python Interpreter

6.3 Building C and C++ Extensions with distutils
================================================

Starting in Python 1.4, Python provides, on Unix, a special make file
for building make files for building dynamically-linked extensions and
custom interpreters.  Starting with Python 2.0, this mechanism (known
as related to Makefile.pre.in, and Setup files) is no longer supported.
Building custom interpreters was rarely used, and extension modules can
be built using distutils.

  Building an extension module using distutils requires that distutils
is installed on the build machine, which is included in Python 2.x and
available separately for Python 1.5. Since distutils also supports
creation of binary packages, users don't necessarily need a compiler
and distutils to install the extension.

  A distutils package contains a driver script, `setup.py'. This is a
plain Python file, which, in the most simple case, could look like this:

    from distutils.core import setup, Extension

    module1 = Extension('demo',
                        sources = ['demo.c'])

    setup (name = 'PackageName',
           version = '1.0',
           description = 'This is a demo package',
           ext_modules = [module1])

With this `setup.py', and a file `demo.c', running

    python setup.py build

will compile `demo.c', and produce an extension module named `demo' in
the `build' directory. Depending on the system, the module file will end
up in a subdirectory `build/lib.system', and may have a name like
`demo.so' or `demo.pyd'.

  In the `setup.py', all execution is performed by calling the `setup'
function. This takes a variable number of keyword arguments, of which
the example above uses only a subset. Specifically, the example
specifies meta-information to build packages, and it specifies the
contents of the package.  Normally, a package will contain of addition
modules, like Python source modules, documentation, subpackages, etc.
Please refer to the distutils documentation in *note Distributing
Python Modules: 245a. to learn more about the features of distutils;
this section explains building extension modules only.

  It is common to pre-compute arguments to `setup()', to better
structure the driver script. In the example above, the`ext_modules'
argument to `setup()' is a list of extension modules, each of which is
an instance of the `Extension'. In the example, the instance defines an
extension named `demo' which is build by compiling a single source
file, `demo.c'.

  In many cases, building an extension is more complex, since additional
preprocessor defines and libraries may be needed. This is demonstrated
in the example below.

    from distutils.core import setup, Extension

    module1 = Extension('demo',
                        define_macros = [('MAJOR_VERSION', '1'),
                                         ('MINOR_VERSION', '0')],
                        include_dirs = ['/usr/local/include'],
                        libraries = ['tcl83'],
                        library_dirs = ['/usr/local/lib'],
                        sources = ['demo.c'])

    setup (name = 'PackageName',
           version = '1.0',
           description = 'This is a demo package',
           author = 'Martin v. Loewis',
           author_email = 'martin@v.loewis.de',
           url = 'http://docs.python.org/extending/building',
           long_description = '''
    This is really just a demo package.
    ''',
           ext_modules = [module1])

In this example, `setup()' is called with additional meta-information,
which is recommended when distribution packages have to be built. For
the extension itself, it specifies preprocessor defines, include
directories, library directories, and libraries. Depending on the
compiler, distutils passes this information in different ways to the
compiler. For example, on Unix, this may result in the compilation
commands

    gcc -DNDEBUG -g -O3 -Wall -Wstrict-prototypes -fPIC -DMAJOR_VERSION=1 -DMINOR_VERSION=0 -I/usr/local/include -I/usr/local/include/python2.2 -c demo.c -o build/temp.linux-i686-2.2/demo.o

    gcc -shared build/temp.linux-i686-2.2/demo.o -L/usr/local/lib -ltcl83 -o build/lib.linux-i686-2.2/demo.so

These lines are for demonstration purposes only; distutils users should
trust that distutils gets the invocations right.

* Menu:

* Distributing your extension modules::


File: python.info,  Node: Distributing your extension modules,  Up: Building C and C++ Extensions with distutils

6.3.1 Distributing your extension modules
-----------------------------------------

When an extension has been successfully build, there are three ways to
use it.

  End-users will typically want to install the module, they do so by
running

    python setup.py install

Module maintainers should produce source packages; to do so, they run

    python setup.py sdist

In some cases, additional files need to be included in a source
distribution; this is done through a `MANIFEST.in' file; see the
distutils documentation for details.

  If the source distribution has been build successfully, maintainers
can also create binary distributions. Depending on the platform, one of
the following commands can be used to do so.

    python setup.py bdist_wininst
    python setup.py bdist_rpm
    python setup.py bdist_dumb



File: python.info,  Node: Building C and C++ Extensions on Windows,  Next: Embedding Python in Another Application,  Prev: Building C and C++ Extensions with distutils,  Up: Extending and Embedding the Python Interpreter

6.4 Building C and C++ Extensions on Windows
============================================

This chapter briefly explains how to create a Windows extension module
for Python using Microsoft Visual C++, and follows with more detailed
background information on how it works.  The explanatory material is
useful for both the Windows programmer learning to build Python
extensions and the Unix programmer interested in producing software
which can be successfully built on both Unix and Windows.

  Module authors are encouraged to use the distutils approach for
building extension modules, instead of the one described in this
section. You will still need the C compiler that was used to build
Python; typically Microsoft Visual C++.

     Note: This chapter mentions a number of filenames that include an
     encoded Python version number.  These filenames are represented
     with the version number shown as `XY'; in practice, `'X'' will be
     the major version number and `'Y'' will be the minor version
     number of the Python release you're working with.  For example, if
     you are using Python 2.2.1, `XY' will actually be `22'.

* Menu:

* A Cookbook Approach::
* Differences Between Unix and Windows::
* Using DLLs in Practice::


File: python.info,  Node: A Cookbook Approach,  Next: Differences Between Unix and Windows,  Up: Building C and C++ Extensions on Windows

6.4.1 A Cookbook Approach
-------------------------

There are two approaches to building extension modules on Windows, just
as there are on Unix: use the *note distutils: 85. package to control
the build process, or do things manually.  The distutils approach works
well for most extensions; documentation on using *note distutils: 85.
to build and package extension modules is available in *note
Distributing Python Modules: 245a.  This section describes the manual
approach to building Python extensions written in C or C++.

  To build extensions using these instructions, you need to have a copy
of the Python sources of the same version as your installed Python. You
will need Microsoft Visual C++ "Developer Studio"; project files are
supplied for VC++ version 7.1, but you can use older versions of VC++.
Notice that you should use the same version of VC++that was used to
build Python itself. The example files described here are distributed
with the Python sources in the `PC\example_nt\' directory.

  1. *Copy the example files* --  The `example_nt' directory is a
     subdirectory of the `PC' directory, in order to keep all the
     PC-specific files under the same directory in the source
     distribution.  However, the `example_nt' directory can't actually
     be used from this location.  You first need to copy or move it up
     one level, so that `example_nt' is a sibling of the `PC' and
     `Include' directories.  Do all your work from within this new
     location.

  2. *Open the project* --  From VC++, use the _File ‣ Open Solution_
     dialog (not _File ‣ Open_!).  Navigate to and select the file
     `example.sln', in the _copy_ of the `example_nt' directory you
     made above.  Click Open.

  3. *Build the example DLL* --  In order to check that everything is
     set up right, try building:

  4. Select a configuration.  This step is optional.  Choose _Build ‣
     Configuration Manager ‣ Active Solution Configuration_ and select
     either _Release_  or _Debug_.  If you skip this step, VC++ will
     use the Debug configuration by default.

  5. Build the DLL.  Choose _Build ‣ Build Solution_.  This creates all
     intermediate and result files in a subdirectory called either
     `Debug' or `Release', depending on which configuration you selected
     in the preceding step.

  6. *Testing the debug-mode DLL* --  Once the Debug build has
     succeeded, bring up a DOS box, and change to the
     `example_nt\Debug' directory.  You should now be able to repeat
     the following session (`C>' is the DOS prompt, `>>>' is the Python
     prompt; note that build information and various debug output from
     Python may not match this screen dump exactly):

         C>..\..\PCbuild\python_d
         Adding parser accelerators ...
         Done.
         Python 2.2 (#28, Dec 19 2001, 23:26:37) [MSC 32 bit (Intel)] on win32
         Type "copyright", "credits" or "license" for more information.
         >>> import example
         [4897 refs]
         >>> example.foo()
         Hello, world
         [4903 refs]
         >>>

     Congratulations!  You've successfully built your first Python
     extension module.

  7. *Creating your own project* --  Choose a name and create a
     directory for it.  Copy your C sources into it.  Note that the
     module source file name does not necessarily have to match the
     module name, but the name of the initialization function should
     match the module name -- you can only import a module `spam' if
     its initialization function is called `initspam()', and it should
     call *note Py_InitModule(): 2988. with the string `"spam"' as its
     first argument (use the minimal `example.c' in this directory as a
     guide).  By convention, it lives in a file called `spam.c' or
     `spammodule.c'.  The output file should be called `spam.pyd' (in
     Release mode) or `spam_d.pyd' (in Debug mode). The extension
     `.pyd' was chosen to avoid confusion with a system library
     `spam.dll' to which your module could be a Python interface.

     Changed in version 2.5: Previously, file names like `spam.dll' (in
     release mode) or `spam_d.dll' (in debug mode) were also recognized.

     Now your options are:

  8. Copy `example.sln' and `example.vcproj', rename them to `spam.*',
     and edit them by hand, or

  9. Create a brand new project; instructions are below.

     In either case, copy `example_nt\example.def' to `spam\spam.def',
     and edit the new `spam.def' so its second line contains the string
     '`initspam''.  If you created a new project yourself, add the file
     `spam.def' to the project now.  (This is an annoying little file
     with only two lines.  An alternative approach is to forget about
     the `.def' file, and add the option `/export:initspam' somewhere
     to the Link settings, by manually editing the setting in Project
     Properties dialog).

 10. *Creating a brand new project* --  Use the _File ‣ New ‣ Project_
     dialog to create a new Project Workspace.  Select _Visual C++
     Projects/Win32/ Win32 Project_, enter the name (`spam'), and make
     sure the Location is set to parent of the `spam' directory you
     have created (which should be a direct subdirectory of the Python
     build tree, a sibling of `Include' and `PC').  Select Win32 as the
     platform (in my version, this is the only choice).  Make sure the
     Create new workspace radio button is selected.  Click OK.

     You should now create the file `spam.def' as instructed in the
     previous section. Add the source files to the project, using
     _Project ‣ Add Existing Item_. Set the pattern to `*.*' and select
     both `spam.c' and `spam.def' and click OK.  (Inserting them one by
     one is fine too.)

     Now open the _Project ‣ spam properties_ dialog. You only need to
     change a few settings.  Make sure _All Configurations_ is selected
     from the _Settings for:_ dropdown list.  Select the C/C++ tab.
     Choose the General category in the popup menu at the top.  Type
     the following text in the entry box labeled _Additional Include
     Directories_:

         ..\Include,..\PC

     Then, choose the General category in the Linker tab, and enter

         ..\PCbuild

     in the text box labelled _Additional library Directories_.

     Now you need to add some mode-specific settings:

     Select _Release_ in the _Configuration_ dropdown list.  Choose the
     _Link_ tab, choose the _Input_ category, and append `pythonXY.lib'
     to the list in the _Additional Dependencies_ box.

     Select _Debug_ in the _Configuration_ dropdown list, and append
     `pythonXY_d.lib' to the list in the _Additional Dependencies_ box.
     Then click the C/C++ tab, select _Code Generation_, and select
     _Multi-threaded Debug DLL_ from the _Runtime library_ dropdown
     list.

     Select _Release_ again from the _Configuration_ dropdown list.
     Select _Multi-threaded DLL_ from the _Runtime library_ dropdown
     list.

  If your module creates a new type, you may have trouble with this
line:

    PyObject_HEAD_INIT(&PyType_Type)

Static type object initializers in extension modules may cause compiles
to fail with an error message like "initializer not a constant".  This
shows up when building DLL under MSVC.  Change it to:

    PyObject_HEAD_INIT(NULL)

and add the following to the module initialization function:

    if (PyType_Ready(&MyObject_Type) < 0)
         return NULL;



File: python.info,  Node: Differences Between Unix and Windows,  Next: Using DLLs in Practice,  Prev: A Cookbook Approach,  Up: Building C and C++ Extensions on Windows

6.4.2 Differences Between Unix and Windows
------------------------------------------

Unix and Windows use completely different paradigms for run-time
loading of code.  Before you try to build a module that can be
dynamically loaded, be aware of how your system works.

  In Unix, a shared object (`.so') file contains code to be used by the
program, and also the names of functions and data that it expects to
find in the program.  When the file is joined to the program, all
references to those functions and data in the file's code are changed
to point to the actual locations in the program where the functions and
data are placed in memory.  This is basically a link operation.

  In Windows, a dynamic-link library (`.dll') file has no dangling
references.  Instead, an access to functions or data goes through a
lookup table.  So the DLL code does not have to be fixed up at runtime
to refer to the program's memory; instead, the code already uses the
DLL's lookup table, and the lookup table is modified at runtime to
point to the functions and data.

  In Unix, there is only one type of library file (`.a') which contains
code from several object files (`.o').  During the link step to create
a shared object file (`.so'), the linker may find that it doesn't know
where an identifier is defined.  The linker will look for it in the
object files in the libraries; if it finds it, it will include all the
code from that object file.

  In Windows, there are two types of library, a static library and an
import library (both called `.lib').  A static library is like a Unix
`.a' file; it contains code to be included as necessary. An import
library is basically used only to reassure the linker that a certain
identifier is legal, and will be present in the program when the DLL is
loaded.  So the linker uses the information from the import library to
build the lookup table for using identifiers that are not included in
the DLL.  When an application or a DLL is linked, an import library may
be generated, which will need to be used for all future DLLs that
depend on the symbols in the application or DLL.

  Suppose you are building two dynamic-load modules, B and C, which
should share another block of code A.  On Unix, you would _not_ pass
`A.a' to the linker for `B.so' and `C.so'; that would cause it to be
included twice, so that B and C would each have their own copy.  In
Windows, building `A.dll' will also build `A.lib'.  You _do_ pass
`A.lib' to the linker for B and C.  `A.lib' does not contain code; it
just contains information which will be used at runtime to access A's
code.

  In Windows, using an import library is sort of like using `import
spam'; it gives you access to spam's names, but does not create a
separate copy.  On Unix, linking with a library is more like `from spam
import *'; it does create a separate copy.


File: python.info,  Node: Using DLLs in Practice,  Prev: Differences Between Unix and Windows,  Up: Building C and C++ Extensions on Windows

6.4.3 Using DLLs in Practice
----------------------------

Windows Python is built in Microsoft Visual C++; using other compilers
may or may not work (though Borland seems to).  The rest of this
section is MSVC++ specific.

  When creating DLLs in Windows, you must pass `pythonXY.lib' to the
linker.  To build two DLLs, spam and ni (which uses C functions found
in spam), you could use these commands:

    cl /LD /I/python/include spam.c ../libs/pythonXY.lib
    cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib

The first command created three files: `spam.obj', `spam.dll' and
`spam.lib'.  `Spam.dll' does not contain any Python functions (such as
*note PyArg_ParseTuple(): 314.), but it does know how to find the
Python code thanks to `pythonXY.lib'.

  The second command created `ni.dll' (and `.obj' and `.lib'), which
knows how to find the necessary functions from spam, and also from the
Python executable.

  Not every identifier is exported to the lookup table.  If you want
any other modules (including Python) to be able to see your
identifiers, you have to say `_declspec(dllexport)', as in `void
_declspec(dllexport) initspam(void)' or `PyObject _declspec(dllexport)
*NiGetSpamData(void)'.

  Developer Studio will throw in a lot of import libraries that you do
not really need, adding about 100K to your executable.  To get rid of
them, use the Project Settings dialog, Link tab, to specify _ignore
default libraries_.  Add the correct `msvcrtxx.lib' to the list of
libraries.


File: python.info,  Node: Embedding Python in Another Application,  Prev: Building C and C++ Extensions on Windows,  Up: Extending and Embedding the Python Interpreter

6.5 Embedding Python in Another Application
===========================================

The previous chapters discussed how to extend Python, that is, how to
extend the functionality of Python by attaching a library of C
functions to it.  It is also possible to do it the other way around:
enrich your C/C++ application by embedding Python in it.  Embedding
provides your application with the ability to implement some of the
functionality of your application in Python rather than C or C++. This
can be used for many purposes; one example would be to allow users to
tailor the application to their needs by writing some scripts in
Python.  You can also use it yourself if some of the functionality can
be written in Python more easily.

  Embedding Python is similar to extending it, but not quite.  The
difference is that when you extend Python, the main program of the
application is still the Python interpreter, while if you embed Python,
the main program may have nothing to do with Python -- instead, some
parts of the application occasionally call the Python interpreter to
run some Python code.

  So if you are embedding Python, you are providing your own main
program.  One of the things this main program has to do is initialize
the Python interpreter.  At the very least, you have to call the
function *note Py_Initialize(): 2989.  There are optional calls to pass
command line arguments to Python.  Then later you can call the
interpreter from any part of the application.

  There are several different ways to call the interpreter: you can
pass a string containing Python statements to *note
PyRun_SimpleString(): 29eb, or you can pass a stdio file pointer and a
file name (for identification in error messages only) to *note
PyRun_SimpleFile(): 29ec.  You can also call the lower-level operations
described in the previous chapters to construct and use Python objects.

  A simple demo of embedding Python can be found in the directory
`Demo/embed/' of the source distribution.

See also
........

*note Python/C API Reference Manual: 4f2.
     The details of Python's C interface are given in this manual. A
     great deal of necessary information can be found here.

* Menu:

* Very High Level Embedding::
* Beyond Very High Level Embedding; An overview: Beyond Very High Level Embedding An overview.
* Pure Embedding::
* Extending Embedded Python::
* Embedding Python in C++::
* Linking Requirements::


File: python.info,  Node: Very High Level Embedding,  Next: Beyond Very High Level Embedding An overview,  Up: Embedding Python in Another Application

6.5.1 Very High Level Embedding
-------------------------------

The simplest form of embedding Python is the use of the very high level
interface. This interface is intended to execute a Python script
without needing to interact with the application directly. This can for
example be used to perform some operation on a file.

    #include <Python.h>

    int
    main(int argc, char *argv[])
    {
      Py_SetProgramName(argv[0]);  /* optional but recommended */
      Py_Initialize();
      PyRun_SimpleString("from time import time,ctime\n"
                         "print 'Today is',ctime(time())\n");
      Py_Finalize();
      return 0;
    }

The *note Py_SetProgramName(): 29ef. function should be called before
*note Py_Initialize(): 2989. to inform the interpreter about paths to
Python run-time libraries.  Next, the Python interpreter is initialized
with *note Py_Initialize(): 2989, followed by the execution of a
hard-coded Python script that prints the date and time.  Afterwards,
the *note Py_Finalize(): 2c0. call shuts the interpreter down, followed
by the end of the program.  In a real program, you may want to get the
Python script from another source, perhaps a text-editor routine, a
file, or a database.  Getting the Python code from a file can better be
done by using the *note PyRun_SimpleFile(): 29ec. function, which saves
you the trouble of allocating memory space and loading the file
contents.


File: python.info,  Node: Beyond Very High Level Embedding An overview,  Next: Pure Embedding,  Prev: Very High Level Embedding,  Up: Embedding Python in Another Application

6.5.2 Beyond Very High Level Embedding: An overview
---------------------------------------------------

The high level interface gives you the ability to execute arbitrary
pieces of Python code from your application, but exchanging data values
is quite cumbersome to say the least. If you want that, you should use
lower level calls.  At the cost of having to write more C code, you can
achieve almost anything.

  It should be noted that extending Python and embedding Python is
quite the same activity, despite the different intent. Most topics
discussed in the previous chapters are still valid. To show this,
consider what the extension code from Python to C really does:

  1. Convert data values from Python to C,

  2. Perform a function call to a C routine using the converted values,
     and

  3. Convert the data values from the call from C to Python.

  When embedding Python, the interface code does:

  1. Convert data values from C to Python,

  2. Perform a function call to a Python interface routine using the
     converted values, and

  3. Convert the data values from the call from Python to C.

  As you can see, the data conversion steps are simply swapped to
accommodate the different direction of the cross-language transfer. The
only difference is the routine that you call between both data
conversions. When extending, you call a C routine, when embedding, you
call a Python routine.

  This chapter will not discuss how to convert data from Python to C
and vice versa.  Also, proper use of references and dealing with errors
is assumed to be understood.  Since these aspects do not differ from
extending the interpreter, you can refer to earlier chapters for the
required information.


File: python.info,  Node: Pure Embedding,  Next: Extending Embedded Python,  Prev: Beyond Very High Level Embedding An overview,  Up: Embedding Python in Another Application

6.5.3 Pure Embedding
--------------------

The first program aims to execute a function in a Python script. Like
in the section about the very high level interface, the Python
interpreter does not directly interact with the application (but that
will change in the next section).

  The code to run a function defined in a Python script is:

    #include <Python.h>

    int
    main(int argc, char *argv[])
    {
        PyObject *pName, *pModule, *pDict, *pFunc;
        PyObject *pArgs, *pValue;
        int i;

        if (argc < 3) {
            fprintf(stderr,"Usage: call pythonfile funcname [args]\n");
            return 1;
        }

        Py_Initialize();
        pName = PyString_FromString(argv[1]);
        /* Error checking of pName left out */

        pModule = PyImport_Import(pName);
        Py_DECREF(pName);

        if (pModule != NULL) {
            pFunc = PyObject_GetAttrString(pModule, argv[2]);
            /* pFunc is a new reference */

            if (pFunc && PyCallable_Check(pFunc)) {
                pArgs = PyTuple_New(argc - 3);
                for (i = 0; i < argc - 3; ++i) {
                    pValue = PyInt_FromLong(atoi(argv[i + 3]));
                    if (!pValue) {
                        Py_DECREF(pArgs);
                        Py_DECREF(pModule);
                        fprintf(stderr, "Cannot convert argument\n");
                        return 1;
                    }
                    /* pValue reference stolen here: */
                    PyTuple_SetItem(pArgs, i, pValue);
                }
                pValue = PyObject_CallObject(pFunc, pArgs);
                Py_DECREF(pArgs);
                if (pValue != NULL) {
                    printf("Result of call: %ld\n", PyInt_AsLong(pValue));
                    Py_DECREF(pValue);
                }
                else {
                    Py_DECREF(pFunc);
                    Py_DECREF(pModule);
                    PyErr_Print();
                    fprintf(stderr,"Call failed\n");
                    return 1;
                }
            }
            else {
                if (PyErr_Occurred())
                    PyErr_Print();
                fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
            }
            Py_XDECREF(pFunc);
            Py_DECREF(pModule);
        }
        else {
            PyErr_Print();
            fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
            return 1;
        }
        Py_Finalize();
        return 0;
    }

This code loads a Python script using `argv[1]', and calls the function
named in `argv[2]'.  Its integer arguments are the other values of the
`argv' array.  If you compile and link this program (let's call the
finished executable *call*), and use it to execute a Python script,
such as:

    def multiply(a,b):
        print "Will compute", a, "times", b
        c = 0
        for i in range(0, a):
            c = c + b
        return c

then the result should be:

    $ call multiply multiply 3 2
    Will compute 3 times 2
    Result of call: 6

Although the program is quite large for its functionality, most of the
code is for data conversion between Python and C, and for error
reporting.  The interesting part with respect to embedding Python
starts with

    Py_Initialize();
    pName = PyString_FromString(argv[1]);
    /* Error checking of pName left out */
    pModule = PyImport_Import(pName);

After initializing the interpreter, the script is loaded using *note
PyImport_Import(): 378.  This routine needs a Python string as its
argument, which is constructed using the *note PyString_FromString():
29f4. data conversion routine.

    pFunc = PyObject_GetAttrString(pModule, argv[2]);
    /* pFunc is a new reference */

    if (pFunc && PyCallable_Check(pFunc)) {
        ...
    }
    Py_XDECREF(pFunc);

Once the script is loaded, the name we're looking for is retrieved using
*note PyObject_GetAttrString(): 299f.  If the name exists, and the
object returned is callable, you can safely assume that it is a
function.  The program then proceeds by constructing a tuple of
arguments as normal.  The call to the Python function is then made with:

    pValue = PyObject_CallObject(pFunc, pArgs);

Upon return of the function, `pValue' is either _NULL_ or it contains a
reference to the return value of the function.  Be sure to release the
reference after examining the value.


File: python.info,  Node: Extending Embedded Python,  Next: Embedding Python in C++,  Prev: Pure Embedding,  Up: Embedding Python in Another Application

6.5.4 Extending Embedded Python
-------------------------------

Until now, the embedded Python interpreter had no access to
functionality from the application itself.  The Python API allows this
by extending the embedded interpreter.  That is, the embedded
interpreter gets extended with routines provided by the application.
While it sounds complex, it is not so bad.  Simply forget for a while
that the application starts the Python interpreter.  Instead, consider
the application to be a set of subroutines, and write some glue code
that gives Python access to those routines, just like you would write a
normal Python extension.  For example:

    static int numargs=0;

    /* Return the number of arguments of the application command line */
    static PyObject*
    emb_numargs(PyObject *self, PyObject *args)
    {
        if(!PyArg_ParseTuple(args, ":numargs"))
            return NULL;
        return Py_BuildValue("i", numargs);
    }

    static PyMethodDef EmbMethods[] = {
        {"numargs", emb_numargs, METH_VARARGS,
         "Return the number of arguments received by the process."},
        {NULL, NULL, 0, NULL}
    };

Insert the above code just above the `main()' function. Also, insert the
following two statements directly after *note Py_Initialize(): 2989.:

    numargs = argc;
    Py_InitModule("emb", EmbMethods);

These two lines initialize the `numargs' variable, and make the
`emb.numargs()' function accessible to the embedded Python interpreter.
With these extensions, the Python script can do things like

    import emb
    print "Number of arguments", emb.numargs()

In a real application, the methods will expose an API of the
application to Python.


File: python.info,  Node: Embedding Python in C++,  Next: Linking Requirements,  Prev: Extending Embedded Python,  Up: Embedding Python in Another Application

6.5.5 Embedding Python in C++
-----------------------------

It is also possible to embed Python in a C++ program; precisely how
this is done will depend on the details of the C++ system used; in
general you will need to write the main program in C++, and use the C++
compiler to compile and link your program.  There is no need to
recompile Python itself using C++.


File: python.info,  Node: Linking Requirements,  Prev: Embedding Python in C++,  Up: Embedding Python in Another Application

6.5.6 Linking Requirements
--------------------------

While the *configure* script shipped with the Python sources will
correctly build Python to export the symbols needed by dynamically
linked extensions, this is not automatically inherited by applications
which embed the Python library statically, at least on Unix.  This is
an issue when the application is linked to the static runtime library
(`libpython.a') and needs to load dynamic extensions (implemented as
`.so' files).

  The problem is that some entry points are defined by the Python
runtime solely for extension modules to use.  If the embedding
application does not use any of these entry points, some linkers will
not include those entries in the symbol table of the finished
executable.  Some additional options are needed to inform the linker
not to remove these symbols.

  Determining the right options to use for any given platform can be
quite difficult, but fortunately the Python configuration already has
those values.  To retrieve them from an installed Python interpreter,
start an interactive interpreter and have a short session like this

    >>> import distutils.sysconfig
    >>> distutils.sysconfig.get_config_var('LINKFORSHARED')
    '-Xlinker -export-dynamic'


  The contents of the string presented will be the options that should
be used.  If the string is empty, there's no need to add any additional
options.  The `LINKFORSHARED' definition corresponds to the variable of
the same name in Python's top-level `Makefile'.


File: python.info,  Node: Python/C API Reference Manual,  Next: Distributing Python Modules,  Prev: Extending and Embedding the Python Interpreter,  Up: Top

7 Python/C API Reference Manual
*******************************

This manual documents the API used by C and C++ programmers who want to
write extension modules or embed Python.  It is a companion to *note
Extending and Embedding the Python Interpreter: 4f1, which describes
the general principles of extension writing but does not document the
API functions in detail.

* Menu:

* Introduction: Introduction<10>.
* The Very High Level Layer::
* Reference Counting::
* Exception Handling::
* Utilities::
* Abstract Objects Layer::
* Concrete Objects Layer::
* Initialization, Finalization, and Threads: Initialization Finalization and Threads.
* Memory Management::
* Object Implementation Support::

Introduction

* Include Files::
* Objects, Types and Reference Counts: Objects Types and Reference Counts.
* Exceptions: Exceptions<7>.
* Embedding Python::
* Debugging Builds::

Objects, Types and Reference Counts

* Reference Counts: Reference Counts<2>.
* Types::

Reference Counts

* Reference Count Details::

Exception Handling

* Unicode Exception Objects::
* Recursion Control::
* Standard Exceptions::
* String Exceptions::

Utilities

* Operating System Utilities::
* System Functions::
* Process Control::
* Importing Modules: Importing Modules<2>.
* Data marshalling support::
* Parsing arguments and building values::
* String conversion and formatting::
* Reflection::
* Codec registry and support functions::

Codec registry and support functions

* Codec lookup API::
* Registry API for Unicode encoding error handlers::

Abstract Objects Layer

* Object Protocol::
* Number Protocol::
* Sequence Protocol::
* Mapping Protocol::
* Iterator Protocol::
* Old Buffer Protocol::

Concrete Objects Layer

* Fundamental Objects::
* Numeric Objects::
* Sequence Objects::
* Mapping Objects::
* Other Objects::

Fundamental Objects

* Type Objects: Type Objects<2>.
* The None Object::

Numeric Objects

* Plain Integer Objects::
* Boolean Objects: Boolean Objects<2>.
* Long Integer Objects::
* Floating Point Objects::
* Complex Number Objects::

Complex Number Objects

* Complex Numbers as C Structures::
* Complex Numbers as Python Objects::

Sequence Objects

* Byte Array Objects::
* String/Bytes Objects::
* Unicode Objects and Codecs::
* Buffers and Memoryview Objects::
* Tuple Objects::
* List Objects::

Byte Array Objects

* Type check macros::
* Direct API functions::
* Macros::

Unicode Objects and Codecs

* Unicode Objects::
* Built-in Codecs::
* Methods and Slot Functions::

Unicode Objects

* Unicode Type::
* Unicode Character Properties::
* Plain Py_UNICODE::
* wchar_t Support::

Built-in Codecs

* Generic Codecs::
* UTF-8 Codecs::
* UTF-32 Codecs::
* UTF-16 Codecs::
* UTF-7 Codecs::
* Unicode-Escape Codecs::
* Raw-Unicode-Escape Codecs::
* Latin-1 Codecs::
* ASCII Codecs::
* Character Map Codecs::
* MBCS codecs for Windows::
* Methods & Slots::

Buffers and Memoryview Objects

* The new-style Py_buffer struct::
* Buffer related functions::
* MemoryView objects::
* Old-style buffer objects::

Mapping Objects

* Dictionary Objects::

Other Objects

* Class and Instance Objects::
* Function Objects: Function Objects<2>.
* Method Objects: Method Objects<2>.
* File Objects: File Objects<2>.
* Module Objects::
* Iterator Objects::
* Descriptor Objects::
* Slice Objects::
* Weak Reference Objects: Weak Reference Objects<2>.
* Capsules: Capsules<2>.
* CObjects::
* Cell Objects::
* Generator Objects::
* DateTime Objects: DateTime Objects<2>.
* Set Objects: Set Objects<2>.
* Code Objects: Code Objects<2>.

Initialization, Finalization, and Threads

* Initializing and finalizing the interpreter::
* Process-wide parameters::
* Thread State and the Global Interpreter Lock::
* Sub-interpreter support::
* Asynchronous Notifications::
* Profiling and Tracing::
* Advanced Debugger Support::

Thread State and the Global Interpreter Lock

* Releasing the GIL from extension code::
* Non-Python created threads::
* High-level API::
* Low-level API::

Sub-interpreter support

* Bugs and caveats::

Memory Management

* Overview::
* Memory Interface::
* Examples: Examples<23>.

Object Implementation Support

* Allocating Objects on the Heap::
* Common Object Structures::
* Type Objects: Type Objects<3>.
* Number Object Structures::
* Mapping Object Structures::
* Sequence Object Structures::
* Buffer Object Structures::
* Supporting Cyclic Garbage Collection::


File: python.info,  Node: Introduction<10>,  Next: The Very High Level Layer,  Up: Python/C API Reference Manual

7.1 Introduction
================

The Application Programmer's Interface to Python gives C and C++
programmers access to the Python interpreter at a variety of levels.
The API is equally usable from C++, but for brevity it is generally
referred to as the Python/C API.  There are two fundamentally different
reasons for using the Python/C API.  The first reason is to write
_extension modules_ for specific purposes; these are C modules that
extend the Python interpreter.  This is probably the most common use.
The second reason is to use Python as a component in a larger
application; this technique is generally referred to as _embedding_
Python in an application.

  Writing an extension module is a relatively well-understood process,
where a "cookbook" approach works well.  There are several tools  that
automate the process to some extent.  While people have embedded
Python in other applications since its early existence, the process of
embedding Python is less straightforward than writing an extension.

  Many API functions are useful independent of whether you're embedding
or extending Python; moreover, most applications that embed Python
will need to provide a custom extension as well, so it's probably a
good idea to become familiar with writing an extension before
attempting to embed Python in a real application.

* Menu:

* Include Files::
* Objects, Types and Reference Counts: Objects Types and Reference Counts.
* Exceptions: Exceptions<7>.
* Embedding Python::
* Debugging Builds::


File: python.info,  Node: Include Files,  Next: Objects Types and Reference Counts,  Up: Introduction<10>

7.1.1 Include Files
-------------------

All function, type and macro definitions needed to use the Python/C API
are included in your code by the following line:

    #include "Python.h"

This implies inclusion of the following standard headers: `<stdio.h>',
`<string.h>', `<errno.h>', `<limits.h>', `<assert.h>' and `<stdlib.h>'
(if available).

     Note: Since Python may define some pre-processor definitions which
     affect the standard headers on some systems, you _must_ include
     `Python.h' before any standard headers are included.

  All user visible names defined by Python.h (except those defined by
the included standard headers) have one of the prefixes `Py' or `_Py'.
Names beginning with `_Py' are for internal use by the Python
implementation and should not be used by extension writers. Structure
member names do not have a reserved prefix.

  *Important:* user code should never define names that begin with `Py'
or `_Py'.  This confuses the reader, and jeopardizes the portability of
the user code to future Python versions, which may define additional
names beginning with one of these prefixes.

  The header files are typically installed with Python.  On Unix, these
are located in the directories `_prefix_/include/pythonversion/' and
`_exec_prefix_/include/pythonversion/', where `prefix' and `exec_prefix'
are defined by the corresponding parameters to Python's *configure*
script and _version_ is `sys.version[:3]'.  On Windows, the headers are
installed in `_prefix_/include', where `prefix' is the installation
directory specified to the installer.

  To include the headers, place both directories (if different) on your
compiler's search path for includes.  Do _not_ place the parent
directories on the search path and then use `#include
<pythonX.Y/Python.h>'; this will break on multi-platform builds since
the platform independent headers under `prefix' include the platform
specific headers from `exec_prefix'.

  C++ users should note that though the API is defined entirely using
C, the header files do properly declare the entry points to be `extern
"C"', so there is no need to do anything special to use the API from
C++.


File: python.info,  Node: Objects Types and Reference Counts,  Next: Exceptions<7>,  Prev: Include Files,  Up: Introduction<10>

7.1.2 Objects, Types and Reference Counts
-----------------------------------------

Most Python/C API functions have one or more arguments as well as a
return value of type *note PyObject*: 39f.  This type is a pointer to
an opaque data type representing an arbitrary Python object.  Since all
Python object types are treated the same way by the Python language in
most situations (e.g., assignments, scope rules, and argument passing),
it is only fitting that they should be represented by a single C type.
Almost all Python objects live on the heap: you never declare an
automatic or static variable of type *note PyObject: 39f, only pointer
variables of type *note PyObject*: 39f. can  be declared.  The sole
exception are the type objects; since these must never be deallocated,
they are typically static *note PyTypeObject: 29b9. objects.

  All Python objects (even Python integers) have a _type_ and a
_reference count_.  An object's type determines what kind of object it
is (e.g., an integer, a list, or a user-defined function; there are
many more as explained in *note The standard type hierarchy: 6de.).
For each of the well-known types there is a macro to check whether an
object is of that type; for instance, `PyList_Check(a)' is true if (and
only if) the object pointed to by _a_ is a Python list.

* Menu:

* Reference Counts: Reference Counts<2>.
* Types::

Reference Counts

* Reference Count Details::


File: python.info,  Node: Reference Counts<2>,  Next: Types,  Up: Objects Types and Reference Counts

7.1.2.1 Reference Counts
........................

The reference count is important because today's computers have a
finite (and often severely limited) memory size; it counts how many
different places there are that have a reference to an object.  Such a
place could be another object, or a global (or static) C variable, or
a local variable in some C function.  When an object's reference count
becomes zero, the object is deallocated.  If it contains references to
other objects, their reference count is decremented.  Those other
objects may be deallocated in turn, if this decrement makes their
reference count become zero, and so on.  (There's an obvious problem
with objects that reference each other here; for now, the solution is
"don't do that.")

  Reference counts are always manipulated explicitly.  The normal way
is  to use the macro *note Py_INCREF(): 297b. to increment an object's
reference count by one, and *note Py_DECREF(): 2981. to decrement it by
 one.  The *note Py_DECREF(): 2981. macro is considerably more complex
than the incref one, since it must check whether the reference count
becomes zero and then cause the object's deallocator to be called. The
deallocator is a function pointer contained in the object's type
structure.  The type-specific deallocator takes care of decrementing the
reference counts for other objects contained in the object if this is a
compound object type, such as a list, as well as performing any
additional finalization that's needed.  There's no chance that the
reference count can overflow; at least as many bits are used to hold
the reference count as there are distinct memory locations in virtual
memory (assuming `sizeof(Py_ssize_t) >= sizeof(void*)').  Thus, the
reference count increment is a simple operation.

  It is not necessary to increment an object's reference count for
every  local variable that contains a pointer to an object.  In theory,
the  object's reference count goes up by one when the variable is made
to  point to it and it goes down by one when the variable goes out of
scope.  However, these two cancel each other out, so at the end the
reference count hasn't changed.  The only real reason to use the
reference count is to prevent the object from being deallocated as
long as our variable is pointing to it.  If we know that there is at
least one other reference to the object that lives at least as long as
our variable, there is no need to increment the reference count
temporarily.  An important situation where this arises is in objects
that are passed as arguments to C functions in an extension module
that are called from Python; the call mechanism guarantees to hold a
reference to every argument for the duration of the call.

  However, a common pitfall is to extract an object from a list and
hold on to it for a while without incrementing its reference count.
Some other operation might conceivably remove the object from the list,
decrementing its reference count and possible deallocating it. The real
danger is that innocent-looking operations may invoke arbitrary Python
code which could do this; there is a code path which allows control to
flow back to the user from a *note Py_DECREF(): 2981, so almost any
operation is potentially dangerous.

  A safe approach is to always use the generic operations (functions
whose name begins with `PyObject_', `PyNumber_', `PySequence_' or
`PyMapping_').  These operations always increment the reference count
of the object they return.  This leaves the caller with the
responsibility to call *note Py_DECREF(): 2981. when they are done with
the result; this soon becomes second nature.

* Menu:

* Reference Count Details::


File: python.info,  Node: Reference Count Details,  Up: Reference Counts<2>

7.1.2.2 Reference Count Details
...............................

The reference count behavior of functions in the Python/C API is best
explained in terms of _ownership of references_.  Ownership pertains to
references, never to objects (objects are not owned: they are always
shared).  "Owning a reference" means being responsible for calling
Py_DECREF on it when the reference is no longer needed.  Ownership can
also be transferred, meaning that the code that receives ownership of
the reference then becomes responsible for eventually decref'ing it by
calling *note Py_DECREF(): 2981. or *note Py_XDECREF(): 2980.  when
it's no longer needed--or passing on this responsibility (usually to its
caller). When a function passes ownership of a reference on to its
caller, the caller is said to receive a _new_ reference.  When no
ownership is transferred, the caller is said to _borrow_ the reference.
Nothing needs to be done for a borrowed reference.

  Conversely, when a calling function passes in a reference to an
object, there are two possibilities: the function _steals_ a  reference
to the object, or it does not.  _Stealing a reference_ means that when
you pass a reference to a function, that function assumes that it now
owns that reference, and you are not responsible for it any longer.

  Few functions steal references; the two notable exceptions are *note
PyList_SetItem(): 29a6. and *note PyTuple_SetItem(): 29a5, which  steal
a reference to the item (but not to the tuple or list into which the
item is put!).  These functions were designed to steal a reference
because of a common idiom for populating a tuple or list with newly
created objects; for example, the code to create the tuple `(1, 2,
"three")' could look like this (forgetting about error handling for the
moment; a better way to code this is shown below):

    PyObject *t;

    t = PyTuple_New(3);
    PyTuple_SetItem(t, 0, PyInt_FromLong(1L));
    PyTuple_SetItem(t, 1, PyInt_FromLong(2L));
    PyTuple_SetItem(t, 2, PyString_FromString("three"));

Here, *note PyInt_FromLong(): 297f. returns a new reference which is
immediately stolen by *note PyTuple_SetItem(): 29a5.  When you want to
keep using an object although the reference to it will be stolen, use
*note Py_INCREF(): 297b. to grab another reference before calling the
reference-stealing function.

  Incidentally, *note PyTuple_SetItem(): 29a5. is the _only_ way to set
tuple items; *note PySequence_SetItem(): 2a08. and *note
PyObject_SetItem(): 2a09. refuse to do this since tuples are an
immutable data type.  You should only use *note PyTuple_SetItem():
29a5. for tuples that you are creating yourself.

  Equivalent code for populating a list can be written using *note
PyList_New(): 2a0a.  and *note PyList_SetItem(): 29a6.

  However, in practice, you will rarely use these ways of creating and
populating a tuple or list.  There's a generic function, *note
Py_BuildValue(): 3a1, that can create most common objects from C
values, directed by a _format string_.  For example, the above two
blocks of code could be replaced by the following (which also takes
care of the error checking):

    PyObject *tuple, *list;

    tuple = Py_BuildValue("(iis)", 1, 2, "three");
    list = Py_BuildValue("[iis]", 1, 2, "three");

It is much more common to use *note PyObject_SetItem(): 2a09. and
friends with items whose references you are only borrowing, like
arguments that were passed in to the function you are writing.  In that
case, their behaviour regarding reference counts is much saner, since
you don't have to increment a reference count so you can give a
reference away ("have it be stolen").  For example, this function sets
all items of a list (actually, any mutable sequence) to a given item:

    int
    set_all(PyObject *target, PyObject *item)
    {
        int i, n;

        n = PyObject_Length(target);
        if (n < 0)
            return -1;
        for (i = 0; i < n; i++) {
            PyObject *index = PyInt_FromLong(i);
            if (!index)
                return -1;
            if (PyObject_SetItem(target, index, item) < 0) {
                Py_DECREF(index);
                return -1;
        }
            Py_DECREF(index);
        }
        return 0;
    }


  The situation is slightly different for function return values.
While passing a reference to most functions does not change your
ownership responsibilities for that reference, many functions that
return a reference to an object give you ownership of the reference.
The reason is simple: in many cases, the returned object is created  on
the fly, and the reference you get is the only reference to the
object.  Therefore, the generic functions that return object
references, like *note PyObject_GetItem(): 2a0b. and  *note
PySequence_GetItem(): 2a0c, always return a new reference (the caller
becomes the owner of the reference).

  It is important to realize that whether you own a reference returned
by a function depends on which function you call only -- _the plumage_
(the type of the object passed as an argument to the function) _doesn't
enter into it!_ Thus, if you  extract an item from a list using *note
PyList_GetItem(): 29a1, you don't own the reference -- but if you
obtain the same item from the same list using *note
PySequence_GetItem(): 2a0c. (which happens to take exactly the same
arguments), you do own a reference to the returned object.

  Here is an example of how you could write a function that computes
the sum of the items in a list of integers; once using  *note
PyList_GetItem(): 29a1, and once using *note PySequence_GetItem(): 2a0c.

    long
    sum_list(PyObject *list)
    {
        int i, n;
        long total = 0;
        PyObject *item;

        n = PyList_Size(list);
        if (n < 0)
            return -1; /* Not a list */
        for (i = 0; i < n; i++) {
            item = PyList_GetItem(list, i); /* Can't fail */
            if (!PyInt_Check(item)) continue; /* Skip non-integers */
            total += PyInt_AsLong(item);
        }
        return total;
    }


    long
    sum_sequence(PyObject *sequence)
    {
        int i, n;
        long total = 0;
        PyObject *item;
        n = PySequence_Length(sequence);
        if (n < 0)
            return -1; /* Has no length */
        for (i = 0; i < n; i++) {
            item = PySequence_GetItem(sequence, i);
            if (item == NULL)
                return -1; /* Not a sequence, or other failure */
            if (PyInt_Check(item))
                total += PyInt_AsLong(item);
            Py_DECREF(item); /* Discard reference ownership */
        }
        return total;
    }



File: python.info,  Node: Types,  Prev: Reference Counts<2>,  Up: Objects Types and Reference Counts

7.1.2.3 Types
.............

There are few other data types that play a significant role in  the
Python/C API; most are simple C types such as `int',  `long', `double'
and `char*'.  A few structure types  are used to describe static tables
used to list the functions exported  by a module or the data attributes
of a new object type, and another is used to describe the value of a
complex number.  These will  be discussed together with the functions
that use them.


File: python.info,  Node: Exceptions<7>,  Next: Embedding Python,  Prev: Objects Types and Reference Counts,  Up: Introduction<10>

7.1.3 Exceptions
----------------

The Python programmer only needs to deal with exceptions if specific
error handling is required; unhandled exceptions are automatically
propagated to the caller, then to the caller's caller, and so on, until
they reach the top-level interpreter, where they are reported to the
user accompanied by a stack traceback.

  For C programmers, however, error checking always has to be explicit.
All functions in the Python/C API can raise exceptions, unless an
explicit claim is made otherwise in a function's documentation.  In
general, when a function encounters an error, it sets an exception,
discards any object references that it owns, and returns an error
indicator.  If not documented otherwise, this indicator is either
_NULL_ or `-1', depending on the function's return type.  A few
functions return a Boolean true/false result, with false indicating an
error.  Very few functions return no explicit error indicator or have an
ambiguous return value, and require explicit testing for errors with
*note PyErr_Occurred(): 297c.  These exceptions are always explicitly
documented.

  Exception state is maintained in per-thread storage (this is
equivalent to using global storage in an unthreaded application).  A
thread can be in one of two states: an exception has occurred, or not.
The function *note PyErr_Occurred(): 297c. can be used to check for
this: it returns a borrowed reference to the exception type object when
an exception has occurred, and _NULL_ otherwise.  There are a number of
functions to set the exception state: *note PyErr_SetString(): 2978. is
the most common (though not the most general) function to set the
exception state, and *note PyErr_Clear(): 297d. clears the exception
state.

  The full exception state consists of three objects (all of which can
be _NULL_): the exception type, the corresponding exception  value, and
the traceback.  These have the same meanings as the Python   objects
`sys.exc_type', `sys.exc_value', and `sys.exc_traceback'; however, they
are not the same: the Python objects represent the last exception being
handled by a Python  *note try: 38e ... *note except: 390. statement,
while the C level exception state only exists while an exception is
being passed on between C functions until it reaches the Python
bytecode interpreter's  main loop, which takes care of transferring it
to `sys.exc_type' and friends.

  Note that starting with Python 1.5, the preferred, thread-safe way to
access the exception state from Python code is to call the function
*note sys.exc_info(): 2ec, which returns the per-thread exception state
for Python code.  Also, the semantics of both ways to access the
exception state have changed so that a function which catches an
exception will save and restore its thread's exception state so as to
preserve the exception state of its caller.  This prevents common bugs
in exception handling code caused by an innocent-looking function
overwriting the exception being handled; it also reduces the often
unwanted lifetime extension for objects that are referenced by the
stack frames in the traceback.

  As a general principle, a function that calls another function to
perform some task should check whether the called function raised an
exception, and if so, pass the exception state on to its caller.  It
should discard any object references that it owns, and return an  error
indicator, but it should _not_ set another exception -- that would
overwrite the exception that was just raised, and lose important
information about the exact cause of the error.

  A simple example of detecting exceptions and passing them on is shown
in the `sum_sequence()' example above.  It so happens that this example
doesn't need to clean up any owned references when it detects an error.
The following example function shows some error cleanup.  First, to
remind you why you like Python, we show the equivalent Python code:

    def incr_item(dict, key):
        try:
            item = dict[key]
        except KeyError:
            item = 0
        dict[key] = item + 1


  Here is the corresponding C code, in all its glory:

    int
    incr_item(PyObject *dict, PyObject *key)
    {
        /* Objects all initialized to NULL for Py_XDECREF */
        PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;
        int rv = -1; /* Return value initialized to -1 (failure) */

        item = PyObject_GetItem(dict, key);
        if (item == NULL) {
            /* Handle KeyError only: */
            if (!PyErr_ExceptionMatches(PyExc_KeyError))
                goto error;

            /* Clear the error and use zero: */
            PyErr_Clear();
            item = PyInt_FromLong(0L);
            if (item == NULL)
                goto error;
        }
        const_one = PyInt_FromLong(1L);
        if (const_one == NULL)
            goto error;

        incremented_item = PyNumber_Add(item, const_one);
        if (incremented_item == NULL)
            goto error;

        if (PyObject_SetItem(dict, key, incremented_item) < 0)
            goto error;
        rv = 0; /* Success */
        /* Continue with cleanup code */

     error:
        /* Cleanup code, shared by success and failure path */

        /* Use Py_XDECREF() to ignore NULL references */
        Py_XDECREF(item);
        Py_XDECREF(const_one);
        Py_XDECREF(incremented_item);

        return rv; /* -1 for error, 0 for success */
    }


  This example represents an endorsed use of the `goto' statement  in C!
It illustrates the use of *note PyErr_ExceptionMatches(): 2a11. and
*note PyErr_Clear(): 297d. to handle specific exceptions, and the use of
*note Py_XDECREF(): 2980. to dispose of owned references that may be
_NULL_ (note the `'X'' in the name; *note Py_DECREF(): 2981. would
crash when confronted with a _NULL_ reference).  It is important that
the variables used to hold owned references are initialized to _NULL_
for this to work; likewise, the proposed return value is initialized to
`-1' (failure) and only set to success after the final call made is
successful.


File: python.info,  Node: Embedding Python,  Next: Debugging Builds,  Prev: Exceptions<7>,  Up: Introduction<10>

7.1.4 Embedding Python
----------------------

The one important task that only embedders (as opposed to extension
writers) of the Python interpreter have to worry about is the
initialization, and possibly the finalization, of the Python
interpreter.  Most functionality of the interpreter can only be used
after the interpreter has been initialized.

  The basic initialization function is *note Py_Initialize(): 2989.
This initializes the table of loaded modules, and creates the
fundamental modules *note __builtin__: 0, *note __main__: 2, *note sys:
16d, and *note exceptions: c9.  It also initializes the module search
path (`sys.path').

  *note Py_Initialize(): 2989. does not set the "script argument list"
(`sys.argv').  If this variable is needed by Python code that will be
executed later, it must be set explicitly with a call to
`PySys_SetArgvEx(argc, argv, updatepath)' after the call to *note
Py_Initialize(): 2989.

  On most systems (in particular, on Unix and Windows, although the
details are slightly different), *note Py_Initialize(): 2989.
calculates the module search path based upon its best guess for the
location of the standard Python interpreter executable, assuming that
the Python library is found in a fixed location relative to the Python
interpreter executable.  In particular, it looks for a directory named
`lib/python_X.Y_' relative to the parent directory where the executable
named `python' is found on the shell command search path (the
environment variable `PATH').

  For instance, if the Python executable is found in
`/usr/local/bin/python', it will assume that the libraries are in
`/usr/local/lib/python_X.Y_'.  (In fact, this particular path is also
the "fallback" location, used when no executable file named `python' is
found along `PATH'.)  The user can override this behavior by setting the
environment variable *note PYTHONHOME: 62a, or insert additional
directories in front of the standard path by setting *note PYTHONPATH:
577.

  The embedding application can steer the search by calling
`Py_SetProgramName(file)' _before_ calling  *note Py_Initialize():
2989.  Note that *note PYTHONHOME: 62a. still overrides this and *note
PYTHONPATH: 577. is still inserted in front of the standard path.  An
application that requires total control has to provide its own
implementation of *note Py_GetPath(): 2a14, *note Py_GetPrefix(): 2a15,
*note Py_GetExecPrefix(): 2a16, and *note Py_GetProgramFullPath():
2a17. (all defined in `Modules/getpath.c').

  Sometimes, it is desirable to "uninitialize" Python.  For instance,
the application may want to start over (make another call to *note
Py_Initialize(): 2989.) or the application is simply done with its  use
of Python and wants to free memory allocated by Python.  This can be
accomplished by calling *note Py_Finalize(): 2c0.  The function *note
Py_IsInitialized(): 2a18. returns true if Python is currently in the
initialized state.  More information about these functions is given in
a later chapter. Notice that *note Py_Finalize(): 2c0.  does _not_ free
all memory allocated by the Python interpreter, e.g. memory allocated
by extension modules currently cannot be released.


File: python.info,  Node: Debugging Builds,  Prev: Embedding Python,  Up: Introduction<10>

7.1.5 Debugging Builds
----------------------

Python can be built with several macros to enable extra checks of the
interpreter and extension modules.  These checks tend to add a large
amount of overhead to the runtime so they are not enabled by default.

  A full list of the various types of debugging builds is in the file
`Misc/SpecialBuilds.txt' in the Python source distribution. Builds are
available that support tracing of reference counts, debugging the memory
allocator, or low-level profiling of the main interpreter loop.  Only
the most frequently-used builds will be described in the remainder of
this section.

  Compiling the interpreter with the `Py_DEBUG' macro defined produces
what is generally meant by "a debug build" of Python. `Py_DEBUG' is
enabled in the Unix build by adding `--with-pydebug' to the
`./configure' command.  It is also implied by the presence of the
not-Python-specific `_DEBUG' macro.  When `Py_DEBUG' is enabled in the
Unix build, compiler optimization is disabled.

  In addition to the reference count debugging described below, the
following extra checks are performed:

   * Extra checks are added to the object allocator.

   * Extra checks are added to the parser and compiler.

   * Downcasts from wide types to narrow types are checked for loss of
     information.

   * A number of assertions are added to the dictionary and set
     implementations.  In addition, the set object acquires a
     `test_c_api()' method.

   * Sanity checks of the input arguments are added to frame creation.

   * The storage for long ints is initialized with a known invalid
     pattern to catch reference to uninitialized digits.

   * Low-level tracing and extra exception checking are added to the
     runtime virtual machine.

   * Extra checks are added to the memory arena implementation.

   * Extra debugging is added to the thread module.

  There may be additional checks not mentioned here.

  Defining `Py_TRACE_REFS' enables reference tracing.  When defined, a
circular doubly linked list of active objects is maintained by adding
two extra fields to every *note PyObject: 39f.  Total allocations are
tracked as well.  Upon exit, all existing references are printed.  (In
interactive mode this happens after every statement run by the
interpreter.)  Implied by `Py_DEBUG'.

  Please refer to `Misc/SpecialBuilds.txt' in the Python source
distribution for more detailed information.


File: python.info,  Node: The Very High Level Layer,  Next: Reference Counting,  Prev: Introduction<10>,  Up: Python/C API Reference Manual

7.2 The Very High Level Layer
=============================

The functions in this chapter will let you execute Python source code
given in a file or a buffer, but they will not let you interact in a
more detailed way with the interpreter.

  Several of these functions accept a start symbol from the grammar as a
parameter.  The available start symbols are `Py_eval_input',
`Py_file_input', and `Py_single_input'.  These are described following
the functions which accept them as parameters.

  Note also that several of these functions take `FILE*' parameters.
One particular issue which needs to be handled carefully is that the
`FILE' structure for different C libraries can be different and
incompatible.  Under Windows (at least), it is possible for dynamically
linked extensions to actually use different libraries, so care should
be taken that `FILE*' parameters are only passed to these functions if
it is certain that they were created by the same library that the
Python runtime is using.

 -- C Function: int Py_Main (int argc, char **argv)
     The main program for the standard interpreter.  This is made
     available for programs which embed Python.  The _argc_ and _argv_
     parameters should be prepared exactly as those which are passed to
     a C program's `main()' function.  It is important to note that the
     argument list may be modified (but the contents of the strings
     pointed to by the argument list are not). The return value will be
     `0' if the interpreter exits normally (ie, without an exception),
     `1' if the interpreter exits due to an exception, or `2' if the
     parameter list does not represent a valid Python command line.

     Note that if an otherwise unhandled *note SystemExit: 32b. is
     raised, this function will not return `1', but exit the process,
     as long as `Py_InspectFlag' is not set.

 -- C Function: int PyRun_AnyFile (FILE *fp, const char *filename)
     This is a simplified interface to *note PyRun_AnyFileExFlags():
     2a20. below, leaving _closeit_ set to `0' and _flags_ set to
     _NULL_.

 -- C Function: int PyRun_AnyFileFlags (FILE *fp, const char *filename,
          PyCompilerFlags *flags)
     This is a simplified interface to *note PyRun_AnyFileExFlags():
     2a20. below, leaving the _closeit_ argument set to `0'.

 -- C Function: int PyRun_AnyFileEx (FILE *fp, const char *filename,
          int closeit)
     This is a simplified interface to *note PyRun_AnyFileExFlags():
     2a20. below, leaving the _flags_ argument set to _NULL_.

 -- C Function: int PyRun_AnyFileExFlags (FILE *fp, const
          char *filename, int closeit, PyCompilerFlags *flags)
     If _fp_ refers to a file associated with an interactive device
     (console or terminal input or Unix pseudo-terminal), return the
     value of *note PyRun_InteractiveLoop(): 2a23, otherwise return the
     result of *note PyRun_SimpleFile(): 29ec.  If _filename_ is
     _NULL_, this function uses `"???"' as the filename.

 -- C Function: int PyRun_SimpleString (const char *command)
     This is a simplified interface to *note PyRun_SimpleStringFlags():
     2a24. below, leaving the _PyCompilerFlags*_ argument set to NULL.

 -- C Function: int PyRun_SimpleStringFlags (const char *command,
          PyCompilerFlags *flags)
     Executes the Python source code from _command_ in the *note
     __main__: 2. module according to the _flags_ argument. If *note
     __main__: 2. does not already exist, it is created.  Returns `0'
     on success or `-1' if an exception was raised.  If there was an
     error, there is no way to get the exception information. For the
     meaning of _flags_, see below.

     Note that if an otherwise unhandled *note SystemExit: 32b. is
     raised, this function will not return `-1', but exit the process,
     as long as `Py_InspectFlag' is not set.

 -- C Function: int PyRun_SimpleFile (FILE *fp, const char *filename)
     This is a simplified interface to *note PyRun_SimpleFileExFlags():
     2a25. below, leaving _closeit_ set to `0' and _flags_ set to
     _NULL_.

 -- C Function: int PyRun_SimpleFileFlags (FILE *fp, const
          char *filename, PyCompilerFlags *flags)
     This is a simplified interface to *note PyRun_SimpleFileExFlags():
     2a25. below, leaving _closeit_ set to `0'.

 -- C Function: int PyRun_SimpleFileEx (FILE *fp, const char *filename,
          int closeit)
     This is a simplified interface to *note PyRun_SimpleFileExFlags():
     2a25. below, leaving _flags_ set to _NULL_.

 -- C Function: int PyRun_SimpleFileExFlags (FILE *fp, const
          char *filename, int closeit, PyCompilerFlags *flags)
     Similar to *note PyRun_SimpleStringFlags(): 2a24, but the Python
     source code is read from _fp_ instead of an in-memory string.
     _filename_ should be the name of the file.  If _closeit_ is true,
     the file is closed before PyRun_SimpleFileExFlags returns.

 -- C Function: int PyRun_InteractiveOne (FILE *fp, const
          char *filename)
     This is a simplified interface to *note
     PyRun_InteractiveOneFlags(): 2a29. below, leaving _flags_ set to
     _NULL_.

 -- C Function: int PyRun_InteractiveOneFlags (FILE *fp, const
          char *filename, PyCompilerFlags *flags)
     Read and execute a single statement from a file associated with an
     interactive device according to the _flags_ argument.  The user
     will be prompted using `sys.ps1' and `sys.ps2'.  Returns `0' when
     the input was executed successfully, `-1' if there was an
     exception, or an error code from the `errcode.h' include file
     distributed as part of Python if there was a parse error.  (Note
     that `errcode.h' is not included by `Python.h', so must be
     included specifically if needed.)

 -- C Function: int PyRun_InteractiveLoop (FILE *fp, const
          char *filename)
     This is a simplified interface to *note
     PyRun_InteractiveLoopFlags(): 2a2a. below, leaving _flags_ set to
     _NULL_.

 -- C Function: int PyRun_InteractiveLoopFlags (FILE *fp, const
          char *filename, PyCompilerFlags *flags)
     Read and execute statements from a file associated with an
     interactive device until EOF is reached.  The user will be
     prompted using `sys.ps1' and `sys.ps2'.  Returns `0' at EOF.

 -- C Function: struct _node* PyParser_SimpleParseString (const
          char *str, int start)
     This is a simplified interface to *note
     PyParser_SimpleParseStringFlagsFilename(): 2a2c. below, leaving
     _filename_ set to _NULL_ and _flags_ set to `0'.

 -- C Function: struct _node* PyParser_SimpleParseStringFlags (const
          char *str, int start, int flags)
     This is a simplified interface to *note
     PyParser_SimpleParseStringFlagsFilename(): 2a2c. below, leaving
     _filename_ set to _NULL_.

 -- C Function: struct _node* PyParser_SimpleParseStringFlagsFilename
          (const char *str, const char *filename, int start, int flags)
     Parse Python source code from _str_ using the start token _start_
     according to the _flags_ argument.  The result can be used to
     create a code object which can be evaluated efficiently. This is
     useful if a code fragment must be evaluated many times.

 -- C Function: struct _node* PyParser_SimpleParseFile (FILE *fp, const
          char *filename, int start)
     This is a simplified interface to *note
     PyParser_SimpleParseFileFlags(): 2a2f. below, leaving _flags_ set
     to `0'

 -- C Function: struct _node* PyParser_SimpleParseFileFlags (FILE *fp,
          const char *filename, int start, int flags)
     Similar to *note PyParser_SimpleParseStringFlagsFilename(): 2a2c,
     but the Python source code is read from _fp_ instead of an
     in-memory string.

 -- C Function: PyObject* PyRun_String (const char *str, int start,
          PyObject *globals, PyObject *locals)
     Return value: New reference.

     This is a simplified interface to *note PyRun_StringFlags(): 2a31.
     below, leaving _flags_ set to _NULL_.

 -- C Function: PyObject* PyRun_StringFlags (const char *str,
          int start, PyObject *globals, PyObject *locals,
          PyCompilerFlags *flags)
     Return value: New reference.

     Execute Python source code from _str_ in the context specified by
     the dictionaries _globals_ and _locals_ with the compiler flags
     specified by _flags_.  The parameter _start_ specifies the start
     token that should be used to parse the source code.

     Returns the result of executing the code as a Python object, or
     _NULL_ if an exception was raised.

 -- C Function: PyObject* PyRun_File (FILE *fp, const char *filename,
          int start, PyObject *globals, PyObject *locals)
     Return value: New reference.

     This is a simplified interface to *note PyRun_FileExFlags(): 2a33.
     below, leaving _closeit_ set to `0' and _flags_ set to _NULL_.

 -- C Function: PyObject* PyRun_FileEx (FILE *fp, const char *filename,
          int start, PyObject *globals, PyObject *locals, int closeit)
     Return value: New reference.

     This is a simplified interface to *note PyRun_FileExFlags(): 2a33.
     below, leaving _flags_ set to _NULL_.

 -- C Function: PyObject* PyRun_FileFlags (FILE *fp, const
          char *filename, int start, PyObject *globals,
          PyObject *locals, PyCompilerFlags *flags)
     Return value: New reference.

     This is a simplified interface to *note PyRun_FileExFlags(): 2a33.
     below, leaving _closeit_ set to `0'.

 -- C Function: PyObject* PyRun_FileExFlags (FILE *fp, const
          char *filename, int start, PyObject *globals,
          PyObject *locals, int closeit, PyCompilerFlags *flags)
     Return value: New reference.

     Similar to *note PyRun_StringFlags(): 2a31, but the Python source
     code is read from _fp_ instead of an in-memory string. _filename_
     should be the name of the file.  If _closeit_ is true, the file is
     closed before *note PyRun_FileExFlags(): 2a33.  returns.

 -- C Function: PyObject* Py_CompileString (const char *str, const
          char *filename, int start)
     Return value: New reference.

     This is a simplified interface to *note Py_CompileStringFlags():
     2a37. below, leaving _flags_ set to _NULL_.

 -- C Function: PyObject* Py_CompileStringFlags (const char *str, const
          char *filename, int start, PyCompilerFlags *flags)
     Return value: New reference.

     Parse and compile the Python source code in _str_, returning the
     resulting code object.  The start token is given by _start_; this
     can be used to constrain the code which can be compiled and should
     be `Py_eval_input', `Py_file_input', or `Py_single_input'.  The
     filename specified by _filename_ is used to construct the code
     object and may appear in tracebacks or *note SyntaxError: 48f.
     exception messages.  This returns _NULL_ if the code cannot be
     parsed or compiled.

 -- C Function: PyObject* PyEval_EvalCode (PyCodeObject *co,
          PyObject *globals, PyObject *locals)
     Return value: New reference.

     This is a simplified interface to *note PyEval_EvalCodeEx(): 2a39,
     with just the code object, and the dictionaries of global and
     local variables.  The other arguments are set to _NULL_.

 -- C Function: PyObject* PyEval_EvalCodeEx (PyCodeObject *co,
          PyObject *globals, PyObject *locals, PyObject **args,
          int argcount, PyObject **kws, int kwcount, PyObject **defs,
          int defcount, PyObject *closure)
     Evaluate a precompiled code object, given a particular environment
     for its evaluation.  This environment consists of dictionaries of
     global and local variables, arrays of arguments, keywords and
     defaults, and a closure tuple of cells.

 -- C Function: PyObject* PyEval_EvalFrame (PyFrameObject *f)
     Evaluate an execution frame.  This is a simplified interface to
     PyEval_EvalFrameEx, for backward compatibility.

 -- C Function: PyObject* PyEval_EvalFrameEx (PyFrameObject *f,
          int throwflag)
     This is the main, unvarnished function of Python interpretation.
     It is literally 2000 lines long.  The code object associated with
     the execution frame _f_ is executed, interpreting bytecode and
     executing calls as needed.  The additional _throwflag_ parameter
     can mostly be ignored - if true, then it causes an exception to
     immediately be thrown; this is used for the `throw()' methods of
     generator objects.

 -- C Function: int PyEval_MergeCompilerFlags (PyCompilerFlags *cf)
     This function changes the flags of the current evaluation frame,
     and returns true on success, false on failure.

 -- C Variable: int Py_eval_input
     The start symbol from the Python grammar for isolated expressions;
     for use with *note Py_CompileString(): 2a36.

 -- C Variable: int Py_file_input
     The start symbol from the Python grammar for sequences of
     statements as read from a file or other source; for use with *note
     Py_CompileString(): 2a36.  This is the symbol to use when
     compiling arbitrarily long Python source code.

 -- C Variable: int Py_single_input
     The start symbol from the Python grammar for a single statement;
     for use with *note Py_CompileString(): 2a36. This is the symbol
     used for the interactive interpreter loop.

 -- C Type: struct PyCompilerFlags
     This is the structure used to hold compiler flags.  In cases where
     code is only being compiled, it is passed as `int flags', and in
     cases where code is being executed, it is passed as
     `PyCompilerFlags *flags'.  In this case, `from __future__ import'
     can modify _flags_.

     Whenever `PyCompilerFlags *flags' is _NULL_, `cf_flags' is treated
     as equal to `0', and any modification due to `from __future__
     import' is discarded.

         struct PyCompilerFlags {
             int cf_flags;
         }



 -- C Variable: int CO_FUTURE_DIVISION
     This bit can be set in _flags_ to cause division operator `/' to be
     interpreted as "true division" according to PEP 238(1).

  ---------- Footnotes ----------

  (1) http://www.python.org/dev/peps/pep-0238


File: python.info,  Node: Reference Counting,  Next: Exception Handling,  Prev: The Very High Level Layer,  Up: Python/C API Reference Manual

7.3 Reference Counting
======================

The macros in this section are used for managing reference counts of
Python objects.

 -- C Function: void Py_INCREF (PyObject *o)
     Increment the reference count for object _o_.  The object must not
     be _NULL_; if you aren't sure that it isn't _NULL_, use *note
     Py_XINCREF(): 2990.

 -- C Function: void Py_XINCREF (PyObject *o)
     Increment the reference count for object _o_.  The object may be
     _NULL_, in which case the macro has no effect.

 -- C Function: void Py_DECREF (PyObject *o)
     Decrement the reference count for object _o_.  The object must not
     be _NULL_; if you aren't sure that it isn't _NULL_, use *note
     Py_XDECREF(): 2980.  If the reference count reaches zero, the
     object's type's deallocation function (which must not be _NULL_)
     is invoked.

          Warning: The deallocation function can cause arbitrary Python
          code to be invoked (e.g.  when a class instance with a *note
          __del__(): 6f6. method is deallocated).  While exceptions in
          such code are not propagated, the executed code has free
          access to all Python global variables.  This means that any
          object that is reachable from a global variable should be in
          a consistent state before *note Py_DECREF(): 2981. is
          invoked.  For example, code to delete an object from a list
          should copy a reference to the deleted object in a temporary
          variable, update the list data structure, and then call *note
          Py_DECREF(): 2981. for the temporary variable.

 -- C Function: void Py_XDECREF (PyObject *o)
     Decrement the reference count for object _o_.  The object may be
     _NULL_, in which case the macro has no effect; otherwise the
     effect is the same as for *note Py_DECREF(): 2981, and the same
     warning applies.

 -- C Function: void Py_CLEAR (PyObject *o)
     Decrement the reference count for object _o_.  The object may be
     _NULL_, in which case the macro has no effect; otherwise the
     effect is the same as for *note Py_DECREF(): 2981, except that the
     argument is also set to _NULL_.  The warning for *note
     Py_DECREF(): 2981. does not apply with respect to the object
     passed because the macro carefully uses a temporary variable and
     sets the argument to _NULL_ before decrementing its reference
     count.

     It is a good idea to use this macro whenever decrementing the
     value of a variable that might be traversed during garbage
     collection.

     New in version 2.4.

  The following functions are for runtime dynamic embedding of Python:
`Py_IncRef(PyObject *o)', `Py_DecRef(PyObject *o)'. They are simply
exported function versions of *note Py_XINCREF(): 2990. and *note
Py_XDECREF(): 2980, respectively.

  The following functions or macros are only for use within the
interpreter core: `_Py_Dealloc()', `_Py_ForgetReference()',
`_Py_NewReference()', as well as the global variable `_Py_RefTotal'.


File: python.info,  Node: Exception Handling,  Next: Utilities,  Prev: Reference Counting,  Up: Python/C API Reference Manual

7.4 Exception Handling
======================

The functions described in this chapter will let you handle and raise
Python exceptions.  It is important to understand some of the basics of
Python exception handling.  It works somewhat like the Unix `errno'
variable: there is a global indicator (per thread) of the last error
that occurred.  Most functions don't clear this on success, but will
set it to indicate the cause of the error on failure.  Most functions
also return an error indicator, usually _NULL_ if they are supposed to
return a pointer, or `-1' if they return an integer (exception: the
`PyArg_*()' functions return `1' for success and `0' for failure).

  When a function must fail because some function it called failed, it
generally doesn't set the error indicator; the function it called
already set it.  It is responsible for either handling the error and
clearing the exception or returning after cleaning up any resources it
holds (such as object references or memory allocations); it should
_not_ continue normally if it is not prepared to handle the error.  If
returning due to an error, it is important to indicate to the caller
that an error has been set.  If the error is not handled or carefully
propagated, additional calls into the Python/C API may not behave as
intended and may fail in mysterious ways.

  The error indicator consists of three Python objects corresponding to
 the Python variables `sys.exc_type', `sys.exc_value' and
`sys.exc_traceback'.  API functions exist to interact with the error
indicator in various ways.  There is a separate error indicator for
each thread.

 -- C Function: void PyErr_PrintEx (int set_sys_last_vars)
     Print a standard traceback to `sys.stderr' and clear the error
     indicator.  Call this function only when the error indicator is
     set.  (Otherwise it will cause a fatal error!)

     If _set_sys_last_vars_ is nonzero, the variables *note
     sys.last_type: 23a3, *note sys.last_value: 23a4. and *note
     sys.last_traceback: 2319. will be set to the type, value and
     traceback of the printed exception, respectively.

 -- C Function: void PyErr_Print ()
     Alias for `PyErr_PrintEx(1)'.

 -- C Function: PyObject* PyErr_Occurred ()
     Return value: Borrowed reference.

     Test whether the error indicator is set.  If set, return the
     exception _type_ (the first argument to the last call to one of
     the `PyErr_Set*()' functions or to *note PyErr_Restore(): 29cd.).
     If not set, return _NULL_.  You do not own a reference to the
     return value, so you do not need to *note Py_DECREF(): 2981.  it.

          Note: Do not compare the return value to a specific
          exception; use *note PyErr_ExceptionMatches(): 2a11. instead,
          shown below.  (The comparison could easily fail since the
          exception may be an instance instead of a class, in the case
          of a class exception, or it may the a subclass of the
          expected exception.)

 -- C Function: int PyErr_ExceptionMatches (PyObject *exc)
     Equivalent to `PyErr_GivenExceptionMatches(PyErr_Occurred(),
     exc)'.  This should only be called when an exception is actually
     set; a memory access violation will occur if no exception has been
     raised.

 -- C Function: int PyErr_GivenExceptionMatches (PyObject *given,
          PyObject *exc)
     Return true if the _given_ exception matches the exception in
     _exc_.  If _exc_ is a class object, this also returns true when
     _given_ is an instance of a subclass.  If _exc_ is a tuple, all
     exceptions in the tuple (and recursively in subtuples) are
     searched for a match.

 -- C Function: void PyErr_NormalizeException (PyObject**exc,
          PyObject**val, PyObject**tb)
     Under certain circumstances, the values returned by *note
     PyErr_Fetch(): 29cc. below can be "unnormalized", meaning that
     `*exc' is a class object but `*val' is not an instance of the
     same class.  This function can be used to instantiate the class in
     that case.  If the values are already normalized, nothing happens.
     The delayed normalization is implemented to improve performance.

 -- C Function: void PyErr_Clear ()
     Clear the error indicator.  If the error indicator is not set,
     there is no effect.

 -- C Function: void PyErr_Fetch (PyObject **ptype, PyObject **pvalue,
          PyObject **ptraceback)
     Retrieve the error indicator into three variables whose addresses
     are passed.  If the error indicator is not set, set all three
     variables to _NULL_.  If it is set, it will be cleared and you own
     a reference to each object retrieved.  The value and traceback
     object may be _NULL_ even when the type object is not.

          Note: This function is normally only used by code that needs
          to handle exceptions or by code that needs to save and
          restore the error indicator temporarily.

 -- C Function: void PyErr_Restore (PyObject *type, PyObject *value,
          PyObject *traceback)
     Set  the error indicator from the three objects.  If the error
     indicator is already set, it is cleared first.  If the objects are
     _NULL_, the error indicator is cleared.  Do not pass a _NULL_ type
     and non-_NULL_ value or traceback.  The exception type should be a
     class.  Do not pass an invalid exception type or value. (Violating
     these rules will cause subtle problems later.)  This call takes
     away a reference to each object: you must own a reference to each
     object before the call and after the call you no longer own these
     references.  (If you don't understand this, don't use this
     function.  I warned you.)

          Note: This function is normally only used by code that needs
          to save and restore the error indicator temporarily; use
          *note PyErr_Fetch(): 29cc. to save the current exception
          state.

 -- C Function: void PyErr_SetString (PyObject *type, const
          char *message)
     This is the most common way to set the error indicator.  The first
     argument specifies the exception type; it is normally one of the
     standard exceptions, e.g. `PyExc_RuntimeError'.  You need not
     increment its reference count.  The second argument is an error
     message; it is converted to a string object.

 -- C Function: void PyErr_SetObject (PyObject *type, PyObject *value)
     This function is similar to *note PyErr_SetString(): 2978. but
     lets you specify an arbitrary Python object for the "value" of the
     exception.

 -- C Function: PyObject* PyErr_Format (PyObject *exception, const
          char *format, ...)
     Return value: Always NULL.

     This function sets the error indicator and returns _NULL_.
     _exception_ should be a Python exception class.  The _format_ and
     subsequent parameters help format the error message; they have the
     same meaning and values as in *note PyString_FromFormat(): 2a4b.

 -- C Function: void PyErr_SetNone (PyObject *type)
     This is a shorthand for `PyErr_SetObject(type, Py_None)'.

 -- C Function: int PyErr_BadArgument ()
     This is a shorthand for `PyErr_SetString(PyExc_TypeError,
     message)', where _message_ indicates that a built-in operation was
     invoked with an illegal argument.  It is mostly for internal use.

 -- C Function: PyObject* PyErr_NoMemory ()
     Return value: Always NULL.

     This is a shorthand for `PyErr_SetNone(PyExc_MemoryError)'; it
     returns _NULL_ so an object allocation function can write `return
     PyErr_NoMemory();' when it runs out of memory.

 -- C Function: PyObject* PyErr_SetFromErrno (PyObject *type)
     Return value: Always NULL.

     This is a convenience function to raise an exception when a C
     library function has returned an error and set the C variable
     `errno'.  It constructs a tuple object whose first item is the
     integer `errno' value and whose second item is the corresponding
     error message (gotten from `strerror()'), and then calls
     `PyErr_SetObject(type, object)'.  On Unix, when the `errno' value
     is `EINTR', indicating an interrupted system call, this calls
     *note PyErr_CheckSignals(): 2a4e, and if that set the error
     indicator, leaves it set to that.  The function always returns
     _NULL_, so a wrapper function around a system call can write
     `return PyErr_SetFromErrno(type);' when the system call returns an
     error.

 -- C Function: PyObject* PyErr_SetFromErrnoWithFilenameObject
          (PyObject *type, PyObject *filenameObject)
     Similar to *note PyErr_SetFromErrno(): 2979, with the additional
     behavior that if _filenameObject_ is not _NULL_, it is passed to
     the constructor of _type_ as a third parameter.  In the case of
     exceptions such as *note IOError: 1f7. and *note OSError: 22e,
     this is used to define the `filename' attribute of the exception
     instance.

 -- C Function: PyObject* PyErr_SetFromErrnoWithFilename
          (PyObject *type, const char *filename)
     Return value: Always NULL.

     Similar to *note PyErr_SetFromErrnoWithFilenameObject(): 2a4f, but
     the filename is given as a C string.

 -- C Function: PyObject* PyErr_SetFromWindowsErr (int ierr)
     Return value: Always NULL.

     This is a convenience function to raise *note WindowsError: 948.
     If called with _ierr_ of `0', the error code returned by a call to
     `GetLastError()' is used instead.  It calls the Win32 function
     `FormatMessage()' to retrieve the Windows description of error
     code given by _ierr_ or `GetLastError()', then it constructs a
     tuple object whose first item is the _ierr_ value and whose second
     item is the corresponding error message (gotten from
     `FormatMessage()'), and then calls
     `PyErr_SetObject(PyExc_WindowsError, object)'. This function
     always returns _NULL_. Availability: Windows.

 -- C Function: PyObject* PyErr_SetExcFromWindowsErr (PyObject *type,
          int ierr)
     Return value: Always NULL.

     Similar to *note PyErr_SetFromWindowsErr(): 2a51, with an
     additional parameter specifying the exception type to be raised.
     Availability: Windows.

     New in version 2.3.

 -- C Function: PyObject* PyErr_SetFromWindowsErrWithFilenameObject
          (int ierr, PyObject *filenameObject)
     Similar to *note PyErr_SetFromWindowsErr(): 2a51, with the
     additional behavior that if _filenameObject_ is not _NULL_, it is
     passed to the constructor of *note WindowsError: 948. as a third
     parameter. Availability: Windows.

 -- C Function: PyObject* PyErr_SetFromWindowsErrWithFilename
          (int ierr, const char *filename)
     Return value: Always NULL.

     Similar to *note PyErr_SetFromWindowsErrWithFilenameObject():
     2a53, but the filename is given as a C string. Availability:
     Windows.

 -- C Function: PyObject* PyErr_SetExcFromWindowsErrWithFilenameObject
          (PyObject *type, int ierr, PyObject *filename)
     Similar to *note PyErr_SetFromWindowsErrWithFilenameObject():
     2a53, with an additional parameter specifying the exception type
     to be raised.  Availability: Windows.

     New in version 2.3.

 -- C Function: PyObject* PyErr_SetExcFromWindowsErrWithFilename
          (PyObject *type, int ierr, const char *filename)
     Return value: Always NULL.

     Similar to *note PyErr_SetFromWindowsErrWithFilename(): 2a54, with
     an additional parameter specifying the exception type to be
     raised. Availability: Windows.

     New in version 2.3.

 -- C Function: void PyErr_BadInternalCall ()
     This is a shorthand for `PyErr_SetString(PyExc_SystemError,
     message)', where _message_ indicates that an internal operation
     (e.g. a Python/C API function) was invoked with an illegal
     argument.  It is mostly for internal use.

 -- C Function: int PyErr_WarnEx (PyObject *category, char *message,
          int stacklevel)
     Issue a warning message.  The _category_ argument is a warning
     category (see below) or _NULL_; the _message_ argument is a
     message string.  _stacklevel_ is a positive number giving a number
     of stack frames; the warning will be issued from the  currently
     executing line of code in that stack frame.  A _stacklevel_ of 1
     is the function calling *note PyErr_WarnEx(): 3e0, 2 is  the
     function above that, and so forth.

     This function normally prints a warning message to _sys.stderr_;
     however, it is also possible that the user has specified that
     warnings are to be turned into errors, and in that case this will
     raise an exception.  It is also possible that the function raises
     an exception because of a problem with the warning machinery (the
     implementation imports the *note warnings: 193. module to do the
     heavy lifting).  The return value is `0' if no exception is
     raised, or `-1' if an exception is raised.  (It is not possible to
     determine whether a warning message is actually printed, nor what
     the reason is for the exception; this is intentional.)  If an
     exception is raised, the caller should do its normal exception
     handling (for example, *note Py_DECREF(): 2981. owned references
     and return an error value).

     Warning categories must be subclasses of `Warning'; the default
     warning category is `RuntimeWarning'.  The standard Python warning
     categories are available as global variables whose names are
     `PyExc_' followed by the Python exception name. These have the
     type *note PyObject*: 39f.; they are all class objects. Their
     names are `PyExc_Warning', `PyExc_UserWarning',
     `PyExc_UnicodeWarning', `PyExc_DeprecationWarning',
     `PyExc_SyntaxWarning', `PyExc_RuntimeWarning', and
     `PyExc_FutureWarning'.  `PyExc_Warning' is a subclass of
     `PyExc_Exception'; the other warning categories are subclasses of
     `PyExc_Warning'.

     For information about warning control, see the documentation for
     the *note warnings: 193. module and the *note -W: 1ba. option in
     the command line documentation.  There is no C API for warning
     control.

 -- C Function: int PyErr_Warn (PyObject *category, char *message)
     Issue a warning message.  The _category_ argument is a warning
     category (see below) or _NULL_; the _message_ argument is a
     message string.  The warning will appear to be issued from the
     function calling *note PyErr_Warn(): 3df, equivalent to calling
     *note PyErr_WarnEx(): 3e0. with a _stacklevel_ of 1.

     Deprecated; use *note PyErr_WarnEx(): 3e0. instead.

 -- C Function: int PyErr_WarnExplicit (PyObject *category, const
          char *message, const char *filename, int lineno, const
          char *module, PyObject *registry)
     Issue a warning message with explicit control over all warning
     attributes.  This is a straightforward wrapper around the Python
     function *note warnings.warn_explicit(): 23dd, see there for more
     information.  The _module_ and _registry_ arguments may be set to
     _NULL_ to get the default effect described there.

 -- C Function: int PyErr_WarnPy3k (char *message, int stacklevel)
     Issue a *note DeprecationWarning: 1b9. with the given _message_
     and _stacklevel_ if the `Py_Py3kWarningFlag' flag is enabled.

     New in version 2.6.

 -- C Function: int PyErr_CheckSignals ()
     This function interacts with Python's signal handling.  It checks
     whether a signal has been sent to the processes and if so, invokes
     the corresponding signal handler.  If the *note signal: 155.
     module is supported, this can invoke a signal handler written in
     Python.  In all cases, the default effect for `SIGINT' is to raise
     the  *note KeyboardInterrupt: 24e. exception.  If an exception is
     raised the error indicator is set and the function returns `-1';
     otherwise the function returns `0'.  The error indicator may or
     may not be cleared if it was previously set.

 -- C Function: void PyErr_SetInterrupt ()
     This function simulates the effect of a `SIGINT' signal arriving
     -- the next time *note PyErr_CheckSignals(): 2a4e. is called,
     *note KeyboardInterrupt: 24e. will be raised.  It may be called
     without holding the interpreter lock.


 -- C Function: int PySignal_SetWakeupFd (int fd)
     This utility function specifies a file descriptor to which a
     `'\0'' byte will be written whenever a signal is received.  It
     returns the previous such file descriptor.  The value `-1'
     disables the feature; this is the initial state.  This is
     equivalent to *note signal.set_wakeup_fd(): 175b. in Python, but
     without any error checking.  _fd_ should be a valid file
     descriptor.  The function should only be called from the main
     thread.

     New in version 2.6.

 -- C Function: PyObject* PyErr_NewException (char *name,
          PyObject *base, PyObject *dict)
     Return value: New reference.

     This utility function creates and returns a new exception class.
     The _name_ argument must be the name of the new exception, a C
     string of the form `module.classname'.  The _base_ and _dict_
     arguments are normally _NULL_.  This creates a class object
     derived from *note Exception: 332. (accessible in C as
     `PyExc_Exception').

     The `__module__' attribute of the new class is set to the first
     part (up to the last dot) of the _name_ argument, and the class
     name is set to the last part (after the last dot).  The _base_
     argument can be used to specify alternate base classes; it can
     either be only one class or a tuple of classes. The _dict_
     argument can be used to specify a dictionary of class variables
     and methods.

 -- C Function: PyObject* PyErr_NewExceptionWithDoc (char *name,
          char *doc, PyObject *base, PyObject *dict)
     Return value: New reference.

     Same as *note PyErr_NewException(): 2b7, except that the new
     exception class can easily be given a docstring: If _doc_ is
     non-_NULL_, it will be used as the docstring for the exception
     class.

     New in version 2.7.

 -- C Function: void PyErr_WriteUnraisable (PyObject *obj)
     This utility function prints a warning message to `sys.stderr'
     when an exception has been set but it is impossible for the
     interpreter to actually raise the exception.  It is used, for
     example, when an exception occurs in an *note __del__(): 6f6.
     method.

     The function is called with a single argument _obj_ that
     identifies the context in which the unraisable exception occurred.
     The repr of _obj_ will be printed in the warning message.

* Menu:

* Unicode Exception Objects::
* Recursion Control::
* Standard Exceptions::
* String Exceptions::



Local Variables:
coding: utf-8
End:
