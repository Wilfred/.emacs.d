This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: Example<6>,  Next: ArgumentParser objects,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.1 Example
................

The following code is a Python program that takes a list of integers and
produces either the sum or the max:

     import argparse

     parser = argparse.ArgumentParser(description='Process some integers.')
     parser.add_argument('integers', metavar='N', type=int, nargs='+',
                        help='an integer for the accumulator')
     parser.add_argument('--sum', dest='accumulate', action='store_const',
                        const=sum, default=max,
                        help='sum the integers (default: find the max)')

     args = parser.parse_args()
     print args.accumulate(args.integers)

  Assuming the Python code above is saved into a file called ‘prog.py’,
it can be run at the command line and provides useful help messages:

     $ python prog.py -h
     usage: prog.py [-h] [--sum] N [N ...]

     Process some integers.

     positional arguments:
      N           an integer for the accumulator

     optional arguments:
      -h, --help  show this help message and exit
      --sum       sum the integers (default: find the max)

  When run with the appropriate arguments, it prints either the sum or
the max of the command-line integers:

     $ python prog.py 1 2 3 4
     4

     $ python prog.py 1 2 3 4 --sum
     10

  If invalid arguments are passed in, it will issue an error:

     $ python prog.py a b c
     usage: prog.py [-h] [--sum] N [N ...]
     prog.py: error: argument N: invalid int value: 'a'

  The following sections walk you through this example.

* Menu:

* Creating a parser:: 
* Adding arguments:: 
* Parsing arguments:: 


File: python.info,  Node: Creating a parser,  Next: Adding arguments,  Up: Example<6>

5.15.4.2 Creating a parser
..........................

The first step in using the *note argparse: d. is creating an *note
ArgumentParser: 1200. object:

     >>> parser = argparse.ArgumentParser(description='Process some integers.')

  The *note ArgumentParser: 1200. object will hold all the information
necessary to parse the command line into Python data types.


File: python.info,  Node: Adding arguments,  Next: Parsing arguments,  Prev: Creating a parser,  Up: Example<6>

5.15.4.3 Adding arguments
.........................

Filling an *note ArgumentParser: 1200. with information about program
arguments is done by making calls to the *note add_argument(): 1202.
method.  Generally, these calls tell the *note ArgumentParser: 1200. how
to take the strings on the command line and turn them into objects.
This information is stored and used when *note parse_args(): 1203. is
called.  For example:

     >>> parser.add_argument('integers', metavar='N', type=int, nargs='+',
     ...                     help='an integer for the accumulator')
     >>> parser.add_argument('--sum', dest='accumulate', action='store_const',
     ...                     const=sum, default=max,
     ...                     help='sum the integers (default: find the max)')

  Later, calling *note parse_args(): 1203. will return an object with
two attributes, ‘integers’ and ‘accumulate’.  The ‘integers’ attribute
will be a list of one or more ints, and the ‘accumulate’ attribute will
be either the *note sum(): 426. function, if ‘--sum’ was specified at
the command line, or the *note max(): 225. function if it was not.


File: python.info,  Node: Parsing arguments,  Prev: Adding arguments,  Up: Example<6>

5.15.4.4 Parsing arguments
..........................

*note ArgumentParser: 1200. parses arguments through the *note
parse_args(): 1203. method.  This will inspect the command line, convert
each argument to the appropriate type and then invoke the appropriate
action.  In most cases, this means a simple *note Namespace: 1205.
object will be built up from attributes parsed out of the command line:

     >>> parser.parse_args(['--sum', '7', '-1', '42'])
     Namespace(accumulate=<built-in function sum>, integers=[7, -1, 42])

  In a script, *note parse_args(): 1203. will typically be called with
no arguments, and the *note ArgumentParser: 1200. will automatically
determine the command-line arguments from *note sys.argv: 634.


File: python.info,  Node: ArgumentParser objects,  Next: The add_argument method,  Prev: Example<6>,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.5 ArgumentParser objects
...............................

 -- Class: argparse.ArgumentParser (prog=None, usage=None,
          description=None, epilog=None, parents=[],
          formatter_class=argparse.HelpFormatter, prefix_chars='-',
          fromfile_prefix_chars=None, argument_default=None,
          conflict_handler='error', add_help=True)

     Create a new *note ArgumentParser: 1200. object.  All parameters
     should be passed as keyword arguments.  Each parameter has its own
     more detailed description below, but in short they are:

        * *note prog: 1207. - The name of the program (default:
          ‘sys.argv[0]’)

        * *note usage: 1208. - The string describing the program usage
          (default: generated from arguments added to parser)

        * *note description: 1209. - Text to display before the argument
          help (default: none)

        * *note epilog: 120a. - Text to display after the argument help
          (default: none)

        * *note parents: 120b. - A list of *note ArgumentParser: 1200.
          objects whose arguments should also be included

        * *note formatter_class: 120c. - A class for customizing the
          help output

        * *note prefix_chars: 120d. - The set of characters that prefix
          optional arguments (default: ’-’)

        * *note fromfile_prefix_chars: 120e. - The set of characters
          that prefix files from which additional arguments should be
          read (default: ‘None’)

        * *note argument_default: 120f. - The global default value for
          arguments (default: ‘None’)

        * *note conflict_handler: 1210. - The strategy for resolving
          conflicting optionals (usually unnecessary)

        * *note add_help: 1211. - Add a -h/–help option to the parser
          (default: ‘True’)

  The following sections describe how each of these are used.

* Menu:

* prog:: 
* usage:: 
* description:: 
* epilog:: 
* parents:: 
* formatter_class:: 
* prefix_chars:: 
* fromfile_prefix_chars:: 
* argument_default:: 
* conflict_handler:: 
* add_help:: 


File: python.info,  Node: prog,  Next: usage,  Up: ArgumentParser objects

5.15.4.6 prog
.............

By default, *note ArgumentParser: 1200. objects uses ‘sys.argv[0]’ to
determine how to display the name of the program in help messages.  This
default is almost always desirable because it will make the help
messages match how the program was invoked on the command line.  For
example, consider a file named ‘myprogram.py’ with the following code:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument('--foo', help='foo help')
     args = parser.parse_args()

  The help for this program will display ‘myprogram.py’ as the program
name (regardless of where the program was invoked from):

     $ python myprogram.py --help
     usage: myprogram.py [-h] [--foo FOO]

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO   foo help
     $ cd ..
     $ python subdir\myprogram.py --help
     usage: myprogram.py [-h] [--foo FOO]

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO   foo help

  To change this default behavior, another value can be supplied using
the ‘prog=’ argument to *note ArgumentParser: 1200.:

     >>> parser = argparse.ArgumentParser(prog='myprogram')
     >>> parser.print_help()
     usage: myprogram [-h]

     optional arguments:
      -h, --help  show this help message and exit

  Note that the program name, whether determined from ‘sys.argv[0]’ or
from the ‘prog=’ argument, is available to help messages using the
‘%(prog)s’ format specifier.

     >>> parser = argparse.ArgumentParser(prog='myprogram')
     >>> parser.add_argument('--foo', help='foo of the %(prog)s program')
     >>> parser.print_help()
     usage: myprogram [-h] [--foo FOO]

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO   foo of the myprogram program


File: python.info,  Node: usage,  Next: description,  Prev: prog,  Up: ArgumentParser objects

5.15.4.7 usage
..............

By default, *note ArgumentParser: 1200. calculates the usage message
from the arguments it contains:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('--foo', nargs='?', help='foo help')
     >>> parser.add_argument('bar', nargs='+', help='bar help')
     >>> parser.print_help()
     usage: PROG [-h] [--foo [FOO]] bar [bar ...]

     positional arguments:
      bar          bar help

     optional arguments:
      -h, --help   show this help message and exit
      --foo [FOO]  foo help

  The default message can be overridden with the ‘usage=’ keyword
argument:

     >>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
     >>> parser.add_argument('--foo', nargs='?', help='foo help')
     >>> parser.add_argument('bar', nargs='+', help='bar help')
     >>> parser.print_help()
     usage: PROG [options]

     positional arguments:
      bar          bar help

     optional arguments:
      -h, --help   show this help message and exit
      --foo [FOO]  foo help

  The ‘%(prog)s’ format specifier is available to fill in the program
name in your usage messages.


File: python.info,  Node: description,  Next: epilog,  Prev: usage,  Up: ArgumentParser objects

5.15.4.8 description
....................

Most calls to the *note ArgumentParser: 1200. constructor will use the
‘description=’ keyword argument.  This argument gives a brief
description of what the program does and how it works.  In help
messages, the description is displayed between the command-line usage
string and the help messages for the various arguments:

     >>> parser = argparse.ArgumentParser(description='A foo that bars')
     >>> parser.print_help()
     usage: argparse.py [-h]

     A foo that bars

     optional arguments:
      -h, --help  show this help message and exit

  By default, the description will be line-wrapped so that it fits
within the given space.  To change this behavior, see the *note
formatter_class: 120c. argument.


File: python.info,  Node: epilog,  Next: parents,  Prev: description,  Up: ArgumentParser objects

5.15.4.9 epilog
...............

Some programs like to display additional description of the program
after the description of the arguments.  Such text can be specified
using the ‘epilog=’ argument to *note ArgumentParser: 1200.:

     >>> parser = argparse.ArgumentParser(
     ...     description='A foo that bars',
     ...     epilog="And that's how you'd foo a bar")
     >>> parser.print_help()
     usage: argparse.py [-h]

     A foo that bars

     optional arguments:
      -h, --help  show this help message and exit

     And that's how you'd foo a bar

  As with the *note description: 1209. argument, the ‘epilog=’ text is
by default line-wrapped, but this behavior can be adjusted with the
*note formatter_class: 120c. argument to *note ArgumentParser: 1200.


File: python.info,  Node: parents,  Next: formatter_class,  Prev: epilog,  Up: ArgumentParser objects

5.15.4.10 parents
.................

Sometimes, several parsers share a common set of arguments.  Rather than
repeating the definitions of these arguments, a single parser with all
the shared arguments and passed to ‘parents=’ argument to *note
ArgumentParser: 1200. can be used.  The ‘parents=’ argument takes a list
of *note ArgumentParser: 1200. objects, collects all the positional and
optional actions from them, and adds these actions to the *note
ArgumentParser: 1200. object being constructed:

     >>> parent_parser = argparse.ArgumentParser(add_help=False)
     >>> parent_parser.add_argument('--parent', type=int)

     >>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])
     >>> foo_parser.add_argument('foo')
     >>> foo_parser.parse_args(['--parent', '2', 'XXX'])
     Namespace(foo='XXX', parent=2)

     >>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])
     >>> bar_parser.add_argument('--bar')
     >>> bar_parser.parse_args(['--bar', 'YYY'])
     Namespace(bar='YYY', parent=None)

  Note that most parent parsers will specify ‘add_help=False’.
Otherwise, the *note ArgumentParser: 1200. will see two ‘-h/--help’
options (one in the parent and one in the child) and raise an error.

     Note: You must fully initialize the parsers before passing them via
     ‘parents=’.  If you change the parent parsers after the child
     parser, those changes will not be reflected in the child.


File: python.info,  Node: formatter_class,  Next: prefix_chars,  Prev: parents,  Up: ArgumentParser objects

5.15.4.11 formatter_class
.........................

*note ArgumentParser: 1200. objects allow the help formatting to be
customized by specifying an alternate formatting class.  Currently,
there are three such classes:

 -- Class: argparse.RawDescriptionHelpFormatter
 -- Class: argparse.RawTextHelpFormatter
 -- Class: argparse.ArgumentDefaultsHelpFormatter

  The first two allow more control over how textual descriptions are
displayed, while the last automatically adds information about argument
default values.

  By default, *note ArgumentParser: 1200. objects line-wrap the *note
description: 1209. and *note epilog: 120a. texts in command-line help
messages:

     >>> parser = argparse.ArgumentParser(
     ...     prog='PROG',
     ...     description='''this description
     ...         was indented weird
     ...             but that is okay''',
     ...     epilog='''
     ...             likewise for this epilog whose whitespace will
     ...         be cleaned up and whose words will be wrapped
     ...         across a couple lines''')
     >>> parser.print_help()
     usage: PROG [-h]

     this description was indented weird but that is okay

     optional arguments:
      -h, --help  show this help message and exit

     likewise for this epilog whose whitespace will be cleaned up and whose words
     will be wrapped across a couple lines

  Passing *note RawDescriptionHelpFormatter: 1212. as ‘formatter_class=’
indicates that *note description: 1209. and *note epilog: 120a. are
already correctly formatted and should not be line-wrapped:

     >>> parser = argparse.ArgumentParser(
     ...     prog='PROG',
     ...     formatter_class=argparse.RawDescriptionHelpFormatter,
     ...     description=textwrap.dedent('''\
     ...         Please do not mess up this text!
     ...         --------------------------------
     ...             I have indented it
     ...             exactly the way
     ...             I want it
     ...         '''))
     >>> parser.print_help()
     usage: PROG [-h]

     Please do not mess up this text!
     --------------------------------
        I have indented it
        exactly the way
        I want it

     optional arguments:
      -h, --help  show this help message and exit

  *note RawTextHelpFormatter: 1213. maintains whitespace for all sorts
of help text, including argument descriptions.

  The other formatter class available, *note
ArgumentDefaultsHelpFormatter: 1214, will add information about the
default value of each of the arguments:

     >>> parser = argparse.ArgumentParser(
     ...     prog='PROG',
     ...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
     >>> parser.add_argument('--foo', type=int, default=42, help='FOO!')
     >>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
     >>> parser.print_help()
     usage: PROG [-h] [--foo FOO] [bar [bar ...]]

     positional arguments:
      bar         BAR! (default: [1, 2, 3])

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO   FOO! (default: 42)


File: python.info,  Node: prefix_chars,  Next: fromfile_prefix_chars,  Prev: formatter_class,  Up: ArgumentParser objects

5.15.4.12 prefix_chars
......................

Most command-line options will use ‘-’ as the prefix, e.g.  ‘-f/--foo’.
Parsers that need to support different or additional prefix characters,
e.g.  for options like ‘+f’ or ‘/foo’, may specify them using the
‘prefix_chars=’ argument to the ArgumentParser constructor:

     >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
     >>> parser.add_argument('+f')
     >>> parser.add_argument('++bar')
     >>> parser.parse_args('+f X ++bar Y'.split())
     Namespace(bar='Y', f='X')

  The ‘prefix_chars=’ argument defaults to ‘'-'’.  Supplying a set of
characters that does not include ‘-’ will cause ‘-f/--foo’ options to be
disallowed.


File: python.info,  Node: fromfile_prefix_chars,  Next: argument_default,  Prev: prefix_chars,  Up: ArgumentParser objects

5.15.4.13 fromfile_prefix_chars
...............................

Sometimes, for example when dealing with a particularly long argument
lists, it may make sense to keep the list of arguments in a file rather
than typing it out at the command line.  If the ‘fromfile_prefix_chars=’
argument is given to the *note ArgumentParser: 1200. constructor, then
arguments that start with any of the specified characters will be
treated as files, and will be replaced by the arguments they contain.
For example:

     >>> with open('args.txt', 'w') as fp:
     ...    fp.write('-f\nbar')
     >>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
     >>> parser.add_argument('-f')
     >>> parser.parse_args(['-f', 'foo', '@args.txt'])
     Namespace(f='bar')

  Arguments read from a file must by default be one per line (but see
also *note convert_arg_line_to_args(): 1215.) and are treated as if they
were in the same place as the original file referencing argument on the
command line.  So in the example above, the expression ‘['-f', 'foo',
'@args.txt']’ is considered equivalent to the expression ‘['-f', 'foo',
'-f', 'bar']’.

  The ‘fromfile_prefix_chars=’ argument defaults to ‘None’, meaning that
arguments will never be treated as file references.


File: python.info,  Node: argument_default,  Next: conflict_handler,  Prev: fromfile_prefix_chars,  Up: ArgumentParser objects

5.15.4.14 argument_default
..........................

Generally, argument defaults are specified either by passing a default
to *note add_argument(): 1202. or by calling the *note set_defaults():
1216. methods with a specific set of name-value pairs.  Sometimes
however, it may be useful to specify a single parser-wide default for
arguments.  This can be accomplished by passing the ‘argument_default=’
keyword argument to *note ArgumentParser: 1200.  For example, to
globally suppress attribute creation on *note parse_args(): 1203. calls,
we supply ‘argument_default=SUPPRESS’:

     >>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
     >>> parser.add_argument('--foo')
     >>> parser.add_argument('bar', nargs='?')
     >>> parser.parse_args(['--foo', '1', 'BAR'])
     Namespace(bar='BAR', foo='1')
     >>> parser.parse_args([])
     Namespace()


File: python.info,  Node: conflict_handler,  Next: add_help,  Prev: argument_default,  Up: ArgumentParser objects

5.15.4.15 conflict_handler
..........................

*note ArgumentParser: 1200. objects do not allow two actions with the
same option string.  By default, *note ArgumentParser: 1200. objects
raises an exception if an attempt is made to create an argument with an
option string that is already in use:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-f', '--foo', help='old foo help')
     >>> parser.add_argument('--foo', help='new foo help')
     Traceback (most recent call last):
      ..
     ArgumentError: argument --foo: conflicting option string(s): --foo

  Sometimes (e.g.  when using *note parents: 120b.) it may be useful to
simply override any older arguments with the same option string.  To get
this behavior, the value ‘'resolve'’ can be supplied to the
‘conflict_handler=’ argument of *note ArgumentParser: 1200.:

     >>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
     >>> parser.add_argument('-f', '--foo', help='old foo help')
     >>> parser.add_argument('--foo', help='new foo help')
     >>> parser.print_help()
     usage: PROG [-h] [-f FOO] [--foo FOO]

     optional arguments:
      -h, --help  show this help message and exit
      -f FOO      old foo help
      --foo FOO   new foo help

  Note that *note ArgumentParser: 1200. objects only remove an action if
all of its option strings are overridden.  So, in the example above, the
old ‘-f/--foo’ action is retained as the ‘-f’ action, because only the
‘--foo’ option string was overridden.


File: python.info,  Node: add_help,  Prev: conflict_handler,  Up: ArgumentParser objects

5.15.4.16 add_help
..................

By default, ArgumentParser objects add an option which simply displays
the parser’s help message.  For example, consider a file named
‘myprogram.py’ containing the following code:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument('--foo', help='foo help')
     args = parser.parse_args()

  If ‘-h’ or ‘--help’ is supplied at the command line, the
ArgumentParser help will be printed:

     $ python myprogram.py --help
     usage: myprogram.py [-h] [--foo FOO]

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO   foo help

  Occasionally, it may be useful to disable the addition of this help
option.  This can be achieved by passing ‘False’ as the ‘add_help=’
argument to *note ArgumentParser: 1200.:

     >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
     >>> parser.add_argument('--foo', help='foo help')
     >>> parser.print_help()
     usage: PROG [--foo FOO]

     optional arguments:
      --foo FOO  foo help

  The help option is typically ‘-h/--help’.  The exception to this is if
the ‘prefix_chars=’ is specified and does not include ‘-’, in which case
‘-h’ and ‘--help’ are not valid options.  In this case, the first
character in ‘prefix_chars’ is used to prefix the help options:

     >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')
     >>> parser.print_help()
     usage: PROG [+h]

     optional arguments:
       +h, ++help  show this help message and exit


File: python.info,  Node: The add_argument method,  Next: The parse_args method,  Prev: ArgumentParser objects,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.17 The add_argument() method
...................................

 -- Method: ArgumentParser.add_argument (name or flags...[, action][,
          nargs][, const][, default][, type][, choices][, required][,
          help][, metavar][, dest])

     Define how a single command-line argument should be parsed.  Each
     parameter has its own more detailed description below, but in short
     they are:

        * *note name or flags: 1218. - Either a name or a list of option
          strings, e.g.  ‘foo’ or ‘-f, --foo’.

        * *note action: 1219. - The basic type of action to be taken
          when this argument is encountered at the command line.

        * *note nargs: 121a. - The number of command-line arguments that
          should be consumed.

        * *note const: 121b. - A constant value required by some *note
          action: 1219. and *note nargs: 121a. selections.

        * *note default: 121c. - The value produced if the argument is
          absent from the command line.

        * *note type: 121d. - The type to which the command-line
          argument should be converted.

        * *note choices: 121e. - A container of the allowable values for
          the argument.

        * *note required: 121f. - Whether or not the command-line option
          may be omitted (optionals only).

        * *note help: 1220. - A brief description of what the argument
          does.

        * *note metavar: 1221. - A name for the argument in usage
          messages.

        * *note dest: 1222. - The name of the attribute to be added to
          the object returned by *note parse_args(): 1203.

  The following sections describe how each of these are used.

* Menu:

* name or flags:: 
* action:: 
* nargs:: 
* const:: 
* default:: 
* type:: 
* choices:: 
* required:: 
* help:: 
* metavar:: 
* dest:: 


File: python.info,  Node: name or flags,  Next: action,  Up: The add_argument method

5.15.4.18 name or flags
.......................

The *note add_argument(): 1202. method must know whether an optional
argument, like ‘-f’ or ‘--foo’, or a positional argument, like a list of
filenames, is expected.  The first arguments passed to *note
add_argument(): 1202. must therefore be either a series of flags, or a
simple argument name.  For example, an optional argument could be
created like:

     >>> parser.add_argument('-f', '--foo')

  while a positional argument could be created like:

     >>> parser.add_argument('bar')

  When *note parse_args(): 1203. is called, optional arguments will be
identified by the ‘-’ prefix, and the remaining arguments will be
assumed to be positional:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-f', '--foo')
     >>> parser.add_argument('bar')
     >>> parser.parse_args(['BAR'])
     Namespace(bar='BAR', foo=None)
     >>> parser.parse_args(['BAR', '--foo', 'FOO'])
     Namespace(bar='BAR', foo='FOO')
     >>> parser.parse_args(['--foo', 'FOO'])
     usage: PROG [-h] [-f FOO] bar
     PROG: error: too few arguments


File: python.info,  Node: action,  Next: nargs,  Prev: name or flags,  Up: The add_argument method

5.15.4.19 action
................

*note ArgumentParser: 1200. objects associate command-line arguments
with actions.  These actions can do just about anything with the
command-line arguments associated with them, though most actions simply
add an attribute to the object returned by *note parse_args(): 1203.
The ‘action’ keyword argument specifies how the command-line arguments
should be handled.  The supported actions are:

   * ‘'store'’ - This just stores the argument’s value.  This is the
     default action.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo')
          >>> parser.parse_args('--foo 1'.split())
          Namespace(foo='1')

   * ‘'store_const'’ - This stores the value specified by the *note
     const: 121b. keyword argument.  (Note that the *note const: 121b.
     keyword argument defaults to the rather unhelpful ‘None’.)  The
     ‘'store_const'’ action is most commonly used with optional
     arguments that specify some sort of flag.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', action='store_const', const=42)
          >>> parser.parse_args('--foo'.split())
          Namespace(foo=42)

   * ‘'store_true'’ and ‘'store_false'’ - These are special cases of
     ‘'store_const'’ using for storing the values ‘True’ and ‘False’
     respectively.  In addition, they create default values of _False_
     and _True_ respectively.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', action='store_true')
          >>> parser.add_argument('--bar', action='store_false')
          >>> parser.add_argument('--baz', action='store_false')
          >>> parser.parse_args('--foo --bar'.split())
          Namespace(bar=False, baz=True, foo=True)

   * ‘'append'’ - This stores a list, and appends each argument value to
     the list.  This is useful to allow an option to be specified
     multiple times.  Example usage:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', action='append')
          >>> parser.parse_args('--foo 1 --foo 2'.split())
          Namespace(foo=['1', '2'])

   * ‘'append_const'’ - This stores a list, and appends the value
     specified by the *note const: 121b. keyword argument to the list.
     (Note that the *note const: 121b. keyword argument defaults to
     ‘None’.)  The ‘'append_const'’ action is typically useful when
     multiple arguments need to store constants to the same list.  For
     example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--str', dest='types', action='append_const', const=str)
          >>> parser.add_argument('--int', dest='types', action='append_const', const=int)
          >>> parser.parse_args('--str --int'.split())
          Namespace(types=[<type 'str'>, <type 'int'>])

   * ‘'count'’ - This counts the number of times a keyword argument
     occurs.  For example, this is useful for increasing verbosity
     levels:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--verbose', '-v', action='count')
          >>> parser.parse_args('-vvv'.split())
          Namespace(verbose=3)

   * ‘'help'’ - This prints a complete help message for all the options
     in the current parser and then exits.  By default a help action is
     automatically added to the parser.  See *note ArgumentParser: 1200.
     for details of how the output is created.

   * ‘'version'’ - This expects a ‘version=’ keyword argument in the
     *note add_argument(): 1202. call, and prints version information
     and exits when invoked:

          >>> import argparse
          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')
          >>> parser.parse_args(['--version'])
          PROG 2.0

  You can also specify an arbitrary action by passing an object that
implements the Action API. The easiest way to do this is to extend
‘argparse.Action’, supplying an appropriate ‘__call__’ method.  The
‘__call__’ method should accept four parameters:

   * ‘parser’ - The ArgumentParser object which contains this action.

   * ‘namespace’ - The *note Namespace: 1205. object that will be
     returned by *note parse_args(): 1203.  Most actions add an
     attribute to this object.

   * ‘values’ - The associated command-line arguments, with any type
     conversions applied.  (Type conversions are specified with the
     *note type: 121d. keyword argument to *note add_argument(): 1202.)

   * ‘option_string’ - The option string that was used to invoke this
     action.  The ‘option_string’ argument is optional, and will be
     absent if the action is associated with a positional argument.

  An example of a custom action:

     >>> class FooAction(argparse.Action):
     ...     def __call__(self, parser, namespace, values, option_string=None):
     ...         print '%r %r %r' % (namespace, values, option_string)
     ...         setattr(namespace, self.dest, values)
     ...
     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', action=FooAction)
     >>> parser.add_argument('bar', action=FooAction)
     >>> args = parser.parse_args('1 --foo 2'.split())
     Namespace(bar=None, foo=None) '1' None
     Namespace(bar='1', foo=None) '2' '--foo'
     >>> args
     Namespace(bar='1', foo='2')


File: python.info,  Node: nargs,  Next: const,  Prev: action,  Up: The add_argument method

5.15.4.20 nargs
...............

ArgumentParser objects usually associate a single command-line argument
with a single action to be taken.  The ‘nargs’ keyword argument
associates a different number of command-line arguments with a single
action.  The supported values are:

   * ‘N’ (an integer).  ‘N’ arguments from the command line will be
     gathered together into a list.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', nargs=2)
          >>> parser.add_argument('bar', nargs=1)
          >>> parser.parse_args('c --foo a b'.split())
          Namespace(bar=['c'], foo=['a', 'b'])

     Note that ‘nargs=1’ produces a list of one item.  This is different
     from the default, in which the item is produced by itself.

   * ‘'?'’.  One argument will be consumed from the command line if
     possible, and produced as a single item.  If no command-line
     argument is present, the value from *note default: 121c. will be
     produced.  Note that for optional arguments, there is an additional
     case - the option string is present but not followed by a
     command-line argument.  In this case the value from *note const:
     121b. will be produced.  Some examples to illustrate this:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', nargs='?', const='c', default='d')
          >>> parser.add_argument('bar', nargs='?', default='d')
          >>> parser.parse_args('XX --foo YY'.split())
          Namespace(bar='XX', foo='YY')
          >>> parser.parse_args('XX --foo'.split())
          Namespace(bar='XX', foo='c')
          >>> parser.parse_args(''.split())
          Namespace(bar='d', foo='d')

     One of the more common uses of ‘nargs='?'’ is to allow optional
     input and output files:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
          ...                     default=sys.stdin)
          >>> parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'),
          ...                     default=sys.stdout)
          >>> parser.parse_args(['input.txt', 'output.txt'])
          Namespace(infile=<open file 'input.txt', mode 'r' at 0x...>,
                    outfile=<open file 'output.txt', mode 'w' at 0x...>)
          >>> parser.parse_args([])
          Namespace(infile=<open file '<stdin>', mode 'r' at 0x...>,
                    outfile=<open file '<stdout>', mode 'w' at 0x...>)

   * ‘'*'’.  All command-line arguments present are gathered into a
     list.  Note that it generally doesn’t make much sense to have more
     than one positional argument with ‘nargs='*'’, but multiple
     optional arguments with ‘nargs='*'’ is possible.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', nargs='*')
          >>> parser.add_argument('--bar', nargs='*')
          >>> parser.add_argument('baz', nargs='*')
          >>> parser.parse_args('a b --foo x y --bar 1 2'.split())
          Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])

   * ‘'+'’.  Just like ‘'*'’, all command-line args present are gathered
     into a list.  Additionally, an error message will be generated if
     there wasn’t at least one command-line argument present.  For
     example:

          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> parser.add_argument('foo', nargs='+')
          >>> parser.parse_args('a b'.split())
          Namespace(foo=['a', 'b'])
          >>> parser.parse_args(''.split())
          usage: PROG [-h] foo [foo ...]
          PROG: error: too few arguments

   * ‘argparse.REMAINDER’.  All the remaining command-line arguments are
     gathered into a list.  This is commonly useful for command line
     utilities that dispatch to other command line utilities:

          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> parser.add_argument('--foo')
          >>> parser.add_argument('command')
          >>> parser.add_argument('args', nargs=argparse.REMAINDER)
          >>> print parser.parse_args('--foo B cmd --arg1 XX ZZ'.split())
          Namespace(args=['--arg1', 'XX', 'ZZ'], command='cmd', foo='B')

  If the ‘nargs’ keyword argument is not provided, the number of
arguments consumed is determined by the *note action: 1219.  Generally
this means a single command-line argument will be consumed and a single
item (not a list) will be produced.


File: python.info,  Node: const,  Next: default,  Prev: nargs,  Up: The add_argument method

5.15.4.21 const
...............

The ‘const’ argument of *note add_argument(): 1202. is used to hold
constant values that are not read from the command line but are required
for the various *note ArgumentParser: 1200. actions.  The two most
common uses of it are:

   * When *note add_argument(): 1202. is called with
     ‘action='store_const'’ or ‘action='append_const'’.  These actions
     add the ‘const’ value to one of the attributes of the object
     returned by *note parse_args(): 1203.  See the *note action: 1219.
     description for examples.

   * When *note add_argument(): 1202. is called with option strings
     (like ‘-f’ or ‘--foo’) and ‘nargs='?'’.  This creates an optional
     argument that can be followed by zero or one command-line
     arguments.  When parsing the command line, if the option string is
     encountered with no command-line argument following it, the value
     of ‘const’ will be assumed instead.  See the *note nargs: 121a.
     description for examples.

  The ‘const’ keyword argument defaults to ‘None’.


File: python.info,  Node: default,  Next: type,  Prev: const,  Up: The add_argument method

5.15.4.22 default
.................

All optional arguments and some positional arguments may be omitted at
the command line.  The ‘default’ keyword argument of *note
add_argument(): 1202, whose value defaults to ‘None’, specifies what
value should be used if the command-line argument is not present.  For
optional arguments, the ‘default’ value is used when the option string
was not present at the command line:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', default=42)
     >>> parser.parse_args('--foo 2'.split())
     Namespace(foo='2')
     >>> parser.parse_args(''.split())
     Namespace(foo=42)

  If the ‘default’ value is a string, the parser parses the value as if
it were a command-line argument.  In particular, the parser applies any
*note type: 121d. conversion argument, if provided, before setting the
attribute on the *note Namespace: 1205. return value.  Otherwise, the
parser uses the value as is:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--length', default='10', type=int)
     >>> parser.add_argument('--width', default=10.5, type=int)
     >>> parser.parse_args()
     Namespace(length=10, width=10.5)

  For positional arguments with *note nargs: 121a. equal to ‘?’ or ‘*’,
the ‘default’ value is used when no command-line argument was present:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('foo', nargs='?', default=42)
     >>> parser.parse_args('a'.split())
     Namespace(foo='a')
     >>> parser.parse_args(''.split())
     Namespace(foo=42)

  Providing ‘default=argparse.SUPPRESS’ causes no attribute to be added
if the command-line argument was not present.:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', default=argparse.SUPPRESS)
     >>> parser.parse_args([])
     Namespace()
     >>> parser.parse_args(['--foo', '1'])
     Namespace(foo='1')


File: python.info,  Node: type,  Next: choices,  Prev: default,  Up: The add_argument method

5.15.4.23 type
..............

By default, *note ArgumentParser: 1200. objects read command-line
arguments in as simple strings.  However, quite often the command-line
string should instead be interpreted as another type, like a *note
float: 1eb. or *note int: 1f2.  The ‘type’ keyword argument of *note
add_argument(): 1202. allows any necessary type-checking and type
conversions to be performed.  Common built-in types and functions can be
used directly as the value of the ‘type’ argument:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('foo', type=int)
     >>> parser.add_argument('bar', type=file)
     >>> parser.parse_args('2 temp.txt'.split())
     Namespace(bar=<open file 'temp.txt', mode 'r' at 0x...>, foo=2)

  See the section on the *note default: 121c. keyword argument for
information on when the ‘type’ argument is applied to default arguments.

  To ease the use of various types of files, the argparse module
provides the factory FileType which takes the ‘mode=’ and ‘bufsize=’
arguments of the ‘file’ object.  For example, ‘FileType('w')’ can be
used to create a writable file:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('bar', type=argparse.FileType('w'))
     >>> parser.parse_args(['out.txt'])
     Namespace(bar=<open file 'out.txt', mode 'w' at 0x...>)

  ‘type=’ can take any callable that takes a single string argument and
returns the converted value:

     >>> def perfect_square(string):
     ...     value = int(string)
     ...     sqrt = math.sqrt(value)
     ...     if sqrt != int(sqrt):
     ...         msg = "%r is not a perfect square" % string
     ...         raise argparse.ArgumentTypeError(msg)
     ...     return value
     ...
     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('foo', type=perfect_square)
     >>> parser.parse_args('9'.split())
     Namespace(foo=9)
     >>> parser.parse_args('7'.split())
     usage: PROG [-h] foo
     PROG: error: argument foo: '7' is not a perfect square

  The *note choices: 121e. keyword argument may be more convenient for
type checkers that simply check against a range of values:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('foo', type=int, choices=xrange(5, 10))
     >>> parser.parse_args('7'.split())
     Namespace(foo=7)
     >>> parser.parse_args('11'.split())
     usage: PROG [-h] {5,6,7,8,9}
     PROG: error: argument foo: invalid choice: 11 (choose from 5, 6, 7, 8, 9)

  See the *note choices: 121e. section for more details.


File: python.info,  Node: choices,  Next: required,  Prev: type,  Up: The add_argument method

5.15.4.24 choices
.................

Some command-line arguments should be selected from a restricted set of
values.  These can be handled by passing a container object as the
_choices_ keyword argument to *note add_argument(): 1202.  When the
command line is parsed, argument values will be checked, and an error
message will be displayed if the argument was not one of the acceptable
values:

     >>> parser = argparse.ArgumentParser(prog='game.py')
     >>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
     >>> parser.parse_args(['rock'])
     Namespace(move='rock')
     >>> parser.parse_args(['fire'])
     usage: game.py [-h] {rock,paper,scissors}
     game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',
     'paper', 'scissors')

  Note that inclusion in the _choices_ container is checked after any
*note type: 121d. conversions have been performed, so the type of the
objects in the _choices_ container should match the *note type: 121d.
specified:

     >>> parser = argparse.ArgumentParser(prog='doors.py')
     >>> parser.add_argument('door', type=int, choices=range(1, 4))
     >>> print(parser.parse_args(['3']))
     Namespace(door=3)
     >>> parser.parse_args(['4'])
     usage: doors.py [-h] {1,2,3}
     doors.py: error: argument door: invalid choice: 4 (choose from 1, 2, 3)

  Any object that supports the ‘in’ operator can be passed as the
_choices_ value, so *note dict: 305. objects, *note set: 36a. objects,
custom containers, etc.  are all supported.


File: python.info,  Node: required,  Next: help,  Prev: choices,  Up: The add_argument method

5.15.4.25 required
..................

In general, the *note argparse: d. module assumes that flags like ‘-f’
and ‘--bar’ indicate _optional_ arguments, which can always be omitted
at the command line.  To make an option _required_, ‘True’ can be
specified for the ‘required=’ keyword argument to *note add_argument():
1202.:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', required=True)
     >>> parser.parse_args(['--foo', 'BAR'])
     Namespace(foo='BAR')
     >>> parser.parse_args([])
     usage: argparse.py [-h] [--foo FOO]
     argparse.py: error: option --foo is required

  As the example shows, if an option is marked as ‘required’, *note
parse_args(): 1203. will report an error if that option is not present
at the command line.

     Note: Required options are generally considered bad form because
     users expect _options_ to be _optional_, and thus they should be
     avoided when possible.


File: python.info,  Node: help,  Next: metavar,  Prev: required,  Up: The add_argument method

5.15.4.26 help
..............

The ‘help’ value is a string containing a brief description of the
argument.  When a user requests help (usually by using ‘-h’ or ‘--help’
at the command line), these ‘help’ descriptions will be displayed with
each argument:

     >>> parser = argparse.ArgumentParser(prog='frobble')
     >>> parser.add_argument('--foo', action='store_true',
     ...         help='foo the bars before frobbling')
     >>> parser.add_argument('bar', nargs='+',
     ...         help='one of the bars to be frobbled')
     >>> parser.parse_args('-h'.split())
     usage: frobble [-h] [--foo] bar [bar ...]

     positional arguments:
      bar     one of the bars to be frobbled

     optional arguments:
      -h, --help  show this help message and exit
      --foo   foo the bars before frobbling

  The ‘help’ strings can include various format specifiers to avoid
repetition of things like the program name or the argument *note
default: 121c.  The available specifiers include the program name,
‘%(prog)s’ and most keyword arguments to *note add_argument(): 1202,
e.g.  ‘%(default)s’, ‘%(type)s’, etc.:

     >>> parser = argparse.ArgumentParser(prog='frobble')
     >>> parser.add_argument('bar', nargs='?', type=int, default=42,
     ...         help='the bar to %(prog)s (default: %(default)s)')
     >>> parser.print_help()
     usage: frobble [-h] [bar]

     positional arguments:
      bar     the bar to frobble (default: 42)

     optional arguments:
      -h, --help  show this help message and exit

  *note argparse: d. supports silencing the help entry for certain
options, by setting the ‘help’ value to ‘argparse.SUPPRESS’:

     >>> parser = argparse.ArgumentParser(prog='frobble')
     >>> parser.add_argument('--foo', help=argparse.SUPPRESS)
     >>> parser.print_help()
     usage: frobble [-h]

     optional arguments:
       -h, --help  show this help message and exit


File: python.info,  Node: metavar,  Next: dest,  Prev: help,  Up: The add_argument method

5.15.4.27 metavar
.................

When *note ArgumentParser: 1200. generates help messages, it needs some
way to refer to each expected argument.  By default, ArgumentParser
objects use the *note dest: 1222. value as the "name" of each object.
By default, for positional argument actions, the *note dest: 1222. value
is used directly, and for optional argument actions, the *note dest:
1222. value is uppercased.  So, a single positional argument with
‘dest='bar'’ will be referred to as ‘bar’.  A single optional argument
‘--foo’ that should be followed by a single command-line argument will
be referred to as ‘FOO’.  An example:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo')
     >>> parser.add_argument('bar')
     >>> parser.parse_args('X --foo Y'.split())
     Namespace(bar='X', foo='Y')
     >>> parser.print_help()
     usage:  [-h] [--foo FOO] bar

     positional arguments:
      bar

     optional arguments:
      -h, --help  show this help message and exit
      --foo FOO

  An alternative name can be specified with ‘metavar’:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', metavar='YYY')
     >>> parser.add_argument('bar', metavar='XXX')
     >>> parser.parse_args('X --foo Y'.split())
     Namespace(bar='X', foo='Y')
     >>> parser.print_help()
     usage:  [-h] [--foo YYY] XXX

     positional arguments:
      XXX

     optional arguments:
      -h, --help  show this help message and exit
      --foo YYY

  Note that ‘metavar’ only changes the _displayed_ name - the name of
the attribute on the *note parse_args(): 1203. object is still
determined by the *note dest: 1222. value.

  Different values of ‘nargs’ may cause the metavar to be used multiple
times.  Providing a tuple to ‘metavar’ specifies a different display for
each of the arguments:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-x', nargs=2)
     >>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))
     >>> parser.print_help()
     usage: PROG [-h] [-x X X] [--foo bar baz]

     optional arguments:
      -h, --help     show this help message and exit
      -x X X
      --foo bar baz


File: python.info,  Node: dest,  Prev: metavar,  Up: The add_argument method

5.15.4.28 dest
..............

Most *note ArgumentParser: 1200. actions add some value as an attribute
of the object returned by *note parse_args(): 1203.  The name of this
attribute is determined by the ‘dest’ keyword argument of *note
add_argument(): 1202.  For positional argument actions, ‘dest’ is
normally supplied as the first argument to *note add_argument(): 1202.:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('bar')
     >>> parser.parse_args('XXX'.split())
     Namespace(bar='XXX')

  For optional argument actions, the value of ‘dest’ is normally
inferred from the option strings.  *note ArgumentParser: 1200. generates
the value of ‘dest’ by taking the first long option string and stripping
away the initial ‘--’ string.  If no long option strings were supplied,
‘dest’ will be derived from the first short option string by stripping
the initial ‘-’ character.  Any internal ‘-’ characters will be
converted to ‘_’ characters to make sure the string is a valid attribute
name.  The examples below illustrate this behavior:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('-f', '--foo-bar', '--foo')
     >>> parser.add_argument('-x', '-y')
     >>> parser.parse_args('-f 1 -x 2'.split())
     Namespace(foo_bar='1', x='2')
     >>> parser.parse_args('--foo 1 -y 2'.split())
     Namespace(foo_bar='1', x='2')

  ‘dest’ allows a custom attribute name to be provided:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', dest='bar')
     >>> parser.parse_args('--foo XXX'.split())
     Namespace(bar='XXX')


File: python.info,  Node: The parse_args method,  Next: Other utilities,  Prev: The add_argument method,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.29 The parse_args() method
.................................

 -- Method: ArgumentParser.parse_args (args=None, namespace=None)

     Convert argument strings to objects and assign them as attributes
     of the namespace.  Return the populated namespace.

     Previous calls to *note add_argument(): 1202. determine exactly
     what objects are created and how they are assigned.  See the
     documentation for *note add_argument(): 1202. for details.

     By default, the argument strings are taken from *note sys.argv:
     634, and a new empty *note Namespace: 1205. object is created for
     the attributes.

* Menu:

* Option value syntax:: 
* Invalid arguments:: 
* Arguments containing -:: 
* Argument abbreviations (prefix matching): Argument abbreviations prefix matching. 
* Beyond sys.argv: Beyond sys argv. 
* The Namespace object:: 


File: python.info,  Node: Option value syntax,  Next: Invalid arguments,  Up: The parse_args method

5.15.4.30 Option value syntax
.............................

The *note parse_args(): 1203. method supports several ways of specifying
the value of an option (if it takes one).  In the simplest case, the
option and its value are passed as two separate arguments:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-x')
     >>> parser.add_argument('--foo')
     >>> parser.parse_args('-x X'.split())
     Namespace(foo=None, x='X')
     >>> parser.parse_args('--foo FOO'.split())
     Namespace(foo='FOO', x=None)

  For long options (options with names longer than a single character),
the option and value can also be passed as a single command-line
argument, using ‘=’ to separate them:

     >>> parser.parse_args('--foo=FOO'.split())
     Namespace(foo='FOO', x=None)

  For short options (options only one character long), the option and
its value can be concatenated:

     >>> parser.parse_args('-xX'.split())
     Namespace(foo=None, x='X')

  Several short options can be joined together, using only a single ‘-’
prefix, as long as only the last option (or none of them) requires a
value:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-x', action='store_true')
     >>> parser.add_argument('-y', action='store_true')
     >>> parser.add_argument('-z')
     >>> parser.parse_args('-xyzZ'.split())
     Namespace(x=True, y=True, z='Z')


File: python.info,  Node: Invalid arguments,  Next: Arguments containing -,  Prev: Option value syntax,  Up: The parse_args method

5.15.4.31 Invalid arguments
...........................

While parsing the command line, *note parse_args(): 1203. checks for a
variety of errors, including ambiguous options, invalid types, invalid
options, wrong number of positional arguments, etc.  When it encounters
such an error, it exits and prints the error along with a usage message:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('--foo', type=int)
     >>> parser.add_argument('bar', nargs='?')

     >>> # invalid type
     >>> parser.parse_args(['--foo', 'spam'])
     usage: PROG [-h] [--foo FOO] [bar]
     PROG: error: argument --foo: invalid int value: 'spam'

     >>> # invalid option
     >>> parser.parse_args(['--bar'])
     usage: PROG [-h] [--foo FOO] [bar]
     PROG: error: no such option: --bar

     >>> # wrong number of arguments
     >>> parser.parse_args(['spam', 'badger'])
     usage: PROG [-h] [--foo FOO] [bar]
     PROG: error: extra arguments found: badger


File: python.info,  Node: Arguments containing -,  Next: Argument abbreviations prefix matching,  Prev: Invalid arguments,  Up: The parse_args method

5.15.4.32 Arguments containing ‘-’
..................................

The *note parse_args(): 1203. method attempts to give errors whenever
the user has clearly made a mistake, but some situations are inherently
ambiguous.  For example, the command-line argument ‘-1’ could either be
an attempt to specify an option or an attempt to provide a positional
argument.  The *note parse_args(): 1203. method is cautious here:
positional arguments may only begin with ‘-’ if they look like negative
numbers and there are no options in the parser that look like negative
numbers:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-x')
     >>> parser.add_argument('foo', nargs='?')

     >>> # no negative number options, so -1 is a positional argument
     >>> parser.parse_args(['-x', '-1'])
     Namespace(foo=None, x='-1')

     >>> # no negative number options, so -1 and -5 are positional arguments
     >>> parser.parse_args(['-x', '-1', '-5'])
     Namespace(foo='-5', x='-1')

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-1', dest='one')
     >>> parser.add_argument('foo', nargs='?')

     >>> # negative number options present, so -1 is an option
     >>> parser.parse_args(['-1', 'X'])
     Namespace(foo=None, one='X')

     >>> # negative number options present, so -2 is an option
     >>> parser.parse_args(['-2'])
     usage: PROG [-h] [-1 ONE] [foo]
     PROG: error: no such option: -2

     >>> # negative number options present, so both -1s are options
     >>> parser.parse_args(['-1', '-1'])
     usage: PROG [-h] [-1 ONE] [foo]
     PROG: error: argument -1: expected one argument

  If you have positional arguments that must begin with ‘-’ and don’t
look like negative numbers, you can insert the pseudo-argument ‘'--'’
which tells *note parse_args(): 1203. that everything after that is a
positional argument:

     >>> parser.parse_args(['--', '-f'])
     Namespace(foo='-f', one=None)


File: python.info,  Node: Argument abbreviations prefix matching,  Next: Beyond sys argv,  Prev: Arguments containing -,  Up: The parse_args method

5.15.4.33 Argument abbreviations (prefix matching)
..................................................

The *note parse_args(): 1203. method allows long options to be
abbreviated to a prefix, if the abbreviation is unambiguous (the prefix
matches a unique option):

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('-bacon')
     >>> parser.add_argument('-badger')
     >>> parser.parse_args('-bac MMM'.split())
     Namespace(bacon='MMM', badger=None)
     >>> parser.parse_args('-bad WOOD'.split())
     Namespace(bacon=None, badger='WOOD')
     >>> parser.parse_args('-ba BA'.split())
     usage: PROG [-h] [-bacon BACON] [-badger BADGER]
     PROG: error: ambiguous option: -ba could match -badger, -bacon

  An error is produced for arguments that could produce more than one
options.


File: python.info,  Node: Beyond sys argv,  Next: The Namespace object,  Prev: Argument abbreviations prefix matching,  Up: The parse_args method

5.15.4.34 Beyond ‘sys.argv’
...........................

Sometimes it may be useful to have an ArgumentParser parse arguments
other than those of *note sys.argv: 634.  This can be accomplished by
passing a list of strings to *note parse_args(): 1203.  This is useful
for testing at the interactive prompt:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument(
     ...     'integers', metavar='int', type=int, choices=xrange(10),
     ...  nargs='+', help='an integer in the range 0..9')
     >>> parser.add_argument(
     ...     '--sum', dest='accumulate', action='store_const', const=sum,
     ...   default=max, help='sum the integers (default: find the max)')
     >>> parser.parse_args(['1', '2', '3', '4'])
     Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
     >>> parser.parse_args('1 2 3 4 --sum'.split())
     Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])


File: python.info,  Node: The Namespace object,  Prev: Beyond sys argv,  Up: The parse_args method

5.15.4.35 The Namespace object
..............................

 -- Class: argparse.Namespace

     Simple class used by default by *note parse_args(): 1203. to create
     an object holding attributes and return it.

  This class is deliberately simple, just an *note object: 1f1. subclass
with a readable string representation.  If you prefer to have dict-like
view of the attributes, you can use the standard Python idiom, *note
vars(): 598.:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo')
     >>> args = parser.parse_args(['--foo', 'BAR'])
     >>> vars(args)
     {'foo': 'BAR'}

  It may also be useful to have an *note ArgumentParser: 1200. assign
attributes to an already existing object, rather than a new *note
Namespace: 1205. object.  This can be achieved by specifying the
‘namespace=’ keyword argument:

     >>> class C(object):
     ...     pass
     ...
     >>> c = C()
     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo')
     >>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)
     >>> c.foo
     'BAR'


File: python.info,  Node: Other utilities,  Next: Upgrading optparse code,  Prev: The parse_args method,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.36 Other utilities
.........................

* Menu:

* Sub-commands:: 
* FileType objects:: 
* Argument groups:: 
* Mutual exclusion:: 
* Parser defaults:: 
* Printing help:: 
* Partial parsing:: 
* Customizing file parsing:: 
* Exiting methods:: 


File: python.info,  Node: Sub-commands,  Next: FileType objects,  Up: Other utilities

5.15.4.37 Sub-commands
......................

 -- Method: ArgumentParser.add_subparsers ([title][, description][,
          prog][, parser_class][, action][, option_string][, dest][,
          help][, metavar])

     Many programs split up their functionality into a number of
     sub-commands, for example, the ‘svn’ program can invoke
     sub-commands like ‘svn checkout’, ‘svn update’, and ‘svn commit’.
     Splitting up functionality this way can be a particularly good idea
     when a program performs several different functions which require
     different kinds of command-line arguments.  *note ArgumentParser:
     1200. supports the creation of such sub-commands with the *note
     add_subparsers(): 122d. method.  The *note add_subparsers(): 122d.
     method is normally called with no arguments and returns a special
     action object.  This object has a single method, ‘add_parser()’,
     which takes a command name and any *note ArgumentParser: 1200.
     constructor arguments, and returns an *note ArgumentParser: 1200.
     object that can be modified as usual.

     Description of parameters:

        * title - title for the sub-parser group in help output; by
          default "subcommands" if description is provided, otherwise
          uses title for positional arguments

        * description - description for the sub-parser group in help
          output, by default None

        * prog - usage information that will be displayed with
          sub-command help, by default the name of the program and any
          positional arguments before the subparser argument

        * parser_class - class which will be used to create sub-parser
          instances, by default the class of the current parser (e.g.
          ArgumentParser)

        * dest - name of the attribute under which sub-command name will
          be stored; by default None and no value is stored

        * help - help for sub-parser group in help output, by default
          None

        * metavar - string presenting available sub-commands in help; by
          default it is None and presents sub-commands in form {cmd1,
          cmd2, ..}

     Some example usage:

          >>> # create the top-level parser
          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> parser.add_argument('--foo', action='store_true', help='foo help')
          >>> subparsers = parser.add_subparsers(help='sub-command help')
          >>>
          >>> # create the parser for the "a" command
          >>> parser_a = subparsers.add_parser('a', help='a help')
          >>> parser_a.add_argument('bar', type=int, help='bar help')
          >>>
          >>> # create the parser for the "b" command
          >>> parser_b = subparsers.add_parser('b', help='b help')
          >>> parser_b.add_argument('--baz', choices='XYZ', help='baz help')
          >>>
          >>> # parse some argument lists
          >>> parser.parse_args(['a', '12'])
          Namespace(bar=12, foo=False)
          >>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])
          Namespace(baz='Z', foo=True)

     Note that the object returned by *note parse_args(): 1203. will
     only contain attributes for the main parser and the subparser that
     was selected by the command line (and not any other subparsers).
     So in the example above, when the ‘a’ command is specified, only
     the ‘foo’ and ‘bar’ attributes are present, and when the ‘b’
     command is specified, only the ‘foo’ and ‘baz’ attributes are
     present.

     Similarly, when a help message is requested from a subparser, only
     the help for that particular parser will be printed.  The help
     message will not include parent parser or sibling parser messages.
     (A help message for each subparser command, however, can be given
     by supplying the ‘help=’ argument to ‘add_parser()’ as above.)

          >>> parser.parse_args(['--help'])
          usage: PROG [-h] [--foo] {a,b} ...

          positional arguments:
            {a,b}   sub-command help
              a     a help
              b     b help

          optional arguments:
            -h, --help  show this help message and exit
            --foo   foo help

          >>> parser.parse_args(['a', '--help'])
          usage: PROG a [-h] bar

          positional arguments:
            bar     bar help

          optional arguments:
            -h, --help  show this help message and exit

          >>> parser.parse_args(['b', '--help'])
          usage: PROG b [-h] [--baz {X,Y,Z}]

          optional arguments:
            -h, --help     show this help message and exit
            --baz {X,Y,Z}  baz help

     The *note add_subparsers(): 122d. method also supports ‘title’ and
     ‘description’ keyword arguments.  When either is present, the
     subparser’s commands will appear in their own group in the help
     output.  For example:

          >>> parser = argparse.ArgumentParser()
          >>> subparsers = parser.add_subparsers(title='subcommands',
          ...                                    description='valid subcommands',
          ...                                    help='additional help')
          >>> subparsers.add_parser('foo')
          >>> subparsers.add_parser('bar')
          >>> parser.parse_args(['-h'])
          usage:  [-h] {foo,bar} ...

          optional arguments:
            -h, --help  show this help message and exit

          subcommands:
            valid subcommands

            {foo,bar}   additional help

     One particularly effective way of handling sub-commands is to
     combine the use of the *note add_subparsers(): 122d. method with
     calls to *note set_defaults(): 1216. so that each subparser knows
     which Python function it should execute.  For example:

          >>> # sub-command functions
          >>> def foo(args):
          ...     print args.x * args.y
          ...
          >>> def bar(args):
          ...     print '((%s))' % args.z
          ...
          >>> # create the top-level parser
          >>> parser = argparse.ArgumentParser()
          >>> subparsers = parser.add_subparsers()
          >>>
          >>> # create the parser for the "foo" command
          >>> parser_foo = subparsers.add_parser('foo')
          >>> parser_foo.add_argument('-x', type=int, default=1)
          >>> parser_foo.add_argument('y', type=float)
          >>> parser_foo.set_defaults(func=foo)
          >>>
          >>> # create the parser for the "bar" command
          >>> parser_bar = subparsers.add_parser('bar')
          >>> parser_bar.add_argument('z')
          >>> parser_bar.set_defaults(func=bar)
          >>>
          >>> # parse the args and call whatever function was selected
          >>> args = parser.parse_args('foo 1 -x 2'.split())
          >>> args.func(args)
          2.0
          >>>
          >>> # parse the args and call whatever function was selected
          >>> args = parser.parse_args('bar XYZYX'.split())
          >>> args.func(args)
          ((XYZYX))

     This way, you can let *note parse_args(): 1203. do the job of
     calling the appropriate function after argument parsing is
     complete.  Associating functions with actions like this is
     typically the easiest way to handle the different actions for each
     of your subparsers.  However, if it is necessary to check the name
     of the subparser that was invoked, the ‘dest’ keyword argument to
     the *note add_subparsers(): 122d. call will work:

          >>> parser = argparse.ArgumentParser()
          >>> subparsers = parser.add_subparsers(dest='subparser_name')
          >>> subparser1 = subparsers.add_parser('1')
          >>> subparser1.add_argument('-x')
          >>> subparser2 = subparsers.add_parser('2')
          >>> subparser2.add_argument('y')
          >>> parser.parse_args(['2', 'frobble'])
          Namespace(subparser_name='2', y='frobble')


File: python.info,  Node: FileType objects,  Next: Argument groups,  Prev: Sub-commands,  Up: Other utilities

5.15.4.38 FileType objects
..........................

 -- Class: argparse.FileType (mode='r', bufsize=None)

     The *note FileType: 1d6. factory creates objects that can be passed
     to the type argument of *note ArgumentParser.add_argument(): 1202.
     Arguments that have *note FileType: 1d6. objects as their type will
     open command-line arguments as files with the requested modes and
     buffer sizes:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--output', type=argparse.FileType('wb', 0))
          >>> parser.parse_args(['--output', 'out'])
          Namespace(output=<open file 'out', mode 'wb' at 0x...>)

     FileType objects understand the pseudo-argument ‘'-'’ and
     automatically convert this into ‘sys.stdin’ for readable *note
     FileType: 1d6. objects and ‘sys.stdout’ for writable *note
     FileType: 1d6. objects:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('infile', type=argparse.FileType('r'))
          >>> parser.parse_args(['-'])
          Namespace(infile=<open file '<stdin>', mode 'r' at 0x...>)


File: python.info,  Node: Argument groups,  Next: Mutual exclusion,  Prev: FileType objects,  Up: Other utilities

5.15.4.39 Argument groups
.........................

 -- Method: ArgumentParser.add_argument_group (title=None,
          description=None)

     By default, *note ArgumentParser: 1200. groups command-line
     arguments into "positional arguments" and "optional arguments" when
     displaying help messages.  When there is a better conceptual
     grouping of arguments than this default one, appropriate groups can
     be created using the *note add_argument_group(): 1230. method:

          >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
          >>> group = parser.add_argument_group('group')
          >>> group.add_argument('--foo', help='foo help')
          >>> group.add_argument('bar', help='bar help')
          >>> parser.print_help()
          usage: PROG [--foo FOO] bar

          group:
            bar    bar help
            --foo FOO  foo help

     The *note add_argument_group(): 1230. method returns an argument
     group object which has an *note add_argument(): 1202. method just
     like a regular *note ArgumentParser: 1200.  When an argument is
     added to the group, the parser treats it just like a normal
     argument, but displays the argument in a separate group for help
     messages.  The *note add_argument_group(): 1230. method accepts
     _title_ and _description_ arguments which can be used to customize
     this display:

          >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
          >>> group1 = parser.add_argument_group('group1', 'group1 description')
          >>> group1.add_argument('foo', help='foo help')
          >>> group2 = parser.add_argument_group('group2', 'group2 description')
          >>> group2.add_argument('--bar', help='bar help')
          >>> parser.print_help()
          usage: PROG [--bar BAR] foo

          group1:
            group1 description

            foo    foo help

          group2:
            group2 description

            --bar BAR  bar help

     Note that any arguments not in your user-defined groups will end up
     back in the usual "positional arguments" and "optional arguments"
     sections.


File: python.info,  Node: Mutual exclusion,  Next: Parser defaults,  Prev: Argument groups,  Up: Other utilities

5.15.4.40 Mutual exclusion
..........................

 -- Method: ArgumentParser.add_mutually_exclusive_group (required=False)

     Create a mutually exclusive group.  *note argparse: d. will make
     sure that only one of the arguments in the mutually exclusive group
     was present on the command line:

          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> group = parser.add_mutually_exclusive_group()
          >>> group.add_argument('--foo', action='store_true')
          >>> group.add_argument('--bar', action='store_false')
          >>> parser.parse_args(['--foo'])
          Namespace(bar=True, foo=True)
          >>> parser.parse_args(['--bar'])
          Namespace(bar=False, foo=False)
          >>> parser.parse_args(['--foo', '--bar'])
          usage: PROG [-h] [--foo | --bar]
          PROG: error: argument --bar: not allowed with argument --foo

     The *note add_mutually_exclusive_group(): 1232. method also accepts
     a _required_ argument, to indicate that at least one of the
     mutually exclusive arguments is required:

          >>> parser = argparse.ArgumentParser(prog='PROG')
          >>> group = parser.add_mutually_exclusive_group(required=True)
          >>> group.add_argument('--foo', action='store_true')
          >>> group.add_argument('--bar', action='store_false')
          >>> parser.parse_args([])
          usage: PROG [-h] (--foo | --bar)
          PROG: error: one of the arguments --foo --bar is required

     Note that currently mutually exclusive argument groups do not
     support the _title_ and _description_ arguments of *note
     add_argument_group(): 1230.


File: python.info,  Node: Parser defaults,  Next: Printing help,  Prev: Mutual exclusion,  Up: Other utilities

5.15.4.41 Parser defaults
.........................

 -- Method: ArgumentParser.set_defaults (**kwargs)

     Most of the time, the attributes of the object returned by *note
     parse_args(): 1203. will be fully determined by inspecting the
     command-line arguments and the argument actions.  *note
     set_defaults(): 1216. allows some additional attributes that are
     determined without any inspection of the command line to be added:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('foo', type=int)
          >>> parser.set_defaults(bar=42, baz='badger')
          >>> parser.parse_args(['736'])
          Namespace(bar=42, baz='badger', foo=736)

     Note that parser-level defaults always override argument-level
     defaults:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', default='bar')
          >>> parser.set_defaults(foo='spam')
          >>> parser.parse_args([])
          Namespace(foo='spam')

     Parser-level defaults can be particularly useful when working with
     multiple parsers.  See the *note add_subparsers(): 122d. method for
     an example of this type.

 -- Method: ArgumentParser.get_default (dest)

     Get the default value for a namespace attribute, as set by either
     *note add_argument(): 1202. or by *note set_defaults(): 1216.:

          >>> parser = argparse.ArgumentParser()
          >>> parser.add_argument('--foo', default='badger')
          >>> parser.get_default('foo')
          'badger'


File: python.info,  Node: Printing help,  Next: Partial parsing,  Prev: Parser defaults,  Up: Other utilities

5.15.4.42 Printing help
.......................

In most typical applications, *note parse_args(): 1203. will take care
of formatting and printing any usage or error messages.  However,
several formatting methods are available:

 -- Method: ArgumentParser.print_usage (file=None)

     Print a brief description of how the *note ArgumentParser: 1200.
     should be invoked on the command line.  If _file_ is ‘None’, *note
     sys.stdout: 889. is assumed.

 -- Method: ArgumentParser.print_help (file=None)

     Print a help message, including the program usage and information
     about the arguments registered with the *note ArgumentParser: 1200.
     If _file_ is ‘None’, *note sys.stdout: 889. is assumed.

  There are also variants of these methods that simply return a string
instead of printing it:

 -- Method: ArgumentParser.format_usage ()

     Return a string containing a brief description of how the *note
     ArgumentParser: 1200. should be invoked on the command line.

 -- Method: ArgumentParser.format_help ()

     Return a string containing a help message, including the program
     usage and information about the arguments registered with the *note
     ArgumentParser: 1200.


File: python.info,  Node: Partial parsing,  Next: Customizing file parsing,  Prev: Printing help,  Up: Other utilities

5.15.4.43 Partial parsing
.........................

 -- Method: ArgumentParser.parse_known_args (args=None, namespace=None)

  Sometimes a script may only parse a few of the command-line arguments,
passing the remaining arguments on to another script or program.  In
these cases, the *note parse_known_args(): 123b. method can be useful.
It works much like *note parse_args(): 1203. except that it does not
produce an error when extra arguments are present.  Instead, it returns
a two item tuple containing the populated namespace and the list of
remaining argument strings.

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', action='store_true')
     >>> parser.add_argument('bar')
     >>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
     (Namespace(bar='BAR', foo=True), ['--badger', 'spam'])

     Warning: *note Prefix matching: 1227. rules apply to
     ‘parse_known_args()’.  The parser may consume an option even if
     it’s just a prefix of one of its known options, instead of leaving
     it in the remaining arguments list.


File: python.info,  Node: Customizing file parsing,  Next: Exiting methods,  Prev: Partial parsing,  Up: Other utilities

5.15.4.44 Customizing file parsing
..................................

 -- Method: ArgumentParser.convert_arg_line_to_args (arg_line)

     Arguments that are read from a file (see the
     _fromfile_prefix_chars_ keyword argument to the *note
     ArgumentParser: 1200. constructor) are read one argument per line.
     *note convert_arg_line_to_args(): 1215. can be overriden for
     fancier reading.

     This method takes a single argument _arg_line_ which is a string
     read from the argument file.  It returns a list of arguments parsed
     from this string.  The method is called once per line read from the
     argument file, in order.

     A useful override of this method is one that treats each
     space-separated word as an argument:

          def convert_arg_line_to_args(self, arg_line):
              for arg in arg_line.split():
                  if not arg.strip():
                      continue
                  yield arg


File: python.info,  Node: Exiting methods,  Prev: Customizing file parsing,  Up: Other utilities

5.15.4.45 Exiting methods
.........................

 -- Method: ArgumentParser.exit (status=0, message=None)

     This method terminates the program, exiting with the specified
     _status_ and, if given, it prints a _message_ before that.

 -- Method: ArgumentParser.error (message)

     This method prints a usage message including the _message_ to the
     standard error and terminates the program with a status code of 2.


File: python.info,  Node: Upgrading optparse code,  Prev: Other utilities,  Up: argparse --- Parser for command-line options arguments and sub-commands

5.15.4.46 Upgrading optparse code
.................................

Originally, the *note argparse: d. module had attempted to maintain
compatibility with *note optparse: 127.  However, *note optparse: 127.
was difficult to extend transparently, particularly with the changes
required to support the new ‘nargs=’ specifiers and better usage
messages.  When most everything in *note optparse: 127. had either been
copy-pasted over or monkey-patched, it no longer seemed practical to try
to maintain the backwards compatibility.

  A partial upgrade path from *note optparse: 127. to *note argparse:
d.:

   * Replace all *note optparse.OptionParser.add_option(): 1241. calls
     with *note ArgumentParser.add_argument(): 1202. calls.

   * Replace ‘(options, args) = parser.parse_args()’ with ‘args =
     parser.parse_args()’ and add additional *note
     ArgumentParser.add_argument(): 1202. calls for the positional
     arguments.  Keep in mind that what was previously called ‘options’,
     now in *note argparse: d. context is called ‘args’.

   * Replace callback actions and the ‘callback_*’ keyword arguments
     with ‘type’ or ‘action’ arguments.

   * Replace string names for ‘type’ keyword arguments with the
     corresponding type objects (e.g.  int, float, complex, etc).

   * Replace ‘optparse.Values’ with *note Namespace: 1205. and
     ‘optparse.OptionError’ and ‘optparse.OptionValueError’ with
     ‘ArgumentError’.

   * Replace strings with implicit arguments such as ‘%default’ or
     ‘%prog’ with the standard Python syntax to use dictionaries to
     format strings, that is, ‘%(default)s’ and ‘%(prog)s’.

   * Replace the OptionParser constructor ‘version’ argument with a call
     to ‘parser.add_argument('--version', action='version',
     version='<the version>')’


File: python.info,  Node: optparse --- Parser for command line options,  Next: getopt --- C-style parser for command line options,  Prev: argparse --- Parser for command-line options arguments and sub-commands,  Up: Generic Operating System Services

5.15.5 ‘optparse’ — Parser for command line options
---------------------------------------------------

New in version 2.3.

  Deprecated since version 2.7: The *note optparse: 127. module is
deprecated and will not be developed further; development will continue
with the *note argparse: d. module.

  *Source code:* Lib/optparse.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  *note optparse: 127. is a more convenient, flexible, and powerful
library for parsing command-line options than the old *note getopt: de.
module.  *note optparse: 127. uses a more declarative style of
command-line parsing: you create an instance of *note OptionParser:
1244, populate it with options, and parse the command line.  *note
optparse: 127. allows users to specify options in the conventional
GNU/POSIX syntax, and additionally generates usage and help messages for
you.

  Here’s an example of using *note optparse: 127. in a simple script:

     from optparse import OptionParser
     [...]
     parser = OptionParser()
     parser.add_option("-f", "--file", dest="filename",
                       help="write report to FILE", metavar="FILE")
     parser.add_option("-q", "--quiet",
                       action="store_false", dest="verbose", default=True,
                       help="don't print status messages to stdout")

     (options, args) = parser.parse_args()

  With these few lines of code, users of your script can now do the
"usual thing" on the command-line, for example:

     <yourscript> --file=outfile -q

  As it parses the command line, *note optparse: 127. sets attributes of
the ‘options’ object returned by ‘parse_args()’ based on user-supplied
command-line values.  When ‘parse_args()’ returns from parsing this
command line, ‘options.filename’ will be ‘"outfile"’ and
‘options.verbose’ will be ‘False’.  *note optparse: 127. supports both
long and short options, allows short options to be merged together, and
allows options to be associated with their arguments in a variety of
ways.  Thus, the following command lines are all equivalent to the above
example:

     <yourscript> -f outfile --quiet
     <yourscript> --quiet --file outfile
     <yourscript> -q -foutfile
     <yourscript> -qfoutfile

  Additionally, users can run one of

     <yourscript> -h
     <yourscript> --help

  and *note optparse: 127. will print out a brief summary of your
script’s options:

     Usage: <yourscript> [options]

     Options:
       -h, --help            show this help message and exit
       -f FILE, --file=FILE  write report to FILE
       -q, --quiet           don't print status messages to stdout

  where the value of _yourscript_ is determined at runtime (normally
from ‘sys.argv[0]’).

* Menu:

* Background:: 
* Tutorial:: 
* Reference Guide:: 
* Option Callbacks:: 
* Extending optparse:: 

Background

* Terminology:: 
* What are options for?:: 
* What are positional arguments for?:: 

Tutorial

* Understanding option actions:: 
* The store action:: 
* Handling boolean (flag) options: Handling boolean flag options. 
* Other actions:: 
* Default values:: 
* Generating help:: 
* Printing a version string:: 
* How optparse handles errors:: 
* Putting it all together:: 

Generating help

* Grouping Options:: 

Reference Guide

* Creating the parser:: 
* Populating the parser:: 
* Defining options:: 
* Option attributes:: 
* Standard option actions:: 
* Standard option types:: 
* Parsing arguments: Parsing arguments<2>. 
* Querying and manipulating your option parser:: 
* Conflicts between options:: 
* Cleanup:: 
* Other methods:: 

Option Callbacks

* Defining a callback option:: 
* How callbacks are called:: 
* Raising errors in a callback:: 
* Callback example 1; trivial callback: Callback example 1 trivial callback. 
* Callback example 2; check option order: Callback example 2 check option order. 
* Callback example 3; check option order (generalized): Callback example 3 check option order generalized. 
* Callback example 4; check arbitrary condition: Callback example 4 check arbitrary condition. 
* Callback example 5; fixed arguments: Callback example 5 fixed arguments. 
* Callback example 6; variable arguments: Callback example 6 variable arguments. 

Extending optparse

* Adding new types:: 
* Adding new actions:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/optparse.py


File: python.info,  Node: Background,  Next: Tutorial,  Up: optparse --- Parser for command line options

5.15.5.1 Background
...................

*note optparse: 127. was explicitly designed to encourage the creation
of programs with straightforward, conventional command-line interfaces.
To that end, it supports only the most common command-line syntax and
semantics conventionally used under Unix.  If you are unfamiliar with
these conventions, read this section to acquaint yourself with them.

* Menu:

* Terminology:: 
* What are options for?:: 
* What are positional arguments for?:: 


File: python.info,  Node: Terminology,  Next: What are options for?,  Up: Background

5.15.5.2 Terminology
....................

argument

     a string entered on the command-line, and passed by the shell to
     ‘execl()’ or ‘execv()’.  In Python, arguments are elements of
     ‘sys.argv[1:]’ (‘sys.argv[0]’ is the name of the program being
     executed).  Unix shells also use the term "word".

     It is occasionally desirable to substitute an argument list other
     than ‘sys.argv[1:]’, so you should read "argument" as "an element
     of ‘sys.argv[1:]’, or of some other list provided as a substitute
     for ‘sys.argv[1:]’".

option

     an argument used to supply extra information to guide or customize
     the execution of a program.  There are many different syntaxes for
     options; the traditional Unix syntax is a hyphen ("-") followed by
     a single letter, e.g.  ‘-x’ or ‘-F’.  Also, traditional Unix syntax
     allows multiple options to be merged into a single argument, e.g.
     ‘-x -F’ is equivalent to ‘-xF’.  The GNU project introduced ‘--’
     followed by a series of hyphen-separated words, e.g.  ‘--file’ or
     ‘--dry-run’.  These are the only two option syntaxes provided by
     *note optparse: 127.

     Some other option syntaxes that the world has seen include:

        * a hyphen followed by a few letters, e.g.  ‘-pf’ (this is _not_
          the same as multiple options merged into a single argument)

        * a hyphen followed by a whole word, e.g.  ‘-file’ (this is
          technically equivalent to the previous syntax, but they aren’t
          usually seen in the same program)

        * a plus sign followed by a single letter, or a few letters, or
          a word, e.g.  ‘+f’, ‘+rgb’

        * a slash followed by a letter, or a few letters, or a word,
          e.g.  ‘/f’, ‘/file’

     These option syntaxes are not supported by *note optparse: 127, and
     they never will be.  This is deliberate: the first three are
     non-standard on any environment, and the last only makes sense if
     you’re exclusively targeting VMS, MS-DOS, and/or Windows.

option argument

     an argument that follows an option, is closely associated with that
     option, and is consumed from the argument list when that option is.
     With *note optparse: 127, option arguments may either be in a
     separate argument from their option:

          -f foo
          --file foo

     or included in the same argument:

          -ffoo
          --file=foo

     Typically, a given option either takes an argument or it doesn’t.
     Lots of people want an "optional option arguments" feature, meaning
     that some options will take an argument if they see it, and won’t
     if they don’t.  This is somewhat controversial, because it makes
     parsing ambiguous: if ‘-a’ takes an optional argument and ‘-b’ is
     another option entirely, how do we interpret ‘-ab’?  Because of
     this ambiguity, *note optparse: 127. does not support this feature.

positional argument

     something leftover in the argument list after options have been
     parsed, i.e.  after options and their arguments have been parsed
     and removed from the argument list.

required option

     an option that must be supplied on the command-line; note that the
     phrase "required option" is self-contradictory in English.  *note
     optparse: 127. doesn’t prevent you from implementing required
     options, but doesn’t give you much help at it either.

  For example, consider this hypothetical command-line:

     prog -v --report report.txt foo bar

  ‘-v’ and ‘--report’ are both options.  Assuming that ‘--report’ takes
one argument, ‘report.txt’ is an option argument.  ‘foo’ and ‘bar’ are
positional arguments.


File: python.info,  Node: What are options for?,  Next: What are positional arguments for?,  Prev: Terminology,  Up: Background

5.15.5.3 What are options for?
..............................

Options are used to provide extra information to tune or customize the
execution of a program.  In case it wasn’t clear, options are usually
_optional_.  A program should be able to run just fine with no options
whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can
it run without any options at all and still make sense?  The main
exceptions are ‘find’, ‘tar’, and ‘dd’—all of which are mutant oddballs
that have been rightly criticized for their non-standard syntax and
confusing interfaces.)

  Lots of people want their programs to have "required options".  Think
about it.  If it’s required, then it’s _not optional_!  If there is a
piece of information that your program absolutely requires in order to
run successfully, that’s what positional arguments are for.

  As an example of good command-line interface design, consider the
humble ‘cp’ utility, for copying files.  It doesn’t make much sense to
try to copy files without supplying a destination and at least one
source.  Hence, ‘cp’ fails if you run it with no arguments.  However, it
has a flexible, useful syntax that does not require any options at all:

     cp SOURCE DEST
     cp SOURCE ... DEST-DIR

  You can get pretty far with just that.  Most ‘cp’ implementations
provide a bunch of options to tweak exactly how the files are copied:
you can preserve mode and modification time, avoid following symlinks,
ask before clobbering existing files, etc.  But none of this distracts
from the core mission of ‘cp’, which is to copy either one file to
another, or several files to another directory.


File: python.info,  Node: What are positional arguments for?,  Prev: What are options for?,  Up: Background

5.15.5.4 What are positional arguments for?
...........................................

Positional arguments are for those pieces of information that your
program absolutely, positively requires to run.

  A good user interface should have as few absolute requirements as
possible.  If your program requires 17 distinct pieces of information in
order to run successfully, it doesn’t much matter _how_ you get that
information from the user—most people will give up and walk away before
they successfully run the program.  This applies whether the user
interface is a command-line, a configuration file, or a GUI: if you make
that many demands on your users, most of them will simply give up.

  In short, try to minimize the amount of information that users are
absolutely required to supply—use sensible defaults whenever possible.
Of course, you also want to make your programs reasonably flexible.
That’s what options are for.  Again, it doesn’t matter if they are
entries in a config file, widgets in the "Preferences" dialog of a GUI,
or command-line options—the more options you implement, the more
flexible your program is, and the more complicated its implementation
becomes.  Too much flexibility has drawbacks as well, of course; too
many options can overwhelm users and make your code much harder to
maintain.


File: python.info,  Node: Tutorial,  Next: Reference Guide,  Prev: Background,  Up: optparse --- Parser for command line options

5.15.5.5 Tutorial
.................

While *note optparse: 127. is quite flexible and powerful, it’s also
straightforward to use in most cases.  This section covers the code
patterns that are common to any *note optparse: 127.-based program.

  First, you need to import the OptionParser class; then, early in the
main program, create an OptionParser instance:

     from optparse import OptionParser
     [...]
     parser = OptionParser()

  Then you can start defining options.  The basic syntax is:

     parser.add_option(opt_str, ...,
                       attr=value, ...)

  Each option has one or more option strings, such as ‘-f’ or ‘--file’,
and several option attributes that tell *note optparse: 127. what to
expect and what to do when it encounters that option on the command
line.

  Typically, each option will have one short option string and one long
option string, e.g.:

     parser.add_option("-f", "--file", ...)

  You’re free to define as many short option strings and as many long
option strings as you like (including zero), as long as there is at
least one option string overall.

  The option strings passed to *note OptionParser.add_option(): 1241.
are effectively labels for the option defined by that call.  For
brevity, we will frequently refer to _encountering an option_ on the
command line; in reality, *note optparse: 127. encounters _option
strings_ and looks up options from them.

  Once all of your options are defined, instruct *note optparse: 127. to
parse your program’s command line:

     (options, args) = parser.parse_args()

  (If you like, you can pass a custom argument list to ‘parse_args()’,
but that’s rarely necessary: by default it uses ‘sys.argv[1:]’.)

  ‘parse_args()’ returns two values:

   * ‘options’, an object containing values for all of your options—e.g.
     if ‘--file’ takes a single string argument, then ‘options.file’
     will be the filename supplied by the user, or ‘None’ if the user
     did not supply that option

   * ‘args’, the list of positional arguments leftover after parsing
     options

  This tutorial section only covers the four most important option
attributes: *note action: 124f, *note type: 1250, *note dest: 1251.
(destination), and *note help: 1252.  Of these, *note action: 124f. is
the most fundamental.

* Menu:

* Understanding option actions:: 
* The store action:: 
* Handling boolean (flag) options: Handling boolean flag options. 
* Other actions:: 
* Default values:: 
* Generating help:: 
* Printing a version string:: 
* How optparse handles errors:: 
* Putting it all together:: 


File: python.info,  Node: Understanding option actions,  Next: The store action,  Up: Tutorial

5.15.5.6 Understanding option actions
.....................................

Actions tell *note optparse: 127. what to do when it encounters an
option on the command line.  There is a fixed set of actions hard-coded
into *note optparse: 127.; adding new actions is an advanced topic
covered in section *note Extending optparse: 1255.  Most actions tell
*note optparse: 127. to store a value in some variable—for example, take
a string from the command line and store it in an attribute of
‘options’.

  If you don’t specify an option action, *note optparse: 127. defaults
to ‘store’.


File: python.info,  Node: The store action,  Next: Handling boolean flag options,  Prev: Understanding option actions,  Up: Tutorial

5.15.5.7 The store action
.........................

The most common option action is ‘store’, which tells *note optparse:
127. to take the next argument (or the remainder of the current
argument), ensure that it is of the correct type, and store it to your
chosen destination.

  For example:

     parser.add_option("-f", "--file",
                       action="store", type="string", dest="filename")

  Now let’s make up a fake command line and ask *note optparse: 127. to
parse it:

     args = ["-f", "foo.txt"]
     (options, args) = parser.parse_args(args)

  When *note optparse: 127. sees the option string ‘-f’, it consumes the
next argument, ‘foo.txt’, and stores it in ‘options.filename’.  So,
after this call to ‘parse_args()’, ‘options.filename’ is ‘"foo.txt"’.

  Some other option types supported by *note optparse: 127. are ‘int’
and ‘float’.  Here’s an option that expects an integer argument:

     parser.add_option("-n", type="int", dest="num")

  Note that this option has no long option string, which is perfectly
acceptable.  Also, there’s no explicit action, since the default is
‘store’.

  Let’s parse another fake command-line.  This time, we’ll jam the
option argument right up against the option: since ‘-n42’ (one argument)
is equivalent to ‘-n 42’ (two arguments), the code

     (options, args) = parser.parse_args(["-n42"])
     print options.num

  will print ‘42’.

  If you don’t specify a type, *note optparse: 127. assumes ‘string’.
Combined with the fact that the default action is ‘store’, that means
our first example can be a lot shorter:

     parser.add_option("-f", "--file", dest="filename")

  If you don’t supply a destination, *note optparse: 127. figures out a
sensible default from the option strings: if the first long option
string is ‘--foo-bar’, then the default destination is ‘foo_bar’.  If
there are no long option strings, *note optparse: 127. looks at the
first short option string: the default destination for ‘-f’ is ‘f’.

  *note optparse: 127. also includes built-in ‘long’ and ‘complex’
types.  Adding types is covered in section *note Extending optparse:
1255.


File: python.info,  Node: Handling boolean flag options,  Next: Other actions,  Prev: The store action,  Up: Tutorial

5.15.5.8 Handling boolean (flag) options
........................................

Flag options—set a variable to true or false when a particular option is
seen —are quite common.  *note optparse: 127. supports them with two
separate actions, ‘store_true’ and ‘store_false’.  For example, you
might have a ‘verbose’ flag that is turned on with ‘-v’ and off with
‘-q’:

     parser.add_option("-v", action="store_true", dest="verbose")
     parser.add_option("-q", action="store_false", dest="verbose")

  Here we have two different options with the same destination, which is
perfectly OK. (It just means you have to be a bit careful when setting
default values— see below.)

  When *note optparse: 127. encounters ‘-v’ on the command line, it sets
‘options.verbose’ to ‘True’; when it encounters ‘-q’, ‘options.verbose’
is set to ‘False’.


File: python.info,  Node: Other actions,  Next: Default values,  Prev: Handling boolean flag options,  Up: Tutorial

5.15.5.9 Other actions
......................

Some other actions supported by *note optparse: 127. are:

‘"store_const"’

     store a constant value

‘"append"’

     append this option’s argument to a list

‘"count"’

     increment a counter by one

‘"callback"’

     call a specified function

  These are covered in section *note Reference Guide: 125c, Reference
Guide and section *note Option Callbacks: 125d.


File: python.info,  Node: Default values,  Next: Generating help,  Prev: Other actions,  Up: Tutorial

5.15.5.10 Default values
........................

All of the above examples involve setting some variable (the
"destination") when certain command-line options are seen.  What happens
if those options are never seen?  Since we didn’t supply any defaults,
they are all set to ‘None’.  This is usually fine, but sometimes you
want more control.  *note optparse: 127. lets you supply a default value
for each destination, which is assigned before the command line is
parsed.

  First, consider the verbose/quiet example.  If we want *note optparse:
127. to set ‘verbose’ to ‘True’ unless ‘-q’ is seen, then we can do
this:

     parser.add_option("-v", action="store_true", dest="verbose", default=True)
     parser.add_option("-q", action="store_false", dest="verbose")

  Since default values apply to the _destination_ rather than to any
particular option, and these two options happen to have the same
destination, this is exactly equivalent:

     parser.add_option("-v", action="store_true", dest="verbose")
     parser.add_option("-q", action="store_false", dest="verbose", default=True)

  Consider this:

     parser.add_option("-v", action="store_true", dest="verbose", default=False)
     parser.add_option("-q", action="store_false", dest="verbose", default=True)

  Again, the default value for ‘verbose’ will be ‘True’: the last
default value supplied for any particular destination is the one that
counts.

  A clearer way to specify default values is the ‘set_defaults()’ method
of OptionParser, which you can call at any time before calling
‘parse_args()’:

     parser.set_defaults(verbose=True)
     parser.add_option(...)
     (options, args) = parser.parse_args()

  As before, the last value specified for a given option destination is
the one that counts.  For clarity, try to use one method or the other of
setting default values, not both.


File: python.info,  Node: Generating help,  Next: Printing a version string,  Prev: Default values,  Up: Tutorial

5.15.5.11 Generating help
.........................

*note optparse: 127.’s ability to generate help and usage text
automatically is useful for creating user-friendly command-line
interfaces.  All you have to do is supply a *note help: 1252. value for
each option, and optionally a short usage message for your whole
program.  Here’s an OptionParser populated with user-friendly
(documented) options:

     usage = "usage: %prog [options] arg1 arg2"
     parser = OptionParser(usage=usage)
     parser.add_option("-v", "--verbose",
                       action="store_true", dest="verbose", default=True,
                       help="make lots of noise [default]")
     parser.add_option("-q", "--quiet",
                       action="store_false", dest="verbose",
                       help="be vewwy quiet (I'm hunting wabbits)")
     parser.add_option("-f", "--filename",
                       metavar="FILE", help="write output to FILE")
     parser.add_option("-m", "--mode",
                       default="intermediate",
                       help="interaction mode: novice, intermediate, "
                            "or expert [default: %default]")

  If *note optparse: 127. encounters either ‘-h’ or ‘--help’ on the
command-line, or if you just call ‘parser.print_help()’, it prints the
following to standard output:

     Usage: <yourscript> [options] arg1 arg2

     Options:
       -h, --help            show this help message and exit
       -v, --verbose         make lots of noise [default]
       -q, --quiet           be vewwy quiet (I'm hunting wabbits)
       -f FILE, --filename=FILE
                             write output to FILE
       -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                             expert [default: intermediate]

  (If the help output is triggered by a help option, *note optparse:
127. exits after printing the help text.)

  There’s a lot going on here to help *note optparse: 127. generate the
best possible help message:

   * the script defines its own usage message:

          usage = "usage: %prog [options] arg1 arg2"

     *note optparse: 127. expands ‘%prog’ in the usage string to the
     name of the current program, i.e.  ‘os.path.basename(sys.argv[0])’.
     The expanded string is then printed before the detailed option
     help.

     If you don’t supply a usage string, *note optparse: 127. uses a
     bland but sensible default: ‘"Usage: %prog [options]"’, which is
     fine if your script doesn’t take any positional arguments.

   * every option defines a help string, and doesn’t worry about
     line-wrapping— *note optparse: 127. takes care of wrapping lines
     and making the help output look good.

   * options that take a value indicate this fact in their
     automatically-generated help message, e.g.  for the "mode" option:

          -m MODE, --mode=MODE

     Here, "MODE" is called the meta-variable: it stands for the
     argument that the user is expected to supply to ‘-m’/‘--mode’.  By
     default, *note optparse: 127. converts the destination variable
     name to uppercase and uses that for the meta-variable.  Sometimes,
     that’s not what you want—for example, the ‘--filename’ option
     explicitly sets ‘metavar="FILE"’, resulting in this
     automatically-generated option description:

          -f FILE, --filename=FILE

     This is important for more than just saving space, though: the
     manually written help text uses the meta-variable ‘FILE’ to clue
     the user in that there’s a connection between the semi-formal
     syntax ‘-f FILE’ and the informal semantic description "write
     output to FILE". This is a simple but effective way to make your
     help text a lot clearer and more useful for end users.

  New in version 2.4: Options that have a default value can include
‘%default’ in the help string—*note optparse: 127. will replace it with
*note str(): 1ea. of the option’s default value.  If an option has no
default value (or the default value is ‘None’), ‘%default’ expands to
‘none’.

* Menu:

* Grouping Options:: 


File: python.info,  Node: Grouping Options,  Up: Generating help

5.15.5.12 Grouping Options
..........................

When dealing with many options, it is convenient to group these options
for better help output.  An *note OptionParser: 1244. can contain
several option groups, each of which can contain several options.

  An option group is obtained using the class *note OptionGroup: 1263.:

 -- Class: optparse.OptionGroup (parser, title, description=None)

     where

        * parser is the *note OptionParser: 1244. instance the group
          will be insterted in to

        * title is the group title

        * description, optional, is a long description of the group

  *note OptionGroup: 1263. inherits from ‘OptionContainer’ (like *note
OptionParser: 1244.) and so the ‘add_option()’ method can be used to add
an option to the group.

  Once all the options are declared, using the *note OptionParser: 1244.
method ‘add_option_group()’ the group is added to the previously defined
parser.

  Continuing with the parser defined in the previous section, adding an
*note OptionGroup: 1263. to a parser is easy:

     group = OptionGroup(parser, "Dangerous Options",
                         "Caution: use these options at your own risk.  "
                         "It is believed that some of them bite.")
     group.add_option("-g", action="store_true", help="Group option.")
     parser.add_option_group(group)

  This would result in the following help output:

     Usage: <yourscript> [options] arg1 arg2

     Options:
       -h, --help            show this help message and exit
       -v, --verbose         make lots of noise [default]
       -q, --quiet           be vewwy quiet (I'm hunting wabbits)
       -f FILE, --filename=FILE
                             write output to FILE
       -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                             expert [default: intermediate]

       Dangerous Options:
         Caution: use these options at your own risk.  It is believed that some
         of them bite.

         -g                  Group option.

  A bit more complete example might involve using more than one group:
still extending the previous example:

     group = OptionGroup(parser, "Dangerous Options",
                         "Caution: use these options at your own risk.  "
                         "It is believed that some of them bite.")
     group.add_option("-g", action="store_true", help="Group option.")
     parser.add_option_group(group)

     group = OptionGroup(parser, "Debug Options")
     group.add_option("-d", "--debug", action="store_true",
                      help="Print debug information")
     group.add_option("-s", "--sql", action="store_true",
                      help="Print all SQL statements executed")
     group.add_option("-e", action="store_true", help="Print every action done")
     parser.add_option_group(group)

  that results in the following output:

     Usage: <yourscript> [options] arg1 arg2

     Options:
       -h, --help            show this help message and exit
       -v, --verbose         make lots of noise [default]
       -q, --quiet           be vewwy quiet (I'm hunting wabbits)
       -f FILE, --filename=FILE
                             write output to FILE
       -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert
                             [default: intermediate]

       Dangerous Options:
         Caution: use these options at your own risk.  It is believed that some
         of them bite.

         -g                  Group option.

       Debug Options:
         -d, --debug         Print debug information
         -s, --sql           Print all SQL statements executed
         -e                  Print every action done

  Another interesting method, in particular when working
programmatically with option groups is:

 -- Method: OptionParser.get_option_group (opt_str)

     Return the *note OptionGroup: 1263. to which the short or long
     option string _opt_str_ (e.g.  ‘'-o'’ or ‘'--option'’) belongs.  If
     there’s no such *note OptionGroup: 1263, return ‘None’.


File: python.info,  Node: Printing a version string,  Next: How optparse handles errors,  Prev: Generating help,  Up: Tutorial

5.15.5.13 Printing a version string
...................................

Similar to the brief usage string, *note optparse: 127. can also print a
version string for your program.  You have to supply the string as the
‘version’ argument to OptionParser:

     parser = OptionParser(usage="%prog [-f] [-q]", version="%prog 1.0")

  ‘%prog’ is expanded just like it is in ‘usage’.  Apart from that,
‘version’ can contain anything you like.  When you supply it, *note
optparse: 127. automatically adds a ‘--version’ option to your parser.
If it encounters this option on the command line, it expands your
‘version’ string (by replacing ‘%prog’), prints it to stdout, and exits.

  For example, if your script is called ‘/usr/bin/foo’:

     $ /usr/bin/foo --version
     foo 1.0

  The following two methods can be used to print and get the ‘version’
string:

 -- Method: OptionParser.print_version (file=None)

     Print the version message for the current program (‘self.version’)
     to _file_ (default stdout).  As with *note print_usage(): 1268, any
     occurrence of ‘%prog’ in ‘self.version’ is replaced with the name
     of the current program.  Does nothing if ‘self.version’ is empty or
     undefined.

 -- Method: OptionParser.get_version ()

     Same as *note print_version(): 1267. but returns the version string
     instead of printing it.


File: python.info,  Node: How optparse handles errors,  Next: Putting it all together,  Prev: Printing a version string,  Up: Tutorial

5.15.5.14 How ‘optparse’ handles errors
.......................................

There are two broad classes of errors that *note optparse: 127. has to
worry about: programmer errors and user errors.  Programmer errors are
usually erroneous calls to *note OptionParser.add_option(): 1241, e.g.
invalid option strings, unknown option attributes, missing option
attributes, etc.  These are dealt with in the usual way: raise an
exception (either ‘optparse.OptionError’ or *note TypeError: 218.) and
let the program crash.

  Handling user errors is much more important, since they are guaranteed
to happen no matter how stable your code is.  *note optparse: 127. can
automatically detect some user errors, such as bad option arguments
(passing ‘-n 4x’ where ‘-n’ takes an integer argument), missing
arguments (‘-n’ at the end of the command line, where ‘-n’ takes an
argument of any type).  Also, you can call ‘OptionParser.error()’ to
signal an application-defined error condition:

     (options, args) = parser.parse_args()
     [...]
     if options.a and options.b:
         parser.error("options -a and -b are mutually exclusive")

  In either case, *note optparse: 127. handles the error the same way:
it prints the program’s usage message and an error message to standard
error and exits with error status 2.

  Consider the first example above, where the user passes ‘4x’ to an
option that takes an integer:

     $ /usr/bin/foo -n 4x
     Usage: foo [options]

     foo: error: option -n: invalid integer value: '4x'

  Or, where the user fails to pass a value at all:

     $ /usr/bin/foo -n
     Usage: foo [options]

     foo: error: -n option requires an argument

  *note optparse: 127.-generated error messages take care always to
mention the option involved in the error; be sure to do the same when
calling ‘OptionParser.error()’ from your application code.

  If *note optparse: 127.’s default error-handling behaviour does not
suit your needs, you’ll need to subclass OptionParser and override its
‘exit()’ and/or ‘error()’ methods.


File: python.info,  Node: Putting it all together,  Prev: How optparse handles errors,  Up: Tutorial

5.15.5.15 Putting it all together
.................................

Here’s what *note optparse: 127.-based scripts usually look like:

     from optparse import OptionParser
     [...]
     def main():
         usage = "usage: %prog [options] arg"
         parser = OptionParser(usage)
         parser.add_option("-f", "--file", dest="filename",
                           help="read data from FILENAME")
         parser.add_option("-v", "--verbose",
                           action="store_true", dest="verbose")
         parser.add_option("-q", "--quiet",
                           action="store_false", dest="verbose")
         [...]
         (options, args) = parser.parse_args()
         if len(args) != 1:
             parser.error("incorrect number of arguments")
         if options.verbose:
             print "reading %s..." % options.filename
         [...]

     if __name__ == "__main__":
         main()


File: python.info,  Node: Reference Guide,  Next: Option Callbacks,  Prev: Tutorial,  Up: optparse --- Parser for command line options

5.15.5.16 Reference Guide
.........................

* Menu:

* Creating the parser:: 
* Populating the parser:: 
* Defining options:: 
* Option attributes:: 
* Standard option actions:: 
* Standard option types:: 
* Parsing arguments: Parsing arguments<2>. 
* Querying and manipulating your option parser:: 
* Conflicts between options:: 
* Cleanup:: 
* Other methods:: 


File: python.info,  Node: Creating the parser,  Next: Populating the parser,  Up: Reference Guide

5.15.5.17 Creating the parser
.............................

The first step in using *note optparse: 127. is to create an
OptionParser instance.

 -- Class: optparse.OptionParser (...)

     The OptionParser constructor has no required arguments, but a
     number of optional keyword arguments.  You should always pass them
     as keyword arguments, i.e.  do not rely on the order in which the
     arguments are declared.

     ‘usage’ (default: ‘"%prog [options]"’)

          The usage summary to print when your program is run
          incorrectly or with a help option.  When *note optparse: 127.
          prints the usage string, it expands ‘%prog’ to
          ‘os.path.basename(sys.argv[0])’ (or to ‘prog’ if you passed
          that keyword argument).  To suppress a usage message, pass the
          special value ‘optparse.SUPPRESS_USAGE’.

     ‘option_list’ (default: ‘[]’)

          A list of Option objects to populate the parser with.  The
          options in ‘option_list’ are added after any options in
          ‘standard_option_list’ (a class attribute that may be set by
          OptionParser subclasses), but before any version or help
          options.  Deprecated; use *note add_option(): 1241. after
          creating the parser instead.

     ‘option_class’ (default: optparse.Option)

          Class to use when adding options to the parser in *note
          add_option(): 1241.

     ‘version’ (default: ‘None’)

          A version string to print when the user supplies a version
          option.  If you supply a true value for ‘version’, *note
          optparse: 127. automatically adds a version option with the
          single option string ‘--version’.  The substring ‘%prog’ is
          expanded the same as for ‘usage’.

     ‘conflict_handler’ (default: ‘"error"’)

          Specifies what to do when options with conflicting option
          strings are added to the parser; see section *note Conflicts
          between options: 1271.

     ‘description’ (default: ‘None’)

          A paragraph of text giving a brief overview of your program.
          *note optparse: 127. reformats this paragraph to fit the
          current terminal width and prints it when the user requests
          help (after ‘usage’, but before the list of options).

     ‘formatter’ (default: a new ‘IndentedHelpFormatter’)

          An instance of optparse.HelpFormatter that will be used for
          printing help text.  *note optparse: 127. provides two
          concrete classes for this purpose: IndentedHelpFormatter and
          TitledHelpFormatter.

     ‘add_help_option’ (default: ‘True’)

          If true, *note optparse: 127. will add a help option (with
          option strings ‘-h’ and ‘--help’) to the parser.

     ‘prog’

          The string to use when expanding ‘%prog’ in ‘usage’ and
          ‘version’ instead of ‘os.path.basename(sys.argv[0])’.

     ‘epilog’ (default: ‘None’)

          A paragraph of help text to print after the option help.


File: python.info,  Node: Populating the parser,  Next: Defining options,  Prev: Creating the parser,  Up: Reference Guide

5.15.5.18 Populating the parser
...............................

There are several ways to populate the parser with options.  The
preferred way is by using *note OptionParser.add_option(): 1241, as
shown in section *note Tutorial: 124d.  ‘add_option()’ can be called in
one of two ways:

   * pass it an Option instance (as returned by ‘make_option()’)

   * pass it any combination of positional and keyword arguments that
     are acceptable to ‘make_option()’ (i.e., to the Option
     constructor), and it will create the Option instance for you

  The other alternative is to pass a list of pre-constructed Option
instances to the OptionParser constructor, as in:

     option_list = [
         make_option("-f", "--filename",
                     action="store", type="string", dest="filename"),
         make_option("-q", "--quiet",
                     action="store_false", dest="verbose"),
         ]
     parser = OptionParser(option_list=option_list)

  (‘make_option()’ is a factory function for creating Option instances;
currently it is an alias for the Option constructor.  A future version
of *note optparse: 127. may split Option into several classes, and
‘make_option()’ will pick the right class to instantiate.  Do not
instantiate Option directly.)


File: python.info,  Node: Defining options,  Next: Option attributes,  Prev: Populating the parser,  Up: Reference Guide

5.15.5.19 Defining options
..........................

Each Option instance represents a set of synonymous command-line option
strings, e.g.  ‘-f’ and ‘--file’.  You can specify any number of short
or long option strings, but you must specify at least one overall option
string.

  The canonical way to create an ‘Option’ instance is with the
‘add_option()’ method of *note OptionParser: 1244.

 -- Method: OptionParser.add_option (option)

 -- Method: OptionParser.add_option (*opt_str, attr=value, ...)

     To define an option with only a short option string:

          parser.add_option("-f", attr=value, ...)

     And to define an option with only a long option string:

          parser.add_option("--foo", attr=value, ...)

     The keyword arguments define attributes of the new Option object.
     The most important option attribute is *note action: 124f, and it
     largely determines which other attributes are relevant or required.
     If you pass irrelevant option attributes, or fail to pass required
     ones, *note optparse: 127. raises an ‘OptionError’ exception
     explaining your mistake.

     An option’s _action_ determines what *note optparse: 127. does when
     it encounters this option on the command-line.  The standard option
     actions hard-coded into *note optparse: 127. are:

     ‘"store"’

          store this option’s argument (default)

     ‘"store_const"’

          store a constant value

     ‘"store_true"’

          store a true value

     ‘"store_false"’

          store a false value

     ‘"append"’

          append this option’s argument to a list

     ‘"append_const"’

          append a constant value to a list

     ‘"count"’

          increment a counter by one

     ‘"callback"’

          call a specified function

     ‘"help"’

          print a usage message including all options and the
          documentation for them

     (If you don’t supply an action, the default is ‘"store"’.  For this
     action, you may also supply *note type: 1250. and *note dest: 1251.
     option attributes; see *note Standard option actions: 1276.)

  As you can see, most actions involve storing or updating a value
somewhere.  *note optparse: 127. always creates a special object for
this, conventionally called ‘options’ (it happens to be an instance of
‘optparse.Values’).  Option arguments (and various other values) are
stored as attributes of this object, according to the *note dest: 1251.
(destination) option attribute.

  For example, when you call

     parser.parse_args()

  one of the first things *note optparse: 127. does is create the
‘options’ object:

     options = Values()

  If one of the options in this parser is defined with

     parser.add_option("-f", "--file", action="store", type="string", dest="filename")

  and the command-line being parsed includes any of the following:

     -ffoo
     -f foo
     --file=foo
     --file foo

  then *note optparse: 127, on seeing this option, will do the
equivalent of

     options.filename = "foo"

  The *note type: 1250. and *note dest: 1251. option attributes are
almost as important as *note action: 124f, but *note action: 124f. is
the only one that makes sense for _all_ options.


File: python.info,  Node: Option attributes,  Next: Standard option actions,  Prev: Defining options,  Up: Reference Guide

5.15.5.20 Option attributes
...........................

The following option attributes may be passed as keyword arguments to
*note OptionParser.add_option(): 1241.  If you pass an option attribute
that is not relevant to a particular option, or fail to pass a required
option attribute, *note optparse: 127. raises ‘OptionError’.

 -- Attribute: Option.action

     (default: ‘"store"’)

     Determines *note optparse: 127.’s behaviour when this option is
     seen on the command line; the available options are documented
     *note here: 1276.

 -- Attribute: Option.type

     (default: ‘"string"’)

     The argument type expected by this option (e.g., ‘"string"’ or
     ‘"int"’); the available option types are documented *note here:
     1279.

 -- Attribute: Option.dest

     (default: derived from option strings)

     If the option’s action implies writing or modifying a value
     somewhere, this tells *note optparse: 127. where to write it: *note
     dest: 1251. names an attribute of the ‘options’ object that *note
     optparse: 127. builds as it parses the command line.

 -- Attribute: Option.default

     The value to use for this option’s destination if the option is not
     seen on the command line.  See also *note
     OptionParser.set_defaults(): 127b.

 -- Attribute: Option.nargs

     (default: 1)

     How many arguments of type *note type: 1250. should be consumed
     when this option is seen.  If > 1, *note optparse: 127. will store
     a tuple of values to *note dest: 1251.

 -- Attribute: Option.const

     For actions that store a constant value, the constant value to
     store.

 -- Attribute: Option.choices

     For options of type ‘"choice"’, the list of strings the user may
     choose from.

 -- Attribute: Option.callback

     For options with action ‘"callback"’, the callable to call when
     this option is seen.  See section *note Option Callbacks: 125d. for
     detail on the arguments passed to the callable.

 -- Attribute: Option.callback_args
 -- Attribute: Option.callback_kwargs

     Additional positional and keyword arguments to pass to ‘callback’
     after the four standard callback arguments.

 -- Attribute: Option.help

     Help text to print for this option when listing all available
     options after the user supplies a *note help: 1252. option (such as
     ‘--help’).  If no help text is supplied, the option will be listed
     without help text.  To hide this option, use the special value
     ‘optparse.SUPPRESS_HELP’.

 -- Attribute: Option.metavar

     (default: derived from option strings)

     Stand-in for the option argument(s) to use when printing help text.
     See section *note Tutorial: 124d. for an example.


File: python.info,  Node: Standard option actions,  Next: Standard option types,  Prev: Option attributes,  Up: Reference Guide

5.15.5.21 Standard option actions
.................................

The various option actions all have slightly different requirements and
effects.  Most actions have several relevant option attributes which you
may specify to guide *note optparse: 127.’s behaviour; a few have
required attributes, which you must specify for any option using that
action.

   * ‘"store"’ [relevant: *note type: 1250, *note dest: 1251, *note
     nargs: 127c, *note choices: 127e.]

     The option must be followed by an argument, which is converted to a
     value according to *note type: 1250. and stored in *note dest:
     1251.  If *note nargs: 127c. > 1, multiple arguments will be
     consumed from the command line; all will be converted according to
     *note type: 1250. and stored to *note dest: 1251. as a tuple.  See
     the *note Standard option types: 1279. section.

     If *note choices: 127e. is supplied (a list or tuple of strings),
     the type defaults to ‘"choice"’.

     If *note type: 1250. is not supplied, it defaults to ‘"string"’.

     If *note dest: 1251. is not supplied, *note optparse: 127. derives
     a destination from the first long option string (e.g., ‘--foo-bar’
     implies ‘foo_bar’).  If there are no long option strings, *note
     optparse: 127. derives a destination from the first short option
     string (e.g., ‘-f’ implies ‘f’).

     Example:

          parser.add_option("-f")
          parser.add_option("-p", type="float", nargs=3, dest="point")

     As it parses the command line

          -f foo.txt -p 1 -3.5 4 -fbar.txt

     *note optparse: 127. will set

          options.f = "foo.txt"
          options.point = (1.0, -3.5, 4.0)
          options.f = "bar.txt"

   * ‘"store_const"’ [required: *note const: 127d.; relevant: *note
     dest: 1251.]

     The value *note const: 127d. is stored in *note dest: 1251.

     Example:

          parser.add_option("-q", "--quiet",
                            action="store_const", const=0, dest="verbose")
          parser.add_option("-v", "--verbose",
                            action="store_const", const=1, dest="verbose")
          parser.add_option("--noisy",
                            action="store_const", const=2, dest="verbose")

     If ‘--noisy’ is seen, *note optparse: 127. will set

          options.verbose = 2

   * ‘"store_true"’ [relevant: *note dest: 1251.]

     A special case of ‘"store_const"’ that stores a true value to *note
     dest: 1251.

   * ‘"store_false"’ [relevant: *note dest: 1251.]

     Like ‘"store_true"’, but stores a false value.

     Example:

          parser.add_option("--clobber", action="store_true", dest="clobber")
          parser.add_option("--no-clobber", action="store_false", dest="clobber")

   * ‘"append"’ [relevant: *note type: 1250, *note dest: 1251, *note
     nargs: 127c, *note choices: 127e.]

     The option must be followed by an argument, which is appended to
     the list in *note dest: 1251.  If no default value for *note dest:
     1251. is supplied, an empty list is automatically created when
     *note optparse: 127. first encounters this option on the
     command-line.  If *note nargs: 127c. > 1, multiple arguments are
     consumed, and a tuple of length *note nargs: 127c. is appended to
     *note dest: 1251.

     The defaults for *note type: 1250. and *note dest: 1251. are the
     same as for the ‘"store"’ action.

     Example:

          parser.add_option("-t", "--tracks", action="append", type="int")

     If ‘-t3’ is seen on the command-line, *note optparse: 127. does the
     equivalent of:

          options.tracks = []
          options.tracks.append(int("3"))

     If, a little later on, ‘--tracks=4’ is seen, it does:

          options.tracks.append(int("4"))

     The ‘append’ action calls the ‘append’ method on the current value
     of the option.  This means that any default value specified must
     have an ‘append’ method.  It also means that if the default value
     is non-empty, the default elements will be present in the parsed
     value for the option, with any values from the command line
     appended after those default values:

          >>> parser.add_option("--files", action="append", default=['~/.mypkg/defaults'])
          >>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])
          >>> opts.files
          ['~/.mypkg/defaults', 'overrides.mypkg']

   * ‘"append_const"’ [required: *note const: 127d.; relevant: *note
     dest: 1251.]

     Like ‘"store_const"’, but the value *note const: 127d. is appended
     to *note dest: 1251.; as with ‘"append"’, *note dest: 1251.
     defaults to ‘None’, and an empty list is automatically created the
     first time the option is encountered.

   * ‘"count"’ [relevant: *note dest: 1251.]

     Increment the integer stored at *note dest: 1251.  If no default
     value is supplied, *note dest: 1251. is set to zero before being
     incremented the first time.

     Example:

          parser.add_option("-v", action="count", dest="verbosity")

     The first time ‘-v’ is seen on the command line, *note optparse:
     127. does the equivalent of:

          options.verbosity = 0
          options.verbosity += 1

     Every subsequent occurrence of ‘-v’ results in

          options.verbosity += 1

   * ‘"callback"’ [required: *note callback: 127f.; relevant: *note
     type: 1250, *note nargs: 127c, *note callback_args: 1280, *note
     callback_kwargs: 1281.]

     Call the function specified by *note callback: 127f, which is
     called as

          func(option, opt_str, value, parser, *args, **kwargs)

     See section *note Option Callbacks: 125d. for more detail.

   * ‘"help"’

     Prints a complete help message for all the options in the current
     option parser.  The help message is constructed from the ‘usage’
     string passed to OptionParser’s constructor and the *note help:
     1252. string passed to every option.

     If no *note help: 1252. string is supplied for an option, it will
     still be listed in the help message.  To omit an option entirely,
     use the special value ‘optparse.SUPPRESS_HELP’.

     *note optparse: 127. automatically adds a *note help: 1252. option
     to all OptionParsers, so you do not normally need to create one.

     Example:

          from optparse import OptionParser, SUPPRESS_HELP

          # usually, a help option is added automatically, but that can
          # be suppressed using the add_help_option argument
          parser = OptionParser(add_help_option=False)

          parser.add_option("-h", "--help", action="help")
          parser.add_option("-v", action="store_true", dest="verbose",
                            help="Be moderately verbose")
          parser.add_option("--file", dest="filename",
                            help="Input file to read data from")
          parser.add_option("--secret", help=SUPPRESS_HELP)

     If *note optparse: 127. sees either ‘-h’ or ‘--help’ on the command
     line, it will print something like the following help message to
     stdout (assuming ‘sys.argv[0]’ is ‘"foo.py"’):

          Usage: foo.py [options]

          Options:
            -h, --help        Show this help message and exit
            -v                Be moderately verbose
            --file=FILENAME   Input file to read data from

     After printing the help message, *note optparse: 127. terminates
     your process with ‘sys.exit(0)’.

   * ‘"version"’

     Prints the version number supplied to the OptionParser to stdout
     and exits.  The version number is actually formatted and printed by
     the ‘print_version()’ method of OptionParser.  Generally only
     relevant if the ‘version’ argument is supplied to the OptionParser
     constructor.  As with *note help: 1252. options, you will rarely
     create ‘version’ options, since *note optparse: 127. automatically
     adds them when needed.


File: python.info,  Node: Standard option types,  Next: Parsing arguments<2>,  Prev: Standard option actions,  Up: Reference Guide

5.15.5.22 Standard option types
...............................

*note optparse: 127. has six built-in option types: ‘"string"’, ‘"int"’,
‘"long"’, ‘"choice"’, ‘"float"’ and ‘"complex"’.  If you need to add new
option types, see section *note Extending optparse: 1255.

  Arguments to string options are not checked or converted in any way:
the text on the command line is stored in the destination (or passed to
the callback) as-is.

  Integer arguments (type ‘"int"’ or ‘"long"’) are parsed as follows:

   * if the number starts with ‘0x’, it is parsed as a hexadecimal
     number

   * if the number starts with ‘0’, it is parsed as an octal number

   * if the number starts with ‘0b’, it is parsed as a binary number

   * otherwise, the number is parsed as a decimal number

  The conversion is done by calling either *note int(): 1f2. or *note
long(): 1f3. with the appropriate base (2, 8, 10, or 16).  If this
fails, so will *note optparse: 127, although with a more useful error
message.

  ‘"float"’ and ‘"complex"’ option arguments are converted directly with
*note float(): 1eb. and *note complex(): 1ec, with similar
error-handling.

  ‘"choice"’ options are a subtype of ‘"string"’ options.  The *note
choices: 127e. option attribute (a sequence of strings) defines the set
of allowed option arguments.  ‘optparse.check_choice()’ compares
user-supplied option arguments against this master list and raises
‘OptionValueError’ if an invalid string is given.


File: python.info,  Node: Parsing arguments<2>,  Next: Querying and manipulating your option parser,  Prev: Standard option types,  Up: Reference Guide

5.15.5.23 Parsing arguments
...........................

The whole point of creating and populating an OptionParser is to call
its ‘parse_args()’ method:

     (options, args) = parser.parse_args(args=None, values=None)

  where the input parameters are

‘args’

     the list of arguments to process (default: ‘sys.argv[1:]’)

‘values’

     a ‘optparse.Values’ object to store option arguments in (default: a
     new instance of ‘Values’) – if you give an existing object, the
     option defaults will not be initialized on it

  and the return values are

‘options’

     the same object that was passed in as ‘values’, or the
     optparse.Values instance created by *note optparse: 127.

‘args’

     the leftover positional arguments after all options have been
     processed

  The most common usage is to supply neither keyword argument.  If you
supply ‘values’, it will be modified with repeated *note setattr(): 87a.
calls (roughly one for every option argument stored to an option
destination) and returned by ‘parse_args()’.

  If ‘parse_args()’ encounters any errors in the argument list, it calls
the OptionParser’s ‘error()’ method with an appropriate end-user error
message.  This ultimately terminates your process with an exit status of
2 (the traditional Unix exit status for command-line errors).


File: python.info,  Node: Querying and manipulating your option parser,  Next: Conflicts between options,  Prev: Parsing arguments<2>,  Up: Reference Guide

5.15.5.24 Querying and manipulating your option parser
......................................................

The default behavior of the option parser can be customized slightly,
and you can also poke around your option parser and see what’s there.
OptionParser provides several methods to help you out:

 -- Method: OptionParser.disable_interspersed_args ()

     Set parsing to stop on the first non-option.  For example, if ‘-a’
     and ‘-b’ are both simple options that take no arguments, *note
     optparse: 127. normally accepts this syntax:

          prog -a arg1 -b arg2

     and treats it as equivalent to

          prog -a -b arg1 arg2

     To disable this feature, call *note disable_interspersed_args():
     1289.  This restores traditional Unix syntax, where option parsing
     stops with the first non-option argument.

     Use this if you have a command processor which runs another command
     which has options of its own and you want to make sure these
     options don’t get confused.  For example, each command might have a
     different set of options.

 -- Method: OptionParser.enable_interspersed_args ()

     Set parsing to not stop on the first non-option, allowing
     interspersing switches with command arguments.  This is the default
     behavior.

 -- Method: OptionParser.get_option (opt_str)

     Returns the Option instance with the option string _opt_str_, or
     ‘None’ if no options have that option string.

 -- Method: OptionParser.has_option (opt_str)

     Return true if the OptionParser has an option with option string
     _opt_str_ (e.g., ‘-q’ or ‘--verbose’).

 -- Method: OptionParser.remove_option (opt_str)

     If the *note OptionParser: 1244. has an option corresponding to
     _opt_str_, that option is removed.  If that option provided any
     other option strings, all of those option strings become invalid.
     If _opt_str_ does not occur in any option belonging to this *note
     OptionParser: 1244, raises *note ValueError: 236.


File: python.info,  Node: Conflicts between options,  Next: Cleanup,  Prev: Querying and manipulating your option parser,  Up: Reference Guide

5.15.5.25 Conflicts between options
...................................

If you’re not careful, it’s easy to define options with conflicting
option strings:

     parser.add_option("-n", "--dry-run", ...)
     [...]
     parser.add_option("-n", "--noisy", ...)

  (This is particularly true if you’ve defined your own OptionParser
subclass with some standard options.)

  Every time you add an option, *note optparse: 127. checks for
conflicts with existing options.  If it finds any, it invokes the
current conflict-handling mechanism.  You can set the conflict-handling
mechanism either in the constructor:

     parser = OptionParser(..., conflict_handler=handler)

  or with a separate call:

     parser.set_conflict_handler(handler)

  The available conflict handlers are:

     ‘"error"’ (default)

          assume option conflicts are a programming error and raise
          ‘OptionConflictError’

     ‘"resolve"’

          resolve option conflicts intelligently (see below)

  As an example, let’s define an *note OptionParser: 1244. that resolves
conflicts intelligently and add conflicting options to it:

     parser = OptionParser(conflict_handler="resolve")
     parser.add_option("-n", "--dry-run", ..., help="do no harm")
     parser.add_option("-n", "--noisy", ..., help="be noisy")

  At this point, *note optparse: 127. detects that a previously-added
option is already using the ‘-n’ option string.  Since
‘conflict_handler’ is ‘"resolve"’, it resolves the situation by removing
‘-n’ from the earlier option’s list of option strings.  Now ‘--dry-run’
is the only way for the user to activate that option.  If the user asks
for help, the help message will reflect that:

     Options:
       --dry-run     do no harm
       [...]
       -n, --noisy   be noisy

  It’s possible to whittle away the option strings for a
previously-added option until there are none left, and the user has no
way of invoking that option from the command-line.  In that case, *note
optparse: 127. removes that option completely, so it doesn’t show up in
help text or anywhere else.  Carrying on with our existing OptionParser:

     parser.add_option("--dry-run", ..., help="new dry-run option")

  At this point, the original ‘-n’/‘--dry-run’ option is no longer
accessible, so *note optparse: 127. removes it, leaving this help text:

     Options:
       [...]
       -n, --noisy   be noisy
       --dry-run     new dry-run option


File: python.info,  Node: Cleanup,  Next: Other methods,  Prev: Conflicts between options,  Up: Reference Guide

5.15.5.26 Cleanup
.................

OptionParser instances have several cyclic references.  This should not
be a problem for Python’s garbage collector, but you may wish to break
the cyclic references explicitly by calling ‘destroy()’ on your
OptionParser once you are done with it.  This is particularly useful in
long-running applications where large object graphs are reachable from
your OptionParser.


File: python.info,  Node: Other methods,  Prev: Cleanup,  Up: Reference Guide

5.15.5.27 Other methods
.......................

OptionParser supports several other public methods:

 -- Method: OptionParser.set_usage (usage)

     Set the usage string according to the rules described above for the
     ‘usage’ constructor keyword argument.  Passing ‘None’ sets the
     default usage string; use ‘optparse.SUPPRESS_USAGE’ to suppress a
     usage message.

 -- Method: OptionParser.print_usage (file=None)

     Print the usage message for the current program (‘self.usage’) to
     _file_ (default stdout).  Any occurrence of the string ‘%prog’ in
     ‘self.usage’ is replaced with the name of the current program.
     Does nothing if ‘self.usage’ is empty or not defined.

 -- Method: OptionParser.get_usage ()

     Same as *note print_usage(): 1268. but returns the usage string
     instead of printing it.

 -- Method: OptionParser.set_defaults (dest=value, ...)

     Set default values for several option destinations at once.  Using
     *note set_defaults(): 127b. is the preferred way to set default
     values for options, since multiple options can share the same
     destination.  For example, if several "mode" options all set the
     same destination, any one of them can set the default, and the last
     one wins:

          parser.add_option("--advanced", action="store_const",
                            dest="mode", const="advanced",
                            default="novice")    # overridden below
          parser.add_option("--novice", action="store_const",
                            dest="mode", const="novice",
                            default="advanced")  # overrides above setting

     To avoid this confusion, use *note set_defaults(): 127b.:

          parser.set_defaults(mode="advanced")
          parser.add_option("--advanced", action="store_const",
                            dest="mode", const="advanced")
          parser.add_option("--novice", action="store_const",
                            dest="mode", const="novice")


File: python.info,  Node: Option Callbacks,  Next: Extending optparse,  Prev: Reference Guide,  Up: optparse --- Parser for command line options

5.15.5.28 Option Callbacks
..........................

When *note optparse: 127.’s built-in actions and types aren’t quite
enough for your needs, you have two choices: extend *note optparse: 127.
or define a callback option.  Extending *note optparse: 127. is more
general, but overkill for a lot of simple cases.  Quite often a simple
callback is all you need.

  There are two steps to defining a callback option:

   * define the option itself using the ‘"callback"’ action

   * write the callback; this is a function (or method) that takes at
     least four arguments, as described below

* Menu:

* Defining a callback option:: 
* How callbacks are called:: 
* Raising errors in a callback:: 
* Callback example 1; trivial callback: Callback example 1 trivial callback. 
* Callback example 2; check option order: Callback example 2 check option order. 
* Callback example 3; check option order (generalized): Callback example 3 check option order generalized. 
* Callback example 4; check arbitrary condition: Callback example 4 check arbitrary condition. 
* Callback example 5; fixed arguments: Callback example 5 fixed arguments. 
* Callback example 6; variable arguments: Callback example 6 variable arguments. 


File: python.info,  Node: Defining a callback option,  Next: How callbacks are called,  Up: Option Callbacks

5.15.5.29 Defining a callback option
....................................

As always, the easiest way to define a callback option is by using the
*note OptionParser.add_option(): 1241. method.  Apart from *note action:
124f, the only option attribute you must specify is ‘callback’, the
function to call:

     parser.add_option("-c", action="callback", callback=my_callback)

  ‘callback’ is a function (or other callable object), so you must have
already defined ‘my_callback()’ when you create this callback option.
In this simple case, *note optparse: 127. doesn’t even know if ‘-c’
takes any arguments, which usually means that the option takes no
arguments—the mere presence of ‘-c’ on the command-line is all it needs
to know.  In some circumstances, though, you might want your callback to
consume an arbitrary number of command-line arguments.  This is where
writing callbacks gets tricky; it’s covered later in this section.

  *note optparse: 127. always passes four particular arguments to your
callback, and it will only pass additional arguments if you specify them
via *note callback_args: 1280. and *note callback_kwargs: 1281.  Thus,
the minimal callback function signature is:

     def my_callback(option, opt, value, parser):

  The four arguments to a callback are described below.

  There are several other option attributes that you can supply when you
define a callback option:

*note type: 1250.

     has its usual meaning: as with the ‘"store"’ or ‘"append"’ actions,
     it instructs *note optparse: 127. to consume one argument and
     convert it to *note type: 1250.  Rather than storing the converted
     value(s) anywhere, though, *note optparse: 127. passes it to your
     callback function.

*note nargs: 127c.

     also has its usual meaning: if it is supplied and > 1, *note
     optparse: 127. will consume *note nargs: 127c. arguments, each of
     which must be convertible to *note type: 1250.  It then passes a
     tuple of converted values to your callback.

*note callback_args: 1280.

     a tuple of extra positional arguments to pass to the callback

*note callback_kwargs: 1281.

     a dictionary of extra keyword arguments to pass to the callback


File: python.info,  Node: How callbacks are called,  Next: Raising errors in a callback,  Prev: Defining a callback option,  Up: Option Callbacks

5.15.5.30 How callbacks are called
..................................

All callbacks are called as follows:

     func(option, opt_str, value, parser, *args, **kwargs)

  where

‘option’

     is the Option instance that’s calling the callback

‘opt_str’

     is the option string seen on the command-line that’s triggering the
     callback.  (If an abbreviated long option was used, ‘opt_str’ will
     be the full, canonical option string—e.g.  if the user puts ‘--foo’
     on the command-line as an abbreviation for ‘--foobar’, then
     ‘opt_str’ will be ‘"--foobar"’.)

‘value’

     is the argument to this option seen on the command-line.  *note
     optparse: 127. will only expect an argument if *note type: 1250. is
     set; the type of ‘value’ will be the type implied by the option’s
     type.  If *note type: 1250. for this option is ‘None’ (no argument
     expected), then ‘value’ will be ‘None’.  If *note nargs: 127c. > 1,
     ‘value’ will be a tuple of values of the appropriate type.

‘parser’

     is the OptionParser instance driving the whole thing, mainly useful
     because you can access some other interesting data through its
     instance attributes:

     ‘parser.largs’

          the current list of leftover arguments, ie.  arguments that
          have been consumed but are neither options nor option
          arguments.  Feel free to modify ‘parser.largs’, e.g.  by
          adding more arguments to it.  (This list will become ‘args’,
          the second return value of ‘parse_args()’.)

     ‘parser.rargs’

          the current list of remaining arguments, ie.  with ‘opt_str’
          and ‘value’ (if applicable) removed, and only the arguments
          following them still there.  Feel free to modify
          ‘parser.rargs’, e.g.  by consuming more arguments.

     ‘parser.values’

          the object where option values are by default stored (an
          instance of optparse.OptionValues).  This lets callbacks use
          the same mechanism as the rest of *note optparse: 127. for
          storing option values; you don’t need to mess around with
          globals or closures.  You can also access or modify the
          value(s) of any options already encountered on the
          command-line.

‘args’

     is a tuple of arbitrary positional arguments supplied via the *note
     callback_args: 1280. option attribute.

‘kwargs’

     is a dictionary of arbitrary keyword arguments supplied via *note
     callback_kwargs: 1281.


File: python.info,  Node: Raising errors in a callback,  Next: Callback example 1 trivial callback,  Prev: How callbacks are called,  Up: Option Callbacks

5.15.5.31 Raising errors in a callback
......................................

The callback function should raise ‘OptionValueError’ if there are any
problems with the option or its argument(s).  *note optparse: 127.
catches this and terminates the program, printing the error message you
supply to stderr.  Your message should be clear, concise, accurate, and
mention the option at fault.  Otherwise, the user will have a hard time
figuring out what he did wrong.


File: python.info,  Node: Callback example 1 trivial callback,  Next: Callback example 2 check option order,  Prev: Raising errors in a callback,  Up: Option Callbacks

5.15.5.32 Callback example 1: trivial callback
..............................................

Here’s an example of a callback option that takes no arguments, and
simply records that the option was seen:

     def record_foo_seen(option, opt_str, value, parser):
         parser.values.saw_foo = True

     parser.add_option("--foo", action="callback", callback=record_foo_seen)

  Of course, you could do that with the ‘"store_true"’ action.


File: python.info,  Node: Callback example 2 check option order,  Next: Callback example 3 check option order generalized,  Prev: Callback example 1 trivial callback,  Up: Option Callbacks

5.15.5.33 Callback example 2: check option order
................................................

Here’s a slightly more interesting example: record the fact that ‘-a’ is
seen, but blow up if it comes after ‘-b’ in the command-line.

     def check_order(option, opt_str, value, parser):
         if parser.values.b:
             raise OptionValueError("can't use -a after -b")
         parser.values.a = 1
     [...]
     parser.add_option("-a", action="callback", callback=check_order)
     parser.add_option("-b", action="store_true", dest="b")


File: python.info,  Node: Callback example 3 check option order generalized,  Next: Callback example 4 check arbitrary condition,  Prev: Callback example 2 check option order,  Up: Option Callbacks

5.15.5.34 Callback example 3: check option order (generalized)
..............................................................

If you want to re-use this callback for several similar options (set a
flag, but blow up if ‘-b’ has already been seen), it needs a bit of
work: the error message and the flag that it sets must be generalized.

     def check_order(option, opt_str, value, parser):
         if parser.values.b:
             raise OptionValueError("can't use %s after -b" % opt_str)
         setattr(parser.values, option.dest, 1)
     [...]
     parser.add_option("-a", action="callback", callback=check_order, dest='a')
     parser.add_option("-b", action="store_true", dest="b")
     parser.add_option("-c", action="callback", callback=check_order, dest='c')


File: python.info,  Node: Callback example 4 check arbitrary condition,  Next: Callback example 5 fixed arguments,  Prev: Callback example 3 check option order generalized,  Up: Option Callbacks

5.15.5.35 Callback example 4: check arbitrary condition
.......................................................

Of course, you could put any condition in there—you’re not limited to
checking the values of already-defined options.  For example, if you
have options that should not be called when the moon is full, all you
have to do is this:

     def check_moon(option, opt_str, value, parser):
         if is_moon_full():
             raise OptionValueError("%s option invalid when moon is full"
                                    % opt_str)
         setattr(parser.values, option.dest, 1)
     [...]
     parser.add_option("--foo",
                       action="callback", callback=check_moon, dest="foo")

  (The definition of ‘is_moon_full()’ is left as an exercise for the
reader.)


File: python.info,  Node: Callback example 5 fixed arguments,  Next: Callback example 6 variable arguments,  Prev: Callback example 4 check arbitrary condition,  Up: Option Callbacks

5.15.5.36 Callback example 5: fixed arguments
.............................................

Things get slightly more interesting when you define callback options
that take a fixed number of arguments.  Specifying that a callback
option takes arguments is similar to defining a ‘"store"’ or ‘"append"’
option: if you define *note type: 1250, then the option takes one
argument that must be convertible to that type; if you further define
*note nargs: 127c, then the option takes *note nargs: 127c. arguments.

  Here’s an example that just emulates the standard ‘"store"’ action:

     def store_value(option, opt_str, value, parser):
         setattr(parser.values, option.dest, value)
     [...]
     parser.add_option("--foo",
                       action="callback", callback=store_value,
                       type="int", nargs=3, dest="foo")

  Note that *note optparse: 127. takes care of consuming 3 arguments and
converting them to integers for you; all you have to do is store them.
(Or whatever; obviously you don’t need a callback for this example.)


File: python.info,  Node: Callback example 6 variable arguments,  Prev: Callback example 5 fixed arguments,  Up: Option Callbacks

5.15.5.37 Callback example 6: variable arguments
................................................

Things get hairy when you want an option to take a variable number of
arguments.  For this case, you must write a callback, as *note optparse:
127. doesn’t provide any built-in capabilities for it.  And you have to
deal with certain intricacies of conventional Unix command-line parsing
that *note optparse: 127. normally handles for you.  In particular,
callbacks should implement the conventional rules for bare ‘--’ and ‘-’
arguments:

   * either ‘--’ or ‘-’ can be option arguments

   * bare ‘--’ (if not the argument to some option): halt command-line
     processing and discard the ‘--’

   * bare ‘-’ (if not the argument to some option): halt command-line
     processing but keep the ‘-’ (append it to ‘parser.largs’)

  If you want an option that takes a variable number of arguments, there
are several subtle, tricky issues to worry about.  The exact
implementation you choose will be based on which trade-offs you’re
willing to make for your application (which is why *note optparse: 127.
doesn’t support this sort of thing directly).

  Nevertheless, here’s a stab at a callback for an option with variable
arguments:

      def vararg_callback(option, opt_str, value, parser):
          assert value is None
          value = []

          def floatable(str):
              try:
                  float(str)
                  return True
              except ValueError:
                  return False

          for arg in parser.rargs:
              # stop on --foo like options
              if arg[:2] == "--" and len(arg) > 2:
                  break
              # stop on -a, but not on -3 or -3.0
              if arg[:1] == "-" and len(arg) > 1 and not floatable(arg):
                  break
              value.append(arg)

          del parser.rargs[:len(value)]
          setattr(parser.values, option.dest, value)

     [...]
     parser.add_option("-c", "--callback", dest="vararg_attr",
                       action="callback", callback=vararg_callback)


File: python.info,  Node: Extending optparse,  Prev: Option Callbacks,  Up: optparse --- Parser for command line options

5.15.5.38 Extending ‘optparse’
..............................

Since the two major controlling factors in how *note optparse: 127.
interprets command-line options are the action and type of each option,
the most likely direction of extension is to add new actions and new
types.

* Menu:

* Adding new types:: 
* Adding new actions:: 


File: python.info,  Node: Adding new types,  Next: Adding new actions,  Up: Extending optparse

5.15.5.39 Adding new types
..........................

To add new types, you need to define your own subclass of *note
optparse: 127.’s ‘Option’ class.  This class has a couple of attributes
that define *note optparse: 127.’s types: *note TYPES: 12ab. and *note
TYPE_CHECKER: 12ac.

 -- Attribute: Option.TYPES

     A tuple of type names; in your subclass, simply define a new tuple
     *note TYPES: 12ab. that builds on the standard one.

 -- Attribute: Option.TYPE_CHECKER

     A dictionary mapping type names to type-checking functions.  A
     type-checking function has the following signature:

          def check_mytype(option, opt, value)

     where ‘option’ is an ‘Option’ instance, ‘opt’ is an option string
     (e.g., ‘-f’), and ‘value’ is the string from the command line that
     must be checked and converted to your desired type.
     ‘check_mytype()’ should return an object of the hypothetical type
     ‘mytype’.  The value returned by a type-checking function will wind
     up in the OptionValues instance returned by
     ‘OptionParser.parse_args()’, or be passed to a callback as the
     ‘value’ parameter.

     Your type-checking function should raise ‘OptionValueError’ if it
     encounters any problems.  ‘OptionValueError’ takes a single string
     argument, which is passed as-is to *note OptionParser: 1244.’s
     ‘error()’ method, which in turn prepends the program name and the
     string ‘"error:"’ and prints everything to stderr before
     terminating the process.

  Here’s a silly example that demonstrates adding a ‘"complex"’ option
type to parse Python-style complex numbers on the command line.  (This
is even sillier than it used to be, because *note optparse: 127. 1.3
added built-in support for complex numbers, but never mind.)

  First, the necessary imports:

     from copy import copy
     from optparse import Option, OptionValueError

  You need to define your type-checker first, since it’s referred to
later (in the *note TYPE_CHECKER: 12ac. class attribute of your Option
subclass):

     def check_complex(option, opt, value):
         try:
             return complex(value)
         except ValueError:
             raise OptionValueError(
                 "option %s: invalid complex value: %r" % (opt, value))

  Finally, the Option subclass:

     class MyOption (Option):
         TYPES = Option.TYPES + ("complex",)
         TYPE_CHECKER = copy(Option.TYPE_CHECKER)
         TYPE_CHECKER["complex"] = check_complex

  (If we didn’t make a *note copy(): 71. of *note Option.TYPE_CHECKER:
12ac, we would end up modifying the *note TYPE_CHECKER: 12ac. attribute
of *note optparse: 127.’s Option class.  This being Python, nothing
stops you from doing that except good manners and common sense.)

  That’s it!  Now you can write a script that uses the new option type
just like any other *note optparse: 127.-based script, except you have
to instruct your OptionParser to use MyOption instead of Option:

     parser = OptionParser(option_class=MyOption)
     parser.add_option("-c", type="complex")

  Alternately, you can build your own option list and pass it to
OptionParser; if you don’t use ‘add_option()’ in the above way, you
don’t need to tell OptionParser which option class to use:

     option_list = [MyOption("-c", action="store", type="complex", dest="c")]
     parser = OptionParser(option_list=option_list)


File: python.info,  Node: Adding new actions,  Prev: Adding new types,  Up: Extending optparse

5.15.5.40 Adding new actions
............................

Adding new actions is a bit trickier, because you have to understand
that *note optparse: 127. has a couple of classifications for actions:

"store" actions

     actions that result in *note optparse: 127. storing a value to an
     attribute of the current OptionValues instance; these options
     require a *note dest: 1251. attribute to be supplied to the Option
     constructor.

"typed" actions

     actions that take a value from the command line and expect it to be
     of a certain type; or rather, a string that can be converted to a
     certain type.  These options require a *note type: 1250. attribute
     to the Option constructor.

  These are overlapping sets: some default "store" actions are
‘"store"’, ‘"store_const"’, ‘"append"’, and ‘"count"’, while the default
"typed" actions are ‘"store"’, ‘"append"’, and ‘"callback"’.

  When you add an action, you need to categorize it by listing it in at
least one of the following class attributes of Option (all are lists of
strings):

 -- Attribute: Option.ACTIONS

     All actions must be listed in ACTIONS.

 -- Attribute: Option.STORE_ACTIONS

     "store" actions are additionally listed here.

 -- Attribute: Option.TYPED_ACTIONS

     "typed" actions are additionally listed here.

 -- Attribute: Option.ALWAYS_TYPED_ACTIONS

     Actions that always take a type (i.e.  whose options always take a
     value) are additionally listed here.  The only effect of this is
     that *note optparse: 127. assigns the default type, ‘"string"’, to
     options with no explicit type whose action is listed in *note
     ALWAYS_TYPED_ACTIONS: 12b2.

  In order to actually implement your new action, you must override
Option’s ‘take_action()’ method and add a case that recognizes your
action.

  For example, let’s add an ‘"extend"’ action.  This is similar to the
standard ‘"append"’ action, but instead of taking a single value from
the command-line and appending it to an existing list, ‘"extend"’ will
take multiple values in a single comma-delimited string, and extend an
existing list with them.  That is, if ‘--names’ is an ‘"extend"’ option
of type ‘"string"’, the command line

     --names=foo,bar --names blah --names ding,dong

  would result in a list

     ["foo", "bar", "blah", "ding", "dong"]

  Again we define a subclass of Option:

     class MyOption(Option):

         ACTIONS = Option.ACTIONS + ("extend",)
         STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
         TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)
         ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + ("extend",)

         def take_action(self, action, dest, opt, value, values, parser):
             if action == "extend":
                 lvalue = value.split(",")
                 values.ensure_value(dest, []).extend(lvalue)
             else:
                 Option.take_action(
                     self, action, dest, opt, value, values, parser)

  Features of note:

   * ‘"extend"’ both expects a value on the command-line and stores that
     value somewhere, so it goes in both *note STORE_ACTIONS: 12b0. and
     *note TYPED_ACTIONS: 12b1.

   * to ensure that *note optparse: 127. assigns the default type of
     ‘"string"’ to ‘"extend"’ actions, we put the ‘"extend"’ action in
     *note ALWAYS_TYPED_ACTIONS: 12b2. as well.

   * ‘MyOption.take_action()’ implements just this one new action, and
     passes control back to ‘Option.take_action()’ for the standard
     *note optparse: 127. actions.

   * ‘values’ is an instance of the optparse_parser.Values class, which
     provides the very useful ‘ensure_value()’ method.  ‘ensure_value()’
     is essentially *note getattr(): 875. with a safety valve; it is
     called as

          values.ensure_value(attr, value)

     If the ‘attr’ attribute of ‘values’ doesn’t exist or is None, then
     ensure_value() first sets it to ‘value’, and then returns ’value.
     This is very handy for actions like ‘"extend"’, ‘"append"’, and
     ‘"count"’, all of which accumulate data in a variable and expect
     that variable to be of a certain type (a list for the first two, an
     integer for the latter).  Using ‘ensure_value()’ means that scripts
     using your action don’t have to worry about setting a default value
     for the option destinations in question; they can just leave the
     default as None and ‘ensure_value()’ will take care of getting it
     right when it’s needed.


File: python.info,  Node: getopt --- C-style parser for command line options,  Next: logging --- Logging facility for Python,  Prev: optparse --- Parser for command line options,  Up: Generic Operating System Services

5.15.6 ‘getopt’ — C-style parser for command line options
---------------------------------------------------------

*Source code:* Lib/getopt.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

     Note: The *note getopt: de. module is a parser for command line
     options whose API is designed to be familiar to users of the C
     ‘getopt()’ function.  Users who are unfamiliar with the C
     ‘getopt()’ function or who would like to write less code and get
     better help and error messages should consider using the *note
     argparse: d. module instead.

  This module helps scripts to parse the command line arguments in
‘sys.argv’.  It supports the same conventions as the Unix ‘getopt()’
function (including the special meanings of arguments of the form ’‘-’’
and ’‘--’’).  Long options similar to those supported by GNU software
may be used as well via an optional third argument.

  This module provides two functions and an exception:

 -- Function: getopt.getopt (args, options[, long_options])

     Parses command line options and parameter list.  _args_ is the
     argument list to be parsed, without the leading reference to the
     running program.  Typically, this means ‘sys.argv[1:]’.  _options_
     is the string of option letters that the script wants to recognize,
     with options that require an argument followed by a colon (‘':'’;
     i.e., the same format that Unix ‘getopt()’ uses).

          Note: Unlike GNU ‘getopt()’, after a non-option argument, all
          further arguments are considered also non-options.  This is
          similar to the way non-GNU Unix systems work.

     _long_options_, if specified, must be a list of strings with the
     names of the long options which should be supported.  The leading
     ‘'--'’ characters should not be included in the option name.  Long
     options which require an argument should be followed by an equal
     sign (‘'='’).  Optional arguments are not supported.  To accept
     only long options, _options_ should be an empty string.  Long
     options on the command line can be recognized so long as they
     provide a prefix of the option name that matches exactly one of the
     accepted options.  For example, if _long_options_ is ‘['foo',
     'frob']’, the option ‘--fo’ will match as ‘--foo’, but ‘--f’ will
     not match uniquely, so *note GetoptError: 12b6. will be raised.

     The return value consists of two elements: the first is a list of
     ‘(option, value)’ pairs; the second is the list of program
     arguments left after the option list was stripped (this is a
     trailing slice of _args_).  Each option-and-value pair returned has
     the option as its first element, prefixed with a hyphen for short
     options (e.g., ‘'-x'’) or two hyphens for long options (e.g.,
     ‘'--long-option'’), and the option argument as its second element,
     or an empty string if the option has no argument.  The options
     occur in the list in the same order in which they were found, thus
     allowing multiple occurrences.  Long and short options may be
     mixed.

 -- Function: getopt.gnu_getopt (args, options[, long_options])

     This function works like *note getopt(): de, except that GNU style
     scanning mode is used by default.  This means that option and
     non-option arguments may be intermixed.  The *note getopt(): de.
     function stops processing options as soon as a non-option argument
     is encountered.

     If the first character of the option string is ‘'+'’, or if the
     environment variable ‘POSIXLY_CORRECT’ is set, then option
     processing stops as soon as a non-option argument is encountered.

     New in version 2.3.

 -- Exception: getopt.GetoptError

     This is raised when an unrecognized option is found in the argument
     list or when an option requiring an argument is given none.  The
     argument to the exception is a string indicating the cause of the
     error.  For long options, an argument given to an option which does
     not require one will also cause this exception to be raised.  The
     attributes ‘msg’ and ‘opt’ give the error message and related
     option; if there is no specific option to which the exception
     relates, ‘opt’ is an empty string.

     Changed in version 1.6: Introduced *note GetoptError: 12b6. as a
     synonym for *note error: 12b8.

 -- Exception: getopt.error

     Alias for *note GetoptError: 12b6.; for backward compatibility.

  An example using only Unix style options:

     >>> import getopt
     >>> args = '-a -b -cfoo -d bar a1 a2'.split()
     >>> args
     ['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
     >>> optlist, args = getopt.getopt(args, 'abc:d:')
     >>> optlist
     [('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
     >>> args
     ['a1', 'a2']

  Using long option names is equally easy:

     >>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'
     >>> args = s.split()
     >>> args
     ['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
     >>> optlist, args = getopt.getopt(args, 'x', [
     ...     'condition=', 'output-file=', 'testing'])
     >>> optlist
     [('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]
     >>> args
     ['a1', 'a2']

  In a script, typical usage is something like this:

     import getopt, sys

     def main():
         try:
             opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
         except getopt.GetoptError as err:
             # print help information and exit:
             print str(err) # will print something like "option -a not recognized"
             usage()
             sys.exit(2)
         output = None
         verbose = False
         for o, a in opts:
             if o == "-v":
                 verbose = True
             elif o in ("-h", "--help"):
                 usage()
                 sys.exit()
             elif o in ("-o", "--output"):
                 output = a
             else:
                 assert False, "unhandled option"
         # ...

     if __name__ == "__main__":
         main()

  Note that an equivalent command line interface could be produced with
less code and more informative help and error messages by using the
*note argparse: d. module:

     import argparse

     if __name__ == '__main__':
         parser = argparse.ArgumentParser()
         parser.add_argument('-o', '--output')
         parser.add_argument('-v', dest='verbose', action='store_true')
         args = parser.parse_args()
         # ... do something with args.output ...
         # ... do something with args.verbose ..

See also
........

Module *note argparse: d.

     Alternative command line option and argument parsing library.

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/getopt.py


File: python.info,  Node: logging --- Logging facility for Python,  Next: logging config --- Logging configuration,  Prev: getopt --- C-style parser for command line options,  Up: Generic Operating System Services

5.15.7 ‘logging’ — Logging facility for Python
----------------------------------------------

Important
.........

This page contains the API reference information.  For tutorial
information and discussion of more advanced topics, see

   * *note Basic Tutorial: 12bb.

   * *note Advanced Tutorial: 12bc.

   * *note Logging Cookbook: 12bd.

  *Source code:* Lib/logging/__init__.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  New in version 2.3.

  This module defines functions and classes which implement a flexible
event logging system for applications and libraries.

  The key benefit of having the logging API provided by a standard
library module is that all Python modules can participate in logging, so
your application log can include your own messages integrated with
messages from third-party modules.

  The module provides a lot of functionality and flexibility.  If you
are unfamiliar with logging, the best way to get to grips with it is to
see the tutorials (see the links on the right).

  The basic classes defined by the module, together with their
functions, are listed below.

   * Loggers expose the interface that application code directly uses.

   * Handlers send the log records (created by loggers) to the
     appropriate destination.

   * Filters provide a finer grained facility for determining which log
     records to output.

   * Formatters specify the layout of log records in the final output.

* Menu:

* Logger Objects:: 
* Logging Levels:: 
* Handler Objects:: 
* Formatter Objects:: 
* Filter Objects:: 
* LogRecord Objects:: 
* LogRecord attributes:: 
* LoggerAdapter Objects:: 
* Thread Safety:: 
* Module-Level Functions:: 
* Integration with the warnings module:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/logging/__init__.py


File: python.info,  Node: Logger Objects,  Next: Logging Levels,  Up: logging --- Logging facility for Python

5.15.7.1 Logger Objects
.......................

Loggers have the following attributes and methods.  Note that Loggers
are never instantiated directly, but always through the module-level
function ‘logging.getLogger(name)’.  Multiple calls to *note
getLogger(): 12c0. with the same name will always return a reference to
the same Logger object.

  The ‘name’ is potentially a period-separated hierarchical value, like
‘foo.bar.baz’ (though it could also be just plain ‘foo’, for example).
Loggers that are further down in the hierarchical list are children of
loggers higher up in the list.  For example, given a logger with a name
of ‘foo’, loggers with names of ‘foo.bar’, ‘foo.bar.baz’, and ‘foo.bam’
are all descendants of ‘foo’.  The logger name hierarchy is analogous to
the Python package hierarchy, and identical to it if you organise your
loggers on a per-module basis using the recommended construction
‘logging.getLogger(__name__)’.  That’s because in a module, ‘__name__’
is the module’s name in the Python package namespace.

 -- Class: logging.Logger

 -- Attribute: Logger.propagate

     If this evaluates to true, events logged to this logger will be
     passed to the handlers of higher level (ancestor) loggers, in
     addition to any handlers attached to this logger.  Messages are
     passed directly to the ancestor loggers’ handlers - neither the
     level nor filters of the ancestor loggers in question are
     considered.

     If this evaluates to false, logging messages are not passed to the
     handlers of ancestor loggers.

     The constructor sets this attribute to ‘True’.

          Note: If you attach a handler to a logger _and_ one or more of
          its ancestors, it may emit the same record multiple times.  In
          general, you should not need to attach a handler to more than
          one logger - if you just attach it to the appropriate logger
          which is highest in the logger hierarchy, then it will see all
          events logged by all descendant loggers, provided that their
          propagate setting is left set to ‘True’.  A common scenario is
          to attach handlers only to the root logger, and to let
          propagation take care of the rest.

 -- Method: Logger.setLevel (lvl)

     Sets the threshold for this logger to _lvl_.  Logging messages
     which are less severe than _lvl_ will be ignored.  When a logger is
     created, the level is set to ‘NOTSET’ (which causes all messages to
     be processed when the logger is the root logger, or delegation to
     the parent when the logger is a non-root logger).  Note that the
     root logger is created with level ‘WARNING’.

     The term ’delegation to the parent’ means that if a logger has a
     level of NOTSET, its chain of ancestor loggers is traversed until
     either an ancestor with a level other than NOTSET is found, or the
     root is reached.

     If an ancestor is found with a level other than NOTSET, then that
     ancestor’s level is treated as the effective level of the logger
     where the ancestor search began, and is used to determine how a
     logging event is handled.

     If the root is reached, and it has a level of NOTSET, then all
     messages will be processed.  Otherwise, the root’s level will be
     used as the effective level.

     See *note Logging Levels: 12c3. for a list of levels.

 -- Method: Logger.isEnabledFor (lvl)

     Indicates if a message of severity _lvl_ would be processed by this
     logger.  This method checks first the module-level level set by
     ‘logging.disable(lvl)’ and then the logger’s effective level as
     determined by *note getEffectiveLevel(): 12c5.

 -- Method: Logger.getEffectiveLevel ()

     Indicates the effective level for this logger.  If a value other
     than ‘NOTSET’ has been set using *note setLevel(): 12c2, it is
     returned.  Otherwise, the hierarchy is traversed towards the root
     until a value other than ‘NOTSET’ is found, and that value is
     returned.

 -- Method: Logger.getChild (suffix)

     Returns a logger which is a descendant to this logger, as
     determined by the suffix.  Thus,
     ‘logging.getLogger('abc').getChild('def.ghi')’ would return the
     same logger as would be returned by
     ‘logging.getLogger('abc.def.ghi')’.  This is a convenience method,
     useful when the parent logger is named using e.g.  ‘__name__’
     rather than a literal string.

     New in version 2.7.

 -- Method: Logger.debug (msg, *args, **kwargs)

     Logs a message with level ‘DEBUG’ on this logger.  The _msg_ is the
     message format string, and the _args_ are the arguments which are
     merged into _msg_ using the string formatting operator.  (Note that
     this means that you can use keywords in the format string, together
     with a single dictionary argument.)

     There are two keyword arguments in _kwargs_ which are inspected:
     _exc_info_ which, if it does not evaluate as false, causes
     exception information to be added to the logging message.  If an
     exception tuple (in the format returned by *note sys.exc_info():
     2f3.) is provided, it is used; otherwise, *note sys.exc_info():
     2f3. is called to get the exception information.

     The second keyword argument is _extra_ which can be used to pass a
     dictionary which is used to populate the __dict__ of the LogRecord
     created for the logging event with user-defined attributes.  These
     custom attributes can then be used as you like.  For example, they
     could be incorporated into logged messages.  For example:

          FORMAT = '%(asctime)-15s %(clientip)s %(user)-8s %(message)s'
          logging.basicConfig(format=FORMAT)
          d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
          logger = logging.getLogger('tcpserver')
          logger.warning('Protocol problem: %s', 'connection reset', extra=d)

     would print something like

          2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     The keys in the dictionary passed in _extra_ should not clash with
     the keys used by the logging system.  (See the *note Formatter:
     12c7. documentation for more information on which keys are used by
     the logging system.)

     If you choose to use these attributes in logged messages, you need
     to exercise some care.  In the above example, for instance, the
     *note Formatter: 12c7. has been set up with a format string which
     expects ’clientip’ and ’user’ in the attribute dictionary of the
     LogRecord.  If these are missing, the message will not be logged
     because a string formatting exception will occur.  So in this case,
     you always need to pass the _extra_ dictionary with these keys.

     While this might be annoying, this feature is intended for use in
     specialized circumstances, such as multi-threaded servers where the
     same code executes in many contexts, and interesting conditions
     which arise are dependent on this context (such as remote client IP
     address and authenticated user name, in the above example).  In
     such circumstances, it is likely that specialized *note Formatter:
     12c7.s would be used with particular ‘Handler’s.

 -- Method: Logger.info (msg, *args, **kwargs)

     Logs a message with level ‘INFO’ on this logger.  The arguments are
     interpreted as for *note debug(): 12c9.

 -- Method: Logger.warning (msg, *args, **kwargs)

     Logs a message with level ‘WARNING’ on this logger.  The arguments
     are interpreted as for *note debug(): 12c9.

 -- Method: Logger.error (msg, *args, **kwargs)

     Logs a message with level ‘ERROR’ on this logger.  The arguments
     are interpreted as for *note debug(): 12c9.

 -- Method: Logger.critical (msg, *args, **kwargs)

     Logs a message with level ‘CRITICAL’ on this logger.  The arguments
     are interpreted as for *note debug(): 12c9.

 -- Method: Logger.log (lvl, msg, *args, **kwargs)

     Logs a message with integer level _lvl_ on this logger.  The other
     arguments are interpreted as for *note debug(): 12c9.

 -- Method: Logger.exception (msg, *args, **kwargs)

     Logs a message with level ‘ERROR’ on this logger.  The arguments
     are interpreted as for *note debug(): 12c9.  Exception info is
     added to the logging message.  This method should only be called
     from an exception handler.

 -- Method: Logger.addFilter (filt)

     Adds the specified filter _filt_ to this logger.

 -- Method: Logger.removeFilter (filt)

     Removes the specified filter _filt_ from this logger.

 -- Method: Logger.filter (record)

     Applies this logger’s filters to the record and returns a true
     value if the record is to be processed.  The filters are consulted
     in turn, until one of them returns a false value.  If none of them
     return a false value, the record will be processed (passed to
     handlers).  If one returns a false value, no further processing of
     the record occurs.

 -- Method: Logger.addHandler (hdlr)

     Adds the specified handler _hdlr_ to this logger.

 -- Method: Logger.removeHandler (hdlr)

     Removes the specified handler _hdlr_ from this logger.

 -- Method: Logger.findCaller ()

     Finds the caller’s source filename and line number.  Returns the
     filename, line number and function name as a 3-element tuple.

     Changed in version 2.4: The function name was added.  In earlier
     versions, the filename and line number were returned as a 2-element
     tuple.

 -- Method: Logger.handle (record)

     Handles a record by passing it to all handlers associated with this
     logger and its ancestors (until a false value of _propagate_ is
     found).  This method is used for unpickled records received from a
     socket, as well as those created locally.  Logger-level filtering
     is applied using *note filter(): 12d1.

 -- Method: Logger.makeRecord (name, lvl, fn, lno, msg, args, exc_info,
          func=None, extra=None)

     This is a factory method which can be overridden in subclasses to
     create specialized *note LogRecord: 12d7. instances.

     Changed in version 2.5: _func_ and _extra_ were added.


File: python.info,  Node: Logging Levels,  Next: Handler Objects,  Prev: Logger Objects,  Up: logging --- Logging facility for Python

5.15.7.2 Logging Levels
.......................

The numeric values of logging levels are given in the following table.
These are primarily of interest if you want to define your own levels,
and need them to have specific values relative to the predefined levels.
If you define a level with the same numeric value, it overwrites the
predefined value; the predefined name is lost.

Level              Numeric value
                   
---------------------------------------
                   
‘CRITICAL’         50
                   
                   
‘ERROR’            40
                   
                   
‘WARNING’          30
                   
                   
‘INFO’             20
                   
                   
‘DEBUG’            10
                   
                   
‘NOTSET’           0
                   


File: python.info,  Node: Handler Objects,  Next: Formatter Objects,  Prev: Logging Levels,  Up: logging --- Logging facility for Python

5.15.7.3 Handler Objects
........................

Handlers have the following attributes and methods.  Note that ‘Handler’
is never instantiated directly; this class acts as a base for more
useful subclasses.  However, the *note __init__(): 37c. method in
subclasses needs to call *note Handler.__init__(): 12db.

 -- Method: Handler.__init__ (level=NOTSET)

     Initializes the ‘Handler’ instance by setting its level, setting
     the list of filters to the empty list and creating a lock (using
     *note createLock(): 12dc.) for serializing access to an I/O
     mechanism.

 -- Method: Handler.createLock ()

     Initializes a thread lock which can be used to serialize access to
     underlying I/O functionality which may not be threadsafe.

 -- Method: Handler.acquire ()

     Acquires the thread lock created with *note createLock(): 12dc.

 -- Method: Handler.release ()

     Releases the thread lock acquired with *note acquire(): 12dd.

 -- Method: Handler.setLevel (lvl)

     Sets the threshold for this handler to _lvl_.  Logging messages
     which are less severe than _lvl_ will be ignored.  When a handler
     is created, the level is set to ‘NOTSET’ (which causes all messages
     to be processed).

     See *note Logging Levels: 12c3. for a list of levels.

 -- Method: Handler.setFormatter (form)

     Sets the *note Formatter: 12c7. for this handler to _form_.

 -- Method: Handler.addFilter (filt)

     Adds the specified filter _filt_ to this handler.

 -- Method: Handler.removeFilter (filt)

     Removes the specified filter _filt_ from this handler.

 -- Method: Handler.filter (record)

     Applies this handler’s filters to the record and returns a true
     value if the record is to be processed.  The filters are consulted
     in turn, until one of them returns a false value.  If none of them
     return a false value, the record will be emitted.  If one returns a
     false value, the handler will not emit the record.

 -- Method: Handler.flush ()

     Ensure all logging output has been flushed.  This version does
     nothing and is intended to be implemented by subclasses.

 -- Method: Handler.close ()

     Tidy up any resources used by the handler.  This version does no
     output but removes the handler from an internal list of handlers
     which is closed when *note shutdown(): 12e6. is called.  Subclasses
     should ensure that this gets called from overridden *note close():
     12e5. methods.

 -- Method: Handler.handle (record)

     Conditionally emits the specified logging record, depending on
     filters which may have been added to the handler.  Wraps the actual
     emission of the record with acquisition/release of the I/O thread
     lock.

 -- Method: Handler.handleError (record)

     This method should be called from handlers when an exception is
     encountered during an *note emit(): 12e9. call.  If the
     module-level attribute ‘raiseExceptions’ is ‘False’, exceptions get
     silently ignored.  This is what is mostly wanted for a logging
     system - most users will not care about errors in the logging
     system, they are more interested in application errors.  You could,
     however, replace this with a custom handler if you wish.  The
     specified record is the one which was being processed when the
     exception occurred.  (The default value of ‘raiseExceptions’ is
     ‘True’, as that is more useful during development).

 -- Method: Handler.format (record)

     Do formatting for a record - if a formatter is set, use it.
     Otherwise, use the default formatter for the module.

 -- Method: Handler.emit (record)

     Do whatever it takes to actually log the specified logging record.
     This version is intended to be implemented by subclasses and so
     raises a *note NotImplementedError: 94e.

  For a list of handlers included as standard, see *note
logging.handlers: 103.


File: python.info,  Node: Formatter Objects,  Next: Filter Objects,  Prev: Handler Objects,  Up: logging --- Logging facility for Python

5.15.7.4 Formatter Objects
..........................

*note Formatter: 12c7. objects have the following attributes and
methods.  They are responsible for converting a *note LogRecord: 12d7.
to (usually) a string which can be interpreted by either a human or an
external system.  The base *note Formatter: 12c7. allows a formatting
string to be specified.  If none is supplied, the default value of
‘'%(message)s'’ is used.

  A Formatter can be initialized with a format string which makes use of
knowledge of the *note LogRecord: 12d7. attributes - such as the default
value mentioned above making use of the fact that the user’s message and
arguments are pre-formatted into a *note LogRecord: 12d7.’s _message_
attribute.  This format string contains standard Python %-style mapping
keys.  See section *note String Formatting Operations: 524. for more
information on string formatting.

  The useful mapping keys in a *note LogRecord: 12d7. are given in the
section on *note LogRecord attributes: 12ed.

 -- Class: logging.Formatter (fmt=None, datefmt=None)

     Returns a new instance of the *note Formatter: 12c7. class.  The
     instance is initialized with a format string for the message as a
     whole, as well as a format string for the date/time portion of a
     message.  If no _fmt_ is specified, ‘'%(message)s'’ is used.  If no
     _datefmt_ is specified, the ISO8601 date format is used.

      -- Method: format (record)

          The record’s attribute dictionary is used as the operand to a
          string formatting operation.  Returns the resulting string.
          Before formatting the dictionary, a couple of preparatory
          steps are carried out.  The _message_ attribute of the record
          is computed using _msg_ % _args_.  If the formatting string
          contains ‘'(asctime)'’, *note formatTime(): 12ef. is called to
          format the event time.  If there is exception information, it
          is formatted using *note formatException(): 12f0. and appended
          to the message.  Note that the formatted exception information
          is cached in attribute _exc_text_.  This is useful because the
          exception information can be pickled and sent across the wire,
          but you should be careful if you have more than one *note
          Formatter: 12c7. subclass which customizes the formatting of
          exception information.  In this case, you will have to clear
          the cached value after a formatter has done its formatting, so
          that the next formatter to handle the event doesn’t use the
          cached value but recalculates it afresh.

      -- Method: formatTime (record, datefmt=None)

          This method should be called from *note format(): 1ef. by a
          formatter which wants to make use of a formatted time.  This
          method can be overridden in formatters to provide for any
          specific requirement, but the basic behavior is as follows: if
          _datefmt_ (a string) is specified, it is used with *note
          time.strftime(): 3be. to format the creation time of the
          record.  Otherwise, the ISO8601 format is used.  The resulting
          string is returned.

          This function uses a user-configurable function to convert the
          creation time to a tuple.  By default, *note time.localtime():
          ae1. is used; to change this for a particular formatter
          instance, set the ‘converter’ attribute to a function with the
          same signature as *note time.localtime(): ae1. or *note
          time.gmtime(): b54.  To change it for all formatters, for
          example if you want all logging times to be shown in GMT, set
          the ‘converter’ attribute in the ‘Formatter’ class.

      -- Method: formatException (exc_info)

          Formats the specified exception information (a standard
          exception tuple as returned by *note sys.exc_info(): 2f3.) as
          a string.  This default implementation just uses *note
          traceback.print_exception(): 12f1.  The resulting string is
          returned.


File: python.info,  Node: Filter Objects,  Next: LogRecord Objects,  Prev: Formatter Objects,  Up: logging --- Logging facility for Python

5.15.7.5 Filter Objects
.......................

‘Filters’ can be used by ‘Handlers’ and ‘Loggers’ for more sophisticated
filtering than is provided by levels.  The base filter class only allows
events which are below a certain point in the logger hierarchy.  For
example, a filter initialized with ’A.B’ will allow events logged by
loggers ’A.B’, ’A.B.C’, ’A.B.C.D’, ’A.B.D’ etc.  but not ’A.BB’, ’B.A.B’
etc.  If initialized with the empty string, all events are passed.

 -- Class: logging.Filter (name='')

     Returns an instance of the *note Filter: 12f4. class.  If _name_ is
     specified, it names a logger which, together with its children,
     will have its events allowed through the filter.  If _name_ is the
     empty string, allows every event.

      -- Method: filter (record)

          Is the specified record to be logged?  Returns zero for no,
          nonzero for yes.  If deemed appropriate, the record may be
          modified in-place by this method.

  Note that filters attached to handlers are consulted before an event
is emitted by the handler, whereas filters attached to loggers are
consulted whenever an event is logged (using *note debug(): 12c9, *note
info(): 12f6, etc.), before sending an event to handlers.  This means
that events which have been generated by descendant loggers will not be
filtered by a logger’s filter setting, unless the filter has also been
applied to those descendant loggers.

  You don’t actually need to subclass ‘Filter’: you can pass any
instance which has a ‘filter’ method with the same semantics.

  Although filters are used primarily to filter records based on more
sophisticated criteria than levels, they get to see every record which
is processed by the handler or logger they’re attached to: this can be
useful if you want to do things like counting how many records were
processed by a particular logger or handler, or adding, changing or
removing attributes in the LogRecord being processed.  Obviously
changing the LogRecord needs to be done with some care, but it does
allow the injection of contextual information into logs (see *note Using
Filters to impart contextual information: 12f7.).


File: python.info,  Node: LogRecord Objects,  Next: LogRecord attributes,  Prev: Filter Objects,  Up: logging --- Logging facility for Python

5.15.7.6 LogRecord Objects
..........................

*note LogRecord: 12d7. instances are created automatically by the *note
Logger: 1dd. every time something is logged, and can be created manually
via *note makeLogRecord(): 12fa. (for example, from a pickled event
received over the wire).

 -- Class: logging.LogRecord (name, level, pathname, lineno, msg, args,
          exc_info, func=None)

     Contains all the information pertinent to the event being logged.

     The primary information is passed in ‘msg’ and ‘args’, which are
     combined using ‘msg % args’ to create the ‘message’ field of the
     record.

          Parameters:

             * *name* – The name of the logger used to log the event
               represented by this LogRecord.  Note that this name will
               always have this value, even though it may be emitted by
               a handler attached to a different (ancestor) logger.

             * *level* – The numeric level of the logging event (one of
               DEBUG, INFO etc.)  Note that this is converted to _two_
               attributes of the LogRecord: ‘levelno’ for the numeric
               value and ‘levelname’ for the corresponding level name.

             * *pathname* – The full pathname of the source file where
               the logging call was made.

             * *lineno* – The line number in the source file where the
               logging call was made.

             * *msg* – The event description message, possibly a format
               string with placeholders for variable data.

             * *args* – Variable data to merge into the _msg_ argument
               to obtain the event description.

             * *exc_info* – An exception tuple with the current
               exception information, or _None_ if no exception
               information is available.

             * *func* – The name of the function or method from which
               the logging call was invoked.

     Changed in version 2.5: _func_ was added.

      -- Method: getMessage ()

          Returns the message for this *note LogRecord: 12d7. instance
          after merging any user-supplied arguments with the message.
          If the user-supplied message argument to the logging call is
          not a string, *note str(): 1ea. is called on it to convert it
          to a string.  This allows use of user-defined classes as
          messages, whose ‘__str__’ method can return the actual format
          string to be used.


File: python.info,  Node: LogRecord attributes,  Next: LoggerAdapter Objects,  Prev: LogRecord Objects,  Up: logging --- Logging facility for Python

5.15.7.7 LogRecord attributes
.............................

The LogRecord has a number of attributes, most of which are derived from
the parameters to the constructor.  (Note that the names do not always
correspond exactly between the LogRecord constructor parameters and the
LogRecord attributes.)  These attributes can be used to merge data from
the record into the format string.  The following table lists (in
alphabetical order) the attribute names, their meanings and the
corresponding placeholder in a %-style format string.

Attribute name       Format                        Description
                                                   
-------------------------------------------------------------------------------------------------------
                                                   
args                 You shouldn’t need to         The tuple of arguments merged into ‘msg’ to
                     format this yourself.         produce ‘message’.
                                                   
                                                   
asctime              ‘%(asctime)s’                 Human-readable time when the *note LogRecord:
                                                   12d7. was created.  By default this is of the
                                                   form ’2003-07-08 16:49:45,896’ (the numbers after
                                                   the comma are millisecond portion of the time).
                                                   
                                                   
created              ‘%(created)f’                 Time when the *note LogRecord: 12d7. was created
                                                   (as returned by *note time.time(): 461.).
                                                   
                                                   
exc_info             You shouldn’t need to         Exception tuple (à la ‘sys.exc_info’) or, if no
                     format this yourself.         exception has occurred, _None_.
                                                   
                                                   
filename             ‘%(filename)s’                Filename portion of ‘pathname’.
                                                   
                                                   
funcName             ‘%(funcName)s’                Name of function containing the logging call.
                                                   
                                                   
levelname            ‘%(levelname)s’               Text logging level for the message (‘'DEBUG'’,
                                                   ‘'INFO'’, ‘'WARNING'’, ‘'ERROR'’, ‘'CRITICAL'’).
                                                   
                                                   
levelno              ‘%(levelno)s’                 Numeric logging level for the message (‘DEBUG’,
                                                   ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).
                                                   
                                                   
lineno               ‘%(lineno)d’                  Source line number where the logging call was
                                                   issued (if available).
                                                   
                                                   
module               ‘%(module)s’                  Module (name portion of ‘filename’).
                                                   
                                                   
msecs                ‘%(msecs)d’                   Millisecond portion of the time when the *note
                                                   LogRecord: 12d7. was created.
                                                   
                                                   
message              ‘%(message)s’                 The logged message, computed as ‘msg % args’.
                                                   This is set when *note Formatter.format(): 12ee.
                                                   is invoked.
                                                   
                                                   
msg                  You shouldn’t need to         The format string passed in the original logging
                     format this yourself.         call.  Merged with ‘args’ to produce ‘message’,
                                                   or an arbitrary object (see *note Using arbitrary
                                                   objects as messages: 12fd.).
                                                   
                                                   
name                 ‘%(name)s’                    Name of the logger used to log the call.
                                                   
                                                   
pathname             ‘%(pathname)s’                Full pathname of the source file where the
                                                   logging call was issued (if available).
                                                   
                                                   
process              ‘%(process)d’                 Process ID (if available).
                                                   
                                                   
processName          ‘%(processName)s’             Process name (if available).
                                                   
                                                   
relativeCreated      ‘%(relativeCreated)d’         Time in milliseconds when the LogRecord was
                                                   created, relative to the time the logging module
                                                   was loaded.
                                                   
                                                   
thread               ‘%(thread)d’                  Thread ID (if available).
                                                   
                                                   
threadName           ‘%(threadName)s’              Thread name (if available).
                                                   

  Changed in version 2.5: _funcName_ was added.

  Changed in version 2.6: _processName_ was added.


File: python.info,  Node: LoggerAdapter Objects,  Next: Thread Safety,  Prev: LogRecord attributes,  Up: logging --- Logging facility for Python

5.15.7.8 LoggerAdapter Objects
..............................

*note LoggerAdapter: 1df. instances are used to conveniently pass
contextual information into logging calls.  For a usage example, see the
section on *note adding contextual information to your logging output:
1300.

  New in version 2.6.

 -- Class: logging.LoggerAdapter (logger, extra)

     Returns an instance of *note LoggerAdapter: 1df. initialized with
     an underlying *note Logger: 1dd. instance and a dict-like object.

      -- Method: process (msg, kwargs)

          Modifies the message and/or keyword arguments passed to a
          logging call in order to insert contextual information.  This
          implementation takes the object passed as _extra_ to the
          constructor and adds it to _kwargs_ using key ’extra’.  The
          return value is a (_msg_, _kwargs_) tuple which has the
          (possibly modified) versions of the arguments passed in.

  In addition to the above, *note LoggerAdapter: 1df. supports the
following methods of *note Logger: 1dd.: *note debug(): 12c6, *note
info(): 12c8, *note warning(): 12ca, *note error(): 12cb, *note
exception(): 12ce, *note critical(): 12cc, *note log(): 12cd. and *note
isEnabledFor(): 12c4.  These methods have the same signatures as their
counterparts in *note Logger: 1dd, so you can use the two types of
instances interchangeably for these calls.

  Changed in version 2.7: The *note isEnabledFor(): 12c4. method was
added to *note LoggerAdapter: 1df.  This method delegates to the
underlying logger.


File: python.info,  Node: Thread Safety,  Next: Module-Level Functions,  Prev: LoggerAdapter Objects,  Up: logging --- Logging facility for Python

5.15.7.9 Thread Safety
......................

The logging module is intended to be thread-safe without any special
work needing to be done by its clients.  It achieves this though using
threading locks; there is one lock to serialize access to the module’s
shared data, and each handler also creates a lock to serialize access to
its underlying I/O.

  If you are implementing asynchronous signal handlers using the *note
signal: 155. module, you may not be able to use logging from within such
handlers.  This is because lock implementations in the *note threading:
179. module are not always re-entrant, and so cannot be invoked from
such signal handlers.


File: python.info,  Node: Module-Level Functions,  Next: Integration with the warnings module,  Prev: Thread Safety,  Up: logging --- Logging facility for Python

5.15.7.10 Module-Level Functions
................................

In addition to the classes described above, there are a number of
module- level functions.

 -- Function: logging.getLogger ([name])

     Return a logger with the specified name or, if no name is
     specified, return a logger which is the root logger of the
     hierarchy.  If specified, the name is typically a dot-separated
     hierarchical name like _"a"_, _"a.b"_ or _"a.b.c.d"_.  Choice of
     these names is entirely up to the developer who is using logging.

     All calls to this function with a given name return the same logger
     instance.  This means that logger instances never need to be passed
     between different parts of an application.

 -- Function: logging.getLoggerClass ()

     Return either the standard *note Logger: 1dd. class, or the last
     class passed to *note setLoggerClass(): 1305.  This function may be
     called from within a new class definition, to ensure that
     installing a customized *note Logger: 1dd. class will not undo
     customizations already applied by other code.  For example:

          class MyLogger(logging.getLoggerClass()):
              # ... override behaviour here

 -- Function: logging.debug (msg[, *args[, **kwargs]])

     Logs a message with level ‘DEBUG’ on the root logger.  The _msg_ is
     the message format string, and the _args_ are the arguments which
     are merged into _msg_ using the string formatting operator.  (Note
     that this means that you can use keywords in the format string,
     together with a single dictionary argument.)

     There are two keyword arguments in _kwargs_ which are inspected:
     _exc_info_ which, if it does not evaluate as false, causes
     exception information to be added to the logging message.  If an
     exception tuple (in the format returned by *note sys.exc_info():
     2f3.) is provided, it is used; otherwise, *note sys.exc_info():
     2f3. is called to get the exception information.

     The other optional keyword argument is _extra_ which can be used to
     pass a dictionary which is used to populate the __dict__ of the
     LogRecord created for the logging event with user-defined
     attributes.  These custom attributes can then be used as you like.
     For example, they could be incorporated into logged messages.  For
     example:

          FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
          logging.basicConfig(format=FORMAT)
          d = {'clientip': '192.168.0.1', 'user': 'fbloggs'}
          logging.warning("Protocol problem: %s", "connection reset", extra=d)

     would print something like:

          2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     The keys in the dictionary passed in _extra_ should not clash with
     the keys used by the logging system.  (See the *note Formatter:
     12c7. documentation for more information on which keys are used by
     the logging system.)

     If you choose to use these attributes in logged messages, you need
     to exercise some care.  In the above example, for instance, the
     *note Formatter: 12c7. has been set up with a format string which
     expects ’clientip’ and ’user’ in the attribute dictionary of the
     LogRecord.  If these are missing, the message will not be logged
     because a string formatting exception will occur.  So in this case,
     you always need to pass the _extra_ dictionary with these keys.

     While this might be annoying, this feature is intended for use in
     specialized circumstances, such as multi-threaded servers where the
     same code executes in many contexts, and interesting conditions
     which arise are dependent on this context (such as remote client IP
     address and authenticated user name, in the above example).  In
     such circumstances, it is likely that specialized *note Formatter:
     12c7.s would be used with particular ‘Handler’s.

     Changed in version 2.5: _extra_ was added.

 -- Function: logging.info (msg[, *args[, **kwargs]])

     Logs a message with level ‘INFO’ on the root logger.  The arguments
     are interpreted as for *note debug(): 12c9.

 -- Function: logging.warning (msg[, *args[, **kwargs]])

     Logs a message with level ‘WARNING’ on the root logger.  The
     arguments are interpreted as for *note debug(): 12c9.

 -- Function: logging.error (msg[, *args[, **kwargs]])

     Logs a message with level ‘ERROR’ on the root logger.  The
     arguments are interpreted as for *note debug(): 12c9.

 -- Function: logging.critical (msg[, *args[, **kwargs]])

     Logs a message with level ‘CRITICAL’ on the root logger.  The
     arguments are interpreted as for *note debug(): 12c9.

 -- Function: logging.exception (msg[, *args[, **kwargs]])

     Logs a message with level ‘ERROR’ on the root logger.  The
     arguments are interpreted as for *note debug(): 12c9.  Exception
     info is added to the logging message.  This function should only be
     called from an exception handler.

 -- Function: logging.log (level, msg[, *args[, **kwargs]])

     Logs a message with level _level_ on the root logger.  The other
     arguments are interpreted as for *note debug(): 12c9.

          Note: The above module-level convenience functions, which
          delegate to the root logger, call *note basicConfig(): 130b.
          to ensure that at least one handler is available.  Because of
          this, they should _not_ be used in threads, in versions of
          Python earlier than 2.7.1 and 3.2, unless at least one handler
          has been added to the root logger _before_ the threads are
          started.  In earlier versions of Python, due to a thread
          safety shortcoming in *note basicConfig(): 130b, this can
          (under rare circumstances) lead to handlers being added
          multiple times to the root logger, which can in turn lead to
          multiple messages for the same event.

 -- Function: logging.disable (lvl)

     Provides an overriding level _lvl_ for all loggers which takes
     precedence over the logger’s own level.  When the need arises to
     temporarily throttle logging output down across the whole
     application, this function can be useful.  Its effect is to disable
     all logging calls of severity _lvl_ and below, so that if you call
     it with a value of INFO, then all INFO and DEBUG events would be
     discarded, whereas those of severity WARNING and above would be
     processed according to the logger’s effective level.  If
     ‘logging.disable(logging.NOTSET)’ is called, it effectively removes
     this overriding level, so that logging output again depends on the
     effective levels of individual loggers.

 -- Function: logging.addLevelName (lvl, levelName)

     Associates level _lvl_ with text _levelName_ in an internal
     dictionary, which is used to map numeric levels to a textual
     representation, for example when a *note Formatter: 12c7. formats a
     message.  This function can also be used to define your own levels.
     The only constraints are that all levels used must be registered
     using this function, levels should be positive integers and they
     should increase in increasing order of severity.

          Note: If you are thinking of defining your own levels, please
          see the section on *note Custom Levels: 130e.

 -- Function: logging.getLevelName (lvl)

     Returns the textual representation of logging level _lvl_.  If the
     level is one of the predefined levels ‘CRITICAL’, ‘ERROR’,
     ‘WARNING’, ‘INFO’ or ‘DEBUG’ then you get the corresponding string.
     If you have associated levels with names using *note
     addLevelName(): 130d. then the name you have associated with _lvl_
     is returned.  If a numeric value corresponding to one of the
     defined levels is passed in, the corresponding string
     representation is returned.  Otherwise, the string "Level %s" % lvl
     is returned.

 -- Function: logging.makeLogRecord (attrdict)

     Creates and returns a new *note LogRecord: 12d7. instance whose
     attributes are defined by _attrdict_.  This function is useful for
     taking a pickled *note LogRecord: 12d7. attribute dictionary, sent
     over a socket, and reconstituting it as a *note LogRecord: 12d7.
     instance at the receiving end.

 -- Function: logging.basicConfig ([**kwargs])

     Does basic configuration for the logging system by creating a *note
     StreamHandler: 1310. with a default *note Formatter: 12c7. and
     adding it to the root logger.  The functions *note debug(): 12c9,
     *note info(): 12f6, *note warning(): 1306, *note error(): 1307. and
     *note critical(): 1308. will call *note basicConfig(): 130b.
     automatically if no handlers are defined for the root logger.

     This function does nothing if the root logger already has handlers
     configured for it.

     Changed in version 2.4: Formerly, *note basicConfig(): 130b. did
     not take any keyword arguments.

          Note: This function should be called from the main thread
          before other threads are started.  In versions of Python prior
          to 2.7.1 and 3.2, if this function is called from multiple
          threads, it is possible (in rare circumstances) that a handler
          will be added to the root logger more than once, leading to
          unexpected results such as messages being duplicated in the
          log.

     The following keyword arguments are supported.

     Format             Description
                        
     ---------------------------------------------------------------------
                        
     ‘filename’         Specifies that a FileHandler be created, using
                        the specified filename, rather than a
                        StreamHandler.
                        
                        
     ‘filemode’         Specifies the mode to open the file, if
                        filename is specified (if filemode is
                        unspecified, it defaults to ’a’).
                        
                        
     ‘format’           Use the specified format string for the
                        handler.
                        
                        
     ‘datefmt’          Use the specified date/time format.
                        
                        
     ‘level’            Set the root logger level to the specified
                        level.
                        
                        
     ‘stream’           Use the specified stream to initialize the
                        StreamHandler.  Note that this argument is
                        incompatible with ’filename’ - if both are
                        present, ’stream’ is ignored.
                        

 -- Function: logging.shutdown ()

     Informs the logging system to perform an orderly shutdown by
     flushing and closing all handlers.  This should be called at
     application exit and no further use of the logging system should be
     made after this call.

 -- Function: logging.setLoggerClass (klass)

     Tells the logging system to use the class _klass_ when
     instantiating a logger.  The class should define *note __init__():
     37c. such that only a name argument is required, and the *note
     __init__(): 37c. should call ‘Logger.__init__()’.  This function is
     typically called before any loggers are instantiated by
     applications which need to use custom logger behavior.


File: python.info,  Node: Integration with the warnings module,  Prev: Module-Level Functions,  Up: logging --- Logging facility for Python

5.15.7.11 Integration with the warnings module
..............................................

The *note captureWarnings(): 1312. function can be used to integrate
*note logging: 101. with the *note warnings: 193. module.

 -- Function: logging.captureWarnings (capture)

     This function is used to turn the capture of warnings by logging on
     and off.

     If _capture_ is ‘True’, warnings issued by the *note warnings: 193.
     module will be redirected to the logging system.  Specifically, a
     warning will be formatted using *note warnings.formatwarning():
     1313. and the resulting string logged to a logger named
     ‘'py.warnings'’ with a severity of ‘WARNING’.

     If _capture_ is ‘False’, the redirection of warnings to the logging
     system will stop, and warnings will be redirected to their original
     destinations (i.e.  those in effect before ‘captureWarnings(True)’
     was called).

See also
........

Module *note logging.config: 102.

     Configuration API for the logging module.

Module *note logging.handlers: 103.

     Useful handlers included with the logging module.

PEP 282(1) - A Logging System

     The proposal which described this feature for inclusion in the
     Python standard library.

Original Python logging package(2)

     This is the original source for the *note logging: 101. package.
     The version of the package available from this site is suitable for
     use with Python 1.5.2, 2.1.x and 2.2.x, which do not include the
     *note logging: 101. package in the standard library.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0282

   (2) http://www.red-dove.com/python_logging.html


File: python.info,  Node: logging config --- Logging configuration,  Next: logging handlers --- Logging handlers,  Prev: logging --- Logging facility for Python,  Up: Generic Operating System Services

5.15.8 ‘logging.config’ — Logging configuration
-----------------------------------------------

Important
.........

This page contains only reference information.  For tutorials, please
see

   * *note Basic Tutorial: 12bb.

   * *note Advanced Tutorial: 12bc.

   * *note Logging Cookbook: 12bd.

  *Source code:* Lib/logging/config.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  This section describes the API for configuring the logging module.

* Menu:

* Configuration functions:: 
* Configuration dictionary schema:: 
* Configuration file format:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/logging/config.py


File: python.info,  Node: Configuration functions,  Next: Configuration dictionary schema,  Up: logging config --- Logging configuration

5.15.8.1 Configuration functions
................................

The following functions configure the logging module.  They are located
in the *note logging.config: 102. module.  Their use is optional — you
can configure the logging module using these functions or by making
calls to the main API (defined in *note logging: 101. itself) and
defining handlers which are declared either in *note logging: 101. or
*note logging.handlers: 103.

 -- Function: logging.config.dictConfig (config)

          Takes the logging configuration from a dictionary.  The
          contents of this dictionary are described in *note
          Configuration dictionary schema: 1318. below.

          If an error is encountered during configuration, this function
          will raise a *note ValueError: 236, *note TypeError: 218,
          *note AttributeError: 1f8. or *note ImportError: 370. with a
          suitably descriptive message.  The following is a (possibly
          incomplete) list of conditions which will raise an error:

             * A ‘level’ which is not a string or which is a string not
               corresponding to an actual logging level.

             * A ‘propagate’ value which is not a boolean.

             * An id which does not have a corresponding destination.

             * A non-existent handler id found during an incremental
               call.

             * An invalid logger name.

             * Inability to resolve to an internal or external object.

          Parsing is performed by the ‘DictConfigurator’ class, whose
          constructor is passed the dictionary used for configuration,
          and has a ‘configure()’ method.  The *note logging.config:
          102. module has a callable attribute ‘dictConfigClass’ which
          is initially set to ‘DictConfigurator’.  You can replace the
          value of ‘dictConfigClass’ with a suitable implementation of
          your own.

          *note dictConfig(): 1317. calls ‘dictConfigClass’ passing the
          specified dictionary, and then calls the ‘configure()’ method
          on the returned object to put the configuration into effect:

               def dictConfig(config):
                   dictConfigClass(config).configure()

          For example, a subclass of ‘DictConfigurator’ could call
          ‘DictConfigurator.__init__()’ in its own *note __init__():
          37c, then set up custom prefixes which would be usable in the
          subsequent ‘configure()’ call.  ‘dictConfigClass’ would be
          bound to this new subclass, and then *note dictConfig(): 1317.
          could be called exactly as in the default, uncustomized state.

     New in version 2.7.

 -- Function: logging.config.fileConfig (fname, defaults=None,
          disable_existing_loggers=True)

     Reads the logging configuration from a ‘configparser’-format file
     named _fname_.  The format of the file should be as described in
     *note Configuration file format: 131a.  This function can be called
     several times from an application, allowing an end user to select
     from various pre-canned configurations (if the developer provides a
     mechanism to present the choices and load the chosen
     configuration).

          Parameters:

             * *defaults* – Defaults to be passed to the ConfigParser
               can be specified in this argument.

             * *disable_existing_loggers* – If specified as ‘False’,
               loggers which exist when this call is made are left
               alone.  The default is ‘True’ because this enables old
               behaviour in a backward- compatible way.  This behaviour
               is to disable any existing loggers unless they or their
               ancestors are explicitly named in the logging
               configuration.

     Changed in version 2.6: The ‘disable_existing_loggers’ keyword
     argument was added.  Previously, existing loggers were _always_
     disabled.

 -- Function: logging.config.listen (port=DEFAULT_LOGGING_CONFIG_PORT)

     Starts up a socket server on the specified port, and listens for
     new configurations.  If no port is specified, the module’s default
     ‘DEFAULT_LOGGING_CONFIG_PORT’ is used.  Logging configurations will
     be sent as a file suitable for processing by *note fileConfig():
     1319.  Returns a *note Thread: 131c. instance on which you can call
     *note start(): 131d. to start the server, and which you can *note
     join(): 131e. when appropriate.  To stop the server, call *note
     stopListening(): 131f.

     To send a configuration to the socket, read in the configuration
     file and send it to the socket as a string of bytes preceded by a
     four-byte length string packed in binary using ‘struct.pack('>L',
     n)’.

          Note: Because portions of the configuration are passed through
          *note eval(): 360, use of this function may open its users to
          a security risk.  While the function only binds to a socket on
          ‘localhost’, and so does not accept connections from remote
          machines, there are scenarios where untrusted code could be
          run under the account of the process which calls *note
          listen(): 131b.  Specifically, if the process calling *note
          listen(): 131b. runs on a multi-user machine where users
          cannot trust each other, then a malicious user could arrange
          to run essentially arbitrary code in a victim user’s process,
          simply by connecting to the victim’s *note listen(): 131b.
          socket and sending a configuration which runs whatever code
          the attacker wants to have executed in the victim’s process.
          This is especially easy to do if the default port is used, but
          not hard even if a different port is used).

 -- Function: logging.config.stopListening ()

     Stops the listening server which was created with a call to *note
     listen(): 131b.  This is typically called before calling ‘join()’
     on the return value from *note listen(): 131b.


File: python.info,  Node: Configuration dictionary schema,  Next: Configuration file format,  Prev: Configuration functions,  Up: logging config --- Logging configuration

5.15.8.2 Configuration dictionary schema
........................................

Describing a logging configuration requires listing the various objects
to create and the connections between them; for example, you may create
a handler named ’console’ and then say that the logger named ’startup’
will send its messages to the ’console’ handler.  These objects aren’t
limited to those provided by the *note logging: 101. module because you
might write your own formatter or handler class.  The parameters to
these classes may also need to include external objects such as
‘sys.stderr’.  The syntax for describing these objects and connections
is defined in *note Object connections: 1321. below.

* Menu:

* Dictionary Schema Details:: 
* Incremental Configuration:: 
* Object connections:: 
* User-defined objects:: 
* Access to external objects:: 
* Access to internal objects:: 
* Import resolution and custom importers:: 


File: python.info,  Node: Dictionary Schema Details,  Next: Incremental Configuration,  Up: Configuration dictionary schema

5.15.8.3 Dictionary Schema Details
..................................

The dictionary passed to *note dictConfig(): 1317. must contain the
following keys:

   * _version_ - to be set to an integer value representing the schema
     version.  The only valid value at present is 1, but having this key
     allows the schema to evolve while still preserving backwards
     compatibility.

  All other keys are optional, but if present they will be interpreted
as described below.  In all cases below where a ’configuring dict’ is
mentioned, it will be checked for the special ‘'()'’ key to see if a
custom instantiation is required.  If so, the mechanism described in
*note User-defined objects: 1323. below is used to create an instance;
otherwise, the context is used to determine what to instantiate.

   * _formatters_ - the corresponding value will be a dict in which each
     key is a formatter id and each value is a dict describing how to
     configure the corresponding *note Formatter: 12c7. instance.

     The configuring dict is searched for keys ‘format’ and ‘datefmt’
     (with defaults of ‘None’) and these are used to construct a *note
     Formatter: 12c7. instance.

   * _filters_ - the corresponding value will be a dict in which each
     key is a filter id and each value is a dict describing how to
     configure the corresponding Filter instance.

     The configuring dict is searched for the key ‘name’ (defaulting to
     the empty string) and this is used to construct a *note
     logging.Filter: 12f4. instance.

   * _handlers_ - the corresponding value will be a dict in which each
     key is a handler id and each value is a dict describing how to
     configure the corresponding Handler instance.

     The configuring dict is searched for the following keys:

        * ‘class’ (mandatory).  This is the fully qualified name of the
          handler class.

        * ‘level’ (optional).  The level of the handler.

        * ‘formatter’ (optional).  The id of the formatter for this
          handler.

        * ‘filters’ (optional).  A list of ids of the filters for this
          handler.

     All _other_ keys are passed through as keyword arguments to the
     handler’s constructor.  For example, given the snippet:

          handlers:
            console:
              class : logging.StreamHandler
              formatter: brief
              level   : INFO
              filters: [allow_foo]
              stream  : ext://sys.stdout
            file:
              class : logging.handlers.RotatingFileHandler
              formatter: precise
              filename: logconfig.log
              maxBytes: 1024
              backupCount: 3

     the handler with id ‘console’ is instantiated as a *note
     logging.StreamHandler: 1310, using ‘sys.stdout’ as the underlying
     stream.  The handler with id ‘file’ is instantiated as a *note
     logging.handlers.RotatingFileHandler: 1324. with the keyword
     arguments ‘filename='logconfig.log', maxBytes=1024, backupCount=3’.

   * _loggers_ - the corresponding value will be a dict in which each
     key is a logger name and each value is a dict describing how to
     configure the corresponding Logger instance.

     The configuring dict is searched for the following keys:

        * ‘level’ (optional).  The level of the logger.

        * ‘propagate’ (optional).  The propagation setting of the
          logger.

        * ‘filters’ (optional).  A list of ids of the filters for this
          logger.

        * ‘handlers’ (optional).  A list of ids of the handlers for this
          logger.

     The specified loggers will be configured according to the level,
     propagation, filters and handlers specified.

   * _root_ - this will be the configuration for the root logger.
     Processing of the configuration will be as for any logger, except
     that the ‘propagate’ setting will not be applicable.

   * _incremental_ - whether the configuration is to be interpreted as
     incremental to the existing configuration.  This value defaults to
     ‘False’, which means that the specified configuration replaces the
     existing configuration with the same semantics as used by the
     existing *note fileConfig(): 1319. API.

     If the specified value is ‘True’, the configuration is processed as
     described in the section on *note Incremental Configuration: 1325.

   * _disable_existing_loggers_ - whether any existing loggers are to be
     disabled.  This setting mirrors the parameter of the same name in
     *note fileConfig(): 1319.  If absent, this parameter defaults to
     ‘True’.  This value is ignored if _incremental_ is ‘True’.


File: python.info,  Node: Incremental Configuration,  Next: Object connections,  Prev: Dictionary Schema Details,  Up: Configuration dictionary schema

5.15.8.4 Incremental Configuration
..................................

It is difficult to provide complete flexibility for incremental
configuration.  For example, because objects such as filters and
formatters are anonymous, once a configuration is set up, it is not
possible to refer to such anonymous objects when augmenting a
configuration.

  Furthermore, there is not a compelling case for arbitrarily altering
the object graph of loggers, handlers, filters, formatters at run-time,
once a configuration is set up; the verbosity of loggers and handlers
can be controlled just by setting levels (and, in the case of loggers,
propagation flags).  Changing the object graph arbitrarily in a safe way
is problematic in a multi-threaded environment; while not impossible,
the benefits are not worth the complexity it adds to the implementation.

  Thus, when the ‘incremental’ key of a configuration dict is present
and is ‘True’, the system will completely ignore any ‘formatters’ and
‘filters’ entries, and process only the ‘level’ settings in the
‘handlers’ entries, and the ‘level’ and ‘propagate’ settings in the
‘loggers’ and ‘root’ entries.

  Using a value in the configuration dict lets configurations to be sent
over the wire as pickled dicts to a socket listener.  Thus, the logging
verbosity of a long-running application can be altered over time with no
need to stop and restart the application.


File: python.info,  Node: Object connections,  Next: User-defined objects,  Prev: Incremental Configuration,  Up: Configuration dictionary schema

5.15.8.5 Object connections
...........................

The schema describes a set of logging objects - loggers, handlers,
formatters, filters - which are connected to each other in an object
graph.  Thus, the schema needs to represent connections between the
objects.  For example, say that, once configured, a particular logger
has attached to it a particular handler.  For the purposes of this
discussion, we can say that the logger represents the source, and the
handler the destination, of a connection between the two.  Of course in
the configured objects this is represented by the logger holding a
reference to the handler.  In the configuration dict, this is done by
giving each destination object an id which identifies it unambiguously,
and then using the id in the source object’s configuration to indicate
that a connection exists between the source and the destination object
with that id.

  So, for example, consider the following YAML snippet:

     formatters:
       brief:
         # configuration for formatter with id 'brief' goes here
       precise:
         # configuration for formatter with id 'precise' goes here
     handlers:
       h1: #This is an id
        # configuration of handler with id 'h1' goes here
        formatter: brief
       h2: #This is another id
        # configuration of handler with id 'h2' goes here
        formatter: precise
     loggers:
       foo.bar.baz:
         # other configuration for logger 'foo.bar.baz'
         handlers: [h1, h2]

  (Note: YAML used here because it’s a little more readable than the
equivalent Python source form for the dictionary.)

  The ids for loggers are the logger names which would be used
programmatically to obtain a reference to those loggers, e.g.
‘foo.bar.baz’.  The ids for Formatters and Filters can be any string
value (such as ‘brief’, ‘precise’ above) and they are transient, in that
they are only meaningful for processing the configuration dictionary and
used to determine connections between objects, and are not persisted
anywhere when the configuration call is complete.

  The above snippet indicates that logger named ‘foo.bar.baz’ should
have two handlers attached to it, which are described by the handler ids
‘h1’ and ‘h2’.  The formatter for ‘h1’ is that described by id ‘brief’,
and the formatter for ‘h2’ is that described by id ‘precise’.


File: python.info,  Node: User-defined objects,  Next: Access to external objects,  Prev: Object connections,  Up: Configuration dictionary schema

5.15.8.6 User-defined objects
.............................

The schema supports user-defined objects for handlers, filters and
formatters.  (Loggers do not need to have different types for different
instances, so there is no support in this configuration schema for
user-defined logger classes.)

  Objects to be configured are described by dictionaries which detail
their configuration.  In some places, the logging system will be able to
infer from the context how an object is to be instantiated, but when a
user-defined object is to be instantiated, the system will not know how
to do this.  In order to provide complete flexibility for user-defined
object instantiation, the user needs to provide a ’factory’ - a callable
which is called with a configuration dictionary and which returns the
instantiated object.  This is signalled by an absolute import path to
the factory being made available under the special key ‘'()'’.  Here’s a
concrete example:

     formatters:
       brief:
         format: '%(message)s'
       default:
         format: '%(asctime)s %(levelname)-8s %(name)-15s %(message)s'
         datefmt: '%Y-%m-%d %H:%M:%S'
       custom:
           (): my.package.customFormatterFactory
           bar: baz
           spam: 99.9
           answer: 42

  The above YAML snippet defines three formatters.  The first, with id
‘brief’, is a standard *note logging.Formatter: 12c7. instance with the
specified format string.  The second, with id ‘default’, has a longer
format and also defines the time format explicitly, and will result in a
*note logging.Formatter: 12c7. initialized with those two format
strings.  Shown in Python source form, the ‘brief’ and ‘default’
formatters have configuration sub-dictionaries:

     {
       'format' : '%(message)s'
     }

  and:

     {
       'format' : '%(asctime)s %(levelname)-8s %(name)-15s %(message)s',
       'datefmt' : '%Y-%m-%d %H:%M:%S'
     }

  respectively, and as these dictionaries do not contain the special key
‘'()'’, the instantiation is inferred from the context: as a result,
standard *note logging.Formatter: 12c7. instances are created.  The
configuration sub-dictionary for the third formatter, with id ‘custom’,
is:

     {
       '()' : 'my.package.customFormatterFactory',
       'bar' : 'baz',
       'spam' : 99.9,
       'answer' : 42
     }

  and this contains the special key ‘'()'’, which means that
user-defined instantiation is wanted.  In this case, the specified
factory callable will be used.  If it is an actual callable it will be
used directly - otherwise, if you specify a string (as in the example)
the actual callable will be located using normal import mechanisms.  The
callable will be called with the *remaining* items in the configuration
sub-dictionary as keyword arguments.  In the above example, the
formatter with id ‘custom’ will be assumed to be returned by the call:

     my.package.customFormatterFactory(bar='baz', spam=99.9, answer=42)

  The key ‘'()'’ has been used as the special key because it is not a
valid keyword parameter name, and so will not clash with the names of
the keyword arguments used in the call.  The ‘'()'’ also serves as a
mnemonic that the corresponding value is a callable.


File: python.info,  Node: Access to external objects,  Next: Access to internal objects,  Prev: User-defined objects,  Up: Configuration dictionary schema

5.15.8.7 Access to external objects
...................................

There are times where a configuration needs to refer to objects external
to the configuration, for example ‘sys.stderr’.  If the configuration
dict is constructed using Python code, this is straightforward, but a
problem arises when the configuration is provided via a text file (e.g.
JSON, YAML). In a text file, there is no standard way to distinguish
‘sys.stderr’ from the literal string ‘'sys.stderr'’.  To facilitate this
distinction, the configuration system looks for certain special prefixes
in string values and treat them specially.  For example, if the literal
string ‘'ext://sys.stderr'’ is provided as a value in the configuration,
then the ‘ext://’ will be stripped off and the remainder of the value
processed using normal import mechanisms.

  The handling of such prefixes is done in a way analogous to protocol
handling: there is a generic mechanism to look for prefixes which match
the regular expression ‘^(?P<prefix>[a-z]+)://(?P<suffix>.*)$’ whereby,
if the ‘prefix’ is recognised, the ‘suffix’ is processed in a
prefix-dependent manner and the result of the processing replaces the
string value.  If the prefix is not recognised, then the string value
will be left as-is.


File: python.info,  Node: Access to internal objects,  Next: Import resolution and custom importers,  Prev: Access to external objects,  Up: Configuration dictionary schema

5.15.8.8 Access to internal objects
...................................

As well as external objects, there is sometimes also a need to refer to
objects in the configuration.  This will be done implicitly by the
configuration system for things that it knows about.  For example, the
string value ‘'DEBUG'’ for a ‘level’ in a logger or handler will
automatically be converted to the value ‘logging.DEBUG’, and the
‘handlers’, ‘filters’ and ‘formatter’ entries will take an object id and
resolve to the appropriate destination object.

  However, a more generic mechanism is needed for user-defined objects
which are not known to the *note logging: 101. module.  For example,
consider *note logging.handlers.MemoryHandler: 132d, which takes a
‘target’ argument which is another handler to delegate to.  Since the
system already knows about this class, then in the configuration, the
given ‘target’ just needs to be the object id of the relevant target
handler, and the system will resolve to the handler from the id.  If,
however, a user defines a ‘my.package.MyHandler’ which has an
‘alternate’ handler, the configuration system would not know that the
‘alternate’ referred to a handler.  To cater for this, a generic
resolution system allows the user to specify:

     handlers:
       file:
         # configuration of file handler goes here

       custom:
         (): my.package.MyHandler
         alternate: cfg://handlers.file

  The literal string ‘'cfg://handlers.file'’ will be resolved in an
analogous way to strings with the ‘ext://’ prefix, but looking in the
configuration itself rather than the import namespace.  The mechanism
allows access by dot or by index, in a similar way to that provided by
‘str.format’.  Thus, given the following snippet:

     handlers:
       email:
         class: logging.handlers.SMTPHandler
         mailhost: localhost
         fromaddr: my_app@domain.tld
         toaddrs:
           - support_team@domain.tld
           - dev_team@domain.tld
         subject: Houston, we have a problem.

  in the configuration, the string ‘'cfg://handlers'’ would resolve to
the dict with key ‘handlers’, the string ‘'cfg://handlers.email’ would
resolve to the dict with key ‘email’ in the ‘handlers’ dict, and so on.
The string ‘'cfg://handlers.email.toaddrs[1]’ would resolve to
‘'dev_team.domain.tld'’ and the string
‘'cfg://handlers.email.toaddrs[0]'’ would resolve to the value
‘'support_team@domain.tld'’.  The ‘subject’ value could be accessed
using either ‘'cfg://handlers.email.subject'’ or, equivalently,
‘'cfg://handlers.email[subject]'’.  The latter form only needs to be
used if the key contains spaces or non-alphanumeric characters.  If an
index value consists only of decimal digits, access will be attempted
using the corresponding integer value, falling back to the string value
if needed.

  Given a string ‘cfg://handlers.myhandler.mykey.123’, this will resolve
to ‘config_dict['handlers']['myhandler']['mykey']['123']’.  If the
string is specified as ‘cfg://handlers.myhandler.mykey[123]’, the system
will attempt to retrieve the value from
‘config_dict['handlers']['myhandler']['mykey'][123]’, and fall back to
‘config_dict['handlers']['myhandler']['mykey']['123']’ if that fails.


File: python.info,  Node: Import resolution and custom importers,  Prev: Access to internal objects,  Up: Configuration dictionary schema

5.15.8.9 Import resolution and custom importers
...............................................

Import resolution, by default, uses the builtin *note __import__(): 37e.
function to do its importing.  You may want to replace this with your
own importing mechanism: if so, you can replace the ‘importer’ attribute
of the ‘DictConfigurator’ or its superclass, the ‘BaseConfigurator’
class.  However, you need to be careful because of the way functions are
accessed from classes via descriptors.  If you are using a Python
callable to do your imports, and you want to define it at class level
rather than instance level, you need to wrap it with *note
staticmethod(): 3f5.  For example:

     from importlib import import_module
     from logging.config import BaseConfigurator

     BaseConfigurator.importer = staticmethod(import_module)

  You don’t need to wrap with *note staticmethod(): 3f5. if you’re
setting the import callable on a configurator _instance_.


File: python.info,  Node: Configuration file format,  Prev: Configuration dictionary schema,  Up: logging config --- Logging configuration

5.15.8.10 Configuration file format
...................................

The configuration file format understood by *note fileConfig(): 1319. is
based on ‘configparser’ functionality.  The file must contain sections
called ‘[loggers]’, ‘[handlers]’ and ‘[formatters]’ which identify by
name the entities of each type which are defined in the file.  For each
such entity, there is a separate section which identifies how that
entity is configured.  Thus, for a logger named ‘log01’ in the
‘[loggers]’ section, the relevant configuration details are held in a
section ‘[logger_log01]’.  Similarly, a handler called ‘hand01’ in the
‘[handlers]’ section will have its configuration held in a section
called ‘[handler_hand01]’, while a formatter called ‘form01’ in the
‘[formatters]’ section will have its configuration specified in a
section called ‘[formatter_form01]’.  The root logger configuration must
be specified in a section called ‘[logger_root]’.

  Examples of these sections in the file are given below.

     [loggers]
     keys=root,log02,log03,log04,log05,log06,log07

     [handlers]
     keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09

     [formatters]
     keys=form01,form02,form03,form04,form05,form06,form07,form08,form09

  The root logger must specify a level and a list of handlers.  An
example of a root logger section is given below.

     [logger_root]
     level=NOTSET
     handlers=hand01

  The ‘level’ entry can be one of ‘DEBUG, INFO, WARNING, ERROR,
CRITICAL’ or ‘NOTSET’.  For the root logger only, ‘NOTSET’ means that
all messages will be logged.  Level values are *note eval(): 360.uated
in the context of the ‘logging’ package’s namespace.

  The ‘handlers’ entry is a comma-separated list of handler names, which
must appear in the ‘[handlers]’ section.  These names must appear in the
‘[handlers]’ section and have corresponding sections in the
configuration file.

  For loggers other than the root logger, some additional information is
required.  This is illustrated by the following example.

     [logger_parser]
     level=DEBUG
     handlers=hand01
     propagate=1
     qualname=compiler.parser

  The ‘level’ and ‘handlers’ entries are interpreted as for the root
logger, except that if a non-root logger’s level is specified as
‘NOTSET’, the system consults loggers higher up the hierarchy to
determine the effective level of the logger.  The ‘propagate’ entry is
set to 1 to indicate that messages must propagate to handlers higher up
the logger hierarchy from this logger, or 0 to indicate that messages
are *not* propagated to handlers up the hierarchy.  The ‘qualname’ entry
is the hierarchical channel name of the logger, that is to say the name
used by the application to get the logger.

  Sections which specify handler configuration are exemplified by the
following.

     [handler_hand01]
     class=StreamHandler
     level=NOTSET
     formatter=form01
     args=(sys.stdout,)

  The ‘class’ entry indicates the handler’s class (as determined by
*note eval(): 360. in the ‘logging’ package’s namespace).  The ‘level’
is interpreted as for loggers, and ‘NOTSET’ is taken to mean ’log
everything’.

  Changed in version 2.6: Added support for resolving the handler’s
class as a dotted module and class name.

  The ‘formatter’ entry indicates the key name of the formatter for this
handler.  If blank, a default formatter (‘logging._defaultFormatter’) is
used.  If a name is specified, it must appear in the ‘[formatters]’
section and have a corresponding section in the configuration file.

  The ‘args’ entry, when *note eval(): 360.uated in the context of the
‘logging’ package’s namespace, is the list of arguments to the
constructor for the handler class.  Refer to the constructors for the
relevant handlers, or to the examples below, to see how typical entries
are constructed.

     [handler_hand02]
     class=FileHandler
     level=DEBUG
     formatter=form02
     args=('python.log', 'w')

     [handler_hand03]
     class=handlers.SocketHandler
     level=INFO
     formatter=form03
     args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)

     [handler_hand04]
     class=handlers.DatagramHandler
     level=WARN
     formatter=form04
     args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)

     [handler_hand05]
     class=handlers.SysLogHandler
     level=ERROR
     formatter=form05
     args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)

     [handler_hand06]
     class=handlers.NTEventLogHandler
     level=CRITICAL
     formatter=form06
     args=('Python Application', '', 'Application')

     [handler_hand07]
     class=handlers.SMTPHandler
     level=WARN
     formatter=form07
     args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')

     [handler_hand08]
     class=handlers.MemoryHandler
     level=NOTSET
     formatter=form08
     target=
     args=(10, ERROR)

     [handler_hand09]
     class=handlers.HTTPHandler
     level=NOTSET
     formatter=form09
     args=('localhost:9022', '/log', 'GET')

  Sections which specify formatter configuration are typified by the
following.

     [formatter_form01]
     format=F1 %(asctime)s %(levelname)s %(message)s
     datefmt=
     class=logging.Formatter

  The ‘format’ entry is the overall format string, and the ‘datefmt’
entry is the ‘strftime()’-compatible date/time format string.  If empty,
the package substitutes ISO8601 format date/times, which is almost
equivalent to specifying the date format string ‘'%Y-%m-%d %H:%M:%S'’.
The ISO8601 format also specifies milliseconds, which are appended to
the result of using the above format string, with a comma separator.  An
example time in ISO8601 format is ‘2003-01-23 00:29:50,411’.

  The ‘class’ entry is optional.  It indicates the name of the
formatter’s class (as a dotted module and class name.)  This option is
useful for instantiating a *note Formatter: 12c7. subclass.  Subclasses
of *note Formatter: 12c7. can present exception tracebacks in an
expanded or condensed format.

     Note: Due to the use of *note eval(): 360. as described above,
     there are potential security risks which result from using the
     *note listen(): 131b. to send and receive configurations via
     sockets.  The risks are limited to where multiple users with no
     mutual trust run code on the same machine; see the *note listen():
     131b. documentation for more information.

See also
........

Module *note logging: 101.

     API reference for the logging module.

Module *note logging.handlers: 103.

     Useful handlers included with the logging module.


File: python.info,  Node: logging handlers --- Logging handlers,  Next: getpass --- Portable password input,  Prev: logging config --- Logging configuration,  Up: Generic Operating System Services

5.15.9 ‘logging.handlers’ — Logging handlers
--------------------------------------------

Important
.........

This page contains only reference information.  For tutorials, please
see

   * *note Basic Tutorial: 12bb.

   * *note Advanced Tutorial: 12bc.

   * *note Logging Cookbook: 12bd.

  *Source code:* Lib/logging/handlers.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  The following useful handlers are provided in the package.  Note that
three of the handlers (*note StreamHandler: 1310, *note FileHandler:
1333. and *note NullHandler: 1334.) are actually defined in the *note
logging: 101. module itself, but have been documented here along with
the other handlers.

* Menu:

* StreamHandler:: 
* FileHandler:: 
* NullHandler:: 
* WatchedFileHandler:: 
* RotatingFileHandler:: 
* TimedRotatingFileHandler:: 
* SocketHandler:: 
* DatagramHandler:: 
* SysLogHandler:: 
* NTEventLogHandler:: 
* SMTPHandler:: 
* MemoryHandler:: 
* HTTPHandler:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/logging/handlers.py


File: python.info,  Node: StreamHandler,  Next: FileHandler,  Up: logging handlers --- Logging handlers

5.15.9.1 StreamHandler
......................

The *note StreamHandler: 1310. class, located in the core *note logging:
101. package, sends logging output to streams such as _sys.stdout_,
_sys.stderr_ or any file-like object (or, more precisely, any object
which supports ‘write()’ and ‘flush()’ methods).

 -- Class: logging.StreamHandler (stream=None)

     Returns a new instance of the *note StreamHandler: 1310. class.  If
     _stream_ is specified, the instance will use it for logging output;
     otherwise, _sys.stderr_ will be used.

      -- Method: emit (record)

          If a formatter is specified, it is used to format the record.
          The record is then written to the stream with a newline
          terminator.  If exception information is present, it is
          formatted using *note traceback.print_exception(): 12f1. and
          appended to the stream.

      -- Method: flush ()

          Flushes the stream by calling its *note flush(): 1338. method.
          Note that the ‘close()’ method is inherited from ‘Handler’ and
          so does no output, so an explicit *note flush(): 1338. call
          may be needed at times.


File: python.info,  Node: FileHandler,  Next: NullHandler,  Prev: StreamHandler,  Up: logging handlers --- Logging handlers

5.15.9.2 FileHandler
....................

The *note FileHandler: 1333. class, located in the core *note logging:
101. package, sends logging output to a disk file.  It inherits the
output functionality from *note StreamHandler: 1310.

 -- Class: logging.FileHandler (filename, mode='a', encoding=None,
          delay=False)

     Returns a new instance of the *note FileHandler: 1333. class.  The
     specified file is opened and used as the stream for logging.  If
     _mode_ is not specified, ‘'a'’ is used.  If _encoding_ is not
     _None_, it is used to open the file with that encoding.  If _delay_
     is true, then file opening is deferred until the first call to
     *note emit(): 133b.  By default, the file grows indefinitely.

     Changed in version 2.6: _delay_ was added.

      -- Method: close ()

          Closes the file.

      -- Method: emit (record)

          Outputs the record to the file.


File: python.info,  Node: NullHandler,  Next: WatchedFileHandler,  Prev: FileHandler,  Up: logging handlers --- Logging handlers

5.15.9.3 NullHandler
....................

New in version 2.7.

  The *note NullHandler: 1334. class, located in the core *note logging:
101. package, does not do any formatting or output.  It is essentially a
’no-op’ handler for use by library developers.

 -- Class: logging.NullHandler

     Returns a new instance of the *note NullHandler: 1334. class.

      -- Method: emit (record)

          This method does nothing.

      -- Method: handle (record)

          This method does nothing.

      -- Method: createLock ()

          This method returns ‘None’ for the lock, since there is no
          underlying I/O to which access needs to be serialized.

  See *note Configuring Logging for a Library: 1342. for more
information on how to use *note NullHandler: 1334.


File: python.info,  Node: WatchedFileHandler,  Next: RotatingFileHandler,  Prev: NullHandler,  Up: logging handlers --- Logging handlers

5.15.9.4 WatchedFileHandler
...........................

New in version 2.6.

  The *note WatchedFileHandler: 1345. class, located in the *note
logging.handlers: 103. module, is a ‘FileHandler’ which watches the file
it is logging to.  If the file changes, it is closed and reopened using
the file name.

  A file change can happen because of usage of programs such as
_newsyslog_ and _logrotate_ which perform log file rotation.  This
handler, intended for use under Unix/Linux, watches the file to see if
it has changed since the last emit.  (A file is deemed to have changed
if its device or inode have changed.)  If the file has changed, the old
file stream is closed, and the file opened to get a new stream.

  This handler is not appropriate for use under Windows, because under
Windows open log files cannot be moved or renamed - logging opens the
files with exclusive locks - and so there is no need for such a handler.
Furthermore, _ST_INO_ is not supported under Windows; *note stat(): 3c4.
always returns zero for this value.

 -- Class: logging.handlers.WatchedFileHandler (filename[, mode[,
          encoding[, delay]]])

     Returns a new instance of the *note WatchedFileHandler: 1345.
     class.  The specified file is opened and used as the stream for
     logging.  If _mode_ is not specified, ‘'a'’ is used.  If _encoding_
     is not _None_, it is used to open the file with that encoding.  If
     _delay_ is true, then file opening is deferred until the first call
     to *note emit(): 1346.  By default, the file grows indefinitely.

      -- Method: emit (record)

          Outputs the record to the file, but first checks to see if the
          file has changed.  If it has, the existing stream is flushed
          and closed and the file opened again, before outputting the
          record to the file.


File: python.info,  Node: RotatingFileHandler,  Next: TimedRotatingFileHandler,  Prev: WatchedFileHandler,  Up: logging handlers --- Logging handlers

5.15.9.5 RotatingFileHandler
............................

The *note RotatingFileHandler: 1324. class, located in the *note
logging.handlers: 103. module, supports rotation of disk log files.

 -- Class: logging.handlers.RotatingFileHandler (filename, mode='a',
          maxBytes=0, backupCount=0, encoding=None, delay=0)

     Returns a new instance of the *note RotatingFileHandler: 1324.
     class.  The specified file is opened and used as the stream for
     logging.  If _mode_ is not specified, ‘'a'’ is used.  If _encoding_
     is not _None_, it is used to open the file with that encoding.  If
     _delay_ is true, then file opening is deferred until the first call
     to *note emit(): 1349.  By default, the file grows indefinitely.

     You can use the _maxBytes_ and _backupCount_ values to allow the
     file to _rollover_ at a predetermined size.  When the size is about
     to be exceeded, the file is closed and a new file is silently
     opened for output.  Rollover occurs whenever the current log file
     is nearly _maxBytes_ in length; if _maxBytes_ is zero, rollover
     never occurs.  If _backupCount_ is non-zero, the system will save
     old log files by appending the extensions ’.1’, ’.2’ etc., to the
     filename.  For example, with a _backupCount_ of 5 and a base file
     name of ‘app.log’, you would get ‘app.log’, ‘app.log.1’,
     ‘app.log.2’, up to ‘app.log.5’.  The file being written to is
     always ‘app.log’.  When this file is filled, it is closed and
     renamed to ‘app.log.1’, and if files ‘app.log.1’, ‘app.log.2’, etc.
     exist, then they are renamed to ‘app.log.2’, ‘app.log.3’ etc.
     respectively.

     Changed in version 2.6: _delay_ was added.

      -- Method: doRollover ()

          Does a rollover, as described above.

      -- Method: emit (record)

          Outputs the record to the file, catering for rollover as
          described previously.


File: python.info,  Node: TimedRotatingFileHandler,  Next: SocketHandler,  Prev: RotatingFileHandler,  Up: logging handlers --- Logging handlers

5.15.9.6 TimedRotatingFileHandler
.................................

The *note TimedRotatingFileHandler: 134d. class, located in the *note
logging.handlers: 103. module, supports rotation of disk log files at
certain timed intervals.

 -- Class: logging.handlers.TimedRotatingFileHandler (filename,
          when='h', interval=1, backupCount=0, encoding=None,
          delay=False, utc=False)

     Returns a new instance of the *note TimedRotatingFileHandler: 134d.
     class.  The specified file is opened and used as the stream for
     logging.  On rotating it also sets the filename suffix.  Rotating
     happens based on the product of _when_ and _interval_.

     You can use the _when_ to specify the type of _interval_.  The list
     of possible values is below.  Note that they are not case
     sensitive.

     Value                Type of interval
                          
     -------------------------------------------------
                          
     ‘'S'’                Seconds
                          
                          
     ‘'M'’                Minutes
                          
                          
     ‘'H'’                Hours
                          
                          
     ‘'D'’                Days
                          
                          
     ‘'W0'-'W6'’          Weekday (0=Monday)
                          
                          
     ‘'midnight'’         Roll over at midnight
                          

     When using weekday-based rotation, specify ’W0’ for Monday, ’W1’
     for Tuesday, and so on up to ’W6’ for Sunday.  In this case, the
     value passed for _interval_ isn’t used.

     The system will save old log files by appending extensions to the
     filename.  The extensions are date-and-time based, using the
     strftime format ‘%Y-%m-%d_%H-%M-%S’ or a leading portion thereof,
     depending on the rollover interval.

     When computing the next rollover time for the first time (when the
     handler is created), the last modification time of an existing log
     file, or else the current time, is used to compute when the next
     rotation will occur.

     If the _utc_ argument is true, times in UTC will be used; otherwise
     local time is used.

     If _backupCount_ is nonzero, at most _backupCount_ files will be
     kept, and if more would be created when rollover occurs, the oldest
     one is deleted.  The deletion logic uses the interval to determine
     which files to delete, so changing the interval may leave old files
     lying around.

     If _delay_ is true, then file opening is deferred until the first
     call to *note emit(): 134e.

     Changed in version 2.6: _delay_ and _utc_ were added.

      -- Method: doRollover ()

          Does a rollover, as described above.

      -- Method: emit (record)

          Outputs the record to the file, catering for rollover as
          described above.


File: python.info,  Node: SocketHandler,  Next: DatagramHandler,  Prev: TimedRotatingFileHandler,  Up: logging handlers --- Logging handlers

5.15.9.7 SocketHandler
......................

The *note SocketHandler: 1352. class, located in the *note
logging.handlers: 103. module, sends logging output to a network socket.
The base class uses a TCP socket.

 -- Class: logging.handlers.SocketHandler (host, port)

     Returns a new instance of the *note SocketHandler: 1352. class
     intended to communicate with a remote machine whose address is
     given by _host_ and _port_.

      -- Method: close ()

          Closes the socket.

      -- Method: emit ()

          Pickles the record’s attribute dictionary and writes it to the
          socket in binary format.  If there is an error with the
          socket, silently drops the packet.  If the connection was
          previously lost, re-establishes the connection.  To unpickle
          the record at the receiving end into a *note LogRecord: 12d7,
          use the *note makeLogRecord(): 12fa. function.

      -- Method: handleError ()

          Handles an error which has occurred during *note emit(): 1354.
          The most likely cause is a lost connection.  Closes the socket
          so that we can retry on the next event.

      -- Method: makeSocket ()

          This is a factory method which allows subclasses to define the
          precise type of socket they want.  The default implementation
          creates a TCP socket (*note socket.SOCK_STREAM: 1dc.).

      -- Method: makePickle (record)

          Pickles the record’s attribute dictionary in binary format
          with a length prefix, and returns it ready for transmission
          across the socket.

          Note that pickles aren’t completely secure.  If you are
          concerned about security, you may want to override this method
          to implement a more secure mechanism.  For example, you can
          sign pickles using HMAC and then verify them on the receiving
          end, or alternatively you can disable unpickling of global
          objects on the receiving end.

      -- Method: send (packet)

          Send a pickled string _packet_ to the socket.  This function
          allows for partial sends which can happen when the network is
          busy.

      -- Method: createSocket ()

          Tries to create a socket; on failure, uses an exponential
          back-off algorithm.  On intial failure, the handler will drop
          the message it was trying to send.  When subsequent messages
          are handled by the same instance, it will not try connecting
          until some time has passed.  The default parameters are such
          that the initial delay is one second, and if after that delay
          the connection still can’t be made, the handler will double
          the delay each time up to a maximum of 30 seconds.

          This behaviour is controlled by the following handler
          attributes:

             * ‘retryStart’ (initial delay, defaulting to 1.0 seconds).

             * ‘retryFactor’ (multiplier, defaulting to 2.0).

             * ‘retryMax’ (maximum delay, defaulting to 30.0 seconds).

          This means that if the remote listener starts up _after_ the
          handler has been used, you could lose messages (since the
          handler won’t even attempt a connection until the delay has
          elapsed, but just silently drop messages during the delay
          period).


File: python.info,  Node: DatagramHandler,  Next: SysLogHandler,  Prev: SocketHandler,  Up: logging handlers --- Logging handlers

5.15.9.8 DatagramHandler
........................

The *note DatagramHandler: 135c. class, located in the *note
logging.handlers: 103. module, inherits from *note SocketHandler: 1352.
to support sending logging messages over UDP sockets.

 -- Class: logging.handlers.DatagramHandler (host, port)

     Returns a new instance of the *note DatagramHandler: 135c. class
     intended to communicate with a remote machine whose address is
     given by _host_ and _port_.

      -- Method: emit ()

          Pickles the record’s attribute dictionary and writes it to the
          socket in binary format.  If there is an error with the
          socket, silently drops the packet.  To unpickle the record at
          the receiving end into a *note LogRecord: 12d7, use the *note
          makeLogRecord(): 12fa. function.

      -- Method: makeSocket ()

          The factory method of *note SocketHandler: 1352. is here
          overridden to create a UDP socket (*note socket.SOCK_DGRAM:
          1db.).

      -- Method: send (s)

          Send a pickled string to a socket.


File: python.info,  Node: SysLogHandler,  Next: NTEventLogHandler,  Prev: DatagramHandler,  Up: logging handlers --- Logging handlers

5.15.9.9 SysLogHandler
......................

The *note SysLogHandler: 1da. class, located in the *note
logging.handlers: 103. module, supports sending logging messages to a
remote or local Unix syslog.

 -- Class: logging.handlers.SysLogHandler (address=('localhost',
          SYSLOG_UDP_PORT), facility=LOG_USER,
          socktype=socket.SOCK_DGRAM)

     Returns a new instance of the *note SysLogHandler: 1da. class
     intended to communicate with a remote Unix machine whose address is
     given by _address_ in the form of a ‘(host, port)’ tuple.  If
     _address_ is not specified, ‘('localhost', 514)’ is used.  The
     address is used to open a socket.  An alternative to providing a
     ‘(host, port)’ tuple is providing an address as a string, for
     example ’/dev/log’.  In this case, a Unix domain socket is used to
     send the message to the syslog.  If _facility_ is not specified,
     ‘LOG_USER’ is used.  The type of socket opened depends on the
     _socktype_ argument, which defaults to *note socket.SOCK_DGRAM:
     1db. and thus opens a UDP socket.  To open a TCP socket (for use
     with the newer syslog daemons such as rsyslog), specify a value of
     *note socket.SOCK_STREAM: 1dc.

     Note that if your server is not listening on UDP port 514, *note
     SysLogHandler: 1da. may appear not to work.  In that case, check
     what address you should be using for a domain socket - it’s system
     dependent.  For example, on Linux it’s usually ’/dev/log’ but on
     OS/X it’s ’/var/run/syslog’.  You’ll need to check your platform
     and use the appropriate address (you may need to do this check at
     runtime if your application needs to run on several platforms).  On
     Windows, you pretty much have to use the UDP option.

     Changed in version 2.7: _socktype_ was added.

      -- Method: close ()

          Closes the socket to the remote host.

      -- Method: emit (record)

          The record is formatted, and then sent to the syslog server.
          If exception information is present, it is _not_ sent to the
          server.

      -- Method: encodePriority (facility, priority)

          Encodes the facility and priority into an integer.  You can
          pass in strings or integers - if strings are passed, internal
          mapping dictionaries are used to convert them to integers.

          The symbolic ‘LOG_’ values are defined in *note SysLogHandler:
          1da. and mirror the values defined in the ‘sys/syslog.h’
          header file.

          *Priorities*

          Name (string)                  Symbolic value
                                         
          ---------------------------------------------------
                                         
          ‘alert’                        LOG_ALERT
                                         
                                         
          ‘crit’ or ‘critical’           LOG_CRIT
                                         
                                         
          ‘debug’                        LOG_DEBUG
                                         
                                         
          ‘emerg’ or ‘panic’             LOG_EMERG
                                         
                                         
          ‘err’ or ‘error’               LOG_ERR
                                         
                                         
          ‘info’                         LOG_INFO
                                         
                                         
          ‘notice’                       LOG_NOTICE
                                         
                                         
          ‘warn’ or ‘warning’            LOG_WARNING
                                         

          *Facilities*

          Name (string)       Symbolic value
                              
          ----------------------------------------
                              
          ‘auth’              LOG_AUTH
                              
                              
          ‘authpriv’          LOG_AUTHPRIV
                              
                              
          ‘cron’              LOG_CRON
                              
                              
          ‘daemon’            LOG_DAEMON
                              
                              
          ‘ftp’               LOG_FTP
                              
                              
          ‘kern’              LOG_KERN
                              
                              
          ‘lpr’               LOG_LPR
                              
                              
          ‘mail’              LOG_MAIL
                              
                              
          ‘news’              LOG_NEWS
                              
                              
          ‘syslog’            LOG_SYSLOG
                              
                              
          ‘user’              LOG_USER
                              
                              
          ‘uucp’              LOG_UUCP
                              
                              
          ‘local0’            LOG_LOCAL0
                              
                              
          ‘local1’            LOG_LOCAL1
                              
                              
          ‘local2’            LOG_LOCAL2
                              
                              
          ‘local3’            LOG_LOCAL3
                              
                              
          ‘local4’            LOG_LOCAL4
                              
                              
          ‘local5’            LOG_LOCAL5
                              
                              
          ‘local6’            LOG_LOCAL6
                              
                              
          ‘local7’            LOG_LOCAL7
                              

      -- Method: mapPriority (levelname)

          Maps a logging level name to a syslog priority name.  You may
          need to override this if you are using custom levels, or if
          the default algorithm is not suitable for your needs.  The
          default algorithm maps ‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’ and
          ‘CRITICAL’ to the equivalent syslog names, and all other level
          names to ’warning’.


File: python.info,  Node: NTEventLogHandler,  Next: SMTPHandler,  Prev: SysLogHandler,  Up: logging handlers --- Logging handlers

5.15.9.10 NTEventLogHandler
...........................

The *note NTEventLogHandler: 1368. class, located in the *note
logging.handlers: 103. module, supports sending logging messages to a
local Windows NT, Windows 2000 or Windows XP event log.  Before you can
use it, you need Mark Hammond’s Win32 extensions for Python installed.

 -- Class: logging.handlers.NTEventLogHandler (appname, dllname=None,
          logtype='Application')

     Returns a new instance of the *note NTEventLogHandler: 1368. class.
     The _appname_ is used to define the application name as it appears
     in the event log.  An appropriate registry entry is created using
     this name.  The _dllname_ should give the fully qualified pathname
     of a .dll or .exe which contains message definitions to hold in the
     log (if not specified, ‘'win32service.pyd'’ is used - this is
     installed with the Win32 extensions and contains some basic
     placeholder message definitions.  Note that use of these
     placeholders will make your event logs big, as the entire message
     source is held in the log.  If you want slimmer logs, you have to
     pass in the name of your own .dll or .exe which contains the
     message definitions you want to use in the event log).  The
     _logtype_ is one of ‘'Application'’, ‘'System'’ or ‘'Security'’,
     and defaults to ‘'Application'’.

      -- Method: close ()

          At this point, you can remove the application name from the
          registry as a source of event log entries.  However, if you do
          this, you will not be able to see the events as you intended
          in the Event Log Viewer - it needs to be able to access the
          registry to get the .dll name.  The current version does not
          do this.

      -- Method: emit (record)

          Determines the message ID, event category and event type, and
          then logs the message in the NT event log.

      -- Method: getEventCategory (record)

          Returns the event category for the record.  Override this if
          you want to specify your own categories.  This version returns
          0.

      -- Method: getEventType (record)

          Returns the event type for the record.  Override this if you
          want to specify your own types.  This version does a mapping
          using the handler’s typemap attribute, which is set up in
          *note __init__(): 37c. to a dictionary which contains mappings
          for ‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’ and ‘CRITICAL’.  If
          you are using your own levels, you will either need to
          override this method or place a suitable dictionary in the
          handler’s _typemap_ attribute.

      -- Method: getMessageID (record)

          Returns the message ID for the record.  If you are using your
          own messages, you could do this by having the _msg_ passed to
          the logger being an ID rather than a format string.  Then, in
          here, you could use a dictionary lookup to get the message ID.
          This version returns 1, which is the base message ID in
          ‘win32service.pyd’.


File: python.info,  Node: SMTPHandler,  Next: MemoryHandler,  Prev: NTEventLogHandler,  Up: logging handlers --- Logging handlers

5.15.9.11 SMTPHandler
.....................

The *note SMTPHandler: 1370. class, located in the *note
logging.handlers: 103. module, supports sending logging messages to an
email address via SMTP.

 -- Class: logging.handlers.SMTPHandler (mailhost, fromaddr, toaddrs,
          subject, credentials=None, secure=None)

     Returns a new instance of the *note SMTPHandler: 1370. class.  The
     instance is initialized with the from and to addresses and subject
     line of the email.  The _toaddrs_ should be a list of strings.  To
     specify a non-standard SMTP port, use the (host, port) tuple format
     for the _mailhost_ argument.  If you use a string, the standard
     SMTP port is used.  If your SMTP server requires authentication,
     you can specify a (username, password) tuple for the _credentials_
     argument.

     To specify the use of a secure protocol (TLS), pass in a tuple to
     the _secure_ argument.  This will only be used when authentication
     credentials are supplied.  The tuple should be either an empty
     tuple, or a single-value tuple with the name of a keyfile, or a
     2-value tuple with the names of the keyfile and certificate file.
     (This tuple is passed to the *note smtplib.SMTP.starttls(): 1371.
     method.)

     Changed in version 2.6: _credentials_ was added.

     Changed in version 2.7: _secure_ was added.

      -- Method: emit (record)

          Formats the record and sends it to the specified addressees.

      -- Method: getSubject (record)

          If you want to specify a subject line which is
          record-dependent, override this method.


File: python.info,  Node: MemoryHandler,  Next: HTTPHandler,  Prev: SMTPHandler,  Up: logging handlers --- Logging handlers

5.15.9.12 MemoryHandler
.......................

The *note MemoryHandler: 132d. class, located in the *note
logging.handlers: 103. module, supports buffering of logging records in
memory, periodically flushing them to a _target_ handler.  Flushing
occurs whenever the buffer is full, or when an event of a certain
severity or greater is seen.

  *note MemoryHandler: 132d. is a subclass of the more general *note
BufferingHandler: 1376, which is an abstract class.  This buffers
logging records in memory.  Whenever each record is added to the buffer,
a check is made by calling ‘shouldFlush()’ to see if the buffer should
be flushed.  If it should, then ‘flush()’ is expected to do the
flushing.

 -- Class: logging.handlers.BufferingHandler (capacity)

     Initializes the handler with a buffer of the specified capacity.

      -- Method: emit (record)

          Appends the record to the buffer.  If *note shouldFlush():
          1378. returns true, calls *note flush(): 1379. to process the
          buffer.

      -- Method: flush ()

          You can override this to implement custom flushing behavior.
          This version just zaps the buffer to empty.

      -- Method: shouldFlush (record)

          Returns true if the buffer is up to capacity.  This method can
          be overridden to implement custom flushing strategies.

 -- Class: logging.handlers.MemoryHandler (capacity, flushLevel=ERROR,
          target=None)

     Returns a new instance of the *note MemoryHandler: 132d. class.
     The instance is initialized with a buffer size of _capacity_.  If
     _flushLevel_ is not specified, ‘ERROR’ is used.  If no _target_ is
     specified, the target will need to be set using *note setTarget():
     137a. before this handler does anything useful.

      -- Method: close ()

          Calls *note flush(): 137c, sets the target to *note None: 39a.
          and clears the buffer.

      -- Method: flush ()

          For a *note MemoryHandler: 132d, flushing means just sending
          the buffered records to the target, if there is one.  The
          buffer is also cleared when this happens.  Override if you
          want different behavior.

      -- Method: setTarget (target)

          Sets the target handler for this handler.

      -- Method: shouldFlush (record)

          Checks for buffer full or a record at the _flushLevel_ or
          higher.


File: python.info,  Node: HTTPHandler,  Prev: MemoryHandler,  Up: logging handlers --- Logging handlers

5.15.9.13 HTTPHandler
.....................

The *note HTTPHandler: 1380. class, located in the *note
logging.handlers: 103. module, supports sending logging messages to a
Web server, using either ‘GET’ or ‘POST’ semantics.

 -- Class: logging.handlers.HTTPHandler (host, url, method='GET')

     Returns a new instance of the *note HTTPHandler: 1380. class.  The
     ‘host’ can be of the form ‘host:port’, should you need to use a
     specific port number.

      -- Method: mapLogRecord (record)

          Provides a dictionary, based on ‘record’, which is to be
          URL-encoded and sent to the web server.  The default
          implementation just returns ‘record.__dict__’.  This method
          can be overridden if e.g.  only a subset of *note LogRecord:
          12d7. is to be sent to the web server, or if more specific
          customization of what’s sent to the server is required.

      -- Method: emit (record)

          Sends the record to the Web server as an URL-encoded
          dictionary.  The *note mapLogRecord(): 1381. method is used to
          convert the record to the dictionary to be sent.

          Note: Since preparing a record for sending it to a Web server
          is not the same as a generic formatting operation, using
          ‘setFormatter()’ to specify a ‘Formatter’ for a *note
          HTTPHandler: 1380. has no effect.  Instead of calling *note
          format(): 1ef, this handler calls *note mapLogRecord(): 1381.
          and then *note urllib.urlencode(): 1383. to encode the
          dictionary in a form suitable for sending to a Web server.

See also
........

Module *note logging: 101.

     API reference for the logging module.

Module *note logging.config: 102.

     Configuration API for the logging module.


File: python.info,  Node: getpass --- Portable password input,  Next: curses --- Terminal handling for character-cell displays,  Prev: logging handlers --- Logging handlers,  Up: Generic Operating System Services

5.15.10 ‘getpass’ — Portable password input
-------------------------------------------

The *note getpass: df. module provides two functions:

 -- Function: getpass.getpass ([prompt[, stream]])

     Prompt the user for a password without echoing.  The user is
     prompted using the string _prompt_, which defaults to ‘'Password:
     '’.  On Unix, the prompt is written to the file-like object
     _stream_.  _stream_ defaults to the controlling terminal (/dev/tty)
     or if that is unavailable to ‘sys.stderr’ (this argument is ignored
     on Windows).

     If echo free input is unavailable getpass() falls back to printing
     a warning message to _stream_ and reading from ‘sys.stdin’ and
     issuing a *note GetPassWarning: 1387.

     Availability: Macintosh, Unix, Windows.

     Changed in version 2.5: The _stream_ parameter was added.

     Changed in version 2.6: On Unix it defaults to using /dev/tty
     before falling back to ‘sys.stdin’ and ‘sys.stderr’.

          Note: If you call getpass from within IDLE, the input may be
          done in the terminal you launched IDLE from rather than the
          idle window itself.

 -- Exception: getpass.GetPassWarning

     A *note UserWarning: 95d. subclass issued when password input may
     be echoed.

 -- Function: getpass.getuser ()

     Return the "login name" of the user.  Availability: Unix, Windows.

     This function checks the environment variables ‘LOGNAME’, ‘USER’,
     ‘LNAME’ and ‘USERNAME’, in order, and returns the value of the
     first one which is set to a non-empty string.  If none are set, the
     login name from the password database is returned on systems which
     support the *note pwd: 13c. module, otherwise, an exception is
     raised.


File: python.info,  Node: curses --- Terminal handling for character-cell displays,  Next: curses textpad --- Text input widget for curses programs,  Prev: getpass --- Portable password input,  Up: Generic Operating System Services

5.15.11 ‘curses’ — Terminal handling for character-cell displays
----------------------------------------------------------------

Changed in version 1.6: Added support for the ‘ncurses’ library and
converted to a package.

  The *note curses: 79. module provides an interface to the curses
library, the de-facto standard for portable advanced terminal handling.

  While curses is most widely used in the Unix environment, versions are
available for DOS, OS/2, and possibly other systems as well.  This
extension module is designed to match the API of ncurses, an open-source
curses library hosted on Linux and the BSD variants of Unix.

     Note: Since version 5.4, the ncurses library decides how to
     interpret non-ASCII data using the ‘nl_langinfo’ function.  That
     means that you have to call *note locale.setlocale(): 96d. in the
     application and encode Unicode strings using one of the system’s
     available encodings.  This example uses the system’s default
     encoding:

          import locale
          locale.setlocale(locale.LC_ALL, '')
          code = locale.getpreferredencoding()

     Then use _code_ as the encoding for *note str.encode(): 652. calls.

See also
........

Module *note curses.ascii: 7a.

     Utilities for working with ASCII characters, regardless of your
     locale settings.

Module *note curses.panel: 7b.

     A panel stack extension that adds depth to curses windows.

Module *note curses.textpad: 7c.

     Editable text widget for curses supporting *Emacs*-like bindings.

*note Curses Programming with Python: 138b.

     Tutorial material on using curses with Python, by Andrew Kuchling
     and Eric Raymond.

  The Demo/curses/(1) directory in the Python source distribution
contains some example programs using the curses bindings provided by
this module.

* Menu:

* Functions: Functions<2>. 
* Window Objects:: 
* Constants: Constants<3>. 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Demo/curses/


File: python.info,  Node: Functions<2>,  Next: Window Objects,  Up: curses --- Terminal handling for character-cell displays

5.15.11.1 Functions
...................

The module *note curses: 79. defines the following exception:

 -- Exception: curses.error

     Exception raised when a curses library function returns an error.

     Note: Whenever _x_ or _y_ arguments to a function or a method are
     optional, they default to the current cursor location.  Whenever
     _attr_ is optional, it defaults to ‘A_NORMAL’.

  The module *note curses: 79. defines the following functions:

 -- Function: curses.baudrate ()

     Return the output speed of the terminal in bits per second.  On
     software terminal emulators it will have a fixed high value.
     Included for historical reasons; in former times, it was used to
     write output loops for time delays and occasionally to change
     interfaces depending on the line speed.

 -- Function: curses.beep ()

     Emit a short attention sound.

 -- Function: curses.can_change_color ()

     Return ‘True’ or ‘False’, depending on whether the programmer can
     change the colors displayed by the terminal.

 -- Function: curses.cbreak ()

     Enter cbreak mode.  In cbreak mode (sometimes called "rare" mode)
     normal tty line buffering is turned off and characters are
     available to be read one by one.  However, unlike raw mode, special
     characters (interrupt, quit, suspend, and flow control) retain
     their effects on the tty driver and calling program.  Calling first
     *note raw(): 1393. then *note cbreak(): 1392. leaves the terminal
     in cbreak mode.

 -- Function: curses.color_content (color_number)

     Return the intensity of the red, green, and blue (RGB) components
     in the color _color_number_, which must be between ‘0’ and
     ‘COLORS’.  A 3-tuple is returned, containing the R,G,B values for
     the given color, which will be between ‘0’ (no component) and
     ‘1000’ (maximum amount of component).

 -- Function: curses.color_pair (color_number)

     Return the attribute value for displaying text in the specified
     color.  This attribute value can be combined with ‘A_STANDOUT’,
     ‘A_REVERSE’, and the other ‘A_*’ attributes.  *note pair_number():
     1396. is the counterpart to this function.

 -- Function: curses.curs_set (visibility)

     Set the cursor state.  _visibility_ can be set to 0, 1, or 2, for
     invisible, normal, or very visible.  If the terminal supports the
     visibility requested, the previous cursor state is returned;
     otherwise, an exception is raised.  On many terminals, the
     "visible" mode is an underline cursor and the "very visible" mode
     is a block cursor.

 -- Function: curses.def_prog_mode ()

     Save the current terminal mode as the "program" mode, the mode when
     the running program is using curses.  (Its counterpart is the
     "shell" mode, for when the program is not in curses.)  Subsequent
     calls to *note reset_prog_mode(): 1399. will restore this mode.

 -- Function: curses.def_shell_mode ()

     Save the current terminal mode as the "shell" mode, the mode when
     the running program is not using curses.  (Its counterpart is the
     "program" mode, when the program is using curses capabilities.)
     Subsequent calls to *note reset_shell_mode(): 139b. will restore
     this mode.

 -- Function: curses.delay_output (ms)

     Insert an _ms_ millisecond pause in output.

 -- Function: curses.doupdate ()

     Update the physical screen.  The curses library keeps two data
     structures, one representing the current physical screen contents
     and a virtual screen representing the desired next state.  The
     *note doupdate(): 139d. ground updates the physical screen to match
     the virtual screen.

     The virtual screen may be updated by a ‘noutrefresh()’ call after
     write operations such as ‘addstr()’ have been performed on a
     window.  The normal ‘refresh()’ call is simply ‘noutrefresh()’
     followed by *note doupdate(): 139d.; if you have to update multiple
     windows, you can speed performance and perhaps reduce screen
     flicker by issuing ‘noutrefresh()’ calls on all windows, followed
     by a single *note doupdate(): 139d.

 -- Function: curses.echo ()

     Enter echo mode.  In echo mode, each character input is echoed to
     the screen as it is entered.

 -- Function: curses.endwin ()

     De-initialize the library, and return terminal to normal status.

 -- Function: curses.erasechar ()

     Return the user’s current erase character.  Under Unix operating
     systems this is a property of the controlling tty of the curses
     program, and is not set by the curses library itself.

 -- Function: curses.filter ()

     The *note filter(): 13a1. routine, if used, must be called before
     *note initscr(): 13a2. is called.  The effect is that, during those
     calls, ‘LINES’ is set to 1; the capabilities clear, cup, cud, cud1,
     cuu1, cuu, vpa are disabled; and the home string is set to the
     value of cr.  The effect is that the cursor is confined to the
     current line, and so are screen updates.  This may be used for
     enabling character-at-a-time line editing without touching the rest
     of the screen.

 -- Function: curses.flash ()

     Flash the screen.  That is, change it to reverse-video and then
     change it back in a short interval.  Some people prefer such as
     ’visible bell’ to the audible attention signal produced by *note
     beep(): 1390.

 -- Function: curses.flushinp ()

     Flush all input buffers.  This throws away any typeahead that has
     been typed by the user and has not yet been processed by the
     program.

 -- Function: curses.getmouse ()

     After ‘getch()’ returns ‘KEY_MOUSE’ to signal a mouse event, this
     method should be call to retrieve the queued mouse event,
     represented as a 5-tuple ‘(id, x, y, z, bstate)’.  _id_ is an ID
     value used to distinguish multiple devices, and _x_, _y_, _z_ are
     the event’s coordinates.  (_z_ is currently unused.)  _bstate_ is
     an integer value whose bits will be set to indicate the type of
     event, and will be the bitwise OR of one or more of the following
     constants, where _n_ is the button number from 1 to 4:
     ‘BUTTONn_PRESSED’, ‘BUTTONn_RELEASED’, ‘BUTTONn_CLICKED’,
     ‘BUTTONn_DOUBLE_CLICKED’, ‘BUTTONn_TRIPLE_CLICKED’, ‘BUTTON_SHIFT’,
     ‘BUTTON_CTRL’, ‘BUTTON_ALT’.

 -- Function: curses.getsyx ()

     Return the current coordinates of the virtual screen cursor in y
     and x.  If leaveok is currently true, then -1,-1 is returned.

 -- Function: curses.getwin (file)

     Read window related data stored in the file by an earlier
     ‘putwin()’ call.  The routine then creates and initializes a new
     window using that data, returning the new window object.

 -- Function: curses.has_colors ()

     Return ‘True’ if the terminal can display colors; otherwise, return
     ‘False’.

 -- Function: curses.has_ic ()

     Return ‘True’ if the terminal has insert- and delete-character
     capabilities.  This function is included for historical reasons
     only, as all modern software terminal emulators have such
     capabilities.

 -- Function: curses.has_il ()

     Return ‘True’ if the terminal has insert- and delete-line
     capabilities, or can simulate them using scrolling regions.  This
     function is included for historical reasons only, as all modern
     software terminal emulators have such capabilities.

 -- Function: curses.has_key (ch)

     Take a key value _ch_, and return ‘True’ if the current terminal
     type recognizes a key with that value.

 -- Function: curses.halfdelay (tenths)

     Used for half-delay mode, which is similar to cbreak mode in that
     characters typed by the user are immediately available to the
     program.  However, after blocking for _tenths_ tenths of seconds,
     an exception is raised if nothing has been typed.  The value of
     _tenths_ must be a number between ‘1’ and ‘255’.  Use *note
     nocbreak(): 13ad. to leave half-delay mode.

 -- Function: curses.init_color (color_number, r, g, b)

     Change the definition of a color, taking the number of the color to
     be changed followed by three RGB values (for the amounts of red,
     green, and blue components).  The value of _color_number_ must be
     between ‘0’ and ‘COLORS’.  Each of _r_, _g_, _b_, must be a value
     between ‘0’ and ‘1000’.  When *note init_color(): 13ae. is used,
     all occurrences of that color on the screen immediately change to
     the new definition.  This function is a no-op on most terminals; it
     is active only if *note can_change_color(): 1391. returns ‘1’.

 -- Function: curses.init_pair (pair_number, fg, bg)

     Change the definition of a color-pair.  It takes three arguments:
     the number of the color-pair to be changed, the foreground color
     number, and the background color number.  The value of
     _pair_number_ must be between ‘1’ and ‘COLOR_PAIRS - 1’ (the ‘0’
     color pair is wired to white on black and cannot be changed).  The
     value of _fg_ and _bg_ arguments must be between ‘0’ and ‘COLORS’.
     If the color-pair was previously initialized, the screen is
     refreshed and all occurrences of that color-pair are changed to the
     new definition.

 -- Function: curses.initscr ()

     Initialize the library.  Return a ‘WindowObject’ which represents
     the whole screen.

          Note: If there is an error opening the terminal, the
          underlying curses library may cause the interpreter to exit.

 -- Function: curses.is_term_resized (nlines, ncols)

     Return ‘True’ if *note resize_term(): 13b1. would modify the window
     structure, ‘False’ otherwise.

 -- Function: curses.isendwin ()

     Return ‘True’ if *note endwin(): 139f. has been called (that is,
     the curses library has been deinitialized).

 -- Function: curses.keyname (k)

     Return the name of the key numbered _k_.  The name of a key
     generating printable ASCII character is the key’s character.  The
     name of a control-key combination is a two-character string
     consisting of a caret followed by the corresponding printable ASCII
     character.  The name of an alt-key combination (128-255) is a
     string consisting of the prefix ’M-’ followed by the name of the
     corresponding ASCII character.

 -- Function: curses.killchar ()

     Return the user’s current line kill character.  Under Unix
     operating systems this is a property of the controlling tty of the
     curses program, and is not set by the curses library itself.

 -- Function: curses.longname ()

     Return a string containing the terminfo long name field describing
     the current terminal.  The maximum length of a verbose description
     is 128 characters.  It is defined only after the call to *note
     initscr(): 13a2.

 -- Function: curses.meta (yes)

     If _yes_ is 1, allow 8-bit characters to be input.  If _yes_ is 0,
     allow only 7-bit chars.

 -- Function: curses.mouseinterval (interval)

     Set the maximum time in milliseconds that can elapse between press
     and release events in order for them to be recognized as a click,
     and return the previous interval value.  The default value is 200
     msec, or one fifth of a second.

 -- Function: curses.mousemask (mousemask)

     Set the mouse events to be reported, and return a tuple
     ‘(availmask, oldmask)’.  _availmask_ indicates which of the
     specified mouse events can be reported; on complete failure it
     returns 0.  _oldmask_ is the previous value of the given window’s
     mouse event mask.  If this function is never called, no mouse
     events are ever reported.

 -- Function: curses.napms (ms)

     Sleep for _ms_ milliseconds.

 -- Function: curses.newpad (nlines, ncols)

     Create and return a pointer to a new pad data structure with the
     given number of lines and columns.  A pad is returned as a window
     object.

     A pad is like a window, except that it is not restricted by the
     screen size, and is not necessarily associated with a particular
     part of the screen.  Pads can be used when a large window is
     needed, and only a part of the window will be on the screen at one
     time.  Automatic refreshes of pads (such as from scrolling or
     echoing of input) do not occur.  The ‘refresh()’ and
     ‘noutrefresh()’ methods of a pad require 6 arguments to specify the
     part of the pad to be displayed and the location on the screen to
     be used for the display.  The arguments are _pminrow_, _pmincol_,
     _sminrow_, _smincol_, _smaxrow_, _smaxcol_; the _p_ arguments refer
     to the upper left corner of the pad region to be displayed and the
     _s_ arguments define a clipping box on the screen within which the
     pad region is to be displayed.

 -- Function: curses.newwin (nlines, ncols)

 -- Function: curses.newwin (nlines, ncols, begin_y, begin_x)

     Return a new window, whose left-upper corner is at ‘(begin_y,
     begin_x)’, and whose height/width is _nlines_/_ncols_.

     By default, the window will extend from the specified position to
     the lower right corner of the screen.

 -- Function: curses.nl ()

     Enter newline mode.  This mode translates the return key into
     newline on input, and translates newline into return and line-feed
     on output.  Newline mode is initially on.

 -- Function: curses.nocbreak ()

     Leave cbreak mode.  Return to normal "cooked" mode with line
     buffering.

 -- Function: curses.noecho ()

     Leave echo mode.  Echoing of input characters is turned off.

 -- Function: curses.nonl ()

     Leave newline mode.  Disable translation of return into newline on
     input, and disable low-level translation of newline into
     newline/return on output (but this does not change the behavior of
     ‘addch('\n')’, which always does the equivalent of return and line
     feed on the virtual screen).  With translation off, curses can
     sometimes speed up vertical motion a little; also, it will be able
     to detect the return key on input.

 -- Function: curses.noqiflush ()

     When the *note noqiflush(): 13bf. routine is used, normal flush of
     input and output queues associated with the INTR, QUIT and SUSP
     characters will not be done.  You may want to call *note
     noqiflush(): 13bf. in a signal handler if you want output to
     continue as though the interrupt had not occurred, after the
     handler exits.

 -- Function: curses.noraw ()

     Leave raw mode.  Return to normal "cooked" mode with line
     buffering.

 -- Function: curses.pair_content (pair_number)

     Return a tuple ‘(fg, bg)’ containing the colors for the requested
     color pair.  The value of _pair_number_ must be between ‘1’ and
     ‘COLOR_PAIRS - 1’.

 -- Function: curses.pair_number (attr)

     Return the number of the color-pair set by the attribute value
     _attr_.  *note color_pair(): 1395. is the counterpart to this
     function.

 -- Function: curses.putp (string)

     Equivalent to ‘tputs(str, 1, putchar)’; emit the value of a
     specified terminfo capability for the current terminal.  Note that
     the output of *note putp(): 13c2. always goes to standard output.

 -- Function: curses.qiflush ([flag])

     If _flag_ is ‘False’, the effect is the same as calling *note
     noqiflush(): 13bf.  If _flag_ is ‘True’, or no argument is
     provided, the queues will be flushed when these control characters
     are read.

 -- Function: curses.raw ()

     Enter raw mode.  In raw mode, normal line buffering and processing
     of interrupt, quit, suspend, and flow control keys are turned off;
     characters are presented to curses input functions one by one.

 -- Function: curses.reset_prog_mode ()

     Restore the terminal to "program" mode, as previously saved by
     *note def_prog_mode(): 1398.

 -- Function: curses.reset_shell_mode ()

     Restore the terminal to "shell" mode, as previously saved by *note
     def_shell_mode(): 139a.

 -- Function: curses.resetty ()

     Restore the state of the terminal modes to what it was at the last
     call to *note savetty(): 13c5.

 -- Function: curses.resize_term (nlines, ncols)

     Backend function used by *note resizeterm(): 13c6, performing most
     of the work; when resizing the windows, *note resize_term(): 13b1.
     blank-fills the areas that are extended.  The calling application
     should fill in these areas with appropriate data.  The *note
     resize_term(): 13b1. function attempts to resize all windows.
     However, due to the calling convention of pads, it is not possible
     to resize these without additional interaction with the
     application.

 -- Function: curses.resizeterm (nlines, ncols)

     Resize the standard and current windows to the specified
     dimensions, and adjusts other bookkeeping data used by the curses
     library that record the window dimensions (in particular the
     SIGWINCH handler).

 -- Function: curses.savetty ()

     Save the current state of the terminal modes in a buffer, usable by
     *note resetty(): 13c4.

 -- Function: curses.setsyx (y, x)

     Set the virtual screen cursor to _y_, _x_.  If _y_ and _x_ are both
     -1, then leaveok is set.

 -- Function: curses.setupterm ([termstr, fd])

     Initialize the terminal.  _termstr_ is a string giving the terminal
     name; if omitted, the value of the ‘TERM’ environment variable will
     be used.  _fd_ is the file descriptor to which any initialization
     sequences will be sent; if not supplied, the file descriptor for
     ‘sys.stdout’ will be used.

 -- Function: curses.start_color ()

     Must be called if the programmer wants to use colors, and before
     any other color manipulation routine is called.  It is good
     practice to call this routine right after *note initscr(): 13a2.

     *note start_color(): 13c9. initializes eight basic colors (black,
     red, green, yellow, blue, magenta, cyan, and white), and two global
     variables in the *note curses: 79. module, ‘COLORS’ and
     ‘COLOR_PAIRS’, containing the maximum number of colors and
     color-pairs the terminal can support.  It also restores the colors
     on the terminal to the values they had when the terminal was just
     turned on.

 -- Function: curses.termattrs ()

     Return a logical OR of all video attributes supported by the
     terminal.  This information is useful when a curses program needs
     complete control over the appearance of the screen.

 -- Function: curses.termname ()

     Return the value of the environment variable ‘TERM’, truncated to
     14 characters.

 -- Function: curses.tigetflag (capname)

     Return the value of the Boolean capability corresponding to the
     terminfo capability name _capname_.  The value ‘-1’ is returned if
     _capname_ is not a Boolean capability, or ‘0’ if it is canceled or
     absent from the terminal description.

 -- Function: curses.tigetnum (capname)

     Return the value of the numeric capability corresponding to the
     terminfo capability name _capname_.  The value ‘-2’ is returned if
     _capname_ is not a numeric capability, or ‘-1’ if it is canceled or
     absent from the terminal description.

 -- Function: curses.tigetstr (capname)

     Return the value of the string capability corresponding to the
     terminfo capability name _capname_.  ‘None’ is returned if
     _capname_ is not a string capability, or is canceled or absent from
     the terminal description.

 -- Function: curses.tparm (str[, ...])

     Instantiate the string _str_ with the supplied parameters, where
     _str_ should be a parameterized string obtained from the terminfo
     database.  E.g.  ‘tparm(tigetstr("cup"), 5, 3)’ could result in
     ‘'\033[6;4H'’, the exact result depending on terminal type.

 -- Function: curses.typeahead (fd)

     Specify that the file descriptor _fd_ be used for typeahead
     checking.  If _fd_ is ‘-1’, then no typeahead checking is done.

     The curses library does "line-breakout optimization" by looking for
     typeahead periodically while updating the screen.  If input is
     found, and it is coming from a tty, the current update is postponed
     until refresh or doupdate is called again, allowing faster response
     to commands typed in advance.  This function allows specifying a
     different file descriptor for typeahead checking.

 -- Function: curses.unctrl (ch)

     Return a string which is a printable representation of the
     character _ch_.  Control characters are displayed as a caret
     followed by the character, for example as ‘^C’.  Printing
     characters are left as they are.

 -- Function: curses.ungetch (ch)

     Push _ch_ so the next ‘getch()’ will return it.

          Note: Only one _ch_ can be pushed before ‘getch()’ is called.

 -- Function: curses.ungetmouse (id, x, y, z, bstate)

     Push a ‘KEY_MOUSE’ event onto the input queue, associating the
     given state data with it.

 -- Function: curses.use_env (flag)

     If used, this function should be called before *note initscr():
     13a2. or newterm are called.  When _flag_ is ‘False’, the values of
     lines and columns specified in the terminfo database will be used,
     even if environment variables ‘LINES’ and ‘COLUMNS’ (used by
     default) are set, or if curses is running in a window (in which
     case default behavior would be to use the window size if ‘LINES’
     and ‘COLUMNS’ are not set).

 -- Function: curses.use_default_colors ()

     Allow use of default values for colors on terminals supporting this
     feature.  Use this to support transparency in your application.
     The default color is assigned to the color number -1.  After
     calling this function, ‘init_pair(x, curses.COLOR_RED, -1)’
     initializes, for instance, color pair _x_ to a red foreground color
     on the default background.

 -- Function: curses.wrapper (func, ...)

     Initialize curses and call another callable object, _func_, which
     should be the rest of your curses-using application.  If the
     application raises an exception, this function will restore the
     terminal to a sane state before re-raising the exception and
     generating a traceback.  The callable object _func_ is then passed
     the main window ’stdscr’ as its first argument, followed by any
     other arguments passed to *note wrapper(): 13d6.  Before calling
     _func_, *note wrapper(): 13d6. turns on cbreak mode, turns off
     echo, enables the terminal keypad, and initializes colors if the
     terminal has color support.  On exit (whether normally or by
     exception) it restores cooked mode, turns on echo, and disables the
     terminal keypad.

