This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: email parser Parsing email messages,  Next: email generator Generating MIME documents,  Prev: email message Representing an email message,  Up: email --- An email and MIME handling package

5.18.1.2 ‘email.parser’: Parsing email messages
...............................................

Message object structures can be created in one of two ways: they can be
created from whole cloth by instantiating *note Message: 216. objects
and stringing them together via *note attach(): 17d5. and *note
set_payload(): 17d6. calls, or they can be created by parsing a flat
text representation of the email message.

  The *note email: bb. package provides a standard parser that
understands most email document structures, including MIME documents.
You can pass the parser a string or a file object, and the parser will
return to you the root *note Message: 216. instance of the object
structure.  For simple, non-MIME messages the payload of this root
object will likely be a string containing the text of the message.  For
MIME messages, the root object will return ‘True’ from its *note
is_multipart(): 17d2. method, and the subparts can be accessed via the
*note get_payload(): 17d7. and *note walk(): 17fa. methods.

  There are actually two parser interfaces available for use, the
classic *note Parser: 17fc. API and the incremental *note FeedParser:
1801. API. The classic *note Parser: 17fc. API is fine if you have the
entire text of the message in memory as a string, or if the entire
message lives in a file on the file system.  *note FeedParser: 1801. is
more appropriate for when you’re reading the message from a stream which
might block waiting for more input (e.g.  reading an email message from
a socket).  The *note FeedParser: 1801. can consume and parse the
message incrementally, and only returns the root object when you close
the parser (1).

  Note that the parser can be extended in limited ways, and of course
you can implement your own parser completely from scratch.  There is no
magical connection between the *note email: bb. package’s bundled parser
and the *note Message: 216. class, so your custom parser can create
message object trees any way it finds necessary.

* Menu:

* FeedParser API:: 
* Parser class API:: 
* Additional notes:: 

   ---------- Footnotes ----------

   (1) As of email package version 3.0, introduced in Python 2.4, the
classic *note Parser: 17fc. was re-implemented in terms of the *note
FeedParser: 1801, so the semantics and results are identical between the
two parsers.


File: python.info,  Node: FeedParser API,  Next: Parser class API,  Up: email parser Parsing email messages

5.18.1.3 FeedParser API
.......................

New in version 2.4.

  The *note FeedParser: 1801, imported from the ‘email.feedparser’
module, provides an API that is conducive to incremental parsing of
email messages, such as would be necessary when reading the text of an
email message from a source that can block (e.g.  a socket).  The *note
FeedParser: 1801. can of course be used to parse an email message fully
contained in a string or a file, but the classic *note Parser: 17fc. API
may be more convenient for such use cases.  The semantics and results of
the two parser APIs are identical.

  The *note FeedParser: 1801.’s API is simple; you create an instance,
feed it a bunch of text until there’s no more to feed it, then close the
parser to retrieve the root message object.  The *note FeedParser: 1801.
is extremely accurate when parsing standards-compliant messages, and it
does a very good job of parsing non-compliant messages, providing
information about how a message was deemed broken.  It will populate a
message object’s _defects_ attribute with a list of any problems it
found in a message.  See the *note email.errors: be. module for the list
of defects that it can find.

  Here is the API for the *note FeedParser: 1801.:

 -- Class: email.parser.FeedParser ([_factory])

     Create a *note FeedParser: 1801. instance.  Optional __factory_ is
     a no-argument callable that will be called whenever a new message
     object is needed.  It defaults to the *note email.message.Message:
     216. class.

      -- Method: feed (data)

          Feed the *note FeedParser: 1801. some more data.  _data_
          should be a string containing one or more lines.  The lines
          can be partial and the *note FeedParser: 1801. will stitch
          such partial lines together properly.  The lines in the string
          can have any of the common three line endings, carriage
          return, newline, or carriage return and newline (they can even
          be mixed).

      -- Method: close ()

          Closing a *note FeedParser: 1801. completes the parsing of all
          previously fed data, and returns the root message object.  It
          is undefined what happens if you feed more data to a closed
          *note FeedParser: 1801.


File: python.info,  Node: Parser class API,  Next: Additional notes,  Prev: FeedParser API,  Up: email parser Parsing email messages

5.18.1.4 Parser class API
.........................

The *note Parser: 17fc. class, imported from the *note email.parser: c4.
module, provides an API that can be used to parse a message when the
complete contents of the message are available in a string or file.  The
*note email.parser: c4. module also provides a second class, called
‘HeaderParser’ which can be used if you’re only interested in the
headers of the message.  ‘HeaderParser’ can be much faster in these
situations, since it does not attempt to parse the message body, instead
setting the payload to the raw body as a string.  ‘HeaderParser’ has the
same API as the *note Parser: 17fc. class.

 -- Class: email.parser.Parser ([_class])

     The constructor for the *note Parser: 17fc. class takes an optional
     argument __class_.  This must be a callable factory (such as a
     function or a class), and it is used whenever a sub-message object
     needs to be created.  It defaults to *note Message: 216. (see *note
     email.message: c2.).  The factory will be called without arguments.

     The optional _strict_ flag is ignored.

     Deprecated since version 2.4: Because the *note Parser: 17fc. class
     is a backward compatible API wrapper around the new-in-Python 2.4
     *note FeedParser: 1801, _all_ parsing is effectively non-strict.
     You should simply stop passing a _strict_ flag to the *note Parser:
     17fc. constructor.

     Changed in version 2.2.2: The _strict_ flag was added.

     Changed in version 2.4: The _strict_ flag was deprecated.

     The other public *note Parser: 17fc. methods are:

      -- Method: parse (fp[, headersonly])

          Read all the data from the file-like object _fp_, parse the
          resulting text, and return the root message object.  _fp_ must
          support both the *note readline(): 887. and the *note read():
          11e1. methods on file-like objects.

          The text contained in _fp_ must be formatted as a block of RFC
          2822(1) style headers and header continuation lines,
          optionally preceded by a envelope header.  The header block is
          terminated either by the end of the data or by a blank line.
          Following the header block is the body of the message (which
          may contain MIME-encoded subparts).

          Optional _headersonly_ is a flag specifying whether to stop
          parsing after reading the headers or not.  The default is
          ‘False’, meaning it parses the entire contents of the file.

          Changed in version 2.2.2: The _headersonly_ flag was added.

      -- Method: parsestr (text[, headersonly])

          Similar to the *note parse(): 1806. method, except it takes a
          string object instead of a file-like object.  Calling this
          method on a string is exactly equivalent to wrapping _text_ in
          a *note StringIO: 2dd. instance first and calling *note
          parse(): 1806.

          Optional _headersonly_ is as with the *note parse(): 1806.
          method.

          Changed in version 2.2.2: The _headersonly_ flag was added.

  Since creating a message object structure from a string or a file
object is such a common task, two functions are provided as a
convenience.  They are available in the top-level *note email: bb.
package namespace.

 -- Function: email.message_from_string (s[, _class[, strict]])

     Return a message object structure from a string.  This is exactly
     equivalent to ‘Parser().parsestr(s)’.  Optional __class_ and
     _strict_ are interpreted as with the *note Parser: 17fc. class
     constructor.

     Changed in version 2.2.2: The _strict_ flag was added.

 -- Function: email.message_from_file (fp[, _class[, strict]])

     Return a message object structure tree from an open file object.
     This is exactly equivalent to ‘Parser().parse(fp)’.  Optional
     __class_ and _strict_ are interpreted as with the *note Parser:
     17fc. class constructor.

     Changed in version 2.2.2: The _strict_ flag was added.

  Here’s an example of how you might use this at an interactive Python
prompt:

     >>> import email
     >>> msg = email.message_from_string(myString)

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Additional notes,  Prev: Parser class API,  Up: email parser Parsing email messages

5.18.1.5 Additional notes
.........................

Here are some notes on the parsing semantics:

   * Most non-‘multipart’ type messages are parsed as a single message
     object with a string payload.  These objects will return ‘False’
     for *note is_multipart(): 17d2.  Their *note get_payload(): 17d7.
     method will return a string object.

   * All ‘multipart’ type messages will be parsed as a container message
     object with a list of sub-message objects for their payload.  The
     outer container message will return ‘True’ for *note
     is_multipart(): 17d2. and their *note get_payload(): 17d7. method
     will return the list of *note Message: 216. subparts.

   * Most messages with a content type of ‘message/*’ (e.g.
     ‘message/delivery-status’ and ‘message/rfc822’) will also be parsed
     as container object containing a list payload of length 1.  Their
     *note is_multipart(): 17d2. method will return ‘True’.  The single
     element in the list payload will be a sub-message object.

   * Some non-standards compliant messages may not be internally
     consistent about their ‘multipart’-edness.  Such messages may have
     a ‘Content-Type’ header of type ‘multipart’, but their *note
     is_multipart(): 17d2. method may return ‘False’.  If such messages
     were parsed with the *note FeedParser: 1801, they will have an
     instance of the ‘MultipartInvariantViolationDefect’ class in their
     _defects_ attribute list.  See *note email.errors: be. for details.


File: python.info,  Node: email generator Generating MIME documents,  Next: email mime Creating email and MIME objects from scratch,  Prev: email parser Parsing email messages,  Up: email --- An email and MIME handling package

5.18.1.6 ‘email.generator’: Generating MIME documents
.....................................................

One of the most common tasks is to generate the flat text of the email
message represented by a message object structure.  You will need to do
this if you want to send your message via the *note smtplib: 15a. module
or the *note nntplib: 124. module, or print the message on the console.
Taking a message object structure and producing a flat text document is
the job of the *note Generator: 17cf. class.

  Again, as with the *note email.parser: c4. module, you aren’t limited
to the functionality of the bundled generator; you could write one from
scratch yourself.  However the bundled generator knows how to generate
most email in a standards-compliant way, should handle MIME and non-MIME
email messages just fine, and is designed so that the transformation
from flat text, to a message structure via the *note Parser: 17fc.
class, and back to flat text, is idempotent (the input is identical to
the output) (1).  On the other hand, using the Generator on a *note
Message: 216. constructed by program may result in changes to the *note
Message: 216. object as defaults are filled in.

  Here are the public methods of the *note Generator: 17cf. class,
imported from the *note email.generator: bf. module:

 -- Class: email.generator.Generator (outfp[, mangle_from_[,
          maxheaderlen]])

     The constructor for the *note Generator: 17cf. class takes a
     file-like object called _outfp_ for an argument.  _outfp_ must
     support the *note write(): 180d. method and be usable as the output
     file in a Python extended print statement.

     Optional _mangle_from__ is a flag that, when ‘True’, puts a ‘>’
     character in front of any line in the body that starts exactly as
     ‘From’, i.e.  ‘From’ followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD(2) for
     details).  _mangle_from__ defaults to ‘True’, but you might want to
     set this to ‘False’ if you are not writing Unix mailbox format
     files.

     Optional _maxheaderlen_ specifies the longest length for a
     non-continued header.  When a header line is longer than
     _maxheaderlen_ (in characters, with tabs expanded to 8 spaces), the
     header will be split as defined in the *note Header: 180e. class.
     Set to zero to disable header wrapping.  The default is 78, as
     recommended (but not required) by RFC 2822(3).

     The other public *note Generator: 17cf. methods are:

      -- Method: flatten (msg[, unixfrom])

          Print the textual representation of the message object
          structure rooted at _msg_ to the output file specified when
          the *note Generator: 17cf. instance was created.  Subparts are
          visited depth-first and the resulting text will be properly
          MIME encoded.

          Optional _unixfrom_ is a flag that forces the printing of the
          envelope header delimiter before the first RFC 2822(4) header
          of the root message object.  If the root object has no
          envelope header, a standard one is crafted.  By default, this
          is set to ‘False’ to inhibit the printing of the envelope
          delimiter.

          Note that for subparts, no envelope header is ever printed.

          New in version 2.2.2.

      -- Method: clone (fp)

          Return an independent clone of this *note Generator: 17cf.
          instance with the exact same options.

          New in version 2.2.2.

      -- Method: write (s)

          Write the string _s_ to the underlying file object, i.e.
          _outfp_ passed to *note Generator: 17cf.’s constructor.  This
          provides just enough file-like API for *note Generator: 17cf.
          instances to be used in extended print statements.

  As a convenience, see the methods ‘Message.as_string()’ and
‘str(aMessage)’, a.k.a.  ‘Message.__str__()’, which simplify the
generation of a formatted string representation of a message object.
For more detail, see *note email.message: c2.

  The *note email.generator: bf. module also provides a derived class,
called *note DecodedGenerator: 1810. which is like the *note Generator:
17cf. base class, except that non-‘text’ parts are substituted with a
format string representing the part.

 -- Class: email.generator.DecodedGenerator (outfp[, mangle_from_[,
          maxheaderlen[, fmt]]])

     This class, derived from *note Generator: 17cf. walks through all
     the subparts of a message.  If the subpart is of main type ‘text’,
     then it prints the decoded payload of the subpart.  Optional
     __mangle_from__ and _maxheaderlen_ are as with the *note Generator:
     17cf. base class.

     If the subpart is not of main type ‘text’, optional _fmt_ is a
     format string that is used instead of the message payload.  _fmt_
     is expanded with the following keywords, ‘%(keyword)s’ format:

        * ‘type’ – Full MIME type of the non-‘text’ part

        * ‘maintype’ – Main MIME type of the non-‘text’ part

        * ‘subtype’ – Sub-MIME type of the non-‘text’ part

        * ‘filename’ – Filename of the non-‘text’ part

        * ‘description’ – Description associated with the non-‘text’
          part

        * ‘encoding’ – Content transfer encoding of the non-‘text’ part

     The default value for _fmt_ is ‘None’, meaning

          [Non-text (%(type)s) part of message omitted, filename %(filename)s]

     New in version 2.2.2.

  Changed in version 2.5: The previously deprecated method *note
__call__(): 6fa. was removed.

   ---------- Footnotes ----------

   (1) This statement assumes that you use the appropriate setting for
the ‘unixfrom’ argument, and that you set maxheaderlen=0 (which will
preserve whatever the input line lengths were).  It is also not strictly
true, since in many cases runs of whitespace in headers are collapsed
into single blanks.  The latter is a bug that will eventually be fixed.

   (2) http://www.jwz.org/doc/content-length.html

   (3) http://tools.ietf.org/html/rfc2822.html

   (4) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email mime Creating email and MIME objects from scratch,  Next: email header Internationalized headers,  Prev: email generator Generating MIME documents,  Up: email --- An email and MIME handling package

5.18.1.7 ‘email.mime’: Creating email and MIME objects from scratch
...................................................................

Ordinarily, you get a message object structure by passing a file or some
text to a parser, which parses the text and returns the root message
object.  However you can also build a complete message structure from
scratch, or even individual *note Message: 216. objects by hand.  In
fact, you can also take an existing structure and add new *note Message:
216. objects, move them around, etc.  This makes a very convenient
interface for slicing-and-dicing MIME messages.

  You can create a new object structure by creating *note Message: 216.
instances, adding attachments and all the appropriate headers manually.
For MIME messages though, the *note email: bb. package provides some
convenient subclasses to make things easier.

  Here are the classes:

 -- Class: email.mime.base.MIMEBase (_maintype, _subtype, **_params)

     Module: ‘email.mime.base’

     This is the base class for all the MIME-specific subclasses of
     *note Message: 216.  Ordinarily you won’t create instances
     specifically of *note MIMEBase: 1813, although you could.  *note
     MIMEBase: 1813. is provided primarily as a convenient base class
     for more specific MIME-aware subclasses.

     __maintype_ is the ‘Content-Type’ major type (e.g.  ‘text’ or
     ‘image’), and __subtype_ is the ‘Content-Type’ minor type (e.g.
     ‘plain’ or ‘gif’).  __params_ is a parameter key/value dictionary
     and is passed directly to *note Message.add_header: 17e6.

     The *note MIMEBase: 1813. class always adds a ‘Content-Type’ header
     (based on __maintype_, __subtype_, and __params_), and a
     ‘MIME-Version’ header (always set to ‘1.0’).

 -- Class: email.mime.nonmultipart.MIMENonMultipart

     Module: ‘email.mime.nonmultipart’

     A subclass of *note MIMEBase: 1813, this is an intermediate base
     class for MIME messages that are not ‘multipart’.  The primary
     purpose of this class is to prevent the use of the *note attach():
     17d5. method, which only makes sense for ‘multipart’ messages.  If
     *note attach(): 17d5. is called, a *note MultipartConversionError:
     1815. exception is raised.

     New in version 2.2.2.

 -- Class: email.mime.multipart.MIMEMultipart ([_subtype[, boundary[,
          _subparts[, _params]]]])

     Module: ‘email.mime.multipart’

     A subclass of *note MIMEBase: 1813, this is an intermediate base
     class for MIME messages that are ‘multipart’.  Optional __subtype_
     defaults to ‘mixed’, but can be used to specify the subtype of the
     message.  A ‘Content-Type’ header of ‘multipart/_subtype’ will be
     added to the message object.  A ‘MIME-Version’ header will also be
     added.

     Optional _boundary_ is the multipart boundary string.  When ‘None’
     (the default), the boundary is calculated when needed (for example,
     when the message is serialized).

     __subparts_ is a sequence of initial subparts for the payload.  It
     must be possible to convert this sequence to a list.  You can
     always attach new subparts to the message by using the *note
     Message.attach: 17d5. method.

     Additional parameters for the ‘Content-Type’ header are taken from
     the keyword arguments, or passed into the __params_ argument, which
     is a keyword dictionary.

     New in version 2.2.2.

 -- Class: email.mime.application.MIMEApplication (_data[, _subtype[,
          _encoder[, **_params]]])

     Module: ‘email.mime.application’

     A subclass of *note MIMENonMultipart: 1814, the *note
     MIMEApplication: 1817. class is used to represent MIME message
     objects of major type ‘application’.  __data_ is a string
     containing the raw byte data.  Optional __subtype_ specifies the
     MIME subtype and defaults to ‘octet-stream’.

     Optional __encoder_ is a callable (i.e.  function) which will
     perform the actual encoding of the data for transport.  This
     callable takes one argument, which is the *note MIMEApplication:
     1817. instance.  It should use *note get_payload(): 17d7. and *note
     set_payload(): 17d6. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: bd. module for a list of the built-in
     encoders.

     __params_ are passed straight through to the base class
     constructor.

     New in version 2.5.

 -- Class: email.mime.audio.MIMEAudio (_audiodata[, _subtype[,
          _encoder[, **_params]]])

     Module: ‘email.mime.audio’

     A subclass of *note MIMENonMultipart: 1814, the *note MIMEAudio:
     1818. class is used to create MIME message objects of major type
     ‘audio’.  __audiodata_ is a string containing the raw audio data.
     If this data can be decoded by the standard Python module *note
     sndhdr: 15b, then the subtype will be automatically included in the
     ‘Content-Type’ header.  Otherwise you can explicitly specify the
     audio subtype via the __subtype_ parameter.  If the minor type
     could not be guessed and __subtype_ was not given, then *note
     TypeError: 218. is raised.

     Optional __encoder_ is a callable (i.e.  function) which will
     perform the actual encoding of the audio data for transport.  This
     callable takes one argument, which is the *note MIMEAudio: 1818.
     instance.  It should use *note get_payload(): 17d7. and *note
     set_payload(): 17d6. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: bd. module for a list of the built-in
     encoders.

     __params_ are passed straight through to the base class
     constructor.

 -- Class: email.mime.image.MIMEImage (_imagedata[, _subtype[,
          _encoder[, **_params]]])

     Module: ‘email.mime.image’

     A subclass of *note MIMENonMultipart: 1814, the *note MIMEImage:
     1819. class is used to create MIME message objects of major type
     ‘image’.  __imagedata_ is a string containing the raw image data.
     If this data can be decoded by the standard Python module *note
     imghdr: f4, then the subtype will be automatically included in the
     ‘Content-Type’ header.  Otherwise you can explicitly specify the
     image subtype via the __subtype_ parameter.  If the minor type
     could not be guessed and __subtype_ was not given, then *note
     TypeError: 218. is raised.

     Optional __encoder_ is a callable (i.e.  function) which will
     perform the actual encoding of the image data for transport.  This
     callable takes one argument, which is the *note MIMEImage: 1819.
     instance.  It should use *note get_payload(): 17d7. and *note
     set_payload(): 17d6. to change the payload to encoded form.  It
     should also add any ‘Content-Transfer-Encoding’ or other headers to
     the message object as necessary.  The default encoding is base64.
     See the *note email.encoders: bd. module for a list of the built-in
     encoders.

     __params_ are passed straight through to the *note MIMEBase: 1813.
     constructor.

 -- Class: email.mime.message.MIMEMessage (_msg[, _subtype])

     Module: ‘email.mime.message’

     A subclass of *note MIMENonMultipart: 1814, the *note MIMEMessage:
     181a. class is used to create MIME objects of main type ‘message’.
     __msg_ is used as the payload, and must be an instance of class
     *note Message: 216. (or a subclass thereof), otherwise a *note
     TypeError: 218. is raised.

     Optional __subtype_ sets the subtype of the message; it defaults to
     ‘rfc822’.

 -- Class: email.mime.text.MIMEText (_text[, _subtype[, _charset]])

     Module: ‘email.mime.text’

     A subclass of *note MIMENonMultipart: 1814, the *note MIMEText:
     181b. class is used to create MIME objects of major type ‘text’.
     __text_ is the string for the payload.  __subtype_ is the minor
     type and defaults to ‘plain’.  __charset_ is the character set of
     the text and is passed as a parameter to the *note
     MIMENonMultipart: 1814. constructor; it defaults to ‘us-ascii’.  If
     __text_ is unicode, it is encoded using the _output_charset_ of
     __charset_, otherwise it is used as-is.

     Changed in version 2.4: The previously deprecated __encoding_
     argument has been removed.  Content Transfer Encoding now happens
     implicitly based on the __charset_ argument.

     Unless the ‘_charset’ parameter is explicitly set to ‘None’, the
     MIMEText object created will have both a ‘Content-Type’ header with
     a ‘charset’ parameter, and a ‘Content-Transfer-Endcoding’ header.
     This means that a subsequent ‘set_payload’ call will not result in
     an encoded payload, even if a charset is passed in the
     ‘set_payload’ command.  You can "reset" this behavior by deleting
     the ‘Content-Transfer-Encoding’ header, after which a ‘set_payload’
     call will automatically encode the new payload (and add a new
     ‘Content-Transfer-Encoding’ header).


File: python.info,  Node: email header Internationalized headers,  Next: email charset Representing character sets,  Prev: email mime Creating email and MIME objects from scratch,  Up: email --- An email and MIME handling package

5.18.1.8 ‘email.header’: Internationalized headers
..................................................

RFC 2822(1) is the base standard that describes the format of email
messages.  It derives from the older RFC 822(2) standard which came into
widespread use at a time when most email was composed of ASCII
characters only.  RFC 2822(3) is a specification written assuming email
contains only 7-bit ASCII characters.

  Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now be
used in email messages.  The base standard still requires email messages
to be transferred using only 7-bit ASCII characters, so a slew of RFCs
have been written describing how to encode email containing non-ASCII
characters into RFC 2822(4)-compliant format.  These RFCs include RFC
2045(5), RFC 2046(6), RFC 2047(7), and RFC 2231(8).  The *note email:
bb. package supports these standards in its *note email.header: c0. and
*note email.charset: bc. modules.

  If you want to include non-ASCII characters in your email headers, say
in the ‘Subject’ or ‘To’ fields, you should use the *note Header: 180e.
class and assign the field in the *note Message: 216. object to an
instance of *note Header: 180e. instead of using a string for the header
value.  Import the *note Header: 180e. class from the *note
email.header: c0. module.  For example:

     >>> from email.message import Message
     >>> from email.header import Header
     >>> msg = Message()
     >>> h = Header('p\xf6stal', 'iso-8859-1')
     >>> msg['Subject'] = h
     >>> print msg.as_string()
     Subject: =?iso-8859-1?q?p=F6stal?=

  Notice here how we wanted the ‘Subject’ field to contain a non-ASCII
character?  We did this by creating a *note Header: 180e. instance and
passing in the character set that the byte string was encoded in.  When
the subsequent *note Message: 216. instance was flattened, the ‘Subject’
field was properly RFC 2047(9) encoded.  MIME-aware mail readers would
show this header using the embedded ISO-8859-1 character.

  New in version 2.2.2.

  Here is the *note Header: 180e. class description:

 -- Class: email.header.Header ([s[, charset[, maxlinelen[,
          header_name[, continuation_ws[, errors]]]]]])

     Create a MIME-compliant header that can contain strings in
     different character sets.

     Optional _s_ is the initial header value.  If ‘None’ (the default),
     the initial header value is not set.  You can later append to the
     header with *note append(): 181e. method calls.  _s_ may be a byte
     string or a Unicode string, but see the *note append(): 181e.
     documentation for semantics.

     Optional _charset_ serves two purposes: it has the same meaning as
     the _charset_ argument to the *note append(): 181e. method.  It
     also sets the default character set for all subsequent *note
     append(): 181e. calls that omit the _charset_ argument.  If
     _charset_ is not provided in the constructor (the default), the
     ‘us-ascii’ character set is used both as _s_’s initial charset and
     as the default for subsequent *note append(): 181e. calls.

     The maximum line length can be specified explicitly via
     _maxlinelen_.  For splitting the first line to a shorter value (to
     account for the field header which isn’t included in _s_, e.g.
     ‘Subject’) pass in the name of the field in _header_name_.  The
     default _maxlinelen_ is 76, and the default value for _header_name_
     is ‘None’, meaning it is not taken into account for the first line
     of a long, split header.

     Optional _continuation_ws_ must be RFC 2822(10)-compliant folding
     whitespace, and is usually either a space or a hard tab character.
     This character will be prepended to continuation lines.
     _continuation_ws_ defaults to a single space character (" ").

     Optional _errors_ is passed straight through to the *note append():
     181e. method.

      -- Method: append (s[, charset[, errors]])

          Append the string _s_ to the MIME header.

          Optional _charset_, if given, should be a *note Charset: 17d9.
          instance (see *note email.charset: bc.) or the name of a
          character set, which will be converted to a *note Charset:
          17d9. instance.  A value of ‘None’ (the default) means that
          the _charset_ given in the constructor is used.

          _s_ may be a byte string or a Unicode string.  If it is a byte
          string (i.e.  ‘isinstance(s, str)’ is true), then _charset_ is
          the encoding of that byte string, and a *note UnicodeError:
          433. will be raised if the string cannot be decoded with that
          character set.

          If _s_ is a Unicode string, then _charset_ is a hint
          specifying the character set of the characters in the string.
          In this case, when producing an RFC 2822(11)-compliant header
          using RFC 2047(12) rules, the Unicode string will be encoded
          using the following charsets in order: ‘us-ascii’, the
          _charset_ hint, ‘utf-8’.  The first character set to not
          provoke a *note UnicodeError: 433. is used.

          Optional _errors_ is passed through to any *note unicode():
          1f5. or ‘unicode.encode()’ call, and defaults to "strict".

      -- Method: encode ([splitchars])

          Encode a message header into an RFC-compliant format, possibly
          wrapping long lines and encapsulating non-ASCII parts in
          base64 or quoted-printable encodings.  Optional _splitchars_
          is a string containing characters to split long ASCII lines
          on, in rough support of RFC 2822(13)’s _highest level
          syntactic breaks_.  This doesn’t affect RFC 2047(14) encoded
          lines.

     The *note Header: 180e. class also provides a number of methods to
     support standard operators and built-in functions.

      -- Method: __str__ ()

          A synonym for *note Header.encode(): 181f.  Useful for
          ‘str(aHeader)’.

      -- Method: __unicode__ ()

          A helper for the built-in *note unicode(): 1f5. function.
          Returns the header as a Unicode string.

      -- Method: __eq__ (other)

          This method allows you to compare two *note Header: 180e.
          instances for equality.

      -- Method: __ne__ (other)

          This method allows you to compare two *note Header: 180e.
          instances for inequality.

  The *note email.header: c0. module also provides the following
convenient functions.

 -- Function: email.header.decode_header (header)

     Decode a message header value without converting the character set.
     The header value is in _header_.

     This function returns a list of ‘(decoded_string, charset)’ pairs
     containing each of the decoded parts of the header.  _charset_ is
     ‘None’ for non-encoded parts of the header, otherwise a lower case
     string containing the name of the character set specified in the
     encoded string.

     Here’s an example:

          >>> from email.header import decode_header
          >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
          [('p\xf6stal', 'iso-8859-1')]

 -- Function: email.header.make_header (decoded_seq[, maxlinelen[,
          header_name[, continuation_ws]]])

     Create a *note Header: 180e. instance from a sequence of pairs as
     returned by *note decode_header(): 1824.

     *note decode_header(): 1824. takes a header value string and
     returns a sequence of pairs of the format ‘(decoded_string,
     charset)’ where _charset_ is the name of the character set.

     This function takes one of those sequence of pairs and returns a
     *note Header: 180e. instance.  Optional _maxlinelen_,
     _header_name_, and _continuation_ws_ are as in the *note Header:
     180e. constructor.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html

   (2) http://tools.ietf.org/html/rfc822.html

   (3) http://tools.ietf.org/html/rfc2822.html

   (4) http://tools.ietf.org/html/rfc2822.html

   (5) http://tools.ietf.org/html/rfc2045.html

   (6) http://tools.ietf.org/html/rfc2046.html

   (7) http://tools.ietf.org/html/rfc2047.html

   (8) http://tools.ietf.org/html/rfc2231.html

   (9) http://tools.ietf.org/html/rfc2047.html

   (10) http://tools.ietf.org/html/rfc2822.html

   (11) http://tools.ietf.org/html/rfc2822.html

   (12) http://tools.ietf.org/html/rfc2047.html

   (13) http://tools.ietf.org/html/rfc2822.html

   (14) http://tools.ietf.org/html/rfc2047.html


File: python.info,  Node: email charset Representing character sets,  Next: email encoders Encoders,  Prev: email header Internationalized headers,  Up: email --- An email and MIME handling package

5.18.1.9 ‘email.charset’: Representing character sets
.....................................................

This module provides a class *note Charset: 17d9. for representing
character sets and character set conversions in email messages, as well
as a character set registry and several convenience methods for
manipulating this registry.  Instances of *note Charset: 17d9. are used
in several other modules within the *note email: bb. package.

  Import this class from the *note email.charset: bc. module.

  New in version 2.2.2.

 -- Class: email.charset.Charset ([input_charset])

     Map character sets to their email properties.

     This class provides information about the requirements imposed on
     email for a specific character set.  It also provides convenience
     routines for converting between character sets, given the
     availability of the applicable codecs.  Given a character set, it
     will do its best to provide information on how to use that
     character set in an email message in an RFC-compliant way.

     Certain character sets must be encoded with quoted-printable or
     base64 when used in email headers or bodies.  Certain character
     sets must be converted outright, and are not allowed in email.

     Optional _input_charset_ is as described below; it is always
     coerced to lower case.  After being alias normalized it is also
     used as a lookup into the registry of character sets to find out
     the header encoding, body encoding, and output conversion codec to
     be used for the character set.  For example, if _input_charset_ is
     ‘iso-8859-1’, then headers and bodies will be encoded using
     quoted-printable and no output conversion codec is necessary.  If
     _input_charset_ is ‘euc-jp’, then headers will be encoded with
     base64, bodies will not be encoded, but output text will be
     converted from the ‘euc-jp’ character set to the ‘iso-2022-jp’
     character set.

     *note Charset: 17d9. instances have the following data attributes:

      -- Attribute: input_charset

          The initial character set specified.  Common aliases are
          converted to their _official_ email names (e.g.  ‘latin_1’ is
          converted to ‘iso-8859-1’).  Defaults to 7-bit ‘us-ascii’.

      -- Attribute: header_encoding

          If the character set must be encoded before it can be used in
          an email header, this attribute will be set to ‘Charset.QP’
          (for quoted-printable), ‘Charset.BASE64’ (for base64
          encoding), or ‘Charset.SHORTEST’ for the shortest of QP or
          BASE64 encoding.  Otherwise, it will be ‘None’.

      -- Attribute: body_encoding

          Same as _header_encoding_, but describes the encoding for the
          mail message’s body, which indeed may be different than the
          header encoding.  ‘Charset.SHORTEST’ is not allowed for
          _body_encoding_.

      -- Attribute: output_charset

          Some character sets must be converted before they can be used
          in email headers or bodies.  If the _input_charset_ is one of
          them, this attribute will contain the name of the character
          set output will be converted to.  Otherwise, it will be
          ‘None’.

      -- Attribute: input_codec

          The name of the Python codec used to convert the
          _input_charset_ to Unicode.  If no conversion codec is
          necessary, this attribute will be ‘None’.

      -- Attribute: output_codec

          The name of the Python codec used to convert Unicode to the
          _output_charset_.  If no conversion codec is necessary, this
          attribute will have the same value as the _input_codec_.

     *note Charset: 17d9. instances also have the following methods:

      -- Method: get_body_encoding ()

          Return the content transfer encoding used for body encoding.

          This is either the string ‘quoted-printable’ or ‘base64’
          depending on the encoding used, or it is a function, in which
          case you should call the function with a single argument, the
          Message object being encoded.  The function should then set
          the ‘Content-Transfer-Encoding’ header itself to whatever is
          appropriate.

          Returns the string ‘quoted-printable’ if _body_encoding_ is
          ‘QP’, returns the string ‘base64’ if _body_encoding_ is
          ‘BASE64’, and returns the string ‘7bit’ otherwise.

      -- Method: convert (s)

          Convert the string _s_ from the _input_codec_ to the
          _output_codec_.

      -- Method: to_splittable (s)

          Convert a possibly multibyte string to a safely splittable
          format.  _s_ is the string to split.

          Uses the _input_codec_ to try and convert the string to
          Unicode, so it can be safely split on character boundaries
          (even for multibyte characters).

          Returns the string as-is if it isn’t known how to convert _s_
          to Unicode with the _input_charset_.

          Characters that could not be converted to Unicode will be
          replaced with the Unicode replacement character ‘'U+FFFD'’.

      -- Method: from_splittable (ustr[, to_output])

          Convert a splittable string back into an encoded string.
          _ustr_ is a Unicode string to "unsplit".

          This method uses the proper codec to try and convert the
          string from Unicode back into an encoded format.  Return the
          string as-is if it is not Unicode, or if it could not be
          converted from Unicode.

          Characters that could not be converted from Unicode will be
          replaced with an appropriate character (usually ‘'?'’).

          If _to_output_ is ‘True’ (the default), uses _output_codec_ to
          convert to an encoded format.  If _to_output_ is ‘False’, it
          uses _input_codec_.

      -- Method: get_output_charset ()

          Return the output character set.

          This is the _output_charset_ attribute if that is not ‘None’,
          otherwise it is _input_charset_.

      -- Method: encoded_header_len ()

          Return the length of the encoded header string, properly
          calculating for quoted-printable or base64 encoding.

      -- Method: header_encode (s[, convert])

          Header-encode the string _s_.

          If _convert_ is ‘True’, the string will be converted from the
          input charset to the output charset automatically.  This is
          not useful for multibyte character sets, which have line
          length issues (multibyte characters must be split on a
          character, not a byte boundary); use the higher-level *note
          Header: 180e. class to deal with these issues (see *note
          email.header: c0.).  _convert_ defaults to ‘False’.

          The type of encoding (base64 or quoted-printable) will be
          based on the _header_encoding_ attribute.

      -- Method: body_encode (s[, convert])

          Body-encode the string _s_.

          If _convert_ is ‘True’ (the default), the string will be
          converted from the input charset to output charset
          automatically.  Unlike *note header_encode(): 1834, there are
          no issues with byte boundaries and multibyte charsets in email
          bodies, so this is usually pretty safe.

          The type of encoding (base64 or quoted-printable) will be
          based on the _body_encoding_ attribute.

     The *note Charset: 17d9. class also provides a number of methods to
     support standard operations and built-in functions.

      -- Method: __str__ ()

          Returns _input_charset_ as a string coerced to lower case.
          *note __repr__(): 486. is an alias for *note __str__(): 1836.

      -- Method: __eq__ (other)

          This method allows you to compare two *note Charset: 17d9.
          instances for equality.

      -- Method: __ne__ (other)

          This method allows you to compare two *note Charset: 17d9.
          instances for inequality.

  The *note email.charset: bc. module also provides the following
functions for adding new entries to the global character set, alias, and
codec registries:

 -- Function: email.charset.add_charset (charset[, header_enc[,
          body_enc[, output_charset]]])

     Add character properties to the global registry.

     _charset_ is the input character set, and must be the canonical
     name of a character set.

     Optional _header_enc_ and _body_enc_ is either ‘Charset.QP’ for
     quoted-printable, ‘Charset.BASE64’ for base64 encoding,
     ‘Charset.SHORTEST’ for the shortest of quoted-printable or base64
     encoding, or ‘None’ for no encoding.  ‘SHORTEST’ is only valid for
     _header_enc_.  The default is ‘None’ for no encoding.

     Optional _output_charset_ is the character set that the output
     should be in.  Conversions will proceed from input charset, to
     Unicode, to the output charset when the method *note
     Charset.convert(): 182f. is called.  The default is to output in
     the same character set as the input.

     Both _input_charset_ and _output_charset_ must have Unicode codec
     entries in the module’s character set-to-codec mapping; use *note
     add_codec(): 183a. to add codecs the module does not know about.
     See the *note codecs: 63. module’s documentation for more
     information.

     The global character set registry is kept in the module global
     dictionary ‘CHARSETS’.

 -- Function: email.charset.add_alias (alias, canonical)

     Add a character set alias.  _alias_ is the alias name, e.g.
     ‘latin-1’.  _canonical_ is the character set’s canonical name, e.g.
     ‘iso-8859-1’.

     The global charset alias registry is kept in the module global
     dictionary ‘ALIASES’.

 -- Function: email.charset.add_codec (charset, codecname)

     Add a codec that map characters in the given character set to and
     from Unicode.

     _charset_ is the canonical name of a character set.  _codecname_ is
     the name of a Python codec, as appropriate for the second argument
     to the *note unicode(): 1f5. built-in, or to the ‘encode()’ method
     of a Unicode string.


File: python.info,  Node: email encoders Encoders,  Next: email errors Exception and Defect classes,  Prev: email charset Representing character sets,  Up: email --- An email and MIME handling package

5.18.1.10 ‘email.encoders’: Encoders
....................................

When creating *note Message: 216. objects from scratch, you often need
to encode the payloads for transport through compliant mail servers.
This is especially true for ‘image/*’ and ‘text/*’ type messages
containing binary data.

  The *note email: bb. package provides some convenient encodings in its
‘encoders’ module.  These encoders are actually used by the *note
MIMEAudio: 1818. and *note MIMEImage: 1819. class constructors to
provide default encodings.  All encoder functions take exactly one
argument, the message object to encode.  They usually extract the
payload, encode it, and reset the payload to this newly encoded value.
They should also set the ‘Content-Transfer-Encoding’ header as
appropriate.

  Note that these functions are not meaningful for a multipart message.
They must be applied to individual subparts instead, and will raise a
*note TypeError: 218. if passed a message whose type is multipart.

  Here are the encoding functions provided:

 -- Function: email.encoders.encode_quopri (msg)

     Encodes the payload into quoted-printable form and sets the
     ‘Content-Transfer-Encoding’ header to ‘quoted-printable’ (1).  This
     is a good encoding to use when most of your payload is normal
     printable data, but contains a few unprintable characters.

 -- Function: email.encoders.encode_base64 (msg)

     Encodes the payload into base64 form and sets the
     ‘Content-Transfer-Encoding’ header to ‘base64’.  This is a good
     encoding to use when most of your payload is unprintable data since
     it is a more compact form than quoted-printable.  The drawback of
     base64 encoding is that it renders the text non-human readable.

 -- Function: email.encoders.encode_7or8bit (msg)

     This doesn’t actually modify the message’s payload, but it does set
     the ‘Content-Transfer-Encoding’ header to either ‘7bit’ or ‘8bit’
     as appropriate, based on the payload data.

 -- Function: email.encoders.encode_noop (msg)

     This does nothing; it doesn’t even set the
     ‘Content-Transfer-Encoding’ header.

   ---------- Footnotes ----------

   (1) Note that encoding with *note encode_quopri(): 183e. also encodes
all tabs and space characters in the data.


File: python.info,  Node: email errors Exception and Defect classes,  Next: email utils Miscellaneous utilities,  Prev: email encoders Encoders,  Up: email --- An email and MIME handling package

5.18.1.11 ‘email.errors’: Exception and Defect classes
......................................................

The following exception classes are defined in the *note email.errors:
be. module:

 -- Exception: email.errors.MessageError

     This is the base class for all exceptions that the *note email: bb.
     package can raise.  It is derived from the standard *note
     Exception: 339. class and defines no additional methods.

 -- Exception: email.errors.MessageParseError

     This is the base class for exceptions raised by the *note Parser:
     17fc. class.  It is derived from *note MessageError: 1844.

 -- Exception: email.errors.HeaderParseError

     Raised under some error conditions when parsing the RFC 2822(1)
     headers of a message, this class is derived from *note
     MessageParseError: 1845.  It can be raised from the *note
     Parser.parse: 1806. or *note Parser.parsestr: 1807. methods.

     Situations where it can be raised include finding an envelope
     header after the first RFC 2822(2) header of the message, finding a
     continuation line before the first RFC 2822(3) header is found, or
     finding a line in the headers which is neither a header or a
     continuation line.

 -- Exception: email.errors.BoundaryError

     Raised under some error conditions when parsing the RFC 2822(4)
     headers of a message, this class is derived from *note
     MessageParseError: 1845.  It can be raised from the *note
     Parser.parse: 1806. or *note Parser.parsestr: 1807. methods.

     Situations where it can be raised include not being able to find
     the starting or terminating boundary in a ‘multipart/*’ message
     when strict parsing is used.

 -- Exception: email.errors.MultipartConversionError

     Raised when a payload is added to a *note Message: 216. object
     using ‘add_payload()’, but the payload is already a scalar and the
     message’s ‘Content-Type’ main type is not either ‘multipart’ or
     missing.  *note MultipartConversionError: 1815. multiply inherits
     from *note MessageError: 1844. and the built-in *note TypeError:
     218.

     Since ‘Message.add_payload()’ is deprecated, this exception is
     rarely raised in practice.  However the exception may also be
     raised if the *note attach(): 17d5. method is called on an instance
     of a class derived from *note MIMENonMultipart: 1814. (e.g.  *note
     MIMEImage: 1819.).

  Here’s the list of the defects that the *note FeedParser: 1801. can
find while parsing messages.  Note that the defects are added to the
message where the problem was found, so for example, if a message nested
inside a ‘multipart/alternative’ had a malformed header, that nested
message object would have a defect, but the containing messages would
not.

  All defect classes are subclassed from ‘email.errors.MessageDefect’,
but this class is _not_ an exception!

  New in version 2.4: All the defect classes were added.

   * ‘NoBoundaryInMultipartDefect’ – A message claimed to be a
     multipart, but had no ‘boundary’ parameter.

   * ‘StartBoundaryNotFoundDefect’ – The start boundary claimed in the
     ‘Content-Type’ header was never found.

   * ‘FirstHeaderLineIsContinuationDefect’ – The message had a
     continuation line as its first header line.

   * ‘MisplacedEnvelopeHeaderDefect’ - A "Unix From" header was found in
     the middle of a header block.

   * ‘MalformedHeaderDefect’ – A header was found that was missing a
     colon, or was otherwise malformed.

   * ‘MultipartInvariantViolationDefect’ – A message claimed to be a
     ‘multipart’, but no subparts were found.  Note that when a message
     has this defect, its *note is_multipart(): 17d2. method may return
     false even though its content type claims to be ‘multipart’.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html

   (2) http://tools.ietf.org/html/rfc2822.html

   (3) http://tools.ietf.org/html/rfc2822.html

   (4) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email utils Miscellaneous utilities,  Next: email iterators Iterators,  Prev: email errors Exception and Defect classes,  Up: email --- An email and MIME handling package

5.18.1.12 ‘email.utils’: Miscellaneous utilities
................................................

There are several useful utilities provided in the *note email.utils:
c5. module:

 -- Function: email.utils.quote (str)

     Return a new string with backslashes in _str_ replaced by two
     backslashes, and double quotes replaced by backslash-double quote.

 -- Function: email.utils.unquote (str)

     Return a new string which is an _unquoted_ version of _str_.  If
     _str_ ends and begins with double quotes, they are stripped off.
     Likewise if _str_ ends and begins with angle brackets, they are
     stripped off.

 -- Function: email.utils.parseaddr (address)

     Parse address – which should be the value of some
     address-containing field such as ‘To’ or ‘Cc’ – into its
     constituent _realname_ and _email address_ parts.  Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple of ‘('', '')’ is returned.

 -- Function: email.utils.formataddr (pair)

     The inverse of *note parseaddr(): 184a, this takes a 2-tuple of the
     form ‘(realname, email_address)’ and returns the string value
     suitable for a ‘To’ or ‘Cc’ header.  If the first element of _pair_
     is false, then the second element is returned unmodified.

 -- Function: email.utils.getaddresses (fieldvalues)

     This method returns a list of 2-tuples of the form returned by
     ‘parseaddr()’.  _fieldvalues_ is a sequence of header field values
     as might be returned by *note Message.get_all: 17df.  Here’s a
     simple example that gets all the recipients of a message:

          from email.utils import getaddresses

          tos = msg.get_all('to', [])
          ccs = msg.get_all('cc', [])
          resent_tos = msg.get_all('resent-to', [])
          resent_ccs = msg.get_all('resent-cc', [])
          all_recipients = getaddresses(tos + ccs + resent_tos + resent_ccs)

 -- Function: email.utils.parsedate (date)

     Attempts to parse a date according to the rules in RFC 2822(1).
     however, some mailers don’t follow that format as specified, so
     *note parsedate(): 184d. tries to guess correctly in such cases.
     _date_ is a string containing an RFC 2822(2) date, such as ‘"Mon,
     20 Nov 1995 19:12:08 -0500"’.  If it succeeds in parsing the date,
     *note parsedate(): 184d. returns a 9-tuple that can be passed
     directly to *note time.mktime(): 11f3.; otherwise ‘None’ will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: email.utils.parsedate_tz (date)

     Performs the same function as *note parsedate(): 184d, but returns
     either ‘None’ or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *note time.mktime(): 11f3, and the
     tenth is the offset of the date’s timezone from UTC (which is the
     official term for Greenwich Mean Time) (3).  If the input string
     has no timezone, the last element of the tuple returned is ‘None’.
     Note that indexes 6, 7, and 8 of the result tuple are not usable.

 -- Function: email.utils.mktime_tz (tuple)

     Turn a 10-tuple as returned by *note parsedate_tz(): 184e. into a
     UTC timestamp (seconds since the Epoch).  If the timezone item in
     the tuple is ‘None’, assume local time.

 -- Function: email.utils.formatdate ([timeval[, localtime][, usegmt]])

     Returns a date string as per RFC 2822(4), e.g.:

          Fri, 09 Nov 2001 01:08:47 -0000

     Optional _timeval_ if given is a floating point time value as
     accepted by *note time.gmtime(): b54. and *note time.localtime():
     ae1, otherwise the current time is used.

     Optional _localtime_ is a flag that when ‘True’, interprets
     _timeval_, and returns a date relative to the local timezone
     instead of UTC, properly taking daylight savings time into account.
     The default is ‘False’ meaning UTC is used.

     Optional _usegmt_ is a flag that when ‘True’, outputs a date string
     with the timezone as an ascii string ‘GMT’, rather than a numeric
     ‘-0000’.  This is needed for some protocols (such as HTTP). This
     only applies when _localtime_ is ‘False’.  The default is ‘False’.

     New in version 2.4.

 -- Function: email.utils.make_msgid ([idstring])

     Returns a string suitable for an RFC 2822(5)-compliant ‘Message-ID’
     header.  Optional _idstring_ if given, is a string used to
     strengthen the uniqueness of the message id.

 -- Function: email.utils.decode_rfc2231 (s)

     Decode the string _s_ according to RFC 2231(6).

 -- Function: email.utils.encode_rfc2231 (s[, charset[, language]])

     Encode the string _s_ according to RFC 2231(7).  Optional _charset_
     and _language_, if given is the character set name and language
     name to use.  If neither is given, _s_ is returned as-is.  If
     _charset_ is given but _language_ is not, the string is encoded
     using the empty string for _language_.

 -- Function: email.utils.collapse_rfc2231_value (value[, errors[,
          fallback_charset]])

     When a header parameter is encoded in RFC 2231(8) format, *note
     Message.get_param: 17ee. may return a 3-tuple containing the
     character set, language, and value.  *note
     collapse_rfc2231_value(): 17ef. turns this into a unicode string.
     Optional _errors_ is passed to the _errors_ argument of the
     built-in *note unicode(): 1f5. function; it defaults to ‘replace’.
     Optional _fallback_charset_ specifies the character set to use if
     the one in the RFC 2231(9) header is not known by Python; it
     defaults to ‘us-ascii’.

     For convenience, if the _value_ passed to *note
     collapse_rfc2231_value(): 17ef. is not a tuple, it should be a
     string and it is returned unquoted.

 -- Function: email.utils.decode_params (params)

     Decode parameters list according to RFC 2231(10).  _params_ is a
     sequence of 2-tuples containing elements of the form
     ‘(content-type, string-value)’.

  Changed in version 2.4: The ‘dump_address_pair()’ function has been
removed; use *note formataddr(): 184b. instead.

  Changed in version 2.4: The ‘decode()’ function has been removed; use
the ‘Header.decode_header’ method instead.

  Changed in version 2.4: The ‘encode()’ function has been removed; use
the *note Header.encode: 181f. method instead.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html

   (2) http://tools.ietf.org/html/rfc2822.html

   (3) Note that the sign of the timezone offset is the opposite of the
sign of the ‘time.timezone’ variable for the same timezone; the latter
variable follows the POSIX standard while this module follows RFC 2822
(http://tools.ietf.org/html/rfc2822.html).

   (4) http://tools.ietf.org/html/rfc2822.html

   (5) http://tools.ietf.org/html/rfc2822.html

   (6) http://tools.ietf.org/html/rfc2231.html

   (7) http://tools.ietf.org/html/rfc2231.html

   (8) http://tools.ietf.org/html/rfc2231.html

   (9) http://tools.ietf.org/html/rfc2231.html

   (10) http://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email iterators Iterators,  Next: email Examples,  Prev: email utils Miscellaneous utilities,  Up: email --- An email and MIME handling package

5.18.1.13 ‘email.iterators’: Iterators
......................................

Iterating over a message object tree is fairly easy with the *note
Message.walk: 17fa. method.  The *note email.iterators: c1. module
provides some useful higher level iterations over message object trees.

 -- Function: email.iterators.body_line_iterator (msg[, decode])

     This iterates over all the payloads in all the subparts of _msg_,
     returning the string payloads line-by-line.  It skips over all the
     subpart headers, and it skips over any subpart with a payload that
     isn’t a Python string.  This is somewhat equivalent to reading the
     flat text representation of the message from a file using *note
     readline(): 887, skipping over all the intervening headers.

     Optional _decode_ is passed through to *note Message.get_payload:
     17d7.

 -- Function: email.iterators.typed_subpart_iterator (msg[, maintype[,
          subtype]])

     This iterates over all the subparts of _msg_, returning only those
     subparts that match the MIME type specified by _maintype_ and
     _subtype_.

     Note that _subtype_ is optional; if omitted, then subpart MIME type
     matching is done only with the main type.  _maintype_ is optional
     too; it defaults to ‘text’.

     Thus, by default *note typed_subpart_iterator(): 1858. returns each
     subpart that has a MIME type of ‘text/*’.

  The following function has been added as a useful debugging tool.  It
should _not_ be considered part of the supported public interface for
the package.

 -- Function: email.iterators._structure (msg[, fp[, level]])

     Prints an indented representation of the content types of the
     message object structure.  For example:

          >>> msg = email.message_from_file(somefile)
          >>> _structure(msg)
          multipart/mixed
              text/plain
              text/plain
              multipart/digest
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
              text/plain

     Optional _fp_ is a file-like object to print the output to.  It
     must be suitable for Python’s extended print statement.  _level_ is
     used internally.


File: python.info,  Node: email Examples,  Next: Package History,  Prev: email iterators Iterators,  Up: email --- An email and MIME handling package

5.18.1.14 ‘email’: Examples
...........................

Here are a few examples of how to use the *note email: bb. package to
read, write, and send simple email messages, as well as more complex
MIME messages.

  First, let’s see how to create and send a simple text message:

     # Import smtplib for the actual sending function
     import smtplib

     # Import the email modules we'll need
     from email.mime.text import MIMEText

     # Open a plain text file for reading.  For this example, assume that
     # the text file contains only ASCII characters.
     fp = open(textfile, 'rb')
     # Create a text/plain message
     msg = MIMEText(fp.read())
     fp.close()

     # me == the sender's email address
     # you == the recipient's email address
     msg['Subject'] = 'The contents of %s' % textfile
     msg['From'] = me
     msg['To'] = you

     # Send the message via our own SMTP server, but don't include the
     # envelope header.
     s = smtplib.SMTP('localhost')
     s.sendmail(me, [you], msg.as_string())
     s.quit()


  And parsing RFC822 headers can easily be done by the parse(filename)
or parsestr(message_as_string) methods of the Parser() class:

     # Import the email modules we'll need
     from email.parser import Parser

     #  If the e-mail headers are in a file, uncomment this line:
     #headers = Parser().parse(open(messagefile, 'r'))

     #  Or for parsing headers in a string, use:
     headers = Parser().parsestr('From: <user@example.com>\n'
             'To: <someone_else@example.com>\n'
             'Subject: Test message\n'
             '\n'
             'Body would go here\n')

     #  Now the header items can be accessed as a dictionary:
     print 'To: %s' % headers['to']
     print 'From: %s' % headers['from']
     print 'Subject: %s' % headers['subject']


  Here’s an example of how to send a MIME message containing a bunch of
family pictures that may be residing in a directory:

     # Import smtplib for the actual sending function
     import smtplib

     # Here are the email package modules we'll need
     from email.mime.image import MIMEImage
     from email.mime.multipart import MIMEMultipart

     COMMASPACE = ', '

     # Create the container (outer) email message.
     msg = MIMEMultipart()
     msg['Subject'] = 'Our family reunion'
     # me == the sender's email address
     # family = the list of all recipients' email addresses
     msg['From'] = me
     msg['To'] = COMMASPACE.join(family)
     msg.preamble = 'Our family reunion'

     # Assume we know that the image files are all in PNG format
     for file in pngfiles:
         # Open the files in binary mode.  Let the MIMEImage class automatically
         # guess the specific image type.
         fp = open(file, 'rb')
         img = MIMEImage(fp.read())
         fp.close()
         msg.attach(img)

     # Send the email via our own SMTP server.
     s = smtplib.SMTP('localhost')
     s.sendmail(me, family, msg.as_string())
     s.quit()


  Here’s an example of how to send the entire contents of a directory as
an email message: (1)

     #!/usr/bin/env python

     """Send the contents of a directory as a MIME message."""

     import os
     import sys
     import smtplib
     # For guessing MIME type based on file name extension
     import mimetypes

     from optparse import OptionParser

     from email import encoders
     from email.message import Message
     from email.mime.audio import MIMEAudio
     from email.mime.base import MIMEBase
     from email.mime.image import MIMEImage
     from email.mime.multipart import MIMEMultipart
     from email.mime.text import MIMEText

     COMMASPACE = ', '


     def main():
         parser = OptionParser(usage="""\
     Send the contents of a directory as a MIME message.

     Usage: %prog [options]

     Unless the -o option is given, the email is sent by forwarding to your local
     SMTP server, which then does the normal delivery process.  Your local machine
     must be running an SMTP server.
     """)
         parser.add_option('-d', '--directory',
                           type='string', action='store',
                           help="""Mail the contents of the specified directory,
                           otherwise use the current directory.  Only the regular
                           files in the directory are sent, and we don't recurse to
                           subdirectories.""")
         parser.add_option('-o', '--output',
                           type='string', action='store', metavar='FILE',
                           help="""Print the composed message to FILE instead of
                           sending the message to the SMTP server.""")
         parser.add_option('-s', '--sender',
                           type='string', action='store', metavar='SENDER',
                           help='The value of the From: header (required)')
         parser.add_option('-r', '--recipient',
                           type='string', action='append', metavar='RECIPIENT',
                           default=[], dest='recipients',
                           help='A To: header value (at least one required)')
         opts, args = parser.parse_args()
         if not opts.sender or not opts.recipients:
             parser.print_help()
             sys.exit(1)
         directory = opts.directory
         if not directory:
             directory = '.'
         # Create the enclosing (outer) message
         outer = MIMEMultipart()
         outer['Subject'] = 'Contents of directory %s' % os.path.abspath(directory)
         outer['To'] = COMMASPACE.join(opts.recipients)
         outer['From'] = opts.sender
         outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

         for filename in os.listdir(directory):
             path = os.path.join(directory, filename)
             if not os.path.isfile(path):
                 continue
             # Guess the content type based on the file's extension.  Encoding
             # will be ignored, although we should check for simple things like
             # gzip'd or compressed files.
             ctype, encoding = mimetypes.guess_type(path)
             if ctype is None or encoding is not None:
                 # No guess could be made, or the file is encoded (compressed), so
                 # use a generic bag-of-bits type.
                 ctype = 'application/octet-stream'
             maintype, subtype = ctype.split('/', 1)
             if maintype == 'text':
                 fp = open(path)
                 # Note: we should handle calculating the charset
                 msg = MIMEText(fp.read(), _subtype=subtype)
                 fp.close()
             elif maintype == 'image':
                 fp = open(path, 'rb')
                 msg = MIMEImage(fp.read(), _subtype=subtype)
                 fp.close()
             elif maintype == 'audio':
                 fp = open(path, 'rb')
                 msg = MIMEAudio(fp.read(), _subtype=subtype)
                 fp.close()
             else:
                 fp = open(path, 'rb')
                 msg = MIMEBase(maintype, subtype)
                 msg.set_payload(fp.read())
                 fp.close()
                 # Encode the payload using Base64
                 encoders.encode_base64(msg)
             # Set the filename parameter
             msg.add_header('Content-Disposition', 'attachment', filename=filename)
             outer.attach(msg)
         # Now send or store the message
         composed = outer.as_string()
         if opts.output:
             fp = open(opts.output, 'w')
             fp.write(composed)
             fp.close()
         else:
             s = smtplib.SMTP('localhost')
             s.sendmail(opts.sender, opts.recipients, composed)
             s.quit()


     if __name__ == '__main__':
         main()


  Here’s an example of how to unpack a MIME message like the one above,
into a directory of files:

     #!/usr/bin/env python

     """Unpack a MIME message into a directory of files."""

     import os
     import sys
     import email
     import errno
     import mimetypes

     from optparse import OptionParser


     def main():
         parser = OptionParser(usage="""\
     Unpack a MIME message into a directory of files.

     Usage: %prog [options] msgfile
     """)
         parser.add_option('-d', '--directory',
                           type='string', action='store',
                           help="""Unpack the MIME message into the named
                           directory, which will be created if it doesn't already
                           exist.""")
         opts, args = parser.parse_args()
         if not opts.directory:
             parser.print_help()
             sys.exit(1)

         try:
             msgfile = args[0]
         except IndexError:
             parser.print_help()
             sys.exit(1)

         try:
             os.mkdir(opts.directory)
         except OSError as e:
             # Ignore directory exists error
             if e.errno != errno.EEXIST:
                 raise

         fp = open(msgfile)
         msg = email.message_from_file(fp)
         fp.close()

         counter = 1
         for part in msg.walk():
             # multipart/* are just containers
             if part.get_content_maintype() == 'multipart':
                 continue
             # Applications should really sanitize the given filename so that an
             # email message can't be used to overwrite important files
             filename = part.get_filename()
             if not filename:
                 ext = mimetypes.guess_extension(part.get_content_type())
                 if not ext:
                     # Use a generic bag-of-bits extension
                     ext = '.bin'
                 filename = 'part-%03d%s' % (counter, ext)
             counter += 1
             fp = open(os.path.join(opts.directory, filename), 'wb')
             fp.write(part.get_payload(decode=True))
             fp.close()


     if __name__ == '__main__':
         main()


  Here’s an example of how to create an HTML message with an alternative
plain text version: (2)

     #!/usr/bin/env python

     import smtplib

     from email.mime.multipart import MIMEMultipart
     from email.mime.text import MIMEText

     # me == my email address
     # you == recipient's email address
     me = "my@email.com"
     you = "your@email.com"

     # Create message container - the correct MIME type is multipart/alternative.
     msg = MIMEMultipart('alternative')
     msg['Subject'] = "Link"
     msg['From'] = me
     msg['To'] = you

     # Create the body of the message (a plain-text and an HTML version).
     text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttp://www.python.org"
     html = """\
     <html>
       <head></head>
       <body>
         <p>Hi!<br>
            How are you?<br>
            Here is the <a href="http://www.python.org">link</a> you wanted.
         </p>
       </body>
     </html>
     """

     # Record the MIME types of both parts - text/plain and text/html.
     part1 = MIMEText(text, 'plain')
     part2 = MIMEText(html, 'html')

     # Attach parts into message container.
     # According to RFC 2046, the last part of a multipart message, in this case
     # the HTML message, is best and preferred.
     msg.attach(part1)
     msg.attach(part2)

     # Send the message via local SMTP server.
     s = smtplib.SMTP('localhost')
     # sendmail function takes 3 arguments: sender's address, recipient's address
     # and message to send - here it is sent as one string.
     s.sendmail(me, you, msg.as_string())
     s.quit()


See also
........

Module *note smtplib: 15a.

     SMTP protocol client

Module *note nntplib: 124.

     NNTP protocol client

   ---------- Footnotes ----------

   (1) Thanks to Matthew Dixon Cowles for the original inspiration and
examples.

   (2) Contributed by Martin Matejek.


File: python.info,  Node: Package History,  Next: Differences from mimelib,  Prev: email Examples,  Up: email --- An email and MIME handling package

5.18.1.15 Package History
.........................

This table describes the release history of the email package,
corresponding to the version of Python that the package was released
with.  For purposes of this document, when you see a note about change
or added versions, these refer to the Python version the change was made
in, _not_ the email package version.  This table also describes the
Python compatibility of each version of the package.

email version       distributed with                   compatible with
                                                       
-----------------------------------------------------------------------------------
                                                       
‘1.x’               Python 2.2.0 to Python 2.2.1       _no longer supported_
                                                       
                                                       
‘2.5’               Python 2.2.2+ and Python 2.3       Python 2.1 to 2.5
                                                       
                                                       
‘3.0’               Python 2.4                         Python 2.3 to 2.5
                                                       
                                                       
‘4.0’               Python 2.5                         Python 2.3 to 2.5
                                                       

  Here are the major differences between *note email: bb. version 4 and
version 3:

   * All modules have been renamed according to PEP 8(1) standards.  For
     example, the version 3 module ‘email.Message’ was renamed to *note
     email.message: c2. in version 4.

   * A new subpackage *note email.mime: c3. was added and all the
     version 3 ‘email.MIME*’ modules were renamed and situated into the
     *note email.mime: c3. subpackage.  For example, the version 3
     module ‘email.MIMEText’ was renamed to ‘email.mime.text’.

     _Note that the version 3 names will continue to work until Python
     2.6_.

   * The ‘email.mime.application’ module was added, which contains the
     *note MIMEApplication: 1817. class.

   * Methods that were deprecated in version 3 have been removed.  These
     include ‘Generator.__call__()’, ‘Message.get_type()’,
     ‘Message.get_main_type()’, ‘Message.get_subtype()’.

   * Fixes have been added for RFC 2231(2) support which can change some
     of the return types for *note Message.get_param: 17ee. and friends.
     Under some circumstances, values which used to return a 3-tuple now
     return simple strings (specifically, if all extended parameter
     segments were unencoded, there is no language and charset
     designation expected, so the return type is now a simple string).
     Also, %-decoding used to be done for both encoded and unencoded
     segments; this decoding is now done only for encoded segments.

  Here are the major differences between *note email: bb. version 3 and
version 2:

   * The *note FeedParser: 1801. class was introduced, and the *note
     Parser: 17fc. class was implemented in terms of the *note
     FeedParser: 1801.  All parsing therefore is non-strict, and parsing
     will make a best effort never to raise an exception.  Problems
     found while parsing messages are stored in the message’s _defect_
     attribute.

   * All aspects of the API which raised *note DeprecationWarning: 1bc.s
     in version 2 have been removed.  These include the __encoder_
     argument to the *note MIMEText: 181b. constructor, the
     ‘Message.add_payload()’ method, the ‘Utils.dump_address_pair()’
     function, and the functions ‘Utils.decode()’ and ‘Utils.encode()’.

   * New *note DeprecationWarning: 1bc.s have been added to:
     ‘Generator.__call__()’, ‘Message.get_type()’,
     ‘Message.get_main_type()’, ‘Message.get_subtype()’, and the
     _strict_ argument to the *note Parser: 17fc. class.  These are
     expected to be removed in future versions.

   * Support for Pythons earlier than 2.3 has been removed.

  Here are the differences between *note email: bb. version 2 and
version 1:

   * The ‘email.Header’ and ‘email.Charset’ modules have been added.

   * The pickle format for *note Message: 216. instances has changed.
     Since this was never (and still isn’t) formally defined, this isn’t
     considered a backward incompatibility.  However if your application
     pickles and unpickles *note Message: 216. instances, be aware that
     in *note email: bb. version 2, *note Message: 216. instances now
     have private variables __charset_ and __default_type_.

   * Several methods in the *note Message: 216. class have been
     deprecated, or their signatures changed.  Also, many new methods
     have been added.  See the documentation for the *note Message: 216.
     class for details.  The changes should be completely backward
     compatible.

   * The object structure has changed in the face of ‘message/rfc822’
     content types.  In *note email: bb. version 1, such a type would be
     represented by a scalar payload, i.e.  the container message’s
     *note is_multipart(): 17d2. returned false, *note get_payload():
     17d7. was not a list object, but a single *note Message: 216.
     instance.

     This structure was inconsistent with the rest of the package, so
     the object representation for ‘message/rfc822’ content types was
     changed.  In *note email: bb. version 2, the container _does_
     return ‘True’ from *note is_multipart(): 17d2, and *note
     get_payload(): 17d7. returns a list containing a single *note
     Message: 216. item.

     Note that this is one place that backward compatibility could not
     be completely maintained.  However, if you’re already testing the
     return type of *note get_payload(): 17d7, you should be fine.  You
     just need to make sure your code doesn’t do a *note set_payload():
     17d6. with a *note Message: 216. instance on a container with a
     content type of ‘message/rfc822’.

   * The *note Parser: 17fc. constructor’s _strict_ argument was added,
     and its *note parse(): 1806. and *note parsestr(): 1807. methods
     grew a _headersonly_ argument.  The _strict_ flag was also added to
     functions *note email.message_from_file(): 1809. and *note
     email.message_from_string(): 1808.

   * ‘Generator.__call__()’ is deprecated; use *note Generator.flatten:
     17d0. instead.  The *note Generator: 17cf. class has also grown the
     *note clone(): 180f. method.

   * The *note DecodedGenerator: 1810. class in the *note
     email.generator: bf. module was added.

   * The intermediate base classes *note MIMENonMultipart: 1814. and
     *note MIMEMultipart: 1816. have been added, and interposed in the
     class hierarchy for most of the other MIME-related derived classes.

   * The __encoder_ argument to the *note MIMEText: 181b. constructor
     has been deprecated.  Encoding now happens implicitly based on the
     __charset_ argument.

   * The following functions in the ‘email.Utils’ module have been
     deprecated: ‘dump_address_pairs()’, ‘decode()’, and ‘encode()’.
     The following functions have been added to the module:
     ‘make_msgid()’, ‘decode_rfc2231()’, ‘encode_rfc2231()’, and
     ‘decode_params()’.

   * The non-public function ‘email.Iterators._structure()’ was added.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0008

   (2) http://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: Differences from mimelib,  Prev: Package History,  Up: email --- An email and MIME handling package

5.18.1.16 Differences from ‘mimelib’
....................................

The *note email: bb. package was originally prototyped as a separate
library called mimelib(1).  Changes have been made so that method names
are more consistent, and some methods or modules have either been added
or removed.  The semantics of some of the methods have also changed.
For the most part, any functionality available in ‘mimelib’ is still
available in the *note email: bb. package, albeit often in a different
way.  Backward compatibility between the ‘mimelib’ package and the *note
email: bb. package was not a priority.

  Here is a brief description of the differences between the ‘mimelib’
and the *note email: bb. packages, along with hints on how to port your
applications.

  Of course, the most visible difference between the two packages is
that the package name has been changed to *note email: bb.  In addition,
the top-level package has the following differences:

   * ‘messageFromString()’ has been renamed to *note
     message_from_string(): 1808.

   * ‘messageFromFile()’ has been renamed to *note message_from_file():
     1809.

  The *note Message: 216. class has the following differences:

   * The method ‘asString()’ was renamed to *note as_string(): 17ce.

   * The method ‘ismultipart()’ was renamed to *note is_multipart():
     17d2.

   * The *note get_payload(): 17d7. method has grown a _decode_ optional
     argument.

   * The method ‘getall()’ was renamed to *note get_all(): 17df.

   * The method ‘addheader()’ was renamed to *note add_header(): 17e6.

   * The method ‘gettype()’ was renamed to ‘get_type()’.

   * The method ‘getmaintype()’ was renamed to ‘get_main_type()’.

   * The method ‘getsubtype()’ was renamed to ‘get_subtype()’.

   * The method ‘getparams()’ was renamed to *note get_params(): 17ed.
     Also, whereas ‘getparams()’ returned a list of strings, *note
     get_params(): 17ed. returns a list of 2-tuples, effectively the
     key/value pairs of the parameters, split on the ‘'='’ sign.

   * The method ‘getparam()’ was renamed to *note get_param(): 17ee.

   * The method ‘getcharsets()’ was renamed to *note get_charsets():
     17f9.

   * The method ‘getfilename()’ was renamed to *note get_filename():
     17f3.

   * The method ‘getboundary()’ was renamed to *note get_boundary():
     17f5.

   * The method ‘setboundary()’ was renamed to *note set_boundary():
     17f6.

   * The method ‘getdecodedpayload()’ was removed.  To get similar
     functionality, pass the value 1 to the _decode_ flag of the *note
     get_payload(): 17d7. method.

   * The method ‘getpayloadastext()’ was removed.  Similar functionality
     is supported by the *note DecodedGenerator: 1810. class in the
     *note email.generator: bf. module.

   * The method ‘getbodyastext()’ was removed.  You can get similar
     functionality by creating an iterator with *note
     typed_subpart_iterator(): 1858. in the *note email.iterators: c1.
     module.

  The *note Parser: 17fc. class has no differences in its public
interface.  It does have some additional smarts to recognize
‘message/delivery-status’ type messages, which it represents as a *note
Message: 216. instance containing separate *note Message: 216. subparts
for each header block in the delivery status notification (2).

  The *note Generator: 17cf. class has no differences in its public
interface.  There is a new class in the *note email.generator: bf.
module though, called *note DecodedGenerator: 1810. which provides most
of the functionality previously available in the
‘Message.getpayloadastext()’ method.

  The following modules and classes have been changed:

   * The *note MIMEBase: 1813. class constructor arguments __major_ and
     __minor_ have changed to __maintype_ and __subtype_ respectively.

   * The ‘Image’ class/module has been renamed to ‘MIMEImage’.  The
     __minor_ argument has been renamed to __subtype_.

   * The ‘Text’ class/module has been renamed to ‘MIMEText’.  The
     __minor_ argument has been renamed to __subtype_.

   * The ‘MessageRFC822’ class/module has been renamed to ‘MIMEMessage’.
     Note that an earlier version of ‘mimelib’ called this class/module
     ‘RFC822’, but that clashed with the Python standard library module
     *note rfc822: 148. on some case-insensitive file systems.

     Also, the *note MIMEMessage: 181a. class now represents any kind of
     MIME message with main type ‘message’.  It takes an optional
     argument __subtype_ which is used to set the MIME subtype.
     __subtype_ defaults to ‘rfc822’.

  ‘mimelib’ provided some utility functions in its ‘address’ and ‘date’
modules.  All of these functions have been moved to the *note
email.utils: c5. module.

  The ‘MsgReader’ class/module has been removed.  Its functionality is
most closely supported in the *note body_line_iterator(): 1857. function
in the *note email.iterators: c1. module.

   ---------- Footnotes ----------

   (1) http://mimelib.sf.net/

   (2) Delivery Status Notifications (DSN) are defined in RFC 1894
(http://tools.ietf.org/html/rfc1894.html).


File: python.info,  Node: json --- JSON encoder and decoder,  Next: mailcap --- Mailcap file handling,  Prev: email --- An email and MIME handling package,  Up: Internet Data Handling

5.18.2 ‘json’ — JSON encoder and decoder
----------------------------------------

New in version 2.6.

  JSON (JavaScript Object Notation)(1), specified by RFC 4627(2), is a
lightweight data interchange format based on a subset of JavaScript(3)
syntax (ECMA-262 3rd edition(4)).

  *note json: fc. exposes an API familiar to users of the standard
library *note marshal: 10b. and *note pickle: 12d. modules.

  Encoding basic Python object hierarchies:

     >>> import json
     >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
     '["foo", {"bar": ["baz", null, 1.0, 2]}]'
     >>> print json.dumps("\"foo\bar")
     "\"foo\bar"
     >>> print json.dumps(u'\u1234')
     "\u1234"
     >>> print json.dumps('\\')
     "\\"
     >>> print json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
     {"a": 0, "b": 0, "c": 0}
     >>> from StringIO import StringIO
     >>> io = StringIO()
     >>> json.dump(['streaming API'], io)
     >>> io.getvalue()
     '["streaming API"]'

  Compact encoding:

     >>> import json
     >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',',':'))
     '[1,2,3,{"4":5,"6":7}]'

  Pretty printing:

     >>> import json
     >>> print json.dumps({'4': 5, '6': 7}, sort_keys=True,
     ...                  indent=4, separators=(',', ': '))
     {
         "4": 5,
         "6": 7
     }

  Decoding JSON:

     >>> import json
     >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
     [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]
     >>> json.loads('"\\"foo\\bar"')
     u'"foo\x08ar'
     >>> from StringIO import StringIO
     >>> io = StringIO('["streaming API"]')
     >>> json.load(io)
     [u'streaming API']

  Specializing JSON object decoding:

     >>> import json
     >>> def as_complex(dct):
     ...     if '__complex__' in dct:
     ...         return complex(dct['real'], dct['imag'])
     ...     return dct
     ...
     >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
     ...     object_hook=as_complex)
     (1+2j)
     >>> import decimal
     >>> json.loads('1.1', parse_float=decimal.Decimal)
     Decimal('1.1')

  Extending *note JSONEncoder: 1862.:

     >>> import json
     >>> class ComplexEncoder(json.JSONEncoder):
     ...     def default(self, obj):
     ...         if isinstance(obj, complex):
     ...             return [obj.real, obj.imag]
     ...         # Let the base class default method raise the TypeError
     ...         return json.JSONEncoder.default(self, obj)
     ...
     >>> dumps(2 + 1j, cls=ComplexEncoder)
     '[2.0, 1.0]'
     >>> ComplexEncoder().encode(2 + 1j)
     '[2.0, 1.0]'
     >>> list(ComplexEncoder().iterencode(2 + 1j))
     ['[', '2.0', ', ', '1.0', ']']

  Using json.tool from the shell to validate and pretty-print:

     $ echo '{"json":"obj"}' | python -mjson.tool
     {
         "json": "obj"
     }
     $ echo '{1.2:3.4}' | python -mjson.tool
     Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

     Note: JSON is a subset of YAML(5) 1.2.  The JSON produced by this
     module’s default settings (in particular, the default _separators_
     value) is also a subset of YAML 1.0 and 1.1.  This module can thus
     also be used as a YAML serializer.

* Menu:

* Basic Usage:: 
* Encoders and Decoders:: 
* Standard Compliance:: 

   ---------- Footnotes ----------

   (1) http://json.org

   (2) http://tools.ietf.org/html/rfc4627.html

   (3) http://en.wikipedia.org/wiki/JavaScript

   (4) 
http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf

   (5) http://yaml.org/


File: python.info,  Node: Basic Usage,  Next: Encoders and Decoders,  Up: json --- JSON encoder and decoder

5.18.2.1 Basic Usage
....................

 -- Function: json.dump (obj, fp, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, encoding="utf-8", default=None,
          sort_keys=False, **kw)

     Serialize _obj_ as a JSON formatted stream to _fp_ (a
     ‘.write()’-supporting *note file-like object: 1864.) using this
     *note conversion table: 1865.

     If _skipkeys_ is ‘True’ (default: ‘False’), then dict keys that are
     not of a basic type (*note str: 1ea, *note unicode: 1f5, *note int:
     1f2, *note long: 1f3, *note float: 1eb, *note bool: 43c, ‘None’)
     will be skipped instead of raising a *note TypeError: 218.

     If _ensure_ascii_ is ‘True’ (the default), all non-ASCII characters
     in the output are escaped with ‘\uXXXX’ sequences, and the result
     is a *note str: 1ea. instance consisting of ASCII characters only.
     If _ensure_ascii_ is ‘False’, some chunks written to _fp_ may be
     *note unicode: 1f5. instances.  This usually happens because the
     input contains unicode strings or the _encoding_ parameter is used.
     Unless ‘fp.write()’ explicitly understands *note unicode: 1f5. (as
     in *note codecs.getwriter(): a57.) this is likely to cause an
     error.

     If _check_circular_ is ‘False’ (default: ‘True’), then the circular
     reference check for container types will be skipped and a circular
     reference will result in an *note OverflowError: 2db. (or worse).

     If _allow_nan_ is ‘False’ (default: ‘True’), then it will be a
     *note ValueError: 236. to serialize out of range *note float: 1eb.
     values (‘nan’, ‘inf’, ‘-inf’) in strict compliance of the JSON
     specification, instead of using the JavaScript equivalents (‘NaN’,
     ‘Infinity’, ‘-Infinity’).

     If _indent_ is a non-negative integer, then JSON array elements and
     object members will be pretty-printed with that indent level.  An
     indent level of 0, or negative, will only insert newlines.  ‘None’
     (the default) selects the most compact representation.

          Note: Since the default item separator is ‘', '’, the output
          might include trailing whitespace when _indent_ is specified.
          You can use ‘separators=(',', ': ')’ to avoid this.

     If _separators_ is an ‘(item_separator, dict_separator)’ tuple,
     then it will be used instead of the default ‘(', ', ': ')’
     separators.  ‘(',', ':')’ is the most compact JSON representation.

     _encoding_ is the character encoding for str instances, default is
     UTF-8.

     _default(obj)_ is a function that should return a serializable
     version of _obj_ or raise *note TypeError: 218.  The default simply
     raises *note TypeError: 218.

     If _sort_keys_ is ‘True’ (default: ‘False’), then the output of
     dictionaries will be sorted by key.

     To use a custom *note JSONEncoder: 1862. subclass (e.g.  one that
     overrides the ‘default()’ method to serialize additional types),
     specify it with the _cls_ kwarg; otherwise *note JSONEncoder: 1862.
     is used.

          Note: Unlike *note pickle: 12d. and *note marshal: 10b, JSON
          is not a framed protocol so trying to serialize more objects
          with repeated calls to *note dump(): 5a3. and the same _fp_
          will result in an invalid JSON file.

 -- Function: json.dumps (obj, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, encoding="utf-8", default=None,
          sort_keys=False, **kw)

     Serialize _obj_ to a JSON formatted *note str: 1ea. using this
     *note conversion table: 1865.  If _ensure_ascii_ is ‘False’, the
     result may contain non-ASCII characters and the return value may be
     a *note unicode: 1f5. instance.

     The arguments have the same meaning as in *note dump(): 5a3.

          Note: Keys in key/value pairs of JSON are always of the type
          *note str: 1ea.  When a dictionary is converted into JSON, all
          the keys of the dictionary are coerced to strings.  As a
          result of this, if a dictionary is converted into JSON and
          then back into a dictionary, the dictionary may not equal the
          original one.  That is, ‘loads(dumps(x)) != x’ if x has
          non-string keys.

 -- Function: json.load (fp[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[, object_pairs_hook[,
          **kw]]]]]]]])

     Deserialize _fp_ (a ‘.read()’-supporting *note file-like object:
     1864. containing a JSON document) to a Python object using this
     *note conversion table: 1866.

     If the contents of _fp_ are encoded with an ASCII based encoding
     other than UTF-8 (e.g.  latin-1), then an appropriate _encoding_
     name must be specified.  Encodings that are not ASCII based (such
     as UCS-2) are not allowed, and should be wrapped with
     ‘codecs.getreader(encoding)(fp)’, or simply decoded to a *note
     unicode: 1f5. object and passed to *note loads(): 1867.

     _object_hook_ is an optional function that will be called with the
     result of any object literal decoded (a *note dict: 305.).  The
     return value of _object_hook_ will be used instead of the *note
     dict: 305.  This feature can be used to implement custom decoders
     (e.g.  JSON-RPC(1) class hinting).

     _object_pairs_hook_ is an optional function that will be called
     with the result of any object literal decoded with an ordered list
     of pairs.  The return value of _object_pairs_hook_ will be used
     instead of the *note dict: 305.  This feature can be used to
     implement custom decoders that rely on the order that the key and
     value pairs are decoded (for example, *note
     collections.OrderedDict(): 1b5. will remember the order of
     insertion).  If _object_hook_ is also defined, the
     _object_pairs_hook_ takes priority.

     Changed in version 2.7: Added support for _object_pairs_hook_.

     _parse_float_, if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     ‘float(num_str)’.  This can be used to use another datatype or
     parser for JSON floats (e.g.  *note decimal.Decimal: 1b4.).

     _parse_int_, if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     ‘int(num_str)’.  This can be used to use another datatype or parser
     for JSON integers (e.g.  *note float: 1eb.).

     _parse_constant_, if specified, will be called with one of the
     following strings: ‘'-Infinity'’, ‘'Infinity'’, ‘'NaN'’.  This can
     be used to raise an exception if invalid JSON numbers are
     encountered.

     Changed in version 2.7: _parse_constant_ doesn’t get called on
     ’null’, ’true’, ’false’ anymore.

     To use a custom *note JSONDecoder: 1d0. subclass, specify it with
     the ‘cls’ kwarg; otherwise *note JSONDecoder: 1d0. is used.
     Additional keyword arguments will be passed to the constructor of
     the class.

 -- Function: json.loads (s[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[, object_pairs_hook[,
          **kw]]]]]]]])

     Deserialize _s_ (a *note str: 1ea. or *note unicode: 1f5. instance
     containing a JSON document) to a Python object using this *note
     conversion table: 1866.

     If _s_ is a *note str: 1ea. instance and is encoded with an ASCII
     based encoding other than UTF-8 (e.g.  latin-1), then an
     appropriate _encoding_ name must be specified.  Encodings that are
     not ASCII based (such as UCS-2) are not allowed and should be
     decoded to *note unicode: 1f5. first.

     The other arguments have the same meaning as in *note load(): 237.

   ---------- Footnotes ----------

   (1) http://www.jsonrpc.org


File: python.info,  Node: Encoders and Decoders,  Next: Standard Compliance,  Prev: Basic Usage,  Up: json --- JSON encoder and decoder

5.18.2.2 Encoders and Decoders
..............................

 -- Class: json.JSONDecoder ([encoding[, object_hook[, parse_float[,
          parse_int[, parse_constant[, strict[,
          object_pairs_hook]]]]]]])

     Simple JSON decoder.

     Performs the following translations in decoding by default:

     JSON                Python
                         
     --------------------------------------------
                         
     object              dict
                         
                         
     array               list
                         
                         
     string              unicode
                         
                         
     number (int)        int, long
                         
                         
     number (real)       float
                         
                         
     true                True
                         
                         
     false               False
                         
                         
     null                None
                         

     It also understands ‘NaN’, ‘Infinity’, and ‘-Infinity’ as their
     corresponding ‘float’ values, which is outside the JSON spec.

     _encoding_ determines the encoding used to interpret any *note str:
     1ea. objects decoded by this instance (UTF-8 by default).  It has
     no effect when decoding *note unicode: 1f5. objects.

     Note that currently only encodings that are a superset of ASCII
     work, strings of other encodings should be passed in as *note
     unicode: 1f5.

     _object_hook_, if specified, will be called with the result of
     every JSON object decoded and its return value will be used in
     place of the given *note dict: 305.  This can be used to provide
     custom deserializations (e.g.  to support JSON-RPC class hinting).

     _object_pairs_hook_, if specified will be called with the result of
     every JSON object decoded with an ordered list of pairs.  The
     return value of _object_pairs_hook_ will be used instead of the
     *note dict: 305.  This feature can be used to implement custom
     decoders that rely on the order that the key and value pairs are
     decoded (for example, *note collections.OrderedDict(): 1b5. will
     remember the order of insertion).  If _object_hook_ is also
     defined, the _object_pairs_hook_ takes priority.

     Changed in version 2.7: Added support for _object_pairs_hook_.

     _parse_float_, if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     ‘float(num_str)’.  This can be used to use another datatype or
     parser for JSON floats (e.g.  *note decimal.Decimal: 1b4.).

     _parse_int_, if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     ‘int(num_str)’.  This can be used to use another datatype or parser
     for JSON integers (e.g.  *note float: 1eb.).

     _parse_constant_, if specified, will be called with one of the
     following strings: ‘'-Infinity'’, ‘'Infinity'’, ‘'NaN'’, ‘'null'’,
     ‘'true'’, ‘'false'’.  This can be used to raise an exception if
     invalid JSON numbers are encountered.

     If _strict_ is ‘False’ (‘True’ is the default), then control
     characters will be allowed inside strings.  Control characters in
     this context are those with character codes in the 0-31 range,
     including ‘'\t'’ (tab), ‘'\n'’, ‘'\r'’ and ‘'\0'’.

     If the data being deserialized is not a valid JSON document, a
     *note ValueError: 236. will be raised.

      -- Method: decode (s)

          Return the Python representation of _s_ (a *note str: 1ea. or
          *note unicode: 1f5. instance containing a JSON document)

      -- Method: raw_decode (s)

          Decode a JSON document from _s_ (a *note str: 1ea. or *note
          unicode: 1f5. beginning with a JSON document) and return a
          2-tuple of the Python representation and the index in _s_
          where the document ended.

          This can be used to decode a JSON document from a string that
          may have extraneous data at the end.

 -- Class: json.JSONEncoder ([skipkeys[, ensure_ascii[, check_circular[,
          allow_nan[, sort_keys[, indent[, separators[, encoding[,
          default]]]]]]]]])

     Extensible JSON encoder for Python data structures.

     Supports the following objects and types by default:

     Python                  JSON
                             
     --------------------------------------------
                             
     dict                    object
                             
                             
     list, tuple             array
                             
                             
     str, unicode            string
                             
                             
     int, long, float        number
                             
                             
     True                    true
                             
                             
     False                   false
                             
                             
     None                    null
                             

     To extend this to recognize other objects, subclass and implement a
     *note default(): 186b. method with another method that returns a
     serializable object for ‘o’ if possible, otherwise it should call
     the superclass implementation (to raise *note TypeError: 218.).

     If _skipkeys_ is ‘False’ (the default), then it is a *note
     TypeError: 218. to attempt encoding of keys that are not str, int,
     long, float or None.  If _skipkeys_ is ‘True’, such items are
     simply skipped.

     If _ensure_ascii_ is ‘True’ (the default), all non-ASCII characters
     in the output are escaped with ‘\uXXXX’ sequences, and the results
     are *note str: 1ea. instances consisting of ASCII characters only.
     If _ensure_ascii_ is ‘False’, a result may be a *note unicode: 1f5.
     instance.  This usually happens if the input contains unicode
     strings or the _encoding_ parameter is used.

     If _check_circular_ is ‘True’ (the default), then lists, dicts, and
     custom encoded objects will be checked for circular references
     during encoding to prevent an infinite recursion (which would cause
     an *note OverflowError: 2db.).  Otherwise, no such check takes
     place.

     If _allow_nan_ is ‘True’ (the default), then ‘NaN’, ‘Infinity’, and
     ‘-Infinity’ will be encoded as such.  This behavior is not JSON
     specification compliant, but is consistent with most JavaScript
     based encoders and decoders.  Otherwise, it will be a *note
     ValueError: 236. to encode such floats.

     If _sort_keys_ is ‘True’ (default ‘False’), then the output of
     dictionaries will be sorted by key; this is useful for regression
     tests to ensure that JSON serializations can be compared on a
     day-to-day basis.

     If _indent_ is a non-negative integer (it is ‘None’ by default),
     then JSON array elements and object members will be pretty-printed
     with that indent level.  An indent level of 0 will only insert
     newlines.  ‘None’ is the most compact representation.

          Note: Since the default item separator is ‘', '’, the output
          might include trailing whitespace when _indent_ is specified.
          You can use ‘separators=(',', ': ')’ to avoid this.

     If specified, _separators_ should be an ‘(item_separator,
     key_separator)’ tuple.  The default is ‘(', ', ': ')’.  To get the
     most compact JSON representation, you should specify ‘(',', ':')’
     to eliminate whitespace.

     If specified, _default_ is a function that gets called for objects
     that can’t otherwise be serialized.  It should return a JSON
     encodable version of the object or raise a *note TypeError: 218.

     If _encoding_ is not ‘None’, then all input strings will be
     transformed into unicode using that encoding prior to
     JSON-encoding.  The default is UTF-8.

      -- Method: default (o)

          Implement this method in a subclass such that it returns a
          serializable object for _o_, or calls the base implementation
          (to raise a *note TypeError: 218.).

          For example, to support arbitrary iterators, you could
          implement default like this:

               def default(self, o):
                  try:
                      iterable = iter(o)
                  except TypeError:
                      pass
                  else:
                      return list(iterable)
                  # Let the base class default method raise the TypeError
                  return JSONEncoder.default(self, o)

      -- Method: encode (o)

          Return a JSON string representation of a Python data
          structure, _o_.  For example:

               >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
               '{"foo": ["bar", "baz"]}'

      -- Method: iterencode (o)

          Encode the given object, _o_, and yield each string
          representation as available.  For example:

               for chunk in JSONEncoder().iterencode(bigobject):
                   mysocket.write(chunk)


File: python.info,  Node: Standard Compliance,  Prev: Encoders and Decoders,  Up: json --- JSON encoder and decoder

5.18.2.3 Standard Compliance
............................

The JSON format is specified by RFC 4627(1).  This section details this
module’s level of compliance with the RFC. For simplicity, *note
JSONEncoder: 1862. and *note JSONDecoder: 1d0. subclasses, and
parameters other than those explicitly mentioned, are not considered.

  This module does not comply with the RFC in a strict fashion,
implementing some extensions that are valid JavaScript but not valid
JSON. In particular:

   - Top-level non-object, non-array values are accepted and output;

   - Infinite and NaN number values are accepted and output;

   - Repeated names within an object are accepted, and only the value of
     the last name-value pair is used.

  Since the RFC permits RFC-compliant parsers to accept input texts that
are not RFC-compliant, this module’s deserializer is technically
RFC-compliant under default settings.

* Menu:

* Character Encodings:: 
* Top-level Non-Object, Non-Array Values: Top-level Non-Object Non-Array Values. 
* Infinite and NaN Number Values:: 
* Repeated Names Within an Object:: 

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc4627.html


File: python.info,  Node: Character Encodings,  Next: Top-level Non-Object Non-Array Values,  Up: Standard Compliance

5.18.2.4 Character Encodings
............................

The RFC recommends that JSON be represented using either UTF-8, UTF-16,
or UTF-32, with UTF-8 being the default.  Accordingly, this module uses
UTF-8 as the default for its _encoding_ parameter.

  This module’s deserializer only directly works with ASCII-compatible
encodings; UTF-16, UTF-32, and other ASCII-incompatible encodings
require the use of workarounds described in the documentation for the
deserializer’s _encoding_ parameter.

  The RFC also non-normatively describes a limited encoding detection
technique for JSON texts; this module’s deserializer does not implement
this or any other kind of encoding detection.

  As permitted, though not required, by the RFC, this module’s
serializer sets _ensure_ascii=True_ by default, thus escaping the output
so that the resulting strings only contain ASCII characters.


File: python.info,  Node: Top-level Non-Object Non-Array Values,  Next: Infinite and NaN Number Values,  Prev: Character Encodings,  Up: Standard Compliance

5.18.2.5 Top-level Non-Object, Non-Array Values
...............................................

The RFC specifies that the top-level value of a JSON text must be either
a JSON object or array (Python *note dict: 305. or *note list: 3bc.).
This module’s deserializer also accepts input texts consisting solely of
a JSON null, boolean, number, or string value:

     >>> just_a_json_string = '"spam and eggs"'  # Not by itself a valid JSON text
     >>> json.loads(just_a_json_string)
     u'spam and eggs'

  This module itself does not include a way to request that such input
texts be regarded as illegal.  Likewise, this module’s serializer also
accepts single Python *note None: 39a, *note bool: 43c, numeric, and
*note str: 1ea. values as input and will generate output texts
consisting solely of a top-level JSON null, boolean, number, or string
value without raising an exception:

     >>> neither_a_list_nor_a_dict = u"spam and eggs"
     >>> json.dumps(neither_a_list_nor_a_dict)  # The result is not a valid JSON text
     '"spam and eggs"'

  This module’s serializer does not itself include a way to enforce the
aforementioned constraint.


File: python.info,  Node: Infinite and NaN Number Values,  Next: Repeated Names Within an Object,  Prev: Top-level Non-Object Non-Array Values,  Up: Standard Compliance

5.18.2.6 Infinite and NaN Number Values
.......................................

The RFC does not permit the representation of infinite or NaN number
values.  Despite that, by default, this module accepts and outputs
‘Infinity’, ‘-Infinity’, and ‘NaN’ as if they were valid JSON number
literal values:

     >>> # Neither of these calls raises an exception, but the results are not valid JSON
     >>> json.dumps(float('-inf'))
     '-Infinity'
     >>> json.dumps(float('nan'))
     'NaN'
     >>> # Same when deserializing
     >>> json.loads('-Infinity')
     -inf
     >>> json.loads('NaN')
     nan

  In the serializer, the _allow_nan_ parameter can be used to alter this
behavior.  In the deserializer, the _parse_constant_ parameter can be
used to alter this behavior.


File: python.info,  Node: Repeated Names Within an Object,  Prev: Infinite and NaN Number Values,  Up: Standard Compliance

5.18.2.7 Repeated Names Within an Object
........................................

The RFC specifies that the names within a JSON object should be unique,
but does not specify how repeated names in JSON objects should be
handled.  By default, this module does not raise an exception; instead,
it ignores all but the last name-value pair for a given name:

     >>> weird_json = '{"x": 1, "x": 2, "x": 3}'
     >>> json.loads(weird_json)
     {u'x': 3}

  The _object_pairs_hook_ parameter can be used to alter this behavior.


File: python.info,  Node: mailcap --- Mailcap file handling,  Next: mailbox --- Manipulate mailboxes in various formats,  Prev: json --- JSON encoder and decoder,  Up: Internet Data Handling

5.18.3 ‘mailcap’ — Mailcap file handling
----------------------------------------

*Source code:* Lib/mailcap.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  Mailcap files are used to configure how MIME-aware applications such
as mail readers and Web browsers react to files with different MIME
types.  (The name "mailcap" is derived from the phrase "mail
capability".)  For example, a mailcap file might contain a line like
‘video/mpeg; xmpeg %s’.  Then, if the user encounters an email message
or Web document with the MIME type ‘video/mpeg’, ‘%s’ will be replaced
by a filename (usually one belonging to a temporary file) and the
*xmpeg* program can be automatically started to view the file.

  The mailcap format is documented in RFC 1524(2), "A User Agent
Configuration Mechanism For Multimedia Mail Format Information," but is
not an Internet standard.  However, mailcap files are supported on most
Unix systems.

 -- Function: mailcap.findmatch (caps, MIMEtype[, key[, filename[,
          plist]]])

     Return a 2-tuple; the first element is a string containing the
     command line to be executed (which can be passed to *note
     os.system(): 3fa.), and the second element is the mailcap entry for
     a given MIME type.  If no matching MIME type can be found, ‘(None,
     None)’ is returned.

     _key_ is the name of the field desired, which represents the type
     of activity to be performed; the default value is ’view’, since in
     the most common case you simply want to view the body of the
     MIME-typed data.  Other possible values might be ’compose’ and
     ’edit’, if you wanted to create a new body of the given MIME type
     or alter the existing body data.  See RFC 1524(3) for a complete
     list of these fields.

     _filename_ is the filename to be substituted for ‘%s’ in the
     command line; the default value is ‘'/dev/null'’ which is almost
     certainly not what you want, so usually you’ll override it by
     specifying a filename.

     _plist_ can be a list containing named parameters; the default
     value is simply an empty list.  Each entry in the list must be a
     string containing the parameter name, an equals sign (‘'='’), and
     the parameter’s value.  Mailcap entries can contain named
     parameters like ‘%{foo}’, which will be replaced by the value of
     the parameter named ’foo’.  For example, if the command line
     ‘showpartial %{id} %{number} %{total}’ was in a mailcap file, and
     _plist_ was set to ‘['id=1', 'number=2', 'total=3']’, the resulting
     command line would be ‘'showpartial 1 2 3'’.

     In a mailcap file, the "test" field can optionally be specified to
     test some external condition (such as the machine architecture, or
     the window system in use) to determine whether or not the mailcap
     line applies.  *note findmatch(): 1875. will automatically check
     such conditions and skip the entry if the check fails.

 -- Function: mailcap.getcaps ()

     Returns a dictionary mapping MIME types to a list of mailcap file
     entries.  This dictionary must be passed to the *note findmatch():
     1875. function.  An entry is stored as a list of dictionaries, but
     it shouldn’t be necessary to know the details of this
     representation.

     The information is derived from all of the mailcap files found on
     the system.  Settings in the user’s mailcap file ‘$HOME/.mailcap’
     will override settings in the system mailcap files ‘/etc/mailcap’,
     ‘/usr/etc/mailcap’, and ‘/usr/local/etc/mailcap’.

  An example usage:

     >>> import mailcap
     >>> d=mailcap.getcaps()
     >>> mailcap.findmatch(d, 'video/mpeg', filename='tmp1223')
     ('xmpeg tmp1223', {'view': 'xmpeg %s'})

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/mailcap.py

   (2) http://tools.ietf.org/html/rfc1524.html

   (3) http://tools.ietf.org/html/rfc1524.html


File: python.info,  Node: mailbox --- Manipulate mailboxes in various formats,  Next: mhlib --- Access to MH mailboxes,  Prev: mailcap --- Mailcap file handling,  Up: Internet Data Handling

5.18.4 ‘mailbox’ — Manipulate mailboxes in various formats
----------------------------------------------------------

This module defines two classes, *note Mailbox: 1879. and *note Message:
187a, for accessing and manipulating on-disk mailboxes and the messages
they contain.  *note Mailbox: 1879. offers a dictionary-like mapping
from keys to messages.  *note Message: 187a. extends the *note
email.message: c2. module’s *note Message: 216. class with
format-specific state and behavior.  Supported mailbox formats are
Maildir, mbox, MH, Babyl, and MMDF.

See also
........

Module *note email: bb.

     Represent and manipulate messages.

* Menu:

* Mailbox objects:: 
* Message objects:: 
* Exceptions: Exceptions<5>. 
* Deprecated classes and methods:: 
* Examples: Examples<9>. 

Mailbox objects

* Maildir:: 
* mbox:: 
* MH:: 
* Babyl:: 
* MMDF:: 

Message objects

* MaildirMessage:: 
* mboxMessage:: 
* MHMessage:: 
* BabylMessage:: 
* MMDFMessage:: 


File: python.info,  Node: Mailbox objects,  Next: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.1 ‘Mailbox’ objects
..........................

 -- Class: mailbox.Mailbox

     A mailbox, which may be inspected and modified.

     The *note Mailbox: 1879. class defines an interface and is not
     intended to be instantiated.  Instead, format-specific subclasses
     should inherit from *note Mailbox: 1879. and your code should
     instantiate a particular subclass.

     The *note Mailbox: 1879. interface is dictionary-like, with small
     keys corresponding to messages.  Keys are issued by the *note
     Mailbox: 1879. instance with which they will be used and are only
     meaningful to that *note Mailbox: 1879. instance.  A key continues
     to identify a message even if the corresponding message is
     modified, such as by replacing it with another message.

     Messages may be added to a *note Mailbox: 1879. instance using the
     set-like method *note add(): 187d. and removed using a ‘del’
     statement or the set-like methods *note remove(): 187e. and *note
     discard(): 187f.

     *note Mailbox: 1879. interface semantics differ from dictionary
     semantics in some noteworthy ways.  Each time a message is
     requested, a new representation (typically a *note Message: 187a.
     instance) is generated based upon the current state of the mailbox.
     Similarly, when a message is added to a *note Mailbox: 1879.
     instance, the provided message representation’s contents are
     copied.  In neither case is a reference to the message
     representation kept by the *note Mailbox: 1879. instance.

     The default *note Mailbox: 1879. iterator iterates over message
     representations, not keys as the default dictionary iterator does.
     Moreover, modification of a mailbox during iteration is safe and
     well-defined.  Messages added to the mailbox after an iterator is
     created will not be seen by the iterator.  Messages removed from
     the mailbox before the iterator yields them will be silently
     skipped, though using a key from an iterator may result in a *note
     KeyError: 205. exception if the corresponding message is
     subsequently removed.

          Warning: Be very cautious when modifying mailboxes that might
          be simultaneously changed by some other process.  The safest
          mailbox format to use for such tasks is Maildir; try to avoid
          using single-file formats such as mbox for concurrent writing.
          If you’re modifying a mailbox, you _must_ lock it by calling
          the *note lock(): 1880. and *note unlock(): 1881. methods
          _before_ reading any messages in the file or making any
          changes by adding or deleting a message.  Failing to lock the
          mailbox runs the risk of losing messages or corrupting the
          entire mailbox.

     *note Mailbox: 1879. instances have the following methods:

      -- Method: add (message)

          Add _message_ to the mailbox and return the key that has been
          assigned to it.

          Parameter _message_ may be a *note Message: 187a. instance, an
          *note email.message.Message: 216. instance, a string, or a
          file-like object (which should be open in text mode).  If
          _message_ is an instance of the appropriate format-specific
          *note Message: 187a. subclass (e.g., if it’s an *note
          mboxMessage: 1882. instance and this is an *note mbox: 1883.
          instance), its format-specific information is used.
          Otherwise, reasonable defaults for format-specific information
          are used.

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)

          Delete the message corresponding to _key_ from the mailbox.

          If no such message exists, a *note KeyError: 205. exception is
          raised if the method was called as *note remove(): 187e. or
          *note __delitem__(): 1884. but no exception is raised if the
          method was called as *note discard(): 187f.  The behavior of
          *note discard(): 187f. may be preferred if the underlying
          mailbox format supports concurrent modification by other
          processes.

      -- Method: __setitem__ (key, message)

          Replace the message corresponding to _key_ with _message_.
          Raise a *note KeyError: 205. exception if no message already
          corresponds to _key_.

          As with *note add(): 187d, parameter _message_ may be a *note
          Message: 187a. instance, an *note email.message.Message: 216.
          instance, a string, or a file-like object (which should be
          open in text mode).  If _message_ is an instance of the
          appropriate format-specific *note Message: 187a. subclass
          (e.g., if it’s an *note mboxMessage: 1882. instance and this
          is an *note mbox: 1883. instance), its format-specific
          information is used.  Otherwise, the format-specific
          information of the message that currently corresponds to _key_
          is left unchanged.

      -- Method: iterkeys ()
      -- Method: keys ()

          Return an iterator over all keys if called as *note
          iterkeys(): 1886. or return a list of keys if called as *note
          keys(): 1887.

      -- Method: itervalues ()
      -- Method: __iter__ ()
      -- Method: values ()

          Return an iterator over representations of all messages if
          called as *note itervalues(): 1888. or *note __iter__(): 1889.
          or return a list of such representations if called as *note
          values(): 188a.  The messages are represented as instances of
          the appropriate format-specific *note Message: 187a. subclass
          unless a custom message factory was specified when the *note
          Mailbox: 1879. instance was initialized.

               Note: The behavior of *note __iter__(): 1889. is unlike
               that of dictionaries, which iterate over keys.

      -- Method: iteritems ()
      -- Method: items ()

          Return an iterator over (_key_, _message_) pairs, where _key_
          is a key and _message_ is a message representation, if called
          as *note iteritems(): 188b. or return a list of such pairs if
          called as *note items(): 188c.  The messages are represented
          as instances of the appropriate format-specific *note Message:
          187a. subclass unless a custom message factory was specified
          when the *note Mailbox: 1879. instance was initialized.

      -- Method: get (key, default=None)
      -- Method: __getitem__ (key)

          Return a representation of the message corresponding to _key_.
          If no such message exists, _default_ is returned if the method
          was called as *note get(): 188d. and a *note KeyError: 205.
          exception is raised if the method was called as *note
          __getitem__(): 188e.  The message is represented as an
          instance of the appropriate format-specific *note Message:
          187a. subclass unless a custom message factory was specified
          when the *note Mailbox: 1879. instance was initialized.

      -- Method: get_message (key)

          Return a representation of the message corresponding to _key_
          as an instance of the appropriate format-specific *note
          Message: 187a. subclass, or raise a *note KeyError: 205.
          exception if no such message exists.

      -- Method: get_string (key)

          Return a string representation of the message corresponding to
          _key_, or raise a *note KeyError: 205. exception if no such
          message exists.

      -- Method: get_file (key)

          Return a file-like representation of the message corresponding
          to _key_, or raise a *note KeyError: 205. exception if no such
          message exists.  The file-like object behaves as if open in
          binary mode.  This file should be closed once it is no longer
          needed.

               Note: Unlike other representations of messages, file-like
               representations are not necessarily independent of the
               *note Mailbox: 1879. instance that created them or of the
               underlying mailbox.  More specific documentation is
               provided by each subclass.

      -- Method: has_key (key)
      -- Method: __contains__ (key)

          Return ‘True’ if _key_ corresponds to a message, ‘False’
          otherwise.

      -- Method: __len__ ()

          Return a count of messages in the mailbox.

      -- Method: clear ()

          Delete all messages from the mailbox.

      -- Method: pop (key[, default])

          Return a representation of the message corresponding to _key_
          and delete the message.  If no such message exists, return
          _default_ if it was supplied or else raise a *note KeyError:
          205. exception.  The message is represented as an instance of
          the appropriate format-specific *note Message: 187a. subclass
          unless a custom message factory was specified when the *note
          Mailbox: 1879. instance was initialized.

      -- Method: popitem ()

          Return an arbitrary (_key_, _message_) pair, where _key_ is a
          key and _message_ is a message representation, and delete the
          corresponding message.  If the mailbox is empty, raise a *note
          KeyError: 205. exception.  The message is represented as an
          instance of the appropriate format-specific *note Message:
          187a. subclass unless a custom message factory was specified
          when the *note Mailbox: 1879. instance was initialized.

      -- Method: update (arg)

          Parameter _arg_ should be a _key_-to-_message_ mapping or an
          iterable of (_key_, _message_) pairs.  Updates the mailbox so
          that, for each given _key_ and _message_, the message
          corresponding to _key_ is set to _message_ as if by using
          *note __setitem__(): 1885.  As with *note __setitem__(): 1885,
          each _key_ must already correspond to a message in the mailbox
          or else a *note KeyError: 205. exception will be raised, so in
          general it is incorrect for _arg_ to be a *note Mailbox: 1879.
          instance.

               Note: Unlike with dictionaries, keyword arguments are not
               supported.

      -- Method: flush ()

          Write any pending changes to the filesystem.  For some *note
          Mailbox: 1879. subclasses, changes are always written
          immediately and *note flush(): 1899. does nothing, but you
          should still make a habit of calling this method.

      -- Method: lock ()

          Acquire an exclusive advisory lock on the mailbox so that
          other processes know not to modify it.  An *note
          ExternalClashError: 189a. is raised if the lock is not
          available.  The particular locking mechanisms used depend upon
          the mailbox format.  You should _always_ lock the mailbox
          before making any modifications to its contents.

      -- Method: unlock ()

          Release the lock on the mailbox, if any.

      -- Method: close ()

          Flush the mailbox, unlock it if necessary, and close any open
          files.  For some *note Mailbox: 1879. subclasses, this method
          does nothing.

* Menu:

* Maildir:: 
* mbox:: 
* MH:: 
* Babyl:: 
* MMDF:: 


File: python.info,  Node: Maildir,  Next: mbox,  Up: Mailbox objects

5.18.4.2 ‘Maildir’
..................

 -- Class: mailbox.Maildir (dirname, factory=rfc822.Message,
          create=True)

     A subclass of *note Mailbox: 1879. for mailboxes in Maildir format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is ‘None’, *note
     MaildirMessage: 189e. is used as the default message
     representation.  If _create_ is ‘True’, the mailbox is created if
     it does not exist.

     It is for historical reasons that _factory_ defaults to *note
     rfc822.Message: 189f. and that _dirname_ is named as such rather
     than _path_.  For a *note Maildir: 238. instance that behaves like
     instances of other *note Mailbox: 1879. subclasses, set _factory_
     to ‘None’.

     Maildir is a directory-based mailbox format invented for the qmail
     mail transfer agent and now widely supported by other programs.
     Messages in a Maildir mailbox are stored in separate files within a
     common directory structure.  This design allows Maildir mailboxes
     to be accessed and modified by multiple unrelated programs without
     data corruption, so file locking is unnecessary.

     Maildir mailboxes contain three subdirectories, namely: ‘tmp’,
     ‘new’, and ‘cur’.  Messages are created momentarily in the ‘tmp’
     subdirectory and then moved to the ‘new’ subdirectory to finalize
     delivery.  A mail user agent may subsequently move the message to
     the ‘cur’ subdirectory and store information about the state of the
     message in a special "info" section appended to its file name.

     Folders of the style introduced by the Courier mail transfer agent
     are also supported.  Any subdirectory of the main mailbox is
     considered a folder if ‘'.'’ is the first character in its name.
     Folder names are represented by *note Maildir: 238. without the
     leading ‘'.'’.  Each folder is itself a Maildir mailbox but should
     not contain other folders.  Instead, a logical nesting is indicated
     using ‘'.'’ to delimit levels, e.g., "Archived.2005.07".

          Note: The Maildir specification requires the use of a colon
          (‘':'’) in certain message file names.  However, some
          operating systems do not permit this character in file names,
          If you wish to use a Maildir-like format on such an operating
          system, you should specify another character to use instead.
          The exclamation point (‘'!'’) is a popular choice.  For
          example:

               import mailbox
               mailbox.Maildir.colon = '!'

          The ‘colon’ attribute may also be set on a per-instance basis.

     *note Maildir: 238. instances have all of the methods of *note
     Mailbox: 1879. in addition to the following:

      -- Method: list_folders ()

          Return a list of the names of all folders.

      -- Method: get_folder (folder)

          Return a *note Maildir: 238. instance representing the folder
          whose name is _folder_.  A *note NoSuchMailboxError: 18a2.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)

          Create a folder whose name is _folder_ and return a *note
          Maildir: 238. instance representing it.

      -- Method: remove_folder (folder)

          Delete the folder whose name is _folder_.  If the folder
          contains any messages, a *note NotEmptyError: 18a5. exception
          will be raised and the folder will not be deleted.

      -- Method: clean ()

          Delete temporary files from the mailbox that have not been
          accessed in the last 36 hours.  The Maildir specification says
          that mail-reading programs should do this occasionally.

     Some *note Mailbox: 1879. methods implemented by *note Maildir:
     238. deserve special remarks:

      -- Method: add (message)
      -- Method: __setitem__ (key, message)
      -- Method: update (arg)

               Warning: These methods generate unique file names based
               upon the current process ID. When using multiple threads,
               undetected name clashes may occur and cause corruption of
               the mailbox unless threads are coordinated to avoid using
               these methods to manipulate the same mailbox
               simultaneously.

      -- Method: flush ()

          All changes to Maildir mailboxes are immediately applied, so
          this method does nothing.

      -- Method: lock ()
      -- Method: unlock ()

          Maildir mailboxes do not support (or require) locking, so
          these methods do nothing.

      -- Method: close ()

          *note Maildir: 238. instances do not keep any open files and
          the underlying mailboxes do not support locking, so this
          method does nothing.

      -- Method: get_file (key)

          Depending upon the host platform, it may not be possible to
          modify or remove the underlying message while the returned
          file remains open.

See also
........

maildir man page from qmail(1)

     The original specification of the format.

Using maildir format(2)

     Notes on Maildir by its inventor.  Includes an updated
     name-creation scheme and details on "info" semantics.

maildir man page from Courier(3)

     Another specification of the format.  Describes a common extension
     for supporting folders.

   ---------- Footnotes ----------

   (1) http://www.qmail.org/man/man5/maildir.html

   (2) http://cr.yp.to/proto/maildir.html

   (3) http://www.courier-mta.org/maildir.html


File: python.info,  Node: mbox,  Next: MH,  Prev: Maildir,  Up: Mailbox objects

5.18.4.3 ‘mbox’
...............

 -- Class: mailbox.mbox (path, factory=None, create=True)

     A subclass of *note Mailbox: 1879. for mailboxes in mbox format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is ‘None’, *note
     mboxMessage: 1882. is used as the default message representation.
     If _create_ is ‘True’, the mailbox is created if it does not exist.

     The mbox format is the classic format for storing mail on Unix
     systems.  All messages in an mbox mailbox are stored in a single
     file with the beginning of each message indicated by a line whose
     first five characters are "From ".

     Several variations of the mbox format exist to address perceived
     shortcomings in the original.  In the interest of compatibility,
     *note mbox: 1883. implements the original format, which is
     sometimes referred to as _mboxo_.  This means that the
     ‘Content-Length’ header, if present, is ignored and that any
     occurrences of "From " at the beginning of a line in a message body
     are transformed to ">From " when storing the message, although
     occurrences of ">From " are not transformed to "From " when reading
     the message.

     Some *note Mailbox: 1879. methods implemented by *note mbox: 1883.
     deserve special remarks:

      -- Method: get_file (key)

          Using the file after calling ‘flush()’ or ‘close()’ on the
          *note mbox: 1883. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

mbox man page from qmail(1)

     A specification of the format and its variations.

mbox man page from tin(2)

     Another specification of the format, with details on locking.

Configuring Netscape Mail on Unix: Why The Content-Length Format is Bad(3)

     An argument for using the original mbox format rather than a
     variation.

"mbox" is a family of several mutually incompatible mailbox formats(4)

     A history of mbox variations.

   ---------- Footnotes ----------

   (1) http://www.qmail.org/man/man5/mbox.html

   (2) http://www.tin.org/bin/man.cgi?section=5&topic=mbox

   (3) http://www.jwz.org/doc/content-length.html

   (4) 
http://homepages.tesco.net./~J.deBoynePollard/FGA/mail-mbox-formats.html


File: python.info,  Node: MH,  Next: Babyl,  Prev: mbox,  Up: Mailbox objects

5.18.4.4 ‘MH’
.............

 -- Class: mailbox.MH (path, factory=None, create=True)

     A subclass of *note Mailbox: 1879. for mailboxes in MH format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is ‘None’, *note
     MHMessage: 18b7. is used as the default message representation.  If
     _create_ is ‘True’, the mailbox is created if it does not exist.

     MH is a directory-based mailbox format invented for the MH Message
     Handling System, a mail user agent.  Each message in an MH mailbox
     resides in its own file.  An MH mailbox may contain other MH
     mailboxes (called _folders_) in addition to messages.  Folders may
     be nested indefinitely.  MH mailboxes also support _sequences_,
     which are named lists used to logically group messages without
     moving them to sub-folders.  Sequences are defined in a file called
     ‘.mh_sequences’ in each folder.

     The *note MH: 18b6. class manipulates MH mailboxes, but it does not
     attempt to emulate all of *mh*’s behaviors.  In particular, it does
     not modify and is not affected by the ‘context’ or ‘.mh_profile’
     files that are used by *mh* to store its state and configuration.

     *note MH: 18b6. instances have all of the methods of *note Mailbox:
     1879. in addition to the following:

      -- Method: list_folders ()

          Return a list of the names of all folders.

      -- Method: get_folder (folder)

          Return an *note MH: 18b6. instance representing the folder
          whose name is _folder_.  A *note NoSuchMailboxError: 18a2.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)

          Create a folder whose name is _folder_ and return an *note MH:
          18b6. instance representing it.

      -- Method: remove_folder (folder)

          Delete the folder whose name is _folder_.  If the folder
          contains any messages, a *note NotEmptyError: 18a5. exception
          will be raised and the folder will not be deleted.

      -- Method: get_sequences ()

          Return a dictionary of sequence names mapped to key lists.  If
          there are no sequences, the empty dictionary is returned.

      -- Method: set_sequences (sequences)

          Re-define the sequences that exist in the mailbox based upon
          _sequences_, a dictionary of names mapped to key lists, like
          returned by *note get_sequences(): 18bc.

      -- Method: pack ()

          Rename messages in the mailbox as necessary to eliminate gaps
          in numbering.  Entries in the sequences list are updated
          correspondingly.

               Note: Already-issued keys are invalidated by this
               operation and should not be subsequently used.

     Some *note Mailbox: 1879. methods implemented by *note MH: 18b6.
     deserve special remarks:

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)

          These methods immediately delete the message.  The MH
          convention of marking a message for deletion by prepending a
          comma to its name is not used.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.  For MH
          mailboxes, locking the mailbox means locking the
          ‘.mh_sequences’ file and, only for the duration of any
          operations that affect them, locking individual message files.

      -- Method: get_file (key)

          Depending upon the host platform, it may not be possible to
          remove the underlying message while the returned file remains
          open.

      -- Method: flush ()

          All changes to MH mailboxes are immediately applied, so this
          method does nothing.

      -- Method: close ()

          *note MH: 18b6. instances do not keep any open files, so this
          method is equivalent to *note unlock(): 18c3.

See also
........

nmh - Message Handling System(1)

     Home page of *nmh*, an updated version of the original *mh*.

MH & nmh: Email for Users & Programmers(2)

     A GPL-licensed book on *mh* and *nmh*, with some information on the
     mailbox format.

   ---------- Footnotes ----------

   (1) http://www.nongnu.org/nmh/

   (2) http://rand-mh.sourceforge.net/book/


File: python.info,  Node: Babyl,  Next: MMDF,  Prev: MH,  Up: Mailbox objects

5.18.4.5 ‘Babyl’
................

 -- Class: mailbox.Babyl (path, factory=None, create=True)

     A subclass of *note Mailbox: 1879. for mailboxes in Babyl format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is ‘None’, *note
     BabylMessage: 18ca. is used as the default message representation.
     If _create_ is ‘True’, the mailbox is created if it does not exist.

     Babyl is a single-file mailbox format used by the Rmail mail user
     agent included with Emacs.  The beginning of a message is indicated
     by a line containing the two characters Control-Underscore
     (‘'\037'’) and Control-L (‘'\014'’).  The end of a message is
     indicated by the start of the next message or, in the case of the
     last message, a line containing a Control-Underscore (‘'\037'’)
     character.

     Messages in a Babyl mailbox have two sets of headers, original
     headers and so-called visible headers.  Visible headers are
     typically a subset of the original headers that have been
     reformatted or abridged to be more attractive.  Each message in a
     Babyl mailbox also has an accompanying list of _labels_, or short
     strings that record extra information about the message, and a list
     of all user-defined labels found in the mailbox is kept in the
     Babyl options section.

     *note Babyl: 18c9. instances have all of the methods of *note
     Mailbox: 1879. in addition to the following:

      -- Method: get_labels ()

          Return a list of the names of all user-defined labels used in
          the mailbox.

               Note: The actual messages are inspected to determine
               which labels exist in the mailbox rather than consulting
               the list of labels in the Babyl options section, but the
               Babyl section is updated whenever the mailbox is
               modified.

     Some *note Mailbox: 1879. methods implemented by *note Babyl: 18c9.
     deserve special remarks:

      -- Method: get_file (key)

          In Babyl mailboxes, the headers of a message are not stored
          contiguously with the body of the message.  To generate a
          file-like representation, the headers and body are copied
          together into a *note StringIO: 2dd. instance (from the *note
          StringIO: 164. module), which has an API identical to that of
          a file.  As a result, the file-like object is truly
          independent of the underlying mailbox but does not save memory
          compared to a string representation.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

Format of Version 5 Babyl Files(1)

     A specification of the Babyl format.

Reading Mail with Rmail(2)

     The Rmail manual, with some information on Babyl semantics.

   ---------- Footnotes ----------

   (1) http://quimby.gnus.org/notes/BABYL

   (2) 
http://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html


File: python.info,  Node: MMDF,  Prev: Babyl,  Up: Mailbox objects

5.18.4.6 ‘MMDF’
...............

 -- Class: mailbox.MMDF (path, factory=None, create=True)

     A subclass of *note Mailbox: 1879. for mailboxes in MMDF format.
     Parameter _factory_ is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If _factory_ is ‘None’, *note
     MMDFMessage: 18d2. is used as the default message representation.
     If _create_ is ‘True’, the mailbox is created if it does not exist.

     MMDF is a single-file mailbox format invented for the Multichannel
     Memorandum Distribution Facility, a mail transfer agent.  Each
     message is in the same form as an mbox message but is bracketed
     before and after by lines containing four Control-A (‘'\001'’)
     characters.  As with the mbox format, the beginning of each message
     is indicated by a line whose first five characters are "From ", but
     additional occurrences of "From " are not transformed to ">From "
     when storing messages because the extra message separator lines
     prevent mistaking such occurrences for the starts of subsequent
     messages.

     Some *note Mailbox: 1879. methods implemented by *note MMDF: 18d1.
     deserve special remarks:

      -- Method: get_file (key)

          Using the file after calling ‘flush()’ or ‘close()’ on the
          *note MMDF: 18d1. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()

          Three locking mechanisms are used—dot locking and, if
          available, the ‘flock()’ and ‘lockf()’ system calls.

See also
........

mmdf man page from tin(1)

     A specification of MMDF format from the documentation of tin, a
     newsreader.

MMDF(2)

     A Wikipedia article describing the Multichannel Memorandum
     Distribution Facility.

   ---------- Footnotes ----------

   (1) http://www.tin.org/bin/man.cgi?section=5&topic=mmdf

   (2) http://en.wikipedia.org/wiki/MMDF


File: python.info,  Node: Message objects,  Next: Exceptions<5>,  Prev: Mailbox objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.7 ‘Message’ objects
..........................

 -- Class: mailbox.Message ([message])

     A subclass of the *note email.message: c2. module’s *note Message:
     216.  Subclasses of *note mailbox.Message: 187a. add
     mailbox-format-specific state and behavior.

     If _message_ is omitted, the new instance is created in a default,
     empty state.  If _message_ is an *note email.message.Message: 216.
     instance, its contents are copied; furthermore, any format-specific
     information is converted insofar as possible if _message_ is a
     *note Message: 187a. instance.  If _message_ is a string or a file,
     it should contain an RFC 2822(1)-compliant message, which is read
     and parsed.

     The format-specific state and behaviors offered by subclasses vary,
     but in general it is only the properties that are not specific to a
     particular mailbox that are supported (although presumably the
     properties are specific to a particular mailbox format).  For
     example, file offsets for single-file mailbox formats and file
     names for directory-based mailbox formats are not retained, because
     they are only applicable to the original mailbox.  But state such
     as whether a message has been read by the user or marked as
     important is retained, because it applies to the message itself.

     There is no requirement that *note Message: 187a. instances be used
     to represent messages retrieved using *note Mailbox: 1879.
     instances.  In some situations, the time and memory required to
     generate *note Message: 187a. representations might not be
     acceptable.  For such situations, *note Mailbox: 1879. instances
     also offer string and file-like representations, and a custom
     message factory may be specified when a *note Mailbox: 1879.
     instance is initialized.

* Menu:

* MaildirMessage:: 
* mboxMessage:: 
* MHMessage:: 
* BabylMessage:: 
* MMDFMessage:: 

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: MaildirMessage,  Next: mboxMessage,  Up: Message objects

5.18.4.8 ‘MaildirMessage’
.........................

 -- Class: mailbox.MaildirMessage ([message])

     A message with Maildir-specific behaviors.  Parameter _message_ has
     the same meaning as with the *note Message: 187a. constructor.

     Typically, a mail user agent application moves all of the messages
     in the ‘new’ subdirectory to the ‘cur’ subdirectory after the first
     time the user opens and closes the mailbox, recording that the
     messages are old whether or not they’ve actually been read.  Each
     message in ‘cur’ has an "info" section added to its file name to
     store information about its state.  (Some mail readers may also add
     an "info" section to messages in ‘new’.)  The "info" section may
     take one of two forms: it may contain "2," followed by a list of
     standardized flags (e.g., "2,FR") or it may contain "1," followed
     by so-called experimental information.  Standard flags for Maildir
     messages are as follows:

     Flag       Meaning       Explanation
                              
     --------------------------------------------------------------
                              
     D          Draft         Under composition
                              
                              
     F          Flagged       Marked as important
                              
                              
     P          Passed        Forwarded, resent, or bounced
                              
                              
     R          Replied       Replied to
                              
                              
     S          Seen          Read
                              
                              
     T          Trashed       Marked for subsequent deletion
                              

     *note MaildirMessage: 189e. instances offer the following methods:

      -- Method: get_subdir ()

          Return either "new" (if the message should be stored in the
          ‘new’ subdirectory) or "cur" (if the message should be stored
          in the ‘cur’ subdirectory).

               Note: A message is typically moved from ‘new’ to ‘cur’
               after its mailbox has been accessed, whether or not the
               message is has been read.  A message ‘msg’ has been read
               if ‘"S" in msg.get_flags()’ is ‘True’.

      -- Method: set_subdir (subdir)

          Set the subdirectory the message should be stored in.
          Parameter _subdir_ must be either "new" or "cur".

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the standard Maildir format, the
          result is the concatenation in alphabetical order of zero or
          one occurrence of each of ‘'D'’, ‘'F'’, ‘'P'’, ‘'R'’, ‘'S'’,
          and ‘'T'’.  The empty string is returned if no flags are set
          or if "info" contains experimental semantics.

      -- Method: set_flags (flags)

          Set the flags specified by _flags_ and unset all others.

      -- Method: add_flag (flag)

          Set the flag(s) specified by _flag_ without changing other
          flags.  To add more than one flag at a time, _flag_ may be a
          string of more than one character.  The current "info" is
          overwritten whether or not it contains experimental
          information rather than flags.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by _flag_ without changing other
          flags.  To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.  If "info" contains
          experimental information rather than flags, the current "info"
          is not modified.

      -- Method: get_date ()

          Return the delivery date of the message as a floating-point
          number representing seconds since the epoch.

      -- Method: set_date (date)

          Set the delivery date of the message to _date_, a
          floating-point number representing seconds since the epoch.

      -- Method: get_info ()

          Return a string containing the "info" for a message.  This is
          useful for accessing and modifying "info" that is experimental
          (i.e., not a list of flags).

      -- Method: set_info (info)

          Set "info" to _info_, which should be a string.

  When a *note MaildirMessage: 189e. instance is created based upon an
*note mboxMessage: 1882. or *note MMDFMessage: 18d2. instance, the
‘Status’ and ‘X-Status’ headers are omitted and the following
conversions take place:

Resulting state          *note mboxMessage: 1882. or *note MMDFMessage:
                         18d2. state
                         
----------------------------------------------------------------------------
                         
"cur" subdirectory       O flag
                         
                         
F flag                   F flag
                         
                         
R flag                   A flag
                         
                         
S flag                   R flag
                         
                         
T flag                   D flag
                         

  When a *note MaildirMessage: 189e. instance is created based upon an
*note MHMessage: 18b7. instance, the following conversions take place:

Resulting state                     *note MHMessage: 18b7. state
                                    
-------------------------------------------------------------------
                                    
"cur" subdirectory                  "unseen" sequence
                                    
                                    
"cur" subdirectory and S flag       no "unseen" sequence
                                    
                                    
F flag                              "flagged" sequence
                                    
                                    
R flag                              "replied" sequence
                                    

  When a *note MaildirMessage: 189e. instance is created based upon a
*note BabylMessage: 18ca. instance, the following conversions take
place:

Resulting state                     *note BabylMessage: 18ca. state
                                    
------------------------------------------------------------------------
                                    
"cur" subdirectory                  "unseen" label
                                    
                                    
"cur" subdirectory and S flag       no "unseen" label
                                    
                                    
P flag                              "forwarded" or "resent" label
                                    
                                    
R flag                              "answered" label
                                    
                                    
T flag                              "deleted" label
                                    


File: python.info,  Node: mboxMessage,  Next: MHMessage,  Prev: MaildirMessage,  Up: Message objects

5.18.4.9 ‘mboxMessage’
......................

 -- Class: mailbox.mboxMessage ([message])

     A message with mbox-specific behaviors.  Parameter _message_ has
     the same meaning as with the *note Message: 187a. constructor.

     Messages in an mbox mailbox are stored together in a single file.
     The sender’s envelope address and the time of delivery are
     typically stored in a line beginning with "From " that is used to
     indicate the start of a message, though there is considerable
     variation in the exact format of this data among mbox
     implementations.  Flags that indicate the state of the message,
     such as whether it has been read or marked as important, are
     typically stored in ‘Status’ and ‘X-Status’ headers.

     Conventional flags for mbox messages are as follows:

     Flag       Meaning        Explanation
                               
     ---------------------------------------------------------------
                               
     R          Read           Read
                               
                               
     O          Old            Previously detected by MUA
                               
                               
     D          Deleted        Marked for subsequent deletion
                               
                               
     F          Flagged        Marked as important
                               
                               
     A          Answered       Replied to
                               

     The "R" and "O" flags are stored in the ‘Status’ header, and the
     "D", "F", and "A" flags are stored in the ‘X-Status’ header.  The
     flags and headers typically appear in the order mentioned.

     *note mboxMessage: 1882. instances offer the following methods:

      -- Method: get_from ()

          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox.  The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)

          Set the "From " line to _from__, which should be specified
          without a leading "From " or trailing newline.  For
          convenience, _time__ may be specified and will be formatted
          appropriately and appended to _from__.  If _time__ is
          specified, it should be a *note time.struct_time: ae0.
          instance, a tuple suitable for passing to *note
          time.strftime(): 3be, or ‘True’ (to use *note time.gmtime():
          b54.).

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of ‘'R'’, ‘'O'’, ‘'D'’, ‘'F'’, and
          ‘'A'’.

      -- Method: set_flags (flags)

          Set the flags specified by _flags_ and unset all others.
          Parameter _flags_ should be the concatenation in any order of
          zero or more occurrences of each of ‘'R'’, ‘'O'’, ‘'D'’,
          ‘'F'’, and ‘'A'’.

      -- Method: add_flag (flag)

          Set the flag(s) specified by _flag_ without changing other
          flags.  To add more than one flag at a time, _flag_ may be a
          string of more than one character.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by _flag_ without changing other
          flags.  To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.

  When an *note mboxMessage: 1882. instance is created based upon a
*note MaildirMessage: 189e. instance, a "From " line is generated based
upon the *note MaildirMessage: 189e. instance’s delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 189e. state
                      
----------------------------------------------------------
                      
R flag                S flag
                      
                      
O flag                "cur" subdirectory
                      
                      
D flag                T flag
                      
                      
F flag                F flag
                      
                      
A flag                R flag
                      

  When an *note mboxMessage: 1882. instance is created based upon an
*note MHMessage: 18b7. instance, the following conversions take place:

Resulting state         *note MHMessage: 18b7. state
                        
-------------------------------------------------------
                        
R flag and O flag       no "unseen" sequence
                        
                        
O flag                  "unseen" sequence
                        
                        
F flag                  "flagged" sequence
                        
                        
A flag                  "replied" sequence
                        

  When an *note mboxMessage: 1882. instance is created based upon a
*note BabylMessage: 18ca. instance, the following conversions take
place:

Resulting state         *note BabylMessage: 18ca. state
                        
----------------------------------------------------------
                        
R flag and O flag       no "unseen" label
                        
                        
O flag                  "unseen" label
                        
                        
D flag                  "deleted" label
                        
                        
A flag                  "answered" label
                        

  When a *note Message: 187a. instance is created based upon an *note
MMDFMessage: 18d2. instance, the "From " line is copied and all flags
directly correspond:

Resulting state       *note MMDFMessage: 18d2. state
                      
-------------------------------------------------------
                      
R flag                R flag
                      
                      
O flag                O flag
                      
                      
D flag                D flag
                      
                      
F flag                F flag
                      
                      
A flag                A flag
                      


File: python.info,  Node: MHMessage,  Next: BabylMessage,  Prev: mboxMessage,  Up: Message objects

5.18.4.10 ‘MHMessage’
.....................

 -- Class: mailbox.MHMessage ([message])

     A message with MH-specific behaviors.  Parameter _message_ has the
     same meaning as with the *note Message: 187a. constructor.

     MH messages do not support marks or flags in the traditional sense,
     but they do support sequences, which are logical groupings of
     arbitrary messages.  Some mail reading programs (although not the
     standard *mh* and *nmh*) use sequences in much the same way flags
     are used with other formats, as follows:

     Sequence       Explanation
                    
     --------------------------------------------------------------
                    
     unseen         Not read, but previously detected by MUA
                    
                    
     replied        Replied to
                    
                    
     flagged        Marked as important
                    

     *note MHMessage: 18b7. instances offer the following methods:

      -- Method: get_sequences ()

          Return a list of the names of sequences that include this
          message.

      -- Method: set_sequences (sequences)

          Set the list of sequences that include this message.

      -- Method: add_sequence (sequence)

          Add _sequence_ to the list of sequences that include this
          message.

      -- Method: remove_sequence (sequence)

          Remove _sequence_ from the list of sequences that include this
          message.

  When an *note MHMessage: 18b7. instance is created based upon a *note
MaildirMessage: 189e. instance, the following conversions take place:

Resulting state          *note MaildirMessage: 189e. state
                         
-------------------------------------------------------------
                         
"unseen" sequence        no S flag
                         
                         
"replied" sequence       R flag
                         
                         
"flagged" sequence       F flag
                         

  When an *note MHMessage: 18b7. instance is created based upon an *note
mboxMessage: 1882. or *note MMDFMessage: 18d2. instance, the ‘Status’
and ‘X-Status’ headers are omitted and the following conversions take
place:

Resulting state          *note mboxMessage: 1882. or *note MMDFMessage:
                         18d2. state
                         
----------------------------------------------------------------------------
                         
"unseen" sequence        no R flag
                         
                         
"replied" sequence       A flag
                         
                         
"flagged" sequence       F flag
                         

  When an *note MHMessage: 18b7. instance is created based upon a *note
BabylMessage: 18ca. instance, the following conversions take place:

Resulting state          *note BabylMessage: 18ca. state
                         
-----------------------------------------------------------
                         
"unseen" sequence        "unseen" label
                         
                         
"replied" sequence       "answered" label
                         


File: python.info,  Node: BabylMessage,  Next: MMDFMessage,  Prev: MHMessage,  Up: Message objects

5.18.4.11 ‘BabylMessage’
........................

 -- Class: mailbox.BabylMessage ([message])

     A message with Babyl-specific behaviors.  Parameter _message_ has
     the same meaning as with the *note Message: 187a. constructor.

     Certain message labels, called _attributes_, are defined by
     convention to have special meanings.  The attributes are as
     follows:

     Label           Explanation
                     
     ---------------------------------------------------------------
                     
     unseen          Not read, but previously detected by MUA
                     
                     
     deleted         Marked for subsequent deletion
                     
                     
     filed           Copied to another file or mailbox
                     
                     
     answered        Replied to
                     
                     
     forwarded       Forwarded
                     
                     
     edited          Modified by the user
                     
                     
     resent          Resent
                     

     By default, Rmail displays only visible headers.  The *note
     BabylMessage: 18ca. class, though, uses the original headers
     because they are more complete.  Visible headers may be accessed
     explicitly if desired.

     *note BabylMessage: 18ca. instances offer the following methods:

      -- Method: get_labels ()

          Return a list of labels on the message.

      -- Method: set_labels (labels)

          Set the list of labels on the message to _labels_.

      -- Method: add_label (label)

          Add _label_ to the list of labels on the message.

      -- Method: remove_label (label)

          Remove _label_ from the list of labels on the message.

      -- Method: get_visible ()

          Return an *note Message: 187a. instance whose headers are the
          message’s visible headers and whose body is empty.

      -- Method: set_visible (visible)

          Set the message’s visible headers to be the same as the
          headers in _message_.  Parameter _visible_ should be a *note
          Message: 187a. instance, an *note email.message.Message: 216.
          instance, a string, or a file-like object (which should be
          open in text mode).

      -- Method: update_visible ()

          When a *note BabylMessage: 18ca. instance’s original headers
          are modified, the visible headers are not automatically
          modified to correspond.  This method updates the visible
          headers as follows: each visible header with a corresponding
          original header is set to the value of the original header,
          each visible header without a corresponding original header is
          removed, and any of ‘Date’, ‘From’, ‘Reply-To’, ‘To’, ‘CC’,
          and ‘Subject’ that are present in the original headers but not
          the visible headers are added to the visible headers.

  When a *note BabylMessage: 18ca. instance is created based upon a
*note MaildirMessage: 189e. instance, the following conversions take
place:

Resulting state         *note MaildirMessage: 189e. state
                        
------------------------------------------------------------
                        
"unseen" label          no S flag
                        
                        
"deleted" label         T flag
                        
                        
"answered" label        R flag
                        
                        
"forwarded" label       P flag
                        

  When a *note BabylMessage: 18ca. instance is created based upon an
*note mboxMessage: 1882. or *note MMDFMessage: 18d2. instance, the
‘Status’ and ‘X-Status’ headers are omitted and the following
conversions take place:

Resulting state        *note mboxMessage: 1882. or *note MMDFMessage:
                       18d2. state
                       
--------------------------------------------------------------------------
                       
"unseen" label         no R flag
                       
                       
"deleted" label        D flag
                       
                       
"answered" label       A flag
                       

  When a *note BabylMessage: 18ca. instance is created based upon an
*note MHMessage: 18b7. instance, the following conversions take place:

Resulting state        *note MHMessage: 18b7. state
                       
------------------------------------------------------
                       
"unseen" label         "unseen" sequence
                       
                       
"answered" label       "replied" sequence
                       


File: python.info,  Node: MMDFMessage,  Prev: BabylMessage,  Up: Message objects

5.18.4.12 ‘MMDFMessage’
.......................

 -- Class: mailbox.MMDFMessage ([message])

     A message with MMDF-specific behaviors.  Parameter _message_ has
     the same meaning as with the *note Message: 187a. constructor.

     As with message in an mbox mailbox, MMDF messages are stored with
     the sender’s address and the delivery date in an initial line
     beginning with "From ".  Likewise, flags that indicate the state of
     the message are typically stored in ‘Status’ and ‘X-Status’
     headers.

     Conventional flags for MMDF messages are identical to those of mbox
     message and are as follows:

     Flag       Meaning        Explanation
                               
     ---------------------------------------------------------------
                               
     R          Read           Read
                               
                               
     O          Old            Previously detected by MUA
                               
                               
     D          Deleted        Marked for subsequent deletion
                               
                               
     F          Flagged        Marked as important
                               
                               
     A          Answered       Replied to
                               

     The "R" and "O" flags are stored in the ‘Status’ header, and the
     "D", "F", and "A" flags are stored in the ‘X-Status’ header.  The
     flags and headers typically appear in the order mentioned.

     *note MMDFMessage: 18d2. instances offer the following methods,
     which are identical to those offered by *note mboxMessage: 1882.:

      -- Method: get_from ()

          Return a string representing the "From " line that marks the
          start of the message in an mbox mailbox.  The leading "From "
          and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)

          Set the "From " line to _from__, which should be specified
          without a leading "From " or trailing newline.  For
          convenience, _time__ may be specified and will be formatted
          appropriately and appended to _from__.  If _time__ is
          specified, it should be a *note time.struct_time: ae0.
          instance, a tuple suitable for passing to *note
          time.strftime(): 3be, or ‘True’ (to use *note time.gmtime():
          b54.).

      -- Method: get_flags ()

          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of ‘'R'’, ‘'O'’, ‘'D'’, ‘'F'’, and
          ‘'A'’.

      -- Method: set_flags (flags)

          Set the flags specified by _flags_ and unset all others.
          Parameter _flags_ should be the concatenation in any order of
          zero or more occurrences of each of ‘'R'’, ‘'O'’, ‘'D'’,
          ‘'F'’, and ‘'A'’.

      -- Method: add_flag (flag)

          Set the flag(s) specified by _flag_ without changing other
          flags.  To add more than one flag at a time, _flag_ may be a
          string of more than one character.

      -- Method: remove_flag (flag)

          Unset the flag(s) specified by _flag_ without changing other
          flags.  To remove more than one flag at a time, _flag_ maybe a
          string of more than one character.

  When an *note MMDFMessage: 18d2. instance is created based upon a
*note MaildirMessage: 189e. instance, a "From " line is generated based
upon the *note MaildirMessage: 189e. instance’s delivery date, and the
following conversions take place:

Resulting state       *note MaildirMessage: 189e. state
                      
----------------------------------------------------------
                      
R flag                S flag
                      
                      
O flag                "cur" subdirectory
                      
                      
D flag                T flag
                      
                      
F flag                F flag
                      
                      
A flag                R flag
                      

  When an *note MMDFMessage: 18d2. instance is created based upon an
*note MHMessage: 18b7. instance, the following conversions take place:

Resulting state         *note MHMessage: 18b7. state
                        
-------------------------------------------------------
                        
R flag and O flag       no "unseen" sequence
                        
                        
O flag                  "unseen" sequence
                        
                        
F flag                  "flagged" sequence
                        
                        
A flag                  "replied" sequence
                        

  When an *note MMDFMessage: 18d2. instance is created based upon a
*note BabylMessage: 18ca. instance, the following conversions take
place:

Resulting state         *note BabylMessage: 18ca. state
                        
----------------------------------------------------------
                        
R flag and O flag       no "unseen" label
                        
                        
O flag                  "unseen" label
                        
                        
D flag                  "deleted" label
                        
                        
A flag                  "answered" label
                        

  When an *note MMDFMessage: 18d2. instance is created based upon an
*note mboxMessage: 1882. instance, the "From " line is copied and all
flags directly correspond:

Resulting state       *note mboxMessage: 1882. state
                      
-------------------------------------------------------
                      
R flag                R flag
                      
                      
O flag                O flag
                      
                      
D flag                D flag
                      
                      
F flag                F flag
                      
                      
A flag                A flag
                      


File: python.info,  Node: Exceptions<5>,  Next: Deprecated classes and methods,  Prev: Message objects,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.13 Exceptions
....................

The following exception classes are defined in the *note mailbox: 109.
module:

 -- Exception: mailbox.Error

     The based class for all other module-specific exceptions.

 -- Exception: mailbox.NoSuchMailboxError

     Raised when a mailbox is expected but is not found, such as when
     instantiating a *note Mailbox: 1879. subclass with a path that does
     not exist (and with the _create_ parameter set to ‘False’), or when
     opening a folder that does not exist.

 -- Exception: mailbox.NotEmptyError

     Raised when a mailbox is not empty but is expected to be, such as
     when deleting a folder that contains messages.

 -- Exception: mailbox.ExternalClashError

     Raised when some mailbox-related condition beyond the control of
     the program causes it to be unable to proceed, such as when failing
     to acquire a lock that another program already holds a lock, or
     when a uniquely-generated file name already exists.

 -- Exception: mailbox.FormatError

     Raised when the data in a file cannot be parsed, such as when an
     *note MH: 18b6. instance attempts to read a corrupted
     ‘.mh_sequences’ file.


File: python.info,  Node: Deprecated classes and methods,  Next: Examples<9>,  Prev: Exceptions<5>,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.14 Deprecated classes and methods
........................................

Deprecated since version 2.6.

  Older versions of the *note mailbox: 109. module do not support
modification of mailboxes, such as adding or removing message, and do
not provide classes to represent format-specific message properties.
For backward compatibility, the older mailbox classes are still
available, but the newer classes should be used in preference to them.
The old classes have been removed in Python 3.

  Older mailbox objects support only iteration and provide a single
public method:

 -- Method: oldmailbox.next ()

     Return the next message in the mailbox, created with the optional
     _factory_ argument passed into the mailbox object’s constructor.
     By default this is an *note rfc822.Message: 189f. object (see the
     *note rfc822: 148. module).  Depending on the mailbox
     implementation the _fp_ attribute of this object may be a true file
     object or a class instance simulating a file object, taking care of
     things like message boundaries if multiple mail messages are
     contained in a single file, etc.  If no more messages are
     available, this method returns ‘None’.

  Most of the older mailbox classes have names that differ from the
current mailbox class names, except for *note Maildir: 238.  For this
reason, the new *note Maildir: 238. class defines a ‘next()’ method and
its constructor differs slightly from those of the other new mailbox
classes.

  The older mailbox classes whose names are not the same as their newer
counterparts are as follows:

 -- Class: mailbox.UnixMailbox (fp[, factory])

     Access to a classic Unix-style mailbox, where all messages are
     contained in a single file and separated by ‘From’ (a.k.a.
     ‘From_’) lines.  The file object _fp_ points to the mailbox file.
     The optional _factory_ parameter is a callable that should create
     new message objects.  _factory_ is called with one argument, _fp_
     by the ‘next()’ method of the mailbox object.  The default is the
     *note rfc822.Message: 189f. class (see the *note rfc822: 148.
     module – and the note below).

          Note: For reasons of this module’s internal implementation,
          you will probably want to open the _fp_ object in binary mode.
          This is especially important on Windows.

     For maximum portability, messages in a Unix-style mailbox are
     separated by any line that begins exactly with the string ‘'From '’
     (note the trailing space) if preceded by exactly two newlines.
     Because of the wide-range of variations in practice, nothing else
     on the ‘From_’ line should be considered.  However, the current
     implementation doesn’t check for the leading two newlines.  This is
     usually fine for most applications.

     The *note UnixMailbox: 1909. class implements a more strict version
     of ‘From_’ line checking, using a regular expression that usually
     correctly matched ‘From_’ delimiters.  It considers delimiter line
     to be separated by ‘From name time’ lines.  For maximum
     portability, use the *note PortableUnixMailbox: 190a. class
     instead.  This class is identical to *note UnixMailbox: 1909.
     except that individual messages are separated by only ‘From’ lines.

 -- Class: mailbox.PortableUnixMailbox (fp[, factory])

     A less-strict version of *note UnixMailbox: 1909, which considers
     only the ‘From’ at the beginning of the line separating messages.
     The "_name_ _time_" portion of the From line is ignored, to protect
     against some variations that are observed in practice.  This works
     since lines in the message which begin with ‘'From '’ are quoted by
     mail handling software at delivery-time.

 -- Class: mailbox.MmdfMailbox (fp[, factory])

     Access an MMDF-style mailbox, where all messages are contained in a
     single file and separated by lines consisting of 4 control-A
     characters.  The file object _fp_ points to the mailbox file.
     Optional _factory_ is as with the *note UnixMailbox: 1909. class.

 -- Class: mailbox.MHMailbox (dirname[, factory])

     Access an MH mailbox, a directory with each message in a separate
     file with a numeric name.  The name of the mailbox directory is
     passed in _dirname_.  _factory_ is as with the *note UnixMailbox:
     1909. class.

 -- Class: mailbox.BabylMailbox (fp[, factory])

     Access a Babyl mailbox, which is similar to an MMDF mailbox.  In
     Babyl format, each message has two sets of headers, the _original_
     headers and the _visible_ headers.  The original headers appear
     before a line containing only ‘'*** EOOH ***'’
     (End-Of-Original-Headers) and the visible headers appear after the
     ‘EOOH’ line.  Babyl-compliant mail readers will show you only the
     visible headers, and *note BabylMailbox: 190d. objects will return
     messages containing only the visible headers.  You’ll have to do
     your own parsing of the mailbox file to get at the original
     headers.  Mail messages start with the EOOH line and end with a
     line containing only ‘'\037\014'’.  _factory_ is as with the *note
     UnixMailbox: 1909. class.

  If you wish to use the older mailbox classes with the *note email: bb.
module rather than the deprecated *note rfc822: 148. module, you can do
so as follows:

     import email
     import email.Errors
     import mailbox

     def msgfactory(fp):
         try:
             return email.message_from_file(fp)
         except email.Errors.MessageParseError:
             # Don't return None since that will
             # stop the mailbox iterator
             return ''

     mbox = mailbox.UnixMailbox(fp, msgfactory)

  Alternatively, if you know your mailbox contains only well-formed MIME
messages, you can simplify this to:

     import email
     import mailbox

     mbox = mailbox.UnixMailbox(fp, email.message_from_file)


File: python.info,  Node: Examples<9>,  Prev: Deprecated classes and methods,  Up: mailbox --- Manipulate mailboxes in various formats

5.18.4.15 Examples
..................

A simple example of printing the subjects of all messages in a mailbox
that seem interesting:

     import mailbox
     for message in mailbox.mbox('~/mbox'):
         subject = message['subject']       # Could possibly be None.
         if subject and 'python' in subject.lower():
             print subject

  To copy all mail from a Babyl mailbox to an MH mailbox, converting all
of the format-specific information that can be converted:

     import mailbox
     destination = mailbox.MH('~/Mail')
     destination.lock()
     for message in mailbox.Babyl('~/RMAIL'):
         destination.add(mailbox.MHMessage(message))
     destination.flush()
     destination.unlock()

  This example sorts mail from several mailing lists into different
mailboxes, being careful to avoid mail corruption due to concurrent
modification by other programs, mail loss due to interruption of the
program, or premature termination due to malformed messages in the
mailbox:

     import mailbox
     import email.errors

     list_names = ('python-list', 'python-dev', 'python-bugs')

     boxes = dict((name, mailbox.mbox('~/email/%s' % name)) for name in list_names)
     inbox = mailbox.Maildir('~/Maildir', factory=None)

     for key in inbox.iterkeys():
         try:
             message = inbox[key]
         except email.errors.MessageParseError:
             continue                # The message is malformed. Just leave it.

         for name in list_names:
             list_id = message['list-id']
             if list_id and name in list_id:
                 # Get mailbox to use
                 box = boxes[name]

                 # Write copy to disk before removing original.
                 # If there's a crash, you might duplicate a message, but
                 # that's better than losing a message completely.
                 box.lock()
                 box.add(message)
                 box.flush()
                 box.unlock()

                 # Remove original message
                 inbox.lock()
                 inbox.discard(key)
                 inbox.flush()
                 inbox.unlock()
                 break               # Found destination, so stop looking.

     for box in boxes.itervalues():
         box.close()


File: python.info,  Node: mhlib --- Access to MH mailboxes,  Next: mimetools --- Tools for parsing MIME messages,  Prev: mailbox --- Manipulate mailboxes in various formats,  Up: Internet Data Handling

5.18.5 ‘mhlib’ — Access to MH mailboxes
---------------------------------------

Deprecated since version 2.6: The *note mhlib: 10e. module has been
removed in Python 3.  Use the *note mailbox: 109. instead.

  The *note mhlib: 10e. module provides a Python interface to MH folders
and their contents.

  The module contains three basic classes, *note MH: 1912, which
represents a particular collection of folders, *note Folder: 1913, which
represents a single folder, and *note Message: 1914, which represents a
single message.

 -- Class: mhlib.MH ([path[, profile]])

     *note MH: 1912. represents a collection of MH folders.

 -- Class: mhlib.Folder (mh, name)

     The *note Folder: 1913. class represents a single folder and its
     messages.

 -- Class: mhlib.Message (folder, number[, name])

     *note Message: 1914. objects represent individual messages in a
     folder.  The Message class is derived from *note mimetools.Message:
     1915.

* Menu:

* MH Objects:: 
* Folder Objects:: 
* Message Objects:: 


File: python.info,  Node: MH Objects,  Next: Folder Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.1 MH Objects
...................

*note MH: 1912. instances have the following methods:

 -- Method: MH.error (format[, ...])

     Print an error message – can be overridden.

 -- Method: MH.getprofile (key)

     Return a profile entry (‘None’ if not set).

 -- Method: MH.getpath ()

     Return the mailbox pathname.

 -- Method: MH.getcontext ()

     Return the current folder name.

 -- Method: MH.setcontext (name)

     Set the current folder name.

 -- Method: MH.listfolders ()

     Return a list of top-level folders.

 -- Method: MH.listallfolders ()

     Return a list of all folders.

 -- Method: MH.listsubfolders (name)

     Return a list of direct subfolders of the given folder.

 -- Method: MH.listallsubfolders (name)

     Return a list of all subfolders of the given folder.

 -- Method: MH.makefolder (name)

     Create a new folder.

 -- Method: MH.deletefolder (name)

     Delete a folder – must have no subfolders.

 -- Method: MH.openfolder (name)

     Return a new open folder object.


File: python.info,  Node: Folder Objects,  Next: Message Objects,  Prev: MH Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.2 Folder Objects
.......................

*note Folder: 1913. instances represent open folders and have the
following methods:

 -- Method: Folder.error (format[, ...])

     Print an error message – can be overridden.

 -- Method: Folder.getfullname ()

     Return the folder’s full pathname.

 -- Method: Folder.getsequencesfilename ()

     Return the full pathname of the folder’s sequences file.

 -- Method: Folder.getmessagefilename (n)

     Return the full pathname of message _n_ of the folder.

 -- Method: Folder.listmessages ()

     Return a list of messages in the folder (as numbers).

 -- Method: Folder.getcurrent ()

     Return the current message number.

 -- Method: Folder.setcurrent (n)

     Set the current message number to _n_.

 -- Method: Folder.parsesequence (seq)

     Parse msgs syntax into list of messages.

 -- Method: Folder.getlast ()

     Get last message, or ‘0’ if no messages are in the folder.

 -- Method: Folder.setlast (n)

     Set last message (internal use only).

 -- Method: Folder.getsequences ()

     Return dictionary of sequences in folder.  The sequence names are
     used as keys, and the values are the lists of message numbers in
     the sequences.

 -- Method: Folder.putsequences (dict)

     Return dictionary of sequences in folder name: list.

 -- Method: Folder.removemessages (list)

     Remove messages in list from folder.

 -- Method: Folder.refilemessages (list, tofolder)

     Move messages in list to other folder.

 -- Method: Folder.movemessage (n, tofolder, ton)

     Move one message to a given destination in another folder.

 -- Method: Folder.copymessage (n, tofolder, ton)

     Copy one message to a given destination in another folder.


File: python.info,  Node: Message Objects,  Prev: Folder Objects,  Up: mhlib --- Access to MH mailboxes

5.18.5.3 Message Objects
........................

The *note Message: 1914. class adds one method to those of *note
mimetools.Message: 1915.:

 -- Method: Message.openmessage (n)

     Return a new open message object (costs a file descriptor).


File: python.info,  Node: mimetools --- Tools for parsing MIME messages,  Next: mimetypes --- Map filenames to MIME types,  Prev: mhlib --- Access to MH mailboxes,  Up: Internet Data Handling

5.18.6 ‘mimetools’ — Tools for parsing MIME messages
----------------------------------------------------

Deprecated since version 2.3: The *note email: bb. package should be
used in preference to the *note mimetools: 10f. module.  This module is
present only to maintain backward compatibility, and it has been removed
in 3.x.

  This module defines a subclass of the *note rfc822: 148. module’s
*note Message: 1915. class and a number of utility functions that are
useful for the manipulation for MIME multipart or encoded message.

  It defines the following items:

 -- Class: mimetools.Message (fp[, seekable])

     Return a new instance of the *note Message: 1915. class.  This is a
     subclass of the *note rfc822.Message: 189f. class, with some
     additional methods (see below).  The _seekable_ argument has the
     same meaning as for *note rfc822.Message: 189f.

 -- Function: mimetools.choose_boundary ()

     Return a unique string that has a high likelihood of being usable
     as a part boundary.  The string has the form
     ‘'hostipaddr.uid.pid.timestamp.random'’.

 -- Function: mimetools.decode (input, output, encoding)

     Read data encoded using the allowed MIME _encoding_ from open file
     object _input_ and write the decoded data to open file object
     _output_.  Valid values for _encoding_ include ‘'base64'’,
     ‘'quoted-printable'’, ‘'uuencode'’, ‘'x-uuencode'’, ‘'uue'’,
     ‘'x-uue'’, ‘'7bit'’, and ‘'8bit'’.  Decoding messages encoded in
     ‘'7bit'’ or ‘'8bit'’ has no effect.  The input is simply copied to
     the output.

 -- Function: mimetools.encode (input, output, encoding)

     Read data from open file object _input_ and write it encoded using
     the allowed MIME _encoding_ to open file object _output_.  Valid
     values for _encoding_ are the same as for *note decode(): 193c.

 -- Function: mimetools.copyliteral (input, output)

     Read lines from open file _input_ until EOF and write them to open
     file _output_.

 -- Function: mimetools.copybinary (input, output)

     Read blocks until EOF from open file _input_ and write them to open
     file _output_.  The block size is currently fixed at 8192.

See also
........

Module *note email: bb.

     Comprehensive email handling package; supersedes the *note
     mimetools: 10f. module.

Module *note rfc822: 148.

     Provides the base class for *note mimetools.Message: 1915.

Module *note multifile: 118.

     Support for reading files which contain distinct parts, such as
     MIME data.

‘http://faqs.cs.uu.nl/na-dir/mail/mime-faq/.html’

     The MIME Frequently Asked Questions document.  For an overview of
     MIME, see the answer to question 1.1 in Part 1 of this document.

* Menu:

* Additional Methods of Message Objects:: 


File: python.info,  Node: Additional Methods of Message Objects,  Up: mimetools --- Tools for parsing MIME messages

5.18.6.1 Additional Methods of Message Objects
..............................................

The *note Message: 1915. class defines the following methods in addition
to the *note rfc822.Message: 189f. methods:

 -- Method: Message.getplist ()

     Return the parameter list of the ‘Content-Type’ header.  This is a
     list of strings.  For parameters of the form ‘key=value’, _key_ is
     converted to lower case but _value_ is not.  For example, if the
     message contains the header ‘Content-type: text/html; spam=1;
     Spam=2; Spam’ then *note getplist(): 1942. will return the Python
     list ‘['spam=1', 'spam=2', 'Spam']’.

 -- Method: Message.getparam (name)

     Return the _value_ of the first parameter (as returned by *note
     getplist(): 1942.) of the form ‘name=value’ for the given _name_.
     If _value_ is surrounded by quotes of the form ’‘<’...‘>’’ or
     ’‘"’...‘"’’, these are removed.

 -- Method: Message.getencoding ()

     Return the encoding specified in the ‘Content-Transfer-Encoding’
     message header.  If no such header exists, return ‘'7bit'’.  The
     encoding is converted to lower case.

 -- Method: Message.gettype ()

     Return the message type (of the form ‘type/subtype’) as specified
     in the ‘Content-Type’ header.  If no such header exists, return
     ‘'text/plain'’.  The type is converted to lower case.

 -- Method: Message.getmaintype ()

     Return the main type as specified in the ‘Content-Type’ header.  If
     no such header exists, return ‘'text'’.  The main type is converted
     to lower case.

 -- Method: Message.getsubtype ()

     Return the subtype as specified in the ‘Content-Type’ header.  If
     no such header exists, return ‘'plain'’.  The subtype is converted
     to lower case.


File: python.info,  Node: mimetypes --- Map filenames to MIME types,  Next: MimeWriter --- Generic MIME file writer,  Prev: mimetools --- Tools for parsing MIME messages,  Up: Internet Data Handling

5.18.7 ‘mimetypes’ — Map filenames to MIME types
------------------------------------------------

*Source code:* Lib/mimetypes.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  The *note mimetypes: 110. module converts between a filename or URL
and the MIME type associated with the filename extension.  Conversions
are provided from filename to MIME type and from MIME type to filename
extension; encodings are not supported for the latter conversion.

  The module provides one class and a number of convenience functions.
The functions are the normal interface to this module, but some
applications may be interested in the class as well.

  The functions described below provide the primary interface for this
module.  If the module has not been initialized, they will call *note
init(): 194a. if they rely on the information *note init(): 194a. sets
up.

 -- Function: mimetypes.guess_type (url, strict=True)

     Guess the type of a file based on its filename or URL, given by
     _url_.  The return value is a tuple ‘(type, encoding)’ where _type_
     is ‘None’ if the type can’t be guessed (missing or unknown suffix)
     or a string of the form ‘'type/subtype'’, usable for a MIME
     ‘content-type’ header.

     _encoding_ is ‘None’ for no encoding or the name of the program
     used to encode (e.g.  *compress* or *gzip*).  The encoding is
     suitable for use as a ‘Content-Encoding’ header, *not* as a
     ‘Content-Transfer-Encoding’ header.  The mappings are table driven.
     Encoding suffixes are case sensitive; type suffixes are first tried
     case sensitively, then case insensitively.

     The optional _strict_ argument is a flag specifying whether the
     list of known MIME types is limited to only the official types
     registered with IANA(2). When _strict_ is ‘True’ (the default),
     only the IANA types are supported; when _strict_ is ‘False’, some
     additional non-standard but commonly used MIME types are also
     recognized.

 -- Function: mimetypes.guess_all_extensions (type, strict=True)

     Guess the extensions for a file based on its MIME type, given by
     _type_.  The return value is a list of strings giving all possible
     filename extensions, including the leading dot (‘'.'’).  The
     extensions are not guaranteed to have been associated with any
     particular data stream, but would be mapped to the MIME type _type_
     by *note guess_type(): 194b.

     The optional _strict_ argument has the same meaning as with the
     *note guess_type(): 194b. function.

 -- Function: mimetypes.guess_extension (type, strict=True)

     Guess the extension for a file based on its MIME type, given by
     _type_.  The return value is a string giving a filename extension,
     including the leading dot (‘'.'’).  The extension is not guaranteed
     to have been associated with any particular data stream, but would
     be mapped to the MIME type _type_ by *note guess_type(): 194b.  If
     no extension can be guessed for _type_, ‘None’ is returned.

     The optional _strict_ argument has the same meaning as with the
     *note guess_type(): 194b. function.

  Some additional functions and data items are available for controlling
the behavior of the module.

 -- Function: mimetypes.init (files=None)

     Initialize the internal data structures.  If given, _files_ must be
     a sequence of file names which should be used to augment the
     default type map.  If omitted, the file names to use are taken from
     *note knownfiles: 194e.; on Windows, the current registry settings
     are loaded.  Each file named in _files_ or *note knownfiles: 194e.
     takes precedence over those named before it.  Calling *note init():
     194a. repeatedly is allowed.

     Specifying an empty list for _files_ will prevent the system
     defaults from being applied: only the well-known values will be
     present from a built-in list.

     Changed in version 2.7: Previously, Windows registry settings were
     ignored.

 -- Function: mimetypes.read_mime_types (filename)

     Load the type map given in the file _filename_, if it exists.  The
     type map is returned as a dictionary mapping filename extensions,
     including the leading dot (‘'.'’), to strings of the form
     ‘'type/subtype'’.  If the file _filename_ does not exist or cannot
     be read, ‘None’ is returned.

 -- Function: mimetypes.add_type (type, ext, strict=True)

     Add a mapping from the MIME type _type_ to the extension _ext_.
     When the extension is already known, the new type will replace the
     old one.  When the type is already known the extension will be
     added to the list of known extensions.

     When _strict_ is ‘True’ (the default), the mapping will added to
     the official MIME types, otherwise to the non-standard ones.

 -- Data: mimetypes.inited

     Flag indicating whether or not the global data structures have been
     initialized.  This is set to ‘True’ by *note init(): 194a.

 -- Data: mimetypes.knownfiles

     List of type map file names commonly installed.  These files are
     typically named ‘mime.types’ and are installed in different
     locations by different packages.

 -- Data: mimetypes.suffix_map

     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the ‘.tgz’
     extension is mapped to ‘.tar.gz’ to allow the encoding and type to
     be recognized separately.

 -- Data: mimetypes.encodings_map

     Dictionary mapping filename extensions to encoding types.

 -- Data: mimetypes.types_map

     Dictionary mapping filename extensions to MIME types.

 -- Data: mimetypes.common_types

     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.

  An example usage of the module:

     >>> import mimetypes
     >>> mimetypes.init()
     >>> mimetypes.knownfiles
     ['/etc/mime.types', '/etc/httpd/mime.types', ... ]
     >>> mimetypes.suffix_map['.tgz']
     '.tar.gz'
     >>> mimetypes.encodings_map['.gz']
     'gzip'
     >>> mimetypes.types_map['.tgz']
     'application/x-tar-gz'

* Menu:

* MimeTypes Objects:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/mimetypes.py

   (2) http://www.iana.org/assignments/media-types/


File: python.info,  Node: MimeTypes Objects,  Up: mimetypes --- Map filenames to MIME types

5.18.7.1 MimeTypes Objects
..........................

The *note MimeTypes: 1958. class may be useful for applications which
may want more than one MIME-type database; it provides an interface
similar to the one of the *note mimetypes: 110. module.

 -- Class: mimetypes.MimeTypes (filenames=(), strict=True)

     This class represents a MIME-types database.  By default, it
     provides access to the same database as the rest of this module.
     The initial database is a copy of that provided by the module, and
     may be extended by loading additional ‘mime.types’-style files into
     the database using the *note read(): 1959. or *note readfp(): 195a.
     methods.  The mapping dictionaries may also be cleared before
     loading additional data if the default data is not desired.

     The optional _filenames_ parameter can be used to cause additional
     files to be loaded "on top" of the default database.

 -- Attribute: MimeTypes.suffix_map

     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the ‘.tgz’
     extension is mapped to ‘.tar.gz’ to allow the encoding and type to
     be recognized separately.  This is initially a copy of the global
     *note suffix_map: 1952. defined in the module.

 -- Attribute: MimeTypes.encodings_map

     Dictionary mapping filename extensions to encoding types.  This is
     initially a copy of the global *note encodings_map: 1953. defined
     in the module.

 -- Attribute: MimeTypes.types_map

     Tuple containing two dictionaries, mapping filename extensions to
     MIME types: the first dictionary is for the non-standards types and
     the second one is for the standard types.  They are initialized by
     *note common_types: 1955. and *note types_map: 1954.

 -- Attribute: MimeTypes.types_map_inv

     Tuple containing two dictionaries, mapping MIME types to a list of
     filename extensions: the first dictionary is for the non-standards
     types and the second one is for the standard types.  They are
     initialized by *note common_types: 1955. and *note types_map: 1954.

 -- Method: MimeTypes.guess_extension (type, strict=True)

     Similar to the *note guess_extension(): 194d. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.guess_type (url, strict=True)

     Similar to the *note guess_type(): 194b. function, using the tables
     stored as part of the object.

 -- Method: MimeTypes.guess_all_extensions (type, strict=True)

     Similar to the *note guess_all_extensions(): 194c. function, using
     the tables stored as part of the object.

 -- Method: MimeTypes.read (filename, strict=True)

     Load MIME information from a file named _filename_.  This uses
     *note readfp(): 195a. to parse the file.

     If _strict_ is ‘True’, information will be added to list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.readfp (fp, strict=True)

     Load MIME type information from an open file _fp_.  The file must
     have the format of the standard ‘mime.types’ files.

     If _strict_ is ‘True’, information will be added to the list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.read_windows_registry (strict=True)

     Load MIME type information from the Windows registry.
     Availability: Windows.

     If _strict_ is ‘True’, information will be added to the list of
     standard types, else to the list of non-standard types.

     New in version 2.7.


File: python.info,  Node: MimeWriter --- Generic MIME file writer,  Next: mimify --- MIME processing of mail messages,  Prev: mimetypes --- Map filenames to MIME types,  Up: Internet Data Handling

5.18.8 ‘MimeWriter’ — Generic MIME file writer
----------------------------------------------

Deprecated since version 2.3: The *note email: bb. package should be
used in preference to the *note MimeWriter: 111. module.  This module is
present only to maintain backward compatibility.

  This module defines the class *note MimeWriter: 111.  The *note
MimeWriter: 111. class implements a basic formatter for creating MIME
multi-part files.  It doesn’t seek around the output file nor does it
use large amounts of buffer space.  You must write the parts out in the
order that they should occur in the final file.  *note MimeWriter: 111.
does buffer the headers you add, allowing you to rearrange their order.

 -- Class: MimeWriter.MimeWriter (fp)

     Return a new instance of the *note MimeWriter: 111. class.  The
     only argument passed, _fp_, is a file object to be used for
     writing.  Note that a *note StringIO: 2dd. object could also be
     used.

* Menu:

* MimeWriter Objects:: 


File: python.info,  Node: MimeWriter Objects,  Up: MimeWriter --- Generic MIME file writer

5.18.8.1 MimeWriter Objects
...........................

*note MimeWriter: 111. instances have the following methods:

 -- Method: MimeWriter.addheader (key, value[, prefix])

     Add a header line to the MIME message.  The _key_ is the name of
     the header, where the _value_ obviously provides the value of the
     header.  The optional argument _prefix_ determines where the header
     is inserted; ‘0’ means append at the end, ‘1’ is insert at the
     start.  The default is to append.

 -- Method: MimeWriter.flushheaders ()

     Causes all headers accumulated so far to be written out (and
     forgotten).  This is useful if you don’t need a body part at all,
     e.g.  for a subpart of type ‘message/rfc822’ that’s (mis)used to
     store some header-like information.

 -- Method: MimeWriter.startbody (ctype[, plist[, prefix]])

     Returns a file-like object which can be used to write to the body
     of the message.  The content-type is set to the provided _ctype_,
     and the optional parameter _plist_ provides additional parameters
     for the content-type declaration.  _prefix_ functions as in *note
     addheader(): 1968. except that the default is to insert at the
     start.

 -- Method: MimeWriter.startmultipartbody (subtype[, boundary[, plist[,
          prefix]]])

     Returns a file-like object which can be used to write to the body
     of the message.  Additionally, this method initializes the
     multi-part code, where _subtype_ provides the multipart subtype,
     _boundary_ may provide a user-defined boundary specification, and
     _plist_ provides optional parameters for the subtype.  _prefix_
     functions as in *note startbody(): 196a.  Subparts should be
     created using *note nextpart(): 196c.

 -- Method: MimeWriter.nextpart ()

     Returns a new instance of *note MimeWriter: 111. which represents
     an individual part in a multipart message.  This may be used to
     write the part as well as used for creating recursively complex
     multipart messages.  The message must first be initialized with
     *note startmultipartbody(): 196b. before using *note nextpart():
     196c.

 -- Method: MimeWriter.lastpart ()

     This is used to designate the last part of a multipart message, and
     should _always_ be used when writing multipart messages.


File: python.info,  Node: mimify --- MIME processing of mail messages,  Next: multifile --- Support for files containing distinct parts,  Prev: MimeWriter --- Generic MIME file writer,  Up: Internet Data Handling

5.18.9 ‘mimify’ — MIME processing of mail messages
--------------------------------------------------

Deprecated since version 2.3: The *note email: bb. package should be
used in preference to the *note mimify: 112. module.  This module is
present only to maintain backward compatibility.

  The *note mimify: 112. module defines two functions to convert mail
messages to and from MIME format.  The mail message can be either a
simple message or a so-called multipart message.  Each part is treated
separately.  Mimifying (a part of) a message entails encoding the
message as quoted-printable if it contains any characters that cannot be
represented using 7-bit ASCII. Unmimifying (a part of) a message entails
undoing the quoted-printable encoding.  Mimify and unmimify are
especially useful when a message has to be edited before being sent.
Typical use would be:

     unmimify message
     edit message
     mimify message
     send message

  The modules defines the following user-callable functions and
user-settable variables:

 -- Function: mimify.mimify (infile, outfile)

     Copy the message in _infile_ to _outfile_, converting parts to
     quoted-printable and adding MIME mail headers when necessary.
     _infile_ and _outfile_ can be file objects (actually, any object
     that has a *note readline(): 144. method (for _infile_) or a
     ‘write()’ method (for _outfile_)) or strings naming the files.  If
     _infile_ and _outfile_ are both strings, they may have the same
     value.

 -- Function: mimify.unmimify (infile, outfile[, decode_base64])

     Copy the message in _infile_ to _outfile_, decoding all
     quoted-printable parts.  _infile_ and _outfile_ can be file objects
     (actually, any object that has a *note readline(): 144. method (for
     _infile_) or a ‘write()’ method (for _outfile_)) or strings naming
     the files.  If _infile_ and _outfile_ are both strings, they may
     have the same value.  If the _decode_base64_ argument is provided
     and tests true, any parts that are coded in the base64 encoding are
     decoded as well.

 -- Function: mimify.mime_decode_header (line)

     Return a decoded version of the encoded header line in _line_.
     This only supports the ISO 8859-1 charset (Latin-1).

 -- Function: mimify.mime_encode_header (line)

     Return a MIME-encoded version of the header line in _line_.

 -- Data: mimify.MAXLEN

     By default, a part will be encoded as quoted-printable when it
     contains any non-ASCII characters (characters with the 8th bit
     set), or if there are any lines longer than *note MAXLEN: 1974.
     characters (default value 200).

 -- Data: mimify.CHARSET

     When not specified in the mail headers, a character set must be
     filled in.  The string used is stored in *note CHARSET: 1975, and
     the default value is ISO-8859-1 (also known as Latin1 (latin-one)).

  This module can also be used from the command line.  Usage is as
follows:

     mimify.py -e [-l length] [infile [outfile]]
     mimify.py -d [-b] [infile [outfile]]

  to encode (mimify) and decode (unmimify) respectively.  _infile_
defaults to standard input, _outfile_ defaults to standard output.  The
same file can be specified for input and output.

  If the *-l* option is given when encoding, if there are any lines
longer than the specified _length_, the containing part will be encoded.

  If the *-b* option is given when decoding, any base64 parts will be
decoded as well.

See also
........

Module *note quopri: 141.

     Encode and decode MIME quoted-printable files.


File: python.info,  Node: multifile --- Support for files containing distinct parts,  Next: rfc822 --- Parse RFC 2822 mail headers,  Prev: mimify --- MIME processing of mail messages,  Up: Internet Data Handling

5.18.10 ‘multifile’ — Support for files containing distinct parts
-----------------------------------------------------------------

Deprecated since version 2.5: The *note email: bb. package should be
used in preference to the *note multifile: 118. module.  This module is
present only to maintain backward compatibility.

  The *note MultiFile: 1978. object enables you to treat sections of a
text file as file-like input objects, with ‘''’ being returned by *note
readline(): 144. when a given delimiter pattern is encountered.  The
defaults of this class are designed to make it useful for parsing MIME
multipart messages, but by subclassing it and overriding methods it can
be easily adapted for more general use.

 -- Class: multifile.MultiFile (fp[, seekable])

     Create a multi-file.  You must instantiate this class with an input
     object argument for the *note MultiFile: 1978. instance to get
     lines from, such as a file object returned by *note open(): 2d6.

     *note MultiFile: 1978. only ever looks at the input object’s *note
     readline(): 144, *note seek(): 1979. and *note tell(): 197a.
     methods, and the latter two are only needed if you want random
     access to the individual MIME parts.  To use *note MultiFile: 1978.
     on a non-seekable stream object, set the optional _seekable_
     argument to false; this will prevent using the input object’s *note
     seek(): 1979. and *note tell(): 197a. methods.

  It will be useful to know that in *note MultiFile: 1978.’s view of the
world, text is composed of three kinds of lines: data, section-dividers,
and end-markers.  MultiFile is designed to support parsing of messages
that may have multiple nested message parts, each with its own pattern
for section-divider and end-marker lines.

See also
........

Module *note email: bb.

     Comprehensive email handling package; supersedes the *note
     multifile: 118. module.

* Menu:

* MultiFile Objects:: 
* MultiFile Example:: 


File: python.info,  Node: MultiFile Objects,  Next: MultiFile Example,  Up: multifile --- Support for files containing distinct parts

5.18.10.1 MultiFile Objects
...........................

A *note MultiFile: 1978. instance has the following methods:

 -- Method: MultiFile.readline (str)

     Read a line.  If the line is data (not a section-divider or
     end-marker or real EOF) return it.  If the line matches the
     most-recently-stacked boundary, return ‘''’ and set ‘self.last’ to
     1 or 0 according as the match is or is not an end-marker.  If the
     line matches any other stacked boundary, raise an error.  On
     encountering end-of-file on the underlying stream object, the
     method raises ‘Error’ unless all boundaries have been popped.

 -- Method: MultiFile.readlines (str)

     Return all lines remaining in this part as a list of strings.

 -- Method: MultiFile.read ()

     Read all lines, up to the next section.  Return them as a single
     (multiline) string.  Note that this doesn’t take a size argument!

 -- Method: MultiFile.seek (pos[, whence])

     Seek.  Seek indices are relative to the start of the current
     section.  The _pos_ and _whence_ arguments are interpreted as for a
     file seek.

 -- Method: MultiFile.tell ()

     Return the file position relative to the start of the current
     section.

 -- Method: MultiFile.next ()

     Skip lines to the next section (that is, read lines until a
     section-divider or end-marker has been consumed).  Return true if
     there is such a section, false if an end-marker is seen.  Re-enable
     the most-recently-pushed boundary.

 -- Method: MultiFile.is_data (str)

     Return true if _str_ is data and false if it might be a section
     boundary.  As written, it tests for a prefix other than ‘'-’‘-'’ at
     start of line (which all MIME boundaries have) but it is declared
     so it can be overridden in derived classes.

     Note that this test is used intended as a fast guard for the real
     boundary tests; if it always returns false it will merely slow
     processing, not cause it to fail.

 -- Method: MultiFile.push (str)

     Push a boundary string.  When a decorated version of this boundary
     is found as an input line, it will be interpreted as a
     section-divider or end-marker (depending on the decoration, see RFC
     2045(1)).  All subsequent reads will return the empty string to
     indicate end-of-file, until a call to *note pop(): 1983. removes
     the boundary a or *note next(): 1980. call reenables it.

     It is possible to push more than one boundary.  Encountering the
     most-recently-pushed boundary will return EOF; encountering any
     other boundary will raise an error.

 -- Method: MultiFile.pop ()

     Pop a section boundary.  This boundary will no longer be
     interpreted as EOF.

 -- Method: MultiFile.section_divider (str)

     Turn a boundary into a section-divider line.  By default, this
     method prepends ‘'--'’ (which MIME section boundaries have) but it
     is declared so it can be overridden in derived classes.  This
     method need not append LF or CR-LF, as comparison with the result
     ignores trailing whitespace.

 -- Method: MultiFile.end_marker (str)

     Turn a boundary string into an end-marker line.  By default, this
     method prepends ‘'--'’ and appends ‘'--'’ (like a MIME-multipart
     end-of-message marker) but it is declared so it can be overridden
     in derived classes.  This method need not append LF or CR-LF, as
     comparison with the result ignores trailing whitespace.

  Finally, *note MultiFile: 1978. instances have two public instance
variables:

 -- Attribute: MultiFile.level

     Nesting depth of the current part.

 -- Attribute: MultiFile.last

     True if the last end-of-file was for an end-of-message marker.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2045.html


File: python.info,  Node: MultiFile Example,  Prev: MultiFile Objects,  Up: multifile --- Support for files containing distinct parts

5.18.10.2 ‘MultiFile’ Example
.............................

     import mimetools
     import multifile
     import StringIO

     def extract_mime_part_matching(stream, mimetype):
         """Return the first element in a multipart MIME message on stream
         matching mimetype."""

         msg = mimetools.Message(stream)
         msgtype = msg.gettype()
         params = msg.getplist()

         data = StringIO.StringIO()
         if msgtype[:10] == "multipart/":

             file = multifile.MultiFile(stream)
             file.push(msg.getparam("boundary"))
             while file.next():
                 submsg = mimetools.Message(file)
                 try:
                     data = StringIO.StringIO()
                     mimetools.decode(file, data, submsg.getencoding())
                 except ValueError:
                     continue
                 if submsg.gettype() == mimetype:
                     break
             file.pop()
         return data.getvalue()


File: python.info,  Node: rfc822 --- Parse RFC 2822 mail headers,  Next: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Prev: multifile --- Support for files containing distinct parts,  Up: Internet Data Handling

5.18.11 ‘rfc822’ — Parse RFC 2822 mail headers
----------------------------------------------

Deprecated since version 2.3: The *note email: bb. package should be
used in preference to the *note rfc822: 148. module.  This module is
present only to maintain backward compatibility, and has been removed in
Python 3.

  This module defines a class, *note Message: 189f, which represents an
"email message" as defined by the Internet standard RFC 2822(1).  (2)
Such messages consist of a collection of message headers, and a message
body.  This module also defines a helper class *note AddressList: 198c.
for parsing RFC 2822(3) addresses.  Please refer to the RFC for
information on the specific syntax of RFC 2822(4) messages.

  The *note mailbox: 109. module provides classes to read mailboxes
produced by various end-user mail programs.

 -- Class: rfc822.Message (file[, seekable])

     A *note Message: 189f. instance is instantiated with an input
     object as parameter.  Message relies only on the input object
     having a *note readline(): 144. method; in particular, ordinary
     file objects qualify.  Instantiation reads headers from the input
     object up to a delimiter line (normally a blank line) and stores
     them in the instance.  The message body, following the headers, is
     not consumed.

     This class can work with any input object that supports a *note
     readline(): 144. method.  If the input object has seek and tell
     capability, the *note rewindbody(): 198d. method will work; also,
     illegal lines will be pushed back onto the input stream.  If the
     input object lacks seek but has an ‘unread()’ method that can push
     back a line of input, *note Message: 189f. will use that to push
     back illegal lines.  Thus this class can be used to parse messages
     coming from a buffered stream.

     The optional _seekable_ argument is provided as a workaround for
     certain stdio libraries in which ‘tell()’ discards buffered data
     before discovering that the ‘lseek()’ system call doesn’t work.
     For maximum portability, you should set the seekable argument to
     zero to prevent that initial ‘tell()’ when passing in an unseekable
     object such as a file object created from a socket object.

     Input lines as read from the file may either be terminated by CR-LF
     or by a single linefeed; a terminating CR-LF is replaced by a
     single linefeed before the line is stored.

     All header matching is done independent of upper or lower case;
     e.g.  ‘m['From']’, ‘m['from']’ and ‘m['FROM']’ all yield the same
     result.

 -- Class: rfc822.AddressList (field)

     You may instantiate the *note AddressList: 198c. helper class using
     a single string parameter, a comma-separated list of RFC 2822(5)
     addresses to be parsed.  (The parameter ‘None’ yields an empty
     list.)

 -- Function: rfc822.quote (str)

     Return a new string with backslashes in _str_ replaced by two
     backslashes and double quotes replaced by backslash-double quote.

 -- Function: rfc822.unquote (str)

     Return a new string which is an _unquoted_ version of _str_.  If
     _str_ ends and begins with double quotes, they are stripped off.
     Likewise if _str_ ends and begins with angle brackets, they are
     stripped off.

 -- Function: rfc822.parseaddr (address)

     Parse _address_, which should be the value of some
     address-containing field such as ‘To’ or ‘Cc’, into its constituent
     "realname" and "email address" parts.  Returns a tuple of that
     information, unless the parse fails, in which case a 2-tuple
     ‘(None, None)’ is returned.

 -- Function: rfc822.dump_address_pair (pair)

     The inverse of *note parseaddr(): 1990, this takes a 2-tuple of the
     form ‘(realname, email_address)’ and returns the string value
     suitable for a ‘To’ or ‘Cc’ header.  If the first element of _pair_
     is false, then the second element is returned unmodified.

 -- Function: rfc822.parsedate (date)

     Attempts to parse a date according to the rules in RFC 2822(6).
     however, some mailers don’t follow that format as specified, so
     *note parsedate(): 1992. tries to guess correctly in such cases.
     _date_ is a string containing an RFC 2822(7) date, such as ‘'Mon,
     20 Nov 1995 19:12:08 -0500'’.  If it succeeds in parsing the date,
     *note parsedate(): 1992. returns a 9-tuple that can be passed
     directly to *note time.mktime(): 11f3.; otherwise ‘None’ will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: rfc822.parsedate_tz (date)

     Performs the same function as *note parsedate(): 1992, but returns
     either ‘None’ or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *note time.mktime(): 11f3, and the
     tenth is the offset of the date’s timezone from UTC (which is the
     official term for Greenwich Mean Time).  (Note that the sign of the
     timezone offset is the opposite of the sign of the ‘time.timezone’
     variable for the same timezone; the latter variable follows the
     POSIX standard while this module follows RFC 2822(8).)  If the
     input string has no timezone, the last element of the tuple
     returned is ‘None’.  Note that indexes 6, 7, and 8 of the result
     tuple are not usable.

 -- Function: rfc822.mktime_tz (tuple)

     Turn a 10-tuple as returned by *note parsedate_tz(): 1993. into a
     UTC timestamp.  If the timezone item in the tuple is ‘None’, assume
     local time.  Minor deficiency: this first interprets the first 8
     elements as a local time and then compensates for the timezone
     difference; this may yield a slight error around daylight savings
     time switch dates.  Not enough to worry about for common use.

See also
........

Module *note email: bb.

     Comprehensive email handling package; supersedes the *note rfc822:
     148. module.

Module *note mailbox: 109.

     Classes to read various mailbox formats produced by end-user mail
     programs.

Module *note mimetools: 10f.

     Subclass of *note rfc822.Message: 189f. that handles MIME encoded
     messages.

* Menu:

* Message Objects: Message Objects<2>. 
* AddressList Objects:: 

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html

   (2) This module originally conformed to RFC 822
(http://tools.ietf.org/html/rfc822.html), hence the name.  Since then,
RFC 2822 (http://tools.ietf.org/html/rfc2822.html) has been released as
an update to RFC 822 (http://tools.ietf.org/html/rfc822.html).  This
module should be considered RFC 2822
(http://tools.ietf.org/html/rfc2822.html)-conformant, especially in
cases where the syntax or semantics have changed since RFC 822
(http://tools.ietf.org/html/rfc822.html).

   (3) http://tools.ietf.org/html/rfc2822.html

   (4) http://tools.ietf.org/html/rfc2822.html

   (5) http://tools.ietf.org/html/rfc2822.html

   (6) http://tools.ietf.org/html/rfc2822.html

   (7) http://tools.ietf.org/html/rfc2822.html

   (8) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Message Objects<2>,  Next: AddressList Objects,  Up: rfc822 --- Parse RFC 2822 mail headers

5.18.11.1 Message Objects
.........................

A *note Message: 189f. instance has the following methods:

 -- Method: Message.rewindbody ()

     Seek to the start of the message body.  This only works if the file
     object is seekable.

 -- Method: Message.isheader (line)

     Returns a line’s canonicalized fieldname (the dictionary key that
     will be used to index it) if the line is a legal RFC 2822(1)
     header; otherwise returns ‘None’ (implying that parsing should stop
     here and the line be pushed back on the input stream).  It is
     sometimes useful to override this method in a subclass.

 -- Method: Message.islast (line)

     Return true if the given line is a delimiter on which Message
     should stop.  The delimiter line is consumed, and the file object’s
     read location positioned immediately after it.  By default this
     method just checks that the line is blank, but you can override it
     in a subclass.

 -- Method: Message.iscomment (line)

     Return ‘True’ if the given line should be ignored entirely, just
     skipped.  By default this is a stub that always returns ‘False’,
     but you can override it in a subclass.

 -- Method: Message.getallmatchingheaders (name)

     Return a list of lines consisting of all headers matching _name_,
     if any.  Each physical line, whether it is a continuation line or
     not, is a separate list item.  Return the empty list if no header
     matches _name_.

 -- Method: Message.getfirstmatchingheader (name)

     Return a list of lines comprising the first header matching _name_,
     and its continuation line(s), if any.  Return ‘None’ if there is no
     header matching _name_.

 -- Method: Message.getrawheader (name)

     Return a single string consisting of the text after the colon in
     the first header matching _name_.  This includes leading
     whitespace, the trailing linefeed, and internal linefeeds and
     whitespace if there any continuation line(s) were present.  Return
     ‘None’ if there is no header matching _name_.

 -- Method: Message.getheader (name[, default])

     Return a single string consisting of the last header matching
     _name_, but strip leading and trailing whitespace.  Internal
     whitespace is not stripped.  The optional _default_ argument can be
     used to specify a different default to be returned when there is no
     header matching _name_; it defaults to ‘None’.  This is the
     preferred way to get parsed headers.

 -- Method: Message.get (name[, default])

     An alias for *note getheader(): 199d, to make the interface more
     compatible with regular dictionaries.

 -- Method: Message.getaddr (name)

     Return a pair ‘(full name, email address)’ parsed from the string
     returned by ‘getheader(name)’.  If no header matching _name_
     exists, return ‘(None, None)’; otherwise both the full name and the
     address are (possibly empty) strings.

     Example: If _m_’s first ‘From’ header contains the string
     ‘'jack@cwi.nl (Jack Jansen)'’, then ‘m.getaddr('From')’ will yield
     the pair ‘('Jack Jansen', 'jack@cwi.nl')’.  If the header contained
     ‘'Jack Jansen <jack@cwi.nl>'’ instead, it would yield the exact
     same result.

 -- Method: Message.getaddrlist (name)

     This is similar to ‘getaddr(list)’, but parses a header containing
     a list of email addresses (e.g.  a ‘To’ header) and returns a list
     of ‘(full name, email address)’ pairs (even if there was only one
     address in the header).  If there is no header matching _name_,
     return an empty list.

     If multiple headers exist that match the named header (e.g.  if
     there are several ‘Cc’ headers), all are parsed for addresses.  Any
     continuation lines the named headers contain are also parsed.

 -- Method: Message.getdate (name)

     Retrieve a header using *note getheader(): 199d. and parse it into
     a 9-tuple compatible with *note time.mktime(): 11f3.; note that
     fields 6, 7, and 8 are not usable.  If there is no header matching
     _name_, or it is unparsable, return ‘None’.

     Date parsing appears to be a black art, and not all mailers adhere
     to the standard.  While it has been tested and found correct on a
     large collection of email from many sources, it is still possible
     that this function may occasionally yield an incorrect result.

 -- Method: Message.getdate_tz (name)

     Retrieve a header using *note getheader(): 199d. and parse it into
     a 10-tuple; the first 9 elements will make a tuple compatible with
     *note time.mktime(): 11f3, and the 10th is a number giving the
     offset of the date’s timezone from UTC. Note that fields 6, 7, and
     8 are not usable.  Similarly to *note getdate(): 19a1, if there is
     no header matching _name_, or it is unparsable, return ‘None’.

  *note Message: 189f. instances also support a limited mapping
interface.  In particular: ‘m[name]’ is like ‘m.getheader(name)’ but
raises *note KeyError: 205. if there is no matching header; and
‘len(m)’, ‘m.get(name[, default])’, ‘name in m’, ‘m.keys()’,
‘m.values()’ ‘m.items()’, and ‘m.setdefault(name[, default])’ act as
expected, with the one difference that ‘setdefault()’ uses an empty
string as the default value.  *note Message: 189f. instances also
support the mapping writable interface ‘m[name] = value’ and ‘del
m[name]’.  *note Message: 189f. objects do not support the ‘clear()’,
*note copy(): 71, ‘popitem()’, or ‘update()’ methods of the mapping
interface.  (Support for ‘get()’ and ‘setdefault()’ was only added in
Python 2.2.)

  Finally, *note Message: 189f. instances have some public instance
variables:

 -- Attribute: Message.headers

     A list containing the entire set of header lines, in the order in
     which they were read (except that setitem calls may disturb this
     order).  Each line contains a trailing newline.  The blank line
     terminating the headers is not contained in the list.

 -- Attribute: Message.fp

     The file or file-like object passed at instantiation time.  This
     can be used to read the message content.

 -- Attribute: Message.unixfrom

     The Unix ‘From’ line, if the message had one, or an empty string.
     This is needed to regenerate the message in some contexts, such as
     an ‘mbox’-style mailbox file.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: AddressList Objects,  Prev: Message Objects<2>,  Up: rfc822 --- Parse RFC 2822 mail headers

5.18.11.2 AddressList Objects
.............................

An *note AddressList: 198c. instance has the following methods:

 -- Method: AddressList.__len__ ()

     Return the number of addresses in the address list.

 -- Method: AddressList.__str__ ()

     Return a canonicalized string representation of the address list.
     Addresses are rendered in "name" <<host@domain>> form,
     comma-separated.

 -- Method: AddressList.__add__ (alist)

     Return a new *note AddressList: 198c. instance that contains all
     addresses in both *note AddressList: 198c. operands, with
     duplicates removed (set union).

 -- Method: AddressList.__iadd__ (alist)

     In-place version of *note __add__(): 19aa.; turns this *note
     AddressList: 198c. instance into the union of itself and the
     right-hand instance, _alist_.

 -- Method: AddressList.__sub__ (alist)

     Return a new *note AddressList: 198c. instance that contains every
     address in the left-hand *note AddressList: 198c. operand that is
     not present in the right-hand address operand (set difference).

 -- Method: AddressList.__isub__ (alist)

     In-place version of *note __sub__(): 19ac, removing addresses in
     this list which are also in _alist_.

  Finally, *note AddressList: 198c. instances have one public instance
variable:

 -- Attribute: AddressList.addresslist

     A list of tuple string pairs, one per address.  In each member, the
     first is the canonicalized name part, the second is the actual
     route-address (‘'@'’-separated username-host.domain pair).


File: python.info,  Node: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Next: binhex --- Encode and decode binhex4 files,  Prev: rfc822 --- Parse RFC 2822 mail headers,  Up: Internet Data Handling

5.18.12 ‘base64’ — RFC 3548: Base16, Base32, Base64 Data Encodings
------------------------------------------------------------------

This module provides data encoding and decoding as specified in RFC
3548(1).  This standard defines the Base16, Base32, and Base64
algorithms for encoding and decoding arbitrary binary strings into text
strings that can be safely sent by email, used as parts of URLs, or
included as part of an HTTP POST request.  The encoding algorithm is not
the same as the *uuencode* program.

  There are two interfaces provided by this module.  The modern
interface supports encoding and decoding string objects using all three
alphabets.  The legacy interface provides for encoding and decoding to
and from file-like objects as well as strings, but only using the Base64
standard alphabet.

  The modern interface, which was introduced in Python 2.4, provides:

 -- Function: base64.b64encode (s[, altchars])

     Encode a string use Base64.

     _s_ is the string to encode.  Optional _altchars_ must be a string
     of at least length 2 (additional characters are ignored) which
     specifies an alternative alphabet for the ‘+’ and ‘/’ characters.
     This allows an application to e.g.  generate URL or filesystem safe
     Base64 strings.  The default is ‘None’, for which the standard
     Base64 alphabet is used.

     The encoded string is returned.

 -- Function: base64.b64decode (s[, altchars])

     Decode a Base64 encoded string.

     _s_ is the string to decode.  Optional _altchars_ must be a string
     of at least length 2 (additional characters are ignored) which
     specifies the alternative alphabet used instead of the ‘+’ and ‘/’
     characters.

     The decoded string is returned.  A *note TypeError: 218. is raised
     if _s_ were incorrectly padded or if there are non-alphabet
     characters present in the string.

 -- Function: base64.standard_b64encode (s)

     Encode string _s_ using the standard Base64 alphabet.

 -- Function: base64.standard_b64decode (s)

     Decode string _s_ using the standard Base64 alphabet.

 -- Function: base64.urlsafe_b64encode (s)

     Encode string _s_ using a URL-safe alphabet, which substitutes ‘-’
     instead of ‘+’ and ‘_’ instead of ‘/’ in the standard Base64
     alphabet.  The result can still contain ‘=’.

 -- Function: base64.urlsafe_b64decode (s)

     Decode string _s_ using a URL-safe alphabet, which substitutes ‘-’
     instead of ‘+’ and ‘_’ instead of ‘/’ in the standard Base64
     alphabet.

 -- Function: base64.b32encode (s)

     Encode a string using Base32.  _s_ is the string to encode.  The
     encoded string is returned.

 -- Function: base64.b32decode (s[, casefold[, map01]])

     Decode a Base32 encoded string.

     _s_ is the string to decode.  Optional _casefold_ is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is ‘False’.

     RFC 3548(2) allows for optional mapping of the digit 0 (zero) to
     the letter O (oh), and for optional mapping of the digit 1 (one) to
     either the letter I (eye) or letter L (el).  The optional argument
     _map01_ when not ‘None’, specifies which letter the digit 1 should
     be mapped to (when _map01_ is not ‘None’, the digit 0 is always
     mapped to the letter O). For security purposes the default is
     ‘None’, so that 0 and 1 are not allowed in the input.

     The decoded string is returned.  A *note TypeError: 218. is raised
     if _s_ is incorrectly padded or if there are non-alphabet
     characters present in the string.

 -- Function: base64.b16encode (s)

     Encode a string using Base16.

     _s_ is the string to encode.  The encoded string is returned.

 -- Function: base64.b16decode (s[, casefold])

     Decode a Base16 encoded string.

     _s_ is the string to decode.  Optional _casefold_ is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is ‘False’.

     The decoded string is returned.  A *note TypeError: 218. is raised
     if _s_ were incorrectly padded or if there are non-alphabet
     characters present in the string.

  The legacy interface:

 -- Function: base64.decode (input, output)

     Decode the contents of the _input_ file and write the resulting
     binary data to the _output_ file.  _input_ and _output_ must either
     be file objects or objects that mimic the file object interface.
     _input_ will be read until ‘input.read()’ returns an empty string.

 -- Function: base64.decodestring (s)

     Decode the string _s_, which must contain one or more lines of
     base64 encoded data, and return a string containing the resulting
     binary data.

 -- Function: base64.encode (input, output)

     Encode the contents of the _input_ file and write the resulting
     base64 encoded data to the _output_ file.  _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface.  _input_ will be read until ‘input.read()’ returns an
     empty string.  *note encode(): 19b9. returns the encoded data plus
     a trailing newline character (‘'\n'’).

 -- Function: base64.encodestring (s)

     Encode the string _s_, which can contain arbitrary binary data, and
     return a string containing one or more lines of base64-encoded
     data.  *note encodestring(): 19ba. returns a string containing one
     or more lines of base64-encoded data always including an extra
     trailing newline (‘'\n'’).

  An example usage of the module:

     >>> import base64
     >>> encoded = base64.b64encode('data to be encoded')
     >>> encoded
     'ZGF0YSB0byBiZSBlbmNvZGVk'
     >>> data = base64.b64decode(encoded)
     >>> data
     'data to be encoded'

See also
........

Module *note binascii: 19.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

RFC 1521(3) - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies

     Section 5.2, "Base64 Content-Transfer-Encoding," provides the
     definition of the base64 encoding.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc3548.html

   (2) http://tools.ietf.org/html/rfc3548.html

   (3) http://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: binhex --- Encode and decode binhex4 files,  Next: binascii --- Convert between binary and ASCII,  Prev: base64 --- RFC 3548 Base16 Base32 Base64 Data Encodings,  Up: Internet Data Handling

5.18.13 ‘binhex’ — Encode and decode binhex4 files
--------------------------------------------------

This module encodes and decodes files in binhex4 format, a format
allowing representation of Macintosh files in ASCII. On the Macintosh,
both forks of a file and the finder information are encoded (or
decoded), on other platforms only the data fork is handled.

     Note: In Python 3.x, special Macintosh support has been removed.

  The *note binhex: 1a. module defines the following functions:

 -- Function: binhex.binhex (input, output)

     Convert a binary file with filename _input_ to binhex file
     _output_.  The _output_ parameter can either be a filename or a
     file-like object (any object supporting a ‘write()’ and ‘close()’
     method).

 -- Function: binhex.hexbin (input[, output])

     Decode a binhex file _input_.  _input_ may be a filename or a
     file-like object supporting ‘read()’ and ‘close()’ methods.  The
     resulting file is written to a file named _output_, unless the
     argument is omitted in which case the output filename is read from
     the binhex file.

  The following exception is also defined:

 -- Exception: binhex.Error

     Exception raised when something can’t be encoded using the binhex
     format (for example, a filename is too long to fit in the filename
     field), or when input is not properly encoded binhex data.

See also
........

Module *note binascii: 19.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

* Menu:

* Notes: Notes<2>. 


File: python.info,  Node: Notes<2>,  Up: binhex --- Encode and decode binhex4 files

5.18.13.1 Notes
...............

There is an alternative, more powerful interface to the coder and
decoder, see the source for details.

  If you code or decode textfiles on non-Macintosh platforms they will
still use the old Macintosh newline convention (carriage-return as end
of line).

  As of this writing, *note hexbin(): 19be. appears to not work in all
cases.


File: python.info,  Node: binascii --- Convert between binary and ASCII,  Next: quopri --- Encode and decode MIME quoted-printable data,  Prev: binhex --- Encode and decode binhex4 files,  Up: Internet Data Handling

5.18.14 ‘binascii’ — Convert between binary and ASCII
-----------------------------------------------------

The *note binascii: 19. module contains a number of methods to convert
between binary and various ASCII-encoded binary representations.
Normally, you will not use these functions directly but use wrapper
modules like *note uu: 18f, *note base64: 15, or *note binhex: 1a.
instead.  The *note binascii: 19. module contains low-level functions
written in C for greater speed that are used by the higher-level
modules.

  The *note binascii: 19. module defines the following functions:

 -- Function: binascii.a2b_uu (string)

     Convert a single line of uuencoded data back to binary and return
     the binary data.  Lines normally contain 45 (binary) bytes, except
     for the last line.  Line data may be followed by whitespace.

 -- Function: binascii.b2a_uu (data)

     Convert binary data to a line of ASCII characters, the return value
     is the converted line, including a newline char.  The length of
     _data_ should be at most 45.

 -- Function: binascii.a2b_base64 (string)

     Convert a block of base64 data back to binary and return the binary
     data.  More than one line may be passed at a time.

 -- Function: binascii.b2a_base64 (data)

     Convert binary data to a line of ASCII characters in base64 coding.
     The return value is the converted line, including a newline char.
     The length of _data_ should be at most 57 to adhere to the base64
     standard.

 -- Function: binascii.a2b_qp (string[, header])

     Convert a block of quoted-printable data back to binary and return
     the binary data.  More than one line may be passed at a time.  If
     the optional argument _header_ is present and true, underscores
     will be decoded as spaces.

 -- Function: binascii.b2a_qp (data[, quotetabs, istext, header])

     Convert binary data to a line(s) of ASCII characters in
     quoted-printable encoding.  The return value is the converted
     line(s).  If the optional argument _quotetabs_ is present and true,
     all tabs and spaces will be encoded.  If the optional argument
     _istext_ is present and true, newlines are not encoded but trailing
     whitespace will be encoded.  If the optional argument _header_ is
     present and true, spaces will be encoded as underscores per
     RFC1522.  If the optional argument _header_ is present and false,
     newline characters will be encoded as well; otherwise linefeed
     conversion might corrupt the binary data stream.

 -- Function: binascii.a2b_hqx (string)

     Convert binhex4 formatted ASCII data to binary, without doing
     RLE-decompression.  The string should contain a complete number of
     binary bytes, or (in case of the last portion of the binhex4 data)
     have the remaining bits zero.

 -- Function: binascii.rledecode_hqx (data)

     Perform RLE-decompression on the data, as per the binhex4 standard.
     The algorithm uses ‘0x90’ after a byte as a repeat indicator,
     followed by a count.  A count of ‘0’ specifies a byte value of
     ‘0x90’.  The routine returns the decompressed data, unless data
     input data ends in an orphaned repeat indicator, in which case the
     *note Incomplete: 19cc. exception is raised.

 -- Function: binascii.rlecode_hqx (data)

     Perform binhex4 style RLE-compression on _data_ and return the
     result.

 -- Function: binascii.b2a_hqx (data)

     Perform hexbin4 binary-to-ASCII translation and return the
     resulting string.  The argument should already be RLE-coded, and
     have a length divisible by 3 (except possibly the last fragment).

 -- Function: binascii.crc_hqx (data, crc)

     Compute the binhex4 crc value of _data_, starting with an initial
     _crc_ and returning the result.

 -- Function: binascii.crc32 (data[, crc])

     Compute CRC-32, the 32-bit checksum of data, starting with an
     initial crc.  This is consistent with the ZIP file checksum.  Since
     the algorithm is designed for use as a checksum algorithm, it is
     not suitable for use as a general hash algorithm.  Use as follows:

          print binascii.crc32("hello world")
          # Or, in two pieces:
          crc = binascii.crc32("hello")
          crc = binascii.crc32(" world", crc) & 0xffffffff
          print 'crc32 = 0x%08x' % crc

     Note: To generate the same numeric value across all Python versions
     and platforms use crc32(data) & 0xffffffff.  If you are only using
     the checksum in packed binary format this is not necessary as the
     return value is the correct 32bit binary representation regardless
     of sign.

  Changed in version 2.6: The return value is in the range [-2**31,
2**31-1] regardless of platform.  In the past the value would be signed
on some platforms and unsigned on others.  Use & 0xffffffff on the value
if you want it to match Python 3 behavior.

  Changed in version 3.0: The return value is unsigned and in the range
[0, 2**32-1] regardless of platform.

 -- Function: binascii.b2a_hex (data)
 -- Function: binascii.hexlify (data)

     Return the hexadecimal representation of the binary _data_.  Every
     byte of _data_ is converted into the corresponding 2-digit hex
     representation.  The resulting string is therefore twice as long as
     the length of _data_.

 -- Function: binascii.a2b_hex (hexstr)
 -- Function: binascii.unhexlify (hexstr)

     Return the binary data represented by the hexadecimal string
     _hexstr_.  This function is the inverse of *note b2a_hex(): 19d1.
     _hexstr_ must contain an even number of hexadecimal digits (which
     can be upper or lower case), otherwise a *note TypeError: 218. is
     raised.

 -- Exception: binascii.Error

     Exception raised on errors.  These are usually programming errors.

 -- Exception: binascii.Incomplete

     Exception raised on incomplete data.  These are usually not
     programming errors, but may be handled by reading a little more
     data and trying again.

See also
........

Module *note base64: 15.

     Support for base64 encoding used in MIME email messages.

Module *note binhex: 1a.

     Support for the binhex format used on the Macintosh.

Module *note uu: 18f.

     Support for UU encoding used on Unix.

Module *note quopri: 141.

     Support for quoted-printable encoding used in MIME email messages.


File: python.info,  Node: quopri --- Encode and decode MIME quoted-printable data,  Next: uu --- Encode and decode uuencode files,  Prev: binascii --- Convert between binary and ASCII,  Up: Internet Data Handling

5.18.15 ‘quopri’ — Encode and decode MIME quoted-printable data
---------------------------------------------------------------

*Source code:* Lib/quopri.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  This module performs quoted-printable transport encoding and decoding,
as defined in RFC 1521(2): "MIME (Multipurpose Internet Mail Extensions)
Part One: Mechanisms for Specifying and Describing the Format of
Internet Message Bodies".  The quoted-printable encoding is designed for
data where there are relatively few nonprintable characters; the base64
encoding scheme available via the *note base64: 15. module is more
compact if there are many such characters, as when sending a graphics
file.

 -- Function: quopri.decode (input, output[, header])

     Decode the contents of the _input_ file and write the resulting
     decoded binary data to the _output_ file.  _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface.  _input_ will be read until ‘input.readline()’ returns
     an empty string.  If the optional argument _header_ is present and
     true, underscore will be decoded as space.  This is used to decode
     "Q"-encoded headers as described in RFC 1522(3): "MIME
     (Multipurpose Internet Mail Extensions) Part Two: Message Header
     Extensions for Non-ASCII Text".

 -- Function: quopri.encode (input, output, quotetabs)

     Encode the contents of the _input_ file and write the resulting
     quoted-printable data to the _output_ file.  _input_ and _output_
     must either be file objects or objects that mimic the file object
     interface.  _input_ will be read until ‘input.readline()’ returns
     an empty string.  _quotetabs_ is a flag which controls whether to
     encode embedded spaces and tabs; when true it encodes such embedded
     whitespace, and when false it leaves them unencoded.  Note that
     spaces and tabs appearing at the end of lines are always encoded,
     as per RFC 1521(4).

 -- Function: quopri.decodestring (s[, header])

     Like *note decode(): 19d8, except that it accepts a source string
     and returns the corresponding decoded string.

 -- Function: quopri.encodestring (s[, quotetabs])

     Like *note encode(): 19d9, except that it accepts a source string
     and returns the corresponding encoded string.  _quotetabs_ is
     optional (defaulting to 0), and is passed straight through to *note
     encode(): 19d9.

See also
........

Module *note mimify: 112.

     General utilities for processing of MIME messages.

Module *note base64: 15.

     Encode and decode MIME base64 data

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/quopri.py

   (2) http://tools.ietf.org/html/rfc1521.html

   (3) http://tools.ietf.org/html/rfc1522.html

   (4) http://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: uu --- Encode and decode uuencode files,  Prev: quopri --- Encode and decode MIME quoted-printable data,  Up: Internet Data Handling

5.18.16 ‘uu’ — Encode and decode uuencode files
-----------------------------------------------

*Source code:* Lib/uu.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  This module encodes and decodes files in uuencode format, allowing
arbitrary binary data to be transferred over ASCII-only connections.
Wherever a file argument is expected, the methods accept a file-like
object.  For backwards compatibility, a string containing a pathname is
also accepted, and the corresponding file will be opened for reading and
writing; the pathname ‘'-'’ is understood to mean the standard input or
output.  However, this interface is deprecated; it’s better for the
caller to open the file itself, and be sure that, when required, the
mode is ‘'rb'’ or ‘'wb'’ on Windows.

  This code was contributed by Lance Ellinghouse, and modified by Jack
Jansen.

  The *note uu: 18f. module defines the following functions:

 -- Function: uu.encode (in_file, out_file[, name[, mode]])

     Uuencode file _in_file_ into file _out_file_.  The uuencoded file
     will have the header specifying _name_ and _mode_ as the defaults
     for the results of decoding the file.  The default defaults are
     taken from _in_file_, or ‘'-'’ and ‘0666’ respectively.

 -- Function: uu.decode (in_file[, out_file[, mode[, quiet]]])

     This call decodes uuencoded file _in_file_ placing the result on
     file _out_file_.  If _out_file_ is a pathname, _mode_ is used to
     set the permission bits if the file must be created.  Defaults for
     _out_file_ and _mode_ are taken from the uuencode header.  However,
     if the file specified in the header already exists, a *note
     uu.Error: 19dc. is raised.

     *note decode(): a95. may print a warning to standard error if the
     input was produced by an incorrect uuencoder and Python could
     recover from that error.  Setting _quiet_ to a true value silences
     this warning.

 -- Exception: uu.Error

     Subclass of *note Exception: 339, this can be raised by *note
     uu.decode(): a95. under various situations, such as described
     above, but also including a badly formatted header, or truncated
     input file.

See also
........

Module *note binascii: 19.

     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/uu.py


File: python.info,  Node: Structured Markup Processing Tools,  Next: Internet Protocols and Support,  Prev: Internet Data Handling,  Up: The Python Standard Library

5.19 Structured Markup Processing Tools
=======================================

Python supports a variety of modules to work with various forms of
structured data markup.  This includes modules to work with the Standard
Generalized Markup Language (SGML) and the Hypertext Markup Language
(HTML), and several interfaces for working with the Extensible Markup
Language (XML).

  It is important to note that modules in the *note xml: 1a0. package
require that there be at least one SAX-compliant XML parser available.
Starting with Python 2.3, the Expat parser is included with Python, so
the *note xml.parsers.expat: 1a5. module will always be available.  You
may still want to be aware of the PyXML add-on package(1); that package
provides an extended set of XML libraries for Python.

  The documentation for the *note xml.dom: 1a1. and *note xml.sax: 1a6.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

* Menu:

* HTMLParser: HTMLParser --- Simple HTML and XHTML parser. Simple HTML and XHTML parser
* sgmllib: sgmllib --- Simple SGML parser. Simple SGML parser
* htmllib: htmllib --- A parser for HTML documents. A parser for HTML documents
* htmlentitydefs: htmlentitydefs --- Definitions of HTML general entities. Definitions of HTML general entities
* XML Processing Modules:: 
* XML vulnerabilities:: 
* xml.etree.ElementTree: xml etree ElementTree --- The ElementTree XML API. The ElementTree XML API
* xml.dom: xml dom --- The Document Object Model API. The Document Object Model API
* xml.dom.minidom: xml dom minidom --- Minimal DOM implementation. Minimal DOM implementation
* xml.dom.pulldom: xml dom pulldom --- Support for building partial DOM trees. Support for building partial DOM trees
* xml.sax: xml sax --- Support for SAX2 parsers. Support for SAX2 parsers
* xml.sax.handler: xml sax handler --- Base classes for SAX handlers. Base classes for SAX handlers
* xml.sax.saxutils: xml sax saxutils --- SAX Utilities. SAX Utilities
* xml.sax.xmlreader: xml sax xmlreader --- Interface for XML parsers. Interface for XML parsers
* xml.parsers.expat: xml parsers expat --- Fast XML parsing using Expat. Fast XML parsing using Expat

HTMLParser — Simple HTML and XHTML parser

* Example HTML Parser Application:: 
* HTMLParser Methods:: 
* Examples: Examples<10>. 

htmllib — A parser for HTML documents

* HTMLParser Objects:: 

XML vulnerabilities

* defused packages:: 

xml.etree.ElementTree — The ElementTree XML API

* Tutorial: Tutorial<2>. 
* XPath support:: 
* Reference: Reference<2>. 

Tutorial

* XML tree and elements:: 
* Parsing XML:: 
* Finding interesting elements:: 
* Modifying an XML File:: 
* Building XML documents:: 
* Additional resources:: 

XPath support

* Example: Example<10>. 
* Supported XPath syntax:: 

Reference

* Functions: Functions<4>. 
* Element Objects:: 
* ElementTree Objects:: 
* QName Objects:: 
* TreeBuilder Objects:: 
* XMLParser Objects:: 

xml.dom — The Document Object Model API

* Module Contents: Module Contents<3>. 
* Objects in the DOM:: 
* Conformance:: 

Objects in the DOM

* DOMImplementation Objects:: 
* Node Objects:: 
* NodeList Objects:: 
* DocumentType Objects:: 
* Document Objects:: 
* Element Objects: Element Objects<2>. 
* Attr Objects:: 
* NamedNodeMap Objects:: 
* Comment Objects:: 
* Text and CDATASection Objects:: 
* ProcessingInstruction Objects:: 
* Exceptions: Exceptions<6>. 

Conformance

* Type Mapping:: 
* Accessor Methods:: 

xml.dom.minidom — Minimal DOM implementation

* DOM Objects:: 
* DOM Example:: 
* minidom and the DOM standard:: 

xml.dom.pulldom — Support for building partial DOM trees

* DOMEventStream Objects:: 

xml.sax — Support for SAX2 parsers

* SAXException Objects:: 

xml.sax.handler — Base classes for SAX handlers

* ContentHandler Objects:: 
* DTDHandler Objects:: 
* EntityResolver Objects:: 
* ErrorHandler Objects:: 

xml.sax.xmlreader — Interface for XML parsers

* XMLReader Objects:: 
* IncrementalParser Objects:: 
* Locator Objects:: 
* InputSource Objects:: 
* The Attributes Interface:: 
* The AttributesNS Interface:: 

xml.parsers.expat — Fast XML parsing using Expat

* XMLParser Objects: XMLParser Objects<2>. 
* ExpatError Exceptions:: 
* Example: Example<11>. 
* Content Model Descriptions:: 
* Expat error constants:: 

   ---------- Footnotes ----------

   (1) http://pyxml.sourceforge.net/


File: python.info,  Node: HTMLParser --- Simple HTML and XHTML parser,  Next: sgmllib --- Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.1 ‘HTMLParser’ — Simple HTML and XHTML parser
--------------------------------------------------

     Note: The *note HTMLParser: ed. module has been renamed to
     ‘html.parser’ in Python 3.  The *note 2to3: bdb. tool will
     automatically adapt imports when converting your sources to Python
     3.

  New in version 2.2.

  *Source code:* Lib/HTMLParser.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  This module defines a class *note HTMLParser: 19e2. which serves as
the basis for parsing text files formatted in HTML (HyperText Mark-up
Language) and XHTML. Unlike the parser in *note htmllib: ec, this parser
is not based on the SGML parser in *note sgmllib: 150.

 -- Class: HTMLParser.HTMLParser

     An *note HTMLParser: 19e2. instance is fed HTML data and calls
     handler methods when start tags, end tags, text, comments, and
     other markup elements are encountered.  The user should subclass
     *note HTMLParser: 19e2. and override its methods to implement the
     desired behavior.

     The *note HTMLParser: 19e2. class is instantiated without
     arguments.

     Unlike the parser in *note htmllib: ec, this parser does not check
     that end tags match start tags or call the end-tag handler for
     elements which are closed implicitly by closing an outer element.

  An exception is defined as well:

 -- Exception: HTMLParser.HTMLParseError

     *note HTMLParser: 19e2. is able to handle broken markup, but in
     some cases it might raise this exception when it encounters an
     error while parsing.  This exception provides three attributes:
     ‘msg’ is a brief message explaining the error, ‘lineno’ is the
     number of the line on which the broken construct was detected, and
     ‘offset’ is the number of characters into the line at which the
     construct starts.

* Menu:

* Example HTML Parser Application:: 
* HTMLParser Methods:: 
* Examples: Examples<10>. 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/HTMLParser.py


File: python.info,  Node: Example HTML Parser Application,  Next: HTMLParser Methods,  Up: HTMLParser --- Simple HTML and XHTML parser

5.19.1.1 Example HTML Parser Application
........................................

As a basic example, below is a simple HTML parser that uses the *note
HTMLParser: 19e2. class to print out start tags, end tags and data as
they are encountered:

     from HTMLParser import HTMLParser

     # create a subclass and override the handler methods
     class MyHTMLParser(HTMLParser):
         def handle_starttag(self, tag, attrs):
             print "Encountered a start tag:", tag
         def handle_endtag(self, tag):
             print "Encountered an end tag :", tag
         def handle_data(self, data):
             print "Encountered some data  :", data

     # instantiate the parser and fed it some HTML
     parser = MyHTMLParser()
     parser.feed('<html><head><title>Test</title></head>'
                 '<body><h1>Parse me!</h1></body></html>')

  The output will then be:

     Encountered a start tag: html
     Encountered a start tag: head
     Encountered a start tag: title
     Encountered some data  : Test
     Encountered an end tag : title
     Encountered an end tag : head
     Encountered a start tag: body
     Encountered a start tag: h1
     Encountered some data  : Parse me!
     Encountered an end tag : h1
     Encountered an end tag : body
     Encountered an end tag : html


File: python.info,  Node: HTMLParser Methods,  Next: Examples<10>,  Prev: Example HTML Parser Application,  Up: HTMLParser --- Simple HTML and XHTML parser

5.19.1.2 ‘HTMLParser’ Methods
.............................

*note HTMLParser: 19e2. instances have the following methods:

 -- Method: HTMLParser.feed (data)

     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *note close(): 19e7. is called.  _data_ can be
     either *note unicode: 1f5. or *note str: 1ea, but passing *note
     unicode: 1f5. is advised.

 -- Method: HTMLParser.close ()

     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call the *note HTMLParser: 19e2.
     base class method *note close(): 19e7.

 -- Method: HTMLParser.reset ()

     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: HTMLParser.getpos ()

     Return current line number and offset.

 -- Method: HTMLParser.get_starttag_text ()

     Return the text of the most recently opened start tag.  This should
     not normally be needed for structured processing, but may be useful
     in dealing with HTML "as deployed" or for re-generating input with
     minimal changes (whitespace between attributes can be preserved,
     etc.).

  The following methods are called when data or markup elements are
encountered and they are meant to be overridden in a subclass.  The base
class implementations do nothing (except for *note handle_startendtag():
19eb.):

 -- Method: HTMLParser.handle_starttag (tag, attrs)

     This method is called to handle the start of a tag (e.g.  ‘<div
     id="main">’).

     The _tag_ argument is the name of the tag converted to lower case.
     The _attrs_ argument is a list of ‘(name, value)’ pairs containing
     the attributes found inside the tag’s ‘<>’ brackets.  The _name_
     will be translated to lower case, and quotes in the _value_ have
     been removed, and character and entity references have been
     replaced.

     For instance, for the tag ‘<A HREF="http://www.cwi.nl/">’, this
     method would be called as ‘handle_starttag('a', [('href',
     'http://www.cwi.nl/')])’.

     Changed in version 2.6: All entity references from *note
     htmlentitydefs: eb. are now replaced in the attribute values.

 -- Method: HTMLParser.handle_endtag (tag)

     This method is called to handle the end tag of an element (e.g.
     ‘</div>’).

     The _tag_ argument is the name of the tag converted to lower case.

 -- Method: HTMLParser.handle_startendtag (tag, attrs)

     Similar to *note handle_starttag(): 19ec, but called when the
     parser encounters an XHTML-style empty tag (‘<img ... />’).  This
     method may be overridden by subclasses which require this
     particular lexical information; the default implementation simply
     calls *note handle_starttag(): 19ec. and *note handle_endtag():
     19ed.

 -- Method: HTMLParser.handle_data (data)

     This method is called to process arbitrary data (e.g.  text nodes
     and the content of ‘<script>...</script>’ and
     ‘<style>...</style>’).

 -- Method: HTMLParser.handle_entityref (name)

     This method is called to process a named character reference of the
     form ‘&name;’ (e.g.  ‘&gt;’), where _name_ is a general entity
     reference (e.g.  ‘'gt'’).

 -- Method: HTMLParser.handle_charref (name)

     This method is called to process decimal and hexadecimal numeric
     character references of the form ‘&#NNN;’ and ‘&#xNNN;’.  For
     example, the decimal equivalent for ‘&gt;’ is ‘&#62;’, whereas the
     hexadecimal is ‘&#x3E;’; in this case the method will receive
     ‘'62'’ or ‘'x3E'’.

 -- Method: HTMLParser.handle_comment (data)

     This method is called when a comment is encountered (e.g.
     ‘<!--comment-->’).

     For example, the comment ‘<!-- comment -->’ will cause this method
     to be called with the argument ‘' comment '’.

     The content of Internet Explorer conditional comments (condcoms)
     will also be sent to this method, so, for ‘<!--[if IE
     9]>IE9-specific content<![endif]-->’, this method will receive
     ‘'[if IE 9]>IE-specific content<![endif]'’.

 -- Method: HTMLParser.handle_decl (decl)

     This method is called to handle an HTML doctype declaration (e.g.
     ‘<!DOCTYPE html>’).

     The _decl_ parameter will be the entire contents of the declaration
     inside the ‘<!...>’ markup (e.g.  ‘'DOCTYPE html'’).

 -- Method: HTMLParser.handle_pi (data)

     This method is called when a processing instruction is encountered.
     The _data_ parameter will contain the entire processing
     instruction.  For example, for the processing instruction ‘<?proc
     color='red'>’, this method would be called as ‘handle_pi("proc
     color='red'")’.

          Note: The *note HTMLParser: 19e2. class uses the SGML
          syntactic rules for processing instructions.  An XHTML
          processing instruction using the trailing ‘'?'’ will cause the
          ‘'?'’ to be included in _data_.

 -- Method: HTMLParser.unknown_decl (data)

     This method is called when an unrecognized declaration is read by
     the parser.

     The _data_ parameter will be the entire contents of the declaration
     inside the ‘<![...]>’ markup.  It is sometimes useful to be
     overridden by a derived class.


File: python.info,  Node: Examples<10>,  Prev: HTMLParser Methods,  Up: HTMLParser --- Simple HTML and XHTML parser

5.19.1.3 Examples
.................

The following class implements a parser that will be used to illustrate
more examples:

     from HTMLParser import HTMLParser
     from htmlentitydefs import name2codepoint

     class MyHTMLParser(HTMLParser):
         def handle_starttag(self, tag, attrs):
             print "Start tag:", tag
             for attr in attrs:
                 print "     attr:", attr
         def handle_endtag(self, tag):
             print "End tag  :", tag
         def handle_data(self, data):
             print "Data     :", data
         def handle_comment(self, data):
             print "Comment  :", data
         def handle_entityref(self, name):
             c = unichr(name2codepoint[name])
             print "Named ent:", c
         def handle_charref(self, name):
             if name.startswith('x'):
                 c = unichr(int(name[1:], 16))
             else:
                 c = unichr(int(name))
             print "Num ent  :", c
         def handle_decl(self, data):
             print "Decl     :", data

     parser = MyHTMLParser()

  Parsing a doctype:

     >>> parser.feed('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
     ...             '"http://www.w3.org/TR/html4/strict.dtd">')
     Decl     : DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"

  Parsing an element with a few attributes and a title:

     >>> parser.feed('<img src="python-logo.png" alt="The Python logo">')
     Start tag: img
          attr: ('src', 'python-logo.png')
          attr: ('alt', 'The Python logo')
     >>>
     >>> parser.feed('<h1>Python</h1>')
     Start tag: h1
     Data     : Python
     End tag  : h1

  The content of ‘script’ and ‘style’ elements is returned as is,
without further parsing:

     >>> parser.feed('<style type="text/css">#python { color: green }</style>')
     Start tag: style
          attr: ('type', 'text/css')
     Data     : #python { color: green }
     End tag  : style
     >>>
     >>> parser.feed('<script type="text/javascript">'
     ...             'alert("<strong>hello!</strong>");</script>')
     Start tag: script
          attr: ('type', 'text/javascript')
     Data     : alert("<strong>hello!</strong>");
     End tag  : script

  Parsing comments:

     >>> parser.feed('<!-- a comment -->'
     ...             '<!--[if IE 9]>IE-specific content<![endif]-->')
     Comment  :  a comment
     Comment  : [if IE 9]>IE-specific content<![endif]

  Parsing named and numeric character references and converting them to
the correct char (note: these 3 references are all equivalent to ‘'>'’):

     >>> parser.feed('&gt;&#62;&#x3E;')
     Named ent: >
     Num ent  : >
     Num ent  : >

  Feeding incomplete chunks to *note feed(): 19e6. works, but *note
handle_data(): 19ee. might be called more than once:

     >>> for chunk in ['<sp', 'an>buff', 'ered ', 'text</s', 'pan>']:
     ...     parser.feed(chunk)
     ...
     Start tag: span
     Data     : buff
     Data     : ered
     Data     : text
     End tag  : span

  Parsing invalid HTML (e.g.  unquoted attributes) also works:

     >>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')
     Start tag: p
     Start tag: a
          attr: ('class', 'link')
          attr: ('href', '#main')
     Data     : tag soup
     End tag  : p
     End tag  : a


File: python.info,  Node: sgmllib --- Simple SGML parser,  Next: htmllib --- A parser for HTML documents,  Prev: HTMLParser --- Simple HTML and XHTML parser,  Up: Structured Markup Processing Tools

5.19.2 ‘sgmllib’ — Simple SGML parser
-------------------------------------

Deprecated since version 2.6: The *note sgmllib: 150. module has been
removed in Python 3.

  This module defines a class *note SGMLParser: 19f9. which serves as
the basis for parsing text files formatted in SGML (Standard Generalized
Mark-up Language).  In fact, it does not provide a full SGML parser — it
only parses SGML insofar as it is used by HTML, and the module only
exists as a base for the *note htmllib: ec. module.  Another HTML parser
which supports XHTML and offers a somewhat different interface is
available in the *note HTMLParser: ed. module.

 -- Class: sgmllib.SGMLParser

     The *note SGMLParser: 19f9. class is instantiated without
     arguments.  The parser is hardcoded to recognize the following
     constructs:

        * Opening and closing tags of the form ‘<tag attr="value" ...>’
          and ‘</tag>’, respectively.

        * Numeric character references of the form ‘&#name;’.

        * Entity references of the form ‘&name;’.

        * SGML comments of the form ‘<!--text-->’.  Note that spaces,
          tabs, and newlines are allowed between the trailing ‘>’ and
          the immediately preceding ‘--’.

  A single exception is defined as well:

 -- Exception: sgmllib.SGMLParseError

     Exception raised by the *note SGMLParser: 19f9. class when it
     encounters an error while parsing.

     New in version 2.1.

  *note SGMLParser: 19f9. instances have the following methods:

 -- Method: SGMLParser.reset ()

     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: SGMLParser.setnomoretags ()

     Stop processing tags.  Treat all following input as literal input
     (CDATA). (This is only provided so the HTML tag ‘<PLAINTEXT>’ can
     be implemented.)

 -- Method: SGMLParser.setliteral ()

     Enter literal mode (CDATA mode).

 -- Method: SGMLParser.feed (data)

     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *note close(): 19ff. is called.

 -- Method: SGMLParser.close ()

     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call *note close(): 19ff.

 -- Method: SGMLParser.get_starttag_text ()

     Return the text of the most recently opened start tag.  This should
     not normally be needed for structured processing, but may be useful
     in dealing with HTML "as deployed" or for re-generating input with
     minimal changes (whitespace between attributes can be preserved,
     etc.).

 -- Method: SGMLParser.handle_starttag (tag, method, attributes)

     This method is called to handle start tags for which either a
     ‘start_tag()’ or ‘do_tag()’ method has been defined.  The _tag_
     argument is the name of the tag converted to lower case, and the
     _method_ argument is the bound method which should be used to
     support semantic interpretation of the start tag.  The _attributes_
     argument is a list of ‘(name, value)’ pairs containing the
     attributes found inside the tag’s ‘<>’ brackets.

     The _name_ has been translated to lower case.  Double quotes and
     backslashes in the _value_ have been interpreted, as well as known
     character references and known entity references terminated by a
     semicolon (normally, entity references can be terminated by any
     non-alphanumerical character, but this would break the very common
     case of ‘<A HREF="url?spam=1&eggs=2">’ when ‘eggs’ is a valid
     entity name).

     For instance, for the tag ‘<A HREF="http://www.cwi.nl/">’, this
     method would be called as ‘unknown_starttag('a', [('href',
     'http://www.cwi.nl/')])’.  The base implementation simply calls
     _method_ with _attributes_ as the only argument.

     New in version 2.5: Handling of entity and character references
     within attribute values.

 -- Method: SGMLParser.handle_endtag (tag, method)

     This method is called to handle endtags for which an ‘end_tag()’
     method has been defined.  The _tag_ argument is the name of the tag
     converted to lower case, and the _method_ argument is the bound
     method which should be used to support semantic interpretation of
     the end tag.  If no ‘end_tag()’ method is defined for the closing
     element, this handler is not called.  The base implementation
     simply calls _method_.

 -- Method: SGMLParser.handle_data (data)

     This method is called to process arbitrary data.  It is intended to
     be overridden by a derived class; the base class implementation
     does nothing.

 -- Method: SGMLParser.handle_charref (ref)

     This method is called to process a character reference of the form
     ‘&#ref;’.  The base implementation uses *note convert_charref():
     1a05. to convert the reference to a string.  If that method returns
     a string, it is passed to *note handle_data(): 1a03, otherwise
     ‘unknown_charref(ref)’ is called to handle the error.

     Changed in version 2.5: Use *note convert_charref(): 1a05. instead
     of hard-coding the conversion.

 -- Method: SGMLParser.convert_charref (ref)

     Convert a character reference to a string, or ‘None’.  _ref_ is the
     reference passed in as a string.  In the base implementation, _ref_
     must be a decimal number in the range 0-255.  It converts the code
     point found using the *note convert_codepoint(): 1a06. method.  If
     _ref_ is invalid or out of range, this method returns ‘None’.  This
     method is called by the default *note handle_charref(): 1a04.
     implementation and by the attribute value parser.

     New in version 2.5.

 -- Method: SGMLParser.convert_codepoint (codepoint)

     Convert a codepoint to a *note str: 1ea. value.  Encodings can be
     handled here if appropriate, though the rest of *note sgmllib: 150.
     is oblivious on this matter.

     New in version 2.5.

 -- Method: SGMLParser.handle_entityref (ref)

     This method is called to process a general entity reference of the
     form ‘&ref;’ where _ref_ is an general entity reference.  It
     converts _ref_ by passing it to *note convert_entityref(): 1a08.
     If a translation is returned, it calls the method *note
     handle_data(): 1a03. with the translation; otherwise, it calls the
     method ‘unknown_entityref(ref)’.  The default ‘entitydefs’ defines
     translations for ‘&amp;’, ‘&apos’, ‘&gt;’, ‘&lt;’, and ‘&quot;’.

     Changed in version 2.5: Use *note convert_entityref(): 1a08.
     instead of hard-coding the conversion.

 -- Method: SGMLParser.convert_entityref (ref)

     Convert a named entity reference to a *note str: 1ea. value, or
     ‘None’.  The resulting value will not be parsed.  _ref_ will be
     only the name of the entity.  The default implementation looks for
     _ref_ in the instance (or class) variable ‘entitydefs’ which should
     be a mapping from entity names to corresponding translations.  If
     no translation is available for _ref_, this method returns ‘None’.
     This method is called by the default *note handle_entityref():
     1a07. implementation and by the attribute value parser.

     New in version 2.5.

 -- Method: SGMLParser.handle_comment (comment)

     This method is called when a comment is encountered.  The _comment_
     argument is a string containing the text between the ‘<!--’ and
     ‘-->’ delimiters, but not the delimiters themselves.  For example,
     the comment ‘<!--text-->’ will cause this method to be called with
     the argument ‘'text'’.  The default method does nothing.

 -- Method: SGMLParser.handle_decl (data)

     Method called when an SGML declaration is read by the parser.  In
     practice, the ‘DOCTYPE’ declaration is the only thing observed in
     HTML, but the parser does not discriminate among different (or
     broken) declarations.  Internal subsets in a ‘DOCTYPE’ declaration
     are not supported.  The _data_ parameter will be the entire
     contents of the declaration inside the ‘<!’...‘>’ markup.  The
     default implementation does nothing.

 -- Method: SGMLParser.report_unbalanced (tag)

     This method is called when an end tag is found which does not
     correspond to any open element.

 -- Method: SGMLParser.unknown_starttag (tag, attributes)

     This method is called to process an unknown start tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_endtag (tag)

     This method is called to process an unknown end tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_charref (ref)

     This method is called to process unresolvable numeric character
     references.  Refer to *note handle_charref(): 1a04. to determine
     what is handled by default.  It is intended to be overridden by a
     derived class; the base class implementation does nothing.

 -- Method: SGMLParser.unknown_entityref (ref)

     This method is called to process an unknown entity reference.  It
     is intended to be overridden by a derived class; the base class
     implementation does nothing.

  Apart from overriding or extending the methods listed above, derived
classes may also define methods of the following form to define
processing of specific tags.  Tag names in the input stream are case
independent; the _tag_ occurring in method names must be in lower case:

 -- Method: SGMLParser.start_tag (attributes)

     This method is called to process an opening tag _tag_.  It has
     preference over ‘do_tag()’.  The _attributes_ argument has the same
     meaning as described for ‘handle_starttag()’ above.

 -- Method: SGMLParser.do_tag (attributes)

     This method is called to process an opening tag _tag_ for which no
     ‘start_tag()’ method is defined.  The _attributes_ argument has the
     same meaning as described for ‘handle_starttag()’ above.

 -- Method: SGMLParser.end_tag ()

     This method is called to process a closing tag _tag_.

  Note that the parser maintains a stack of open elements for which no
end tag has been found yet.  Only tags processed by ‘start_tag()’ are
pushed on this stack.  Definition of an ‘end_tag()’ method is optional
for these tags.  For tags processed by ‘do_tag()’ or by ‘unknown_tag()’,
no ‘end_tag()’ method must be defined; if defined, it will not be used.
If both ‘start_tag()’ and ‘do_tag()’ methods exist for a tag, the
‘start_tag()’ method takes precedence.

