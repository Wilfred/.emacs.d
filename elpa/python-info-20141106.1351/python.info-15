This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: htmllib --- A parser for HTML documents,  Next: htmlentitydefs --- Definitions of HTML general entities,  Prev: sgmllib --- Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.3 ‘htmllib’ — A parser for HTML documents
----------------------------------------------

Deprecated since version 2.6: The *note htmllib: ec. module has been
removed in Python 3.

  This module defines a class which can serve as a base for parsing text
files formatted in the HyperText Mark-up Language (HTML). The class is
not directly concerned with I/O — it must be provided with input in
string form via a method, and makes calls to methods of a "formatter"
object in order to produce output.  The *note HTMLParser: ed. class is
designed to be used as a base class for other classes in order to add
functionality, and allows most of its methods to be extended or
overridden.  In turn, this class is derived from and extends the
‘SGMLParser’ class defined in module *note sgmllib: 150.  The *note
HTMLParser: ed. implementation supports the HTML 2.0 language as
described in RFC 1866(1).  Two implementations of formatter objects are
provided in the *note formatter: d3. module; refer to the documentation
for that module for information on the formatter interface.

  The following is a summary of the interface defined by *note
sgmllib.SGMLParser: 19f9.:

   * The interface to feed data to an instance is through the ‘feed()’
     method, which takes a string argument.  This can be called with as
     little or as much text at a time as desired; ‘p.feed(a); p.feed(b)’
     has the same effect as ‘p.feed(a+b)’.  When the data contains
     complete HTML markup constructs, these are processed immediately;
     incomplete constructs are saved in a buffer.  To force processing
     of all unprocessed data, call the ‘close()’ method.

     For example, to parse the entire contents of a file, use:

          parser.feed(open('myfile.html').read())
          parser.close()

   * The interface to define semantics for HTML tags is very simple:
     derive a class and define methods called ‘start_tag()’,
     ‘end_tag()’, or ‘do_tag()’.  The parser will call these at
     appropriate moments: ‘start_tag()’ or ‘do_tag()’ is called when an
     opening tag of the form ‘<tag ...>’ is encountered; ‘end_tag()’ is
     called when a closing tag of the form ‘<tag>’ is encountered.  If
     an opening tag requires a corresponding closing tag, like ‘<H1>’
     ...  ‘</H1>’, the class should define the ‘start_tag()’ method; if
     a tag requires no closing tag, like ‘<P>’, the class should define
     the ‘do_tag()’ method.

  The module defines a parser class and an exception:

 -- Class: htmllib.HTMLParser (formatter)

     This is the basic HTML parser class.  It supports all entity names
     required by the XHTML 1.0 Recommendation
     (‘http://www.w3.org/TR/xhtml1’).  It also defines handlers for all
     HTML 2.0 and many HTML 3.0 and 3.2 elements.

 -- Exception: htmllib.HTMLParseError

     Exception raised by the *note HTMLParser: ed. class when it
     encounters an error while parsing.

     New in version 2.4.

See also
........

Module *note formatter: d3.

     Interface definition for transforming an abstract flow of
     formatting events into specific output events on writer objects.

Module *note HTMLParser: ed.

     Alternate HTML parser that offers a slightly lower-level view of
     the input, but is designed to work with XHTML, and does not
     implement some of the SGML syntax not used in "HTML as deployed"
     and which isn’t legal for XHTML.

Module *note htmlentitydefs: eb.

     Definition of replacement text for XHTML 1.0 entities.

Module *note sgmllib: 150.

     Base class for *note HTMLParser: ed.

* Menu:

* HTMLParser Objects:: 

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc1866.html


File: python.info,  Node: HTMLParser Objects,  Up: htmllib --- A parser for HTML documents

5.19.3.1 HTMLParser Objects
...........................

In addition to tag methods, the *note HTMLParser: ed. class provides
some additional methods and instance variables for use within tag
methods.

 -- Attribute: HTMLParser.formatter

     This is the formatter instance associated with the parser.

 -- Attribute: HTMLParser.nofill

     Boolean flag which should be true when whitespace should not be
     collapsed, or false when it should be.  In general, this should
     only be true when character data is to be treated as "preformatted"
     text, as within a ‘<PRE>’ element.  The default value is false.
     This affects the operation of ‘handle_data()’ and *note save_end():
     1a18.

 -- Method: HTMLParser.anchor_bgn (href, name, type)

     This method is called at the start of an anchor region.  The
     arguments correspond to the attributes of the ‘<A>’ tag with the
     same names.  The default implementation maintains a list of
     hyperlinks (defined by the ‘HREF’ attribute for ‘<A>’ tags) within
     the document.  The list of hyperlinks is available as the data
     attribute ‘anchorlist’.

 -- Method: HTMLParser.anchor_end ()

     This method is called at the end of an anchor region.  The default
     implementation adds a textual footnote marker using an index into
     the list of hyperlinks created by *note anchor_bgn(): 1a19.

 -- Method: HTMLParser.handle_image (source, alt[, ismap[, align[,
          width[, height]]]])

     This method is called to handle images.  The default implementation
     simply passes the _alt_ value to the ‘handle_data()’ method.

 -- Method: HTMLParser.save_bgn ()

     Begins saving character data in a buffer instead of sending it to
     the formatter object.  Retrieve the stored data via *note
     save_end(): 1a18.  Use of the *note save_bgn(): 1a1c. / *note
     save_end(): 1a18. pair may not be nested.

 -- Method: HTMLParser.save_end ()

     Ends buffering character data and returns all data saved since the
     preceding call to *note save_bgn(): 1a1c.  If the *note nofill:
     1a17. flag is false, whitespace is collapsed to single spaces.  A
     call to this method without a preceding call to *note save_bgn():
     1a1c. will raise a *note TypeError: 218. exception.


File: python.info,  Node: htmlentitydefs --- Definitions of HTML general entities,  Next: XML Processing Modules,  Prev: htmllib --- A parser for HTML documents,  Up: Structured Markup Processing Tools

5.19.4 ‘htmlentitydefs’ — Definitions of HTML general entities
--------------------------------------------------------------

     Note: The *note htmlentitydefs: eb. module has been renamed to
     ‘html.entities’ in Python 3.  The *note 2to3: bdb. tool will
     automatically adapt imports when converting your sources to Python
     3.

  *Source code:* Lib/htmlentitydefs.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  This module defines three dictionaries, ‘name2codepoint’,
‘codepoint2name’, and ‘entitydefs’.  ‘entitydefs’ is used by the *note
htmllib: ec. module to provide the *note entitydefs: 1a1e. attribute of
the *note HTMLParser: ed. class.  The definition provided here contains
all the entities defined by XHTML 1.0 that can be handled using simple
textual substitution in the Latin-1 character set (ISO-8859-1).

 -- Data: htmlentitydefs.entitydefs

     A dictionary mapping XHTML 1.0 entity definitions to their
     replacement text in ISO Latin-1.

 -- Data: htmlentitydefs.name2codepoint

     A dictionary that maps HTML entity names to the Unicode codepoints.

     New in version 2.3.

 -- Data: htmlentitydefs.codepoint2name

     A dictionary that maps Unicode codepoints to HTML entity names.

     New in version 2.3.

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/htmlentitydefs.py


File: python.info,  Node: XML Processing Modules,  Next: XML vulnerabilities,  Prev: htmlentitydefs --- Definitions of HTML general entities,  Up: Structured Markup Processing Tools

5.19.5 XML Processing Modules
-----------------------------

Python’s interfaces for processing XML are grouped in the ‘xml’ package.

     Warning: The XML modules are not secure against erroneous or
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see *note XML vulnerabilities: 1a24.

  It is important to note that modules in the *note xml: 1a0. package
require that there be at least one SAX-compliant XML parser available.
The Expat parser is included with Python, so the *note
xml.parsers.expat: 1a5. module will always be available.

  The documentation for the *note xml.dom: 1a1. and *note xml.sax: 1a6.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

  The XML handling submodules are:

   * *note xml.etree.ElementTree: 1a4.: the ElementTree API, a simple
     and lightweight XML processor

   * *note xml.dom: 1a1.: the DOM API definition

   * *note xml.dom.minidom: 1a2.: a minimal DOM implementation

   * *note xml.dom.pulldom: 1a3.: support for building partial DOM trees

   * *note xml.sax: 1a6.: SAX2 base classes and convenience functions

   * *note xml.parsers.expat: 1a5.: the Expat parser binding


File: python.info,  Node: XML vulnerabilities,  Next: xml etree ElementTree --- The ElementTree XML API,  Prev: XML Processing Modules,  Up: Structured Markup Processing Tools

5.19.6 XML vulnerabilities
--------------------------

The XML processing modules are not secure against maliciously
constructed data.  An attacker can abuse vulnerabilities for e.g.
denial of service attacks, to access local files, to generate network
connections to other machines, or to or circumvent firewalls.  The
attacks on XML abuse unfamiliar features like inline DTD(1) (document
type definition) with entities.

  The following table gives an overview of the known attacks and if the
various modules are vulnerable to them.

kind                          sax          etree         minidom       pulldom      xmlrpc
                                                                                    
--------------------------------------------------------------------------------------------------
                                                                                    
billion laughs                *Yes*        *Yes*         *Yes*         *Yes*        *Yes*
                                                                                    
                                                                                    
quadratic blowup              *Yes*        *Yes*         *Yes*         *Yes*        *Yes*
                                                                                    
                                                                                    
external entity expansion     *Yes*        No (1)        No (2)        *Yes*        No (3)
                                                                                    
                                                                                    
DTD retrieval                 *Yes*        No            No            *Yes*        No
                                                                                    
                                                                                    
decompression bomb            No           No            No            No           *Yes*
                                                                                    

  1. *note xml.etree.ElementTree: 1a4. doesn’t expand external entities
     and raises a ParserError when an entity occurs.

  2. *note xml.dom.minidom: 1a2. doesn’t expand external entities and
     simply returns the unexpanded entity verbatim.

  3. *note xmlrpclib: 1aa. doesn’t expand external entities and omits
     them.

billion laughs / exponential entity expansion

     The Billion Laughs(2) attack – also known as exponential entity
     expansion – uses multiple levels of nested entities.  Each entity
     refers to another entity several times, the final entity definition
     contains a small string.  Eventually the small string is expanded
     to several gigabytes.  The exponential expansion consumes lots of
     CPU time, too.

quadratic blowup entity expansion

     A quadratic blowup attack is similar to a Billion Laughs(3) attack;
     it abuses entity expansion, too.  Instead of nested entities it
     repeats one large entity with a couple of thousand chars over and
     over again.  The attack isn’t as efficient as the exponential case
     but it avoids triggering countermeasures of parsers against heavily
     nested entities.

external entity expansion

     Entity declarations can contain more than just text for
     replacement.  They can also point to external resources by public
     identifiers or system identifiers.  System identifiers are standard
     URIs or can refer to local files.  The XML parser retrieves the
     resource with e.g.  HTTP or FTP requests and embeds the content
     into the XML document.

DTD retrieval

     Some XML libraries like Python’s *note xml.dom.pulldom: 1a3.
     retrieve document type definitions from remote or local locations.
     The feature has similar implications as the external entity
     expansion issue.

decompression bomb

     The issue of decompression bombs (aka ZIP bomb(4)) apply to all XML
     libraries that can parse compressed XML stream like gzipped HTTP
     streams or LZMA-ed files.  For an attacker it can reduce the amount
     of transmitted data by three magnitudes or more.

  The documentation of defusedxml(5) on PyPI has further information
about all known attack vectors with examples and references.

* Menu:

* defused packages:: 

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Document_Type_Definition

   (2) http://en.wikipedia.org/wiki/Billion_laughs

   (3) http://en.wikipedia.org/wiki/Billion_laughs

   (4) http://en.wikipedia.org/wiki/Zip_bomb

   (5) https://pypi.python.org/pypi/defusedxml/


File: python.info,  Node: defused packages,  Up: XML vulnerabilities

5.19.6.1 defused packages
.........................

These external packages are recommended for any code that parses
untrusted XML data.

  defusedxml(1) is a pure Python package with modified subclasses of all
stdlib XML parsers that prevent any potentially malicious operation.
The package also ships with example exploits and extended documentation
on more XML exploits like xpath injection.

  defusedexpat(2) provides a modified libexpat and patched replacement
‘pyexpat’ extension module with countermeasures against entity expansion
DoS attacks.  Defusedexpat still allows a sane and configurable amount
of entity expansions.  The modifications will be merged into future
releases of Python.

  The workarounds and modifications are not included in patch releases
as they break backward compatibility.  After all inline DTD and entity
expansion are well-defined XML features.

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/defusedxml/

   (2) https://pypi.python.org/pypi/defusedexpat/


File: python.info,  Node: xml etree ElementTree --- The ElementTree XML API,  Next: xml dom --- The Document Object Model API,  Prev: XML vulnerabilities,  Up: Structured Markup Processing Tools

5.19.7 ‘xml.etree.ElementTree’ — The ElementTree XML API
--------------------------------------------------------

New in version 2.5.

  *Source code:* Lib/xml/etree/ElementTree.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  The *note Element: 2b0. type is a flexible container object, designed
to store hierarchical data structures in memory.  The type can be
described as a cross between a list and a dictionary.

     Warning: The *note xml.etree.ElementTree: 1a4. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     1a24.

  Each element has a number of properties associated with it:

   * a tag which is a string identifying what kind of data this element
     represents (the element type, in other words).

   * a number of attributes, stored in a Python dictionary.

   * a text string.

   * an optional tail string.

   * a number of child elements, stored in a Python sequence

  To create an element instance, use the *note Element: 2b0. constructor
or the *note SubElement(): 1a2a. factory function.

  The *note ElementTree: 1a2b. class can be used to wrap an element
structure, and convert it from and to XML.

  A C implementation of this API is available as
‘xml.etree.cElementTree’.

  See ‘http://effbot.org/zone/element-index.htm’ for tutorials and links
to other docs.  Fredrik Lundh’s page is also the location of the
development version of the xml.etree.ElementTree.

  Changed in version 2.7: The ElementTree API is updated to 1.3.  For
more information, see Introducing ElementTree 1.3(2).

* Menu:

* Tutorial: Tutorial<2>. 
* XPath support:: 
* Reference: Reference<2>. 

Tutorial

* XML tree and elements:: 
* Parsing XML:: 
* Finding interesting elements:: 
* Modifying an XML File:: 
* Building XML documents:: 
* Additional resources:: 

XPath support

* Example: Example<10>. 
* Supported XPath syntax:: 

Reference

* Functions: Functions<4>. 
* Element Objects:: 
* ElementTree Objects:: 
* QName Objects:: 
* TreeBuilder Objects:: 
* XMLParser Objects:: 

   ---------- Footnotes ----------

   (1) 
http://hg.python.org/cpython/file/2.7/Lib/xml/etree/ElementTree.py

   (2) http://effbot.org/zone/elementtree-13-intro.htm


File: python.info,  Node: Tutorial<2>,  Next: XPath support,  Up: xml etree ElementTree --- The ElementTree XML API

5.19.7.1 Tutorial
.................

This is a short tutorial for using *note xml.etree.ElementTree: 1a4.
(‘ET’ in short).  The goal is to demonstrate some of the building blocks
and basic concepts of the module.

* Menu:

* XML tree and elements:: 
* Parsing XML:: 
* Finding interesting elements:: 
* Modifying an XML File:: 
* Building XML documents:: 
* Additional resources:: 


File: python.info,  Node: XML tree and elements,  Next: Parsing XML,  Up: Tutorial<2>

5.19.7.2 XML tree and elements
..............................

XML is an inherently hierarchical data format, and the most natural way
to represent it is with a tree.  ‘ET’ has two classes for this purpose -
*note ElementTree: 1a2b. represents the whole XML document as a tree,
and *note Element: 2b0. represents a single node in this tree.
Interactions with the whole document (reading and writing to/from files)
are usually done on the *note ElementTree: 1a2b. level.  Interactions
with a single XML element and its sub-elements are done on the *note
Element: 2b0. level.


File: python.info,  Node: Parsing XML,  Next: Finding interesting elements,  Prev: XML tree and elements,  Up: Tutorial<2>

5.19.7.3 Parsing XML
....................

We’ll be using the following XML document as the sample data for this
section:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank>1</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank>4</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
         <country name="Panama">
             <rank>68</rank>
             <year>2011</year>
             <gdppc>13600</gdppc>
             <neighbor name="Costa Rica" direction="W"/>
             <neighbor name="Colombia" direction="E"/>
         </country>
     </data>

  We have a number of ways to import the data.  Reading the file from
disk:

     import xml.etree.ElementTree as ET
     tree = ET.parse('country_data.xml')
     root = tree.getroot()

  Reading the data from a string:

     root = ET.fromstring(country_data_as_string)

  *note fromstring(): 1a30. parses XML from a string directly into an
*note Element: 2b0, which is the root element of the parsed tree.  Other
parsing functions may create an *note ElementTree: 1a2b.  Check the
documentation to be sure.

  As an *note Element: 2b0, ‘root’ has a tag and a dictionary of
attributes:

     >>> root.tag
     'data'
     >>> root.attrib
     {}

  It also has children nodes over which we can iterate:

     >>> for child in root:
     ...   print child.tag, child.attrib
     ...
     country {'name': 'Liechtenstein'}
     country {'name': 'Singapore'}
     country {'name': 'Panama'}

  Children are nested, and we can access specific child nodes by index:

     >>> root[0][1].text
     '2008'


File: python.info,  Node: Finding interesting elements,  Next: Modifying an XML File,  Prev: Parsing XML,  Up: Tutorial<2>

5.19.7.4 Finding interesting elements
.....................................

*note Element: 2b0. has some useful methods that help iterate
recursively over all the sub-tree below it (its children, their
children, and so on).  For example, *note Element.iter(): 2b2.:

     >>> for neighbor in root.iter('neighbor'):
     ...   print neighbor.attrib
     ...
     {'name': 'Austria', 'direction': 'E'}
     {'name': 'Switzerland', 'direction': 'W'}
     {'name': 'Malaysia', 'direction': 'N'}
     {'name': 'Costa Rica', 'direction': 'W'}
     {'name': 'Colombia', 'direction': 'E'}

  *note Element.findall(): 1a32. finds only elements with a tag which
are direct children of the current element.  *note Element.find(): 1a33.
finds the _first_ child with a particular tag, and *note Element.text:
1a34. accesses the element’s text content.  *note Element.get(): 1a35.
accesses the element’s attributes:

     >>> for country in root.findall('country'):
     ...   rank = country.find('rank').text
     ...   name = country.get('name')
     ...   print name, rank
     ...
     Liechtenstein 1
     Singapore 4
     Panama 68

  More sophisticated specification of which elements to look for is
possible by using *note XPath: 1a36.


File: python.info,  Node: Modifying an XML File,  Next: Building XML documents,  Prev: Finding interesting elements,  Up: Tutorial<2>

5.19.7.5 Modifying an XML File
..............................

*note ElementTree: 1a2b. provides a simple way to build XML documents
and write them to files.  The *note ElementTree.write(): 2ae. method
serves this purpose.

  Once created, an *note Element: 2b0. object may be manipulated by
directly changing its fields (such as *note Element.text: 1a34.), adding
and modifying attributes (*note Element.set(): 1a38. method), as well as
adding new children (for example with *note Element.append(): 1a39.).

  Let’s say we want to add one to each country’s rank, and add an
‘updated’ attribute to the rank element:

     >>> for rank in root.iter('rank'):
     ...   new_rank = int(rank.text) + 1
     ...   rank.text = str(new_rank)
     ...   rank.set('updated', 'yes')
     ...
     >>> tree.write('output.xml')

  Our XML now looks like this:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank updated="yes">2</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank updated="yes">5</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
         <country name="Panama">
             <rank updated="yes">69</rank>
             <year>2011</year>
             <gdppc>13600</gdppc>
             <neighbor name="Costa Rica" direction="W"/>
             <neighbor name="Colombia" direction="E"/>
         </country>
     </data>

  We can remove elements using *note Element.remove(): 1a3a.  Let’s say
we want to remove all countries with a rank higher than 50:

     >>> for country in root.findall('country'):
     ...   rank = int(country.find('rank').text)
     ...   if rank > 50:
     ...     root.remove(country)
     ...
     >>> tree.write('output.xml')

  Our XML now looks like this:

     <?xml version="1.0"?>
     <data>
         <country name="Liechtenstein">
             <rank updated="yes">2</rank>
             <year>2008</year>
             <gdppc>141100</gdppc>
             <neighbor name="Austria" direction="E"/>
             <neighbor name="Switzerland" direction="W"/>
         </country>
         <country name="Singapore">
             <rank updated="yes">5</rank>
             <year>2011</year>
             <gdppc>59900</gdppc>
             <neighbor name="Malaysia" direction="N"/>
         </country>
     </data>


File: python.info,  Node: Building XML documents,  Next: Additional resources,  Prev: Modifying an XML File,  Up: Tutorial<2>

5.19.7.6 Building XML documents
...............................

The *note SubElement(): 1a2a. function also provides a convenient way to
create new sub-elements for a given element:

     >>> a = ET.Element('a')
     >>> b = ET.SubElement(a, 'b')
     >>> c = ET.SubElement(a, 'c')
     >>> d = ET.SubElement(c, 'd')
     >>> ET.dump(a)
     <a><b /><c><d /></c></a>


File: python.info,  Node: Additional resources,  Prev: Building XML documents,  Up: Tutorial<2>

5.19.7.7 Additional resources
.............................

See ‘http://effbot.org/zone/element-index.htm’ for tutorials and links
to other docs.


File: python.info,  Node: XPath support,  Next: Reference<2>,  Prev: Tutorial<2>,  Up: xml etree ElementTree --- The ElementTree XML API

5.19.7.8 XPath support
......................

This module provides limited support for XPath expressions(1) for
locating elements in a tree.  The goal is to support a small subset of
the abbreviated syntax; a full XPath engine is outside the scope of the
module.

* Menu:

* Example: Example<10>. 
* Supported XPath syntax:: 

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/xpath


File: python.info,  Node: Example<10>,  Next: Supported XPath syntax,  Up: XPath support

5.19.7.9 Example
................

Here’s an example that demonstrates some of the XPath capabilities of
the module.  We’ll be using the ‘countrydata’ XML document from the
*note Parsing XML: 1a2e. section:

     import xml.etree.ElementTree as ET

     root = ET.fromstring(countrydata)

     # Top-level elements
     root.findall(".")

     # All 'neighbor' grand-children of 'country' children of the top-level
     # elements
     root.findall("./country/neighbor")

     # Nodes with name='Singapore' that have a 'year' child
     root.findall(".//year/..[@name='Singapore']")

     # 'year' nodes that are children of nodes with name='Singapore'
     root.findall(".//*[@name='Singapore']/year")

     # All 'neighbor' nodes that are the second child of their parent
     root.findall(".//neighbor[2]")


File: python.info,  Node: Supported XPath syntax,  Prev: Example<10>,  Up: XPath support

5.19.7.10 Supported XPath syntax
................................

Syntax                      Meaning
                            
---------------------------------------------------------------------------------------
                            
‘tag’                       Selects all child elements with the given tag.  For
                            example, ‘spam’ selects all child elements named ‘spam’,
                            and ‘spam/egg’ selects all grandchildren named ‘egg’ in
                            all children named ‘spam’.
                            
                            
‘*’                         Selects all child elements.  For example, ‘*/egg’
                            selects all grandchildren named ‘egg’.
                            
                            
‘.’                         Selects the current node.  This is mostly useful at the
                            beginning of the path, to indicate that it’s a relative
                            path.
                            
                            
‘//’                        Selects all subelements, on all levels beneath the
                            current element.  For example, ‘.//egg’ selects all
                            ‘egg’ elements in the entire tree.
                            
                            
‘..’                        Selects the parent element.
                            
                            
‘[@attrib]’                 Selects all elements that have the given attribute.
                            
                            
‘[@attrib='value']’         Selects all elements for which the given attribute has
                            the given value.  The value cannot contain quotes.
                            
                            
‘[tag]’                     Selects all elements that have a child named ‘tag’.
                            Only immediate children are supported.
                            
                            
‘[position]’                Selects all elements that are located at the given
                            position.  The position can be either an integer (1 is
                            the first position), the expression ‘last()’ (for the
                            last position), or a position relative to the last
                            position (e.g.  ‘last()-1’).
                            

  Predicates (expressions within square brackets) must be preceded by a
tag name, an asterisk, or another predicate.  ‘position’ predicates must
be preceded by a tag name.


File: python.info,  Node: Reference<2>,  Prev: XPath support,  Up: xml etree ElementTree --- The ElementTree XML API

5.19.7.11 Reference
...................

* Menu:

* Functions: Functions<4>. 
* Element Objects:: 
* ElementTree Objects:: 
* QName Objects:: 
* TreeBuilder Objects:: 
* XMLParser Objects:: 


File: python.info,  Node: Functions<4>,  Next: Element Objects,  Up: Reference<2>

5.19.7.12 Functions
...................

 -- Function: xml.etree.ElementTree.Comment (text=None)

     Comment element factory.  This factory function creates a special
     element that will be serialized as an XML comment by the standard
     serializer.  The comment string can be either a bytestring or a
     Unicode string.  _text_ is a string containing the comment string.
     Returns an element instance representing a comment.

 -- Function: xml.etree.ElementTree.dump (elem)

     Writes an element tree or element structure to sys.stdout.  This
     function should be used for debugging only.

     The exact output format is implementation dependent.  In this
     version, it’s written as an ordinary XML file.

     _elem_ is an element tree or an individual element.

 -- Function: xml.etree.ElementTree.fromstring (text)

     Parses an XML section from a string constant.  Same as *note XML():
     1a45.  _text_ is a string containing XML data.  Returns an *note
     Element: 2b0. instance.

 -- Function: xml.etree.ElementTree.fromstringlist (sequence,
          parser=None)

     Parses an XML document from a sequence of string fragments.
     _sequence_ is a list or other sequence containing XML data
     fragments.  _parser_ is an optional parser instance.  If not given,
     the standard *note XMLParser: 2ad. parser is used.  Returns an
     *note Element: 2b0. instance.

     New in version 2.7.

 -- Function: xml.etree.ElementTree.iselement (element)

     Checks if an object appears to be a valid element object.
     _element_ is an element instance.  Returns a true value if this is
     an element object.

 -- Function: xml.etree.ElementTree.iterparse (source, events=None,
          parser=None)

     Parses an XML section into an element tree incrementally, and
     reports what’s going on to the user.  _source_ is a filename or
     file object containing XML data.  _events_ is a list of events to
     report back.  If omitted, only "end" events are reported.  _parser_
     is an optional parser instance.  If not given, the standard *note
     XMLParser: 2ad. parser is used.  _parser_ is not supported by
     ‘cElementTree’.  Returns an *note iterator: 87f. providing ‘(event,
     elem)’ pairs.

          Note: *note iterparse(): 1a48. only guarantees that it has
          seen the ">" character of a starting tag when it emits a
          "start" event, so the attributes are defined, but the contents
          of the text and tail attributes are undefined at that point.
          The same applies to the element children; they may or may not
          be present.

          If you need a fully populated element, look for "end" events
          instead.

 -- Function: xml.etree.ElementTree.parse (source, parser=None)

     Parses an XML section into an element tree.  _source_ is a filename
     or file object containing XML data.  _parser_ is an optional parser
     instance.  If not given, the standard *note XMLParser: 2ad. parser
     is used.  Returns an *note ElementTree: 1a2b. instance.

 -- Function: xml.etree.ElementTree.ProcessingInstruction (target,
          text=None)

     PI element factory.  This factory function creates a special
     element that will be serialized as an XML processing instruction.
     _target_ is a string containing the PI target.  _text_ is a string
     containing the PI contents, if given.  Returns an element instance,
     representing a processing instruction.

 -- Function: xml.etree.ElementTree.register_namespace (prefix, uri)

     Registers a namespace prefix.  The registry is global, and any
     existing mapping for either the given prefix or the namespace URI
     will be removed.  _prefix_ is a namespace prefix.  _uri_ is a
     namespace uri.  Tags and attributes in this namespace will be
     serialized with the given prefix, if at all possible.

     New in version 2.7.

 -- Function: xml.etree.ElementTree.SubElement (parent, tag, attrib={},
          **extra)

     Subelement factory.  This function creates an element instance, and
     appends it to an existing element.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  _parent_ is the parent
     element.  _tag_ is the subelement name.  _attrib_ is an optional
     dictionary, containing element attributes.  _extra_ contains
     additional attributes, given as keyword arguments.  Returns an
     element instance.

 -- Function: xml.etree.ElementTree.tostring (element,
          encoding="us-ascii", method="xml")

     Generates a string representation of an XML element, including all
     subelements.  _element_ is an *note Element: 2b0. instance.
     _encoding_ (1) is the output encoding (default is US-ASCII).
     _method_ is either ‘"xml"’, ‘"html"’ or ‘"text"’ (default is
     ‘"xml"’).  Returns an encoded string containing the XML data.

 -- Function: xml.etree.ElementTree.tostringlist (element,
          encoding="us-ascii", method="xml")

     Generates a string representation of an XML element, including all
     subelements.  _element_ is an *note Element: 2b0. instance.
     _encoding_ (2) is the output encoding (default is US-ASCII).
     _method_ is either ‘"xml"’, ‘"html"’ or ‘"text"’ (default is
     ‘"xml"’).  Returns a list of encoded strings containing the XML
     data.  It does not guarantee any specific sequence, except that
     ‘"".join(tostringlist(element)) == tostring(element)’.

     New in version 2.7.

 -- Function: xml.etree.ElementTree.XML (text, parser=None)

     Parses an XML section from a string constant.  This function can be
     used to embed "XML literals" in Python code.  _text_ is a string
     containing XML data.  _parser_ is an optional parser instance.  If
     not given, the standard *note XMLParser: 2ad. parser is used.
     Returns an *note Element: 2b0. instance.

 -- Function: xml.etree.ElementTree.XMLID (text, parser=None)

     Parses an XML section from a string constant, and also returns a
     dictionary which maps from element id:s to elements.  _text_ is a
     string containing XML data.  _parser_ is an optional parser
     instance.  If not given, the standard *note XMLParser: 2ad. parser
     is used.  Returns a tuple containing an *note Element: 2b0.
     instance and a dictionary.

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.

   (2) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.


File: python.info,  Node: Element Objects,  Next: ElementTree Objects,  Prev: Functions<4>,  Up: Reference<2>

5.19.7.13 Element Objects
.........................

 -- Class: xml.etree.ElementTree.Element (tag, attrib={}, **extra)

     Element class.  This class defines the Element interface, and
     provides a reference implementation of this interface.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  _tag_ is the element name.
     _attrib_ is an optional dictionary, containing element attributes.
     _extra_ contains additional attributes, given as keyword arguments.

      -- Attribute: tag

          A string identifying what kind of data this element represents
          (the element type, in other words).

      -- Attribute: text

          The _text_ attribute can be used to hold additional data
          associated with the element.  As the name implies this
          attribute is usually a string but may be any
          application-specific object.  If the element is created from
          an XML file the attribute will contain any text found between
          the element tags.

      -- Attribute: tail

          The _tail_ attribute can be used to hold additional data
          associated with the element.  This attribute is usually a
          string but may be any application-specific object.  If the
          element is created from an XML file the attribute will contain
          any text found after the element’s end tag and before the next
          tag.

      -- Attribute: attrib

          A dictionary containing the element’s attributes.  Note that
          while the _attrib_ value is always a real mutable Python
          dictionary, an ElementTree implementation may choose to use
          another internal representation, and create the dictionary
          only if someone asks for it.  To take advantage of such
          implementations, use the dictionary methods below whenever
          possible.

     The following dictionary-like methods work on the element
     attributes.

      -- Method: clear ()

          Resets an element.  This function removes all subelements,
          clears all attributes, and sets the text and tail attributes
          to None.

      -- Method: get (key, default=None)

          Gets the element attribute named _key_.

          Returns the attribute value, or _default_ if the attribute was
          not found.

      -- Method: items ()

          Returns the element attributes as a sequence of (name, value)
          pairs.  The attributes are returned in an arbitrary order.

      -- Method: keys ()

          Returns the elements attribute names as a list.  The names are
          returned in an arbitrary order.

      -- Method: set (key, value)

          Set the attribute _key_ on the element to _value_.

     The following methods work on the element’s children (subelements).

      -- Method: append (subelement)

          Adds the element _subelement_ to the end of this elements
          internal list of subelements.

      -- Method: extend (subelements)

          Appends _subelements_ from a sequence object with zero or more
          elements.  Raises *note AssertionError: 80c. if a subelement
          is not a valid object.

          New in version 2.7.

      -- Method: find (match)

          Finds the first subelement matching _match_.  _match_ may be a
          tag name or path.  Returns an element instance or ‘None’.

      -- Method: findall (match)

          Finds all matching subelements, by tag name or path.  Returns
          a list containing all matching elements in document order.

      -- Method: findtext (match, default=None)

          Finds text for the first subelement matching _match_.  _match_
          may be a tag name or path.  Returns the text content of the
          first matching element, or _default_ if no element was found.
          Note that if the matching element has no text content an empty
          string is returned.

      -- Method: getchildren ()

          Deprecated since version 2.7: Use ‘list(elem)’ or iteration.

      -- Method: getiterator (tag=None)

          Deprecated since version 2.7: Use method *note Element.iter():
          2b2. instead.

      -- Method: insert (index, element)

          Inserts a subelement at the given position in this element.

      -- Method: iter (tag=None)

          Creates a tree *note iterator: 87f. with the current element
          as the root.  The iterator iterates over this element and all
          elements below it, in document (depth first) order.  If _tag_
          is not ‘None’ or ‘'*'’, only elements whose tag equals _tag_
          are returned from the iterator.  If the tree structure is
          modified during iteration, the result is undefined.

          New in version 2.7.

      -- Method: iterfind (match)

          Finds all matching subelements, by tag name or path.  Returns
          an iterable yielding all matching elements in document order.

          New in version 2.7.

      -- Method: itertext ()

          Creates a text iterator.  The iterator loops over this element
          and all subelements, in document order, and returns all inner
          text.

          New in version 2.7.

      -- Method: makeelement (tag, attrib)

          Creates a new element object of the same type as this element.
          Do not call this method, use the *note SubElement(): 1a2a.
          factory function instead.

      -- Method: remove (subelement)

          Removes _subelement_ from the element.  Unlike the find*
          methods this method compares elements based on the instance
          identity, not on tag value or contents.

     *note Element: 2b0. objects also support the following sequence
     type methods for working with subelements: *note __delitem__():
     466, *note __getitem__(): 44f, *note __setitem__(): 465, *note
     __len__(): 40a.

     Caution: Elements with no subelements will test as ‘False’.  This
     behavior will change in future versions.  Use specific ‘len(elem)’
     or ‘elem is None’ test instead.

          element = root.find('foo')

          if not element:  # careful!
              print "element not found, or element has no subelements"

          if element is None:
              print "element not found"


File: python.info,  Node: ElementTree Objects,  Next: QName Objects,  Prev: Element Objects,  Up: Reference<2>

5.19.7.14 ElementTree Objects
.............................

 -- Class: xml.etree.ElementTree.ElementTree (element=None, file=None)

     ElementTree wrapper class.  This class represents an entire element
     hierarchy, and adds some extra support for serialization to and
     from standard XML.

     _element_ is the root element.  The tree is initialized with the
     contents of the XML _file_ if given.

      -- Method: _setroot (element)

          Replaces the root element for this tree.  This discards the
          current contents of the tree, and replaces it with the given
          element.  Use with care.  _element_ is an element instance.

      -- Method: find (match)

          Same as *note Element.find(): 1a33, starting at the root of
          the tree.

      -- Method: findall (match)

          Same as *note Element.findall(): 1a32, starting at the root of
          the tree.

      -- Method: findtext (match, default=None)

          Same as *note Element.findtext(): 1a56, starting at the root
          of the tree.

      -- Method: getiterator (tag=None)

          Deprecated since version 2.7: Use method *note
          ElementTree.iter(): 1a63. instead.

      -- Method: getroot ()

          Returns the root element for this tree.

      -- Method: iter (tag=None)

          Creates and returns a tree iterator for the root element.  The
          iterator loops over all elements in this tree, in section
          order.  _tag_ is the tag to look for (default is to return all
          elements)

      -- Method: iterfind (match)

          Finds all matching subelements, by tag name or path.  Same as
          getroot().iterfind(match).  Returns an iterable yielding all
          matching elements in document order.

          New in version 2.7.

      -- Method: parse (source, parser=None)

          Loads an external XML section into this element tree.
          _source_ is a file name or file object.  _parser_ is an
          optional parser instance.  If not given, the standard
          XMLParser parser is used.  Returns the section root element.

      -- Method: write (file, encoding="us-ascii", xml_declaration=None,
               default_namespace=None, method="xml")

          Writes the element tree to a file, as XML. _file_ is a file
          name, or a file object opened for writing.  _encoding_ (1) is
          the output encoding (default is US-ASCII). _xml_declaration_
          controls if an XML declaration should be added to the file.
          Use False for never, True for always, None for only if not
          US-ASCII or UTF-8 (default is None).  _default_namespace_ sets
          the default XML namespace (for "xmlns").  _method_ is either
          ‘"xml"’, ‘"html"’ or ‘"text"’ (default is ‘"xml"’).  Returns
          an encoded string.

  This is the XML file that is going to be manipulated:

     <html>
         <head>
             <title>Example page</title>
         </head>
         <body>
             <p>Moved to <a href="http://example.org/">example.org</a>
             or <a href="http://example.com/">example.com</a>.</p>
         </body>
     </html>

  Example of changing the attribute "target" of every link in first
paragraph:

     >>> from xml.etree.ElementTree import ElementTree
     >>> tree = ElementTree()
     >>> tree.parse("index.xhtml")
     <Element 'html' at 0xb77e6fac>
     >>> p = tree.find("body/p")     # Finds first occurrence of tag p in body
     >>> p
     <Element 'p' at 0xb77ec26c>
     >>> links = list(p.iter("a"))   # Returns list of all links
     >>> links
     [<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]
     >>> for i in links:             # Iterates through all found links
     ...     i.attrib["target"] = "blank"
     >>> tree.write("output.xhtml")

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.


File: python.info,  Node: QName Objects,  Next: TreeBuilder Objects,  Prev: ElementTree Objects,  Up: Reference<2>

5.19.7.15 QName Objects
.......................

 -- Class: xml.etree.ElementTree.QName (text_or_uri, tag=None)

     QName wrapper.  This can be used to wrap a QName attribute value,
     in order to get proper namespace handling on output.  _text_or_uri_
     is a string containing the QName value, in the form {uri}local, or,
     if the tag argument is given, the URI part of a QName.  If _tag_ is
     given, the first argument is interpreted as an URI, and this
     argument is interpreted as a local name.  *note QName: 1a69.
     instances are opaque.


File: python.info,  Node: TreeBuilder Objects,  Next: XMLParser Objects,  Prev: QName Objects,  Up: Reference<2>

5.19.7.16 TreeBuilder Objects
.............................

 -- Class: xml.etree.ElementTree.TreeBuilder (element_factory=None)

     Generic element structure builder.  This builder converts a
     sequence of start, data, and end method calls to a well-formed
     element structure.  You can use this class to build an element
     structure using a custom XML parser, or a parser for some other
     XML-like format.  The _element_factory_ is called to create new
     *note Element: 2b0. instances when given.

      -- Method: close ()

          Flushes the builder buffers, and returns the toplevel document
          element.  Returns an *note Element: 2b0. instance.

      -- Method: data (data)

          Adds text to the current element.  _data_ is a string.  This
          should be either a bytestring, or a Unicode string.

      -- Method: end (tag)

          Closes the current element.  _tag_ is the element name.
          Returns the closed element.

      -- Method: start (tag, attrs)

          Opens a new element.  _tag_ is the element name.  _attrs_ is a
          dictionary containing element attributes.  Returns the opened
          element.

     In addition, a custom *note TreeBuilder: 1a6c. object can provide
     the following method:

      -- Method: doctype (name, pubid, system)

          Handles a doctype declaration.  _name_ is the doctype name.
          _pubid_ is the public identifier.  _system_ is the system
          identifier.  This method does not exist on the default *note
          TreeBuilder: 1a6c. class.

          New in version 2.7.


File: python.info,  Node: XMLParser Objects,  Prev: TreeBuilder Objects,  Up: Reference<2>

5.19.7.17 XMLParser Objects
...........................

 -- Class: xml.etree.ElementTree.XMLParser (html=0, target=None,
          encoding=None)

     *note Element: 2b0. structure builder for XML source data, based on
     the expat parser.  _html_ are predefined HTML entities.  This flag
     is not supported by the current implementation.  _target_ is the
     target object.  If omitted, the builder uses an instance of the
     standard TreeBuilder class.  _encoding_ (1) is optional.  If given,
     the value overrides the encoding specified in the XML file.

      -- Method: close ()

          Finishes feeding data to the parser.  Returns an element
          structure.

      -- Method: doctype (name, pubid, system)

          Deprecated since version 2.7: Define the *note
          TreeBuilder.doctype(): 1a71. method on a custom TreeBuilder
          target.

      -- Method: feed (data)

          Feeds data to the parser.  _data_ is encoded data.

  *note XMLParser.feed(): 1a76. calls _target_’s ‘start()’ method for
each opening tag, its ‘end()’ method for each closing tag, and data is
processed by method ‘data()’.  *note XMLParser.close(): 1a74. calls
_target_’s method ‘close()’.  *note XMLParser: 2ad. can be used not only
for building a tree structure.  This is an example of counting the
maximum depth of an XML file:

     >>> from xml.etree.ElementTree import XMLParser
     >>> class MaxDepth:                     # The target object of the parser
     ...     maxDepth = 0
     ...     depth = 0
     ...     def start(self, tag, attrib):   # Called for each opening tag.
     ...         self.depth += 1
     ...         if self.depth > self.maxDepth:
     ...             self.maxDepth = self.depth
     ...     def end(self, tag):             # Called for each closing tag.
     ...         self.depth -= 1
     ...     def data(self, data):
     ...         pass            # We do not need to do anything with data.
     ...     def close(self):    # Called when all data has been parsed.
     ...         return self.maxDepth
     ...
     >>> target = MaxDepth()
     >>> parser = XMLParser(target=target)
     >>> exampleXml = """
     ... <a>
     ...   <b>
     ...   </b>
     ...   <b>
     ...     <c>
     ...       <d>
     ...       </d>
     ...     </c>
     ...   </b>
     ... </a>"""
     >>> parser.feed(exampleXml)
     >>> parser.close()
     4

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.


File: python.info,  Node: xml dom --- The Document Object Model API,  Next: xml dom minidom --- Minimal DOM implementation,  Prev: xml etree ElementTree --- The ElementTree XML API,  Up: Structured Markup Processing Tools

5.19.8 ‘xml.dom’ — The Document Object Model API
------------------------------------------------

New in version 2.0.

  The Document Object Model, or "DOM," is a cross-language API from the
World Wide Web Consortium (W3C) for accessing and modifying XML
documents.  A DOM implementation presents an XML document as a tree
structure, or allows client code to build such a structure from scratch.
It then gives access to the structure through a set of objects which
provided well-known interfaces.

  The DOM is extremely useful for random-access applications.  SAX only
allows you a view of one bit of the document at a time.  If you are
looking at one SAX element, you have no access to another.  If you are
looking at a text node, you have no access to a containing element.
When you write a SAX application, you need to keep track of your
program’s position in the document somewhere in your own code.  SAX does
not do it for you.  Also, if you need to look ahead in the XML document,
you are just out of luck.

  Some applications are simply impossible in an event driven model with
no access to a tree.  Of course you could build some sort of tree
yourself in SAX events, but the DOM allows you to avoid writing that
code.  The DOM is a standard tree representation for XML data.

  The Document Object Model is being defined by the W3C in stages, or
"levels" in their terminology.  The Python mapping of the API is
substantially based on the DOM Level 2 recommendation.

  DOM applications typically start by parsing some XML into a DOM. How
this is accomplished is not covered at all by DOM Level 1, and Level 2
provides only limited improvements: There is a ‘DOMImplementation’
object class which provides access to ‘Document’ creation methods, but
no way to access an XML reader/parser/Document builder in an
implementation-independent way.  There is also no well-defined way to
access these methods without an existing ‘Document’ object.  In Python,
each DOM implementation will provide a function *note
getDOMImplementation(): 1a79.  DOM Level 3 adds a Load/Store
specification, which defines an interface to the reader, but this is not
yet available in the Python standard library.

  Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification; this portion of the reference manual
describes the interpretation of the specification in Python.

  The specification provided by the W3C defines the DOM API for Java,
ECMAScript, and OMG IDL. The Python mapping defined here is based in
large part on the IDL version of the specification, but strict
compliance is not required (though implementations are free to support
the strict mapping from IDL). See section *note Conformance: 1a7a. for a
detailed discussion of mapping requirements.

See also
........

Document Object Model (DOM) Level 2 Specification(1)

     The W3C recommendation upon which the Python DOM API is based.

Document Object Model (DOM) Level 1 Specification(2)

     The W3C recommendation for the DOM supported by *note
     xml.dom.minidom: 1a2.

Python Language Mapping Specification(3)

     This specifies the mapping from OMG IDL to Python.

* Menu:

* Module Contents: Module Contents<3>. 
* Objects in the DOM:: 
* Conformance:: 

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/DOM-Level-2-Core/

   (2) http://www.w3.org/TR/REC-DOM-Level-1/

   (3) http://www.omg.org/spec/PYTH/1.2/PDF


File: python.info,  Node: Module Contents<3>,  Next: Objects in the DOM,  Up: xml dom --- The Document Object Model API

5.19.8.1 Module Contents
........................

The *note xml.dom: 1a1. contains the following functions:

 -- Function: xml.dom.registerDOMImplementation (name, factory)

     Register the _factory_ function with the name _name_.  The factory
     function should return an object which implements the
     ‘DOMImplementation’ interface.  The factory function can return the
     same object every time, or a new one for each call, as appropriate
     for the specific implementation (e.g.  if that implementation
     supports some customization).

 -- Function: xml.dom.getDOMImplementation ([name[, features]])

     Return a suitable DOM implementation.  The _name_ is either
     well-known, the module name of a DOM implementation, or ‘None’.  If
     it is not ‘None’, imports the corresponding module and returns a
     ‘DOMImplementation’ object if the import succeeds.  If no name is
     given, and if the environment variable ‘PYTHON_DOM’ is set, this
     variable is used to find the implementation.

     If name is not given, this examines the available implementations
     to find one with the required feature set.  If no implementation
     can be found, raise an *note ImportError: 370.  The features list
     must be a sequence of ‘(feature, version)’ pairs which are passed
     to the ‘hasFeature()’ method on available ‘DOMImplementation’
     objects.

  Some convenience constants are also provided:

 -- Data: xml.dom.EMPTY_NAMESPACE

     The value used to indicate that no namespace is associated with a
     node in the DOM. This is typically found as the ‘namespaceURI’ of a
     node, or used as the _namespaceURI_ parameter to a
     namespaces-specific method.

     New in version 2.2.

 -- Data: xml.dom.XML_NAMESPACE

     The namespace URI associated with the reserved prefix ‘xml’, as
     defined by Namespaces in XML(1) (section 4).

     New in version 2.2.

 -- Data: xml.dom.XMLNS_NAMESPACE

     The namespace URI for namespace declarations, as defined by
     Document Object Model (DOM) Level 2 Core Specification(2) (section
     1.1.8).

     New in version 2.2.

 -- Data: xml.dom.XHTML_NAMESPACE

     The URI of the XHTML namespace as defined by XHTML 1.0: The
     Extensible HyperText Markup Language(3) (section 3.1.1).

     New in version 2.2.

  In addition, *note xml.dom: 1a1. contains a base ‘Node’ class and the
DOM exception classes.  The ‘Node’ class provided by this module does
not implement any of the methods or attributes defined by the DOM
specification; concrete DOM implementations must provide those.  The
‘Node’ class provided as part of this module does provide the constants
used for the ‘nodeType’ attribute on concrete ‘Node’ objects; they are
located within the class rather than at the module level to conform with
the DOM specifications.

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/REC-xml-names/

   (2) http://www.w3.org/TR/DOM-Level-2-Core/core.html

   (3) http://www.w3.org/TR/xhtml1/


File: python.info,  Node: Objects in the DOM,  Next: Conformance,  Prev: Module Contents<3>,  Up: xml dom --- The Document Object Model API

5.19.8.2 Objects in the DOM
...........................

The definitive documentation for the DOM is the DOM specification from
the W3C.

  Note that DOM attributes may also be manipulated as nodes instead of
as simple strings.  It is fairly rare that you must do this, however, so
this usage is not yet documented.

Interface                            Section                                 Purpose
                                                                             
-------------------------------------------------------------------------------------------------------------------
                                                                             
‘DOMImplementation’                  *note DOMImplementation Objects:        Interface to the underlying
                                     1a83.                                   implementation.
                                                                             
                                                                             
‘Node’                               *note Node Objects: 1a84.               Base interface for most objects in
                                                                             a document.
                                                                             
                                                                             
‘NodeList’                           *note NodeList Objects: 1a85.           Interface for a sequence of nodes.
                                                                             
                                                                             
‘DocumentType’                       *note DocumentType Objects: 1a86.       Information about the declarations
                                                                             needed to process a document.
                                                                             
                                                                             
‘Document’                           *note Document Objects: 1a87.           Object which represents an entire
                                                                             document.
                                                                             
                                                                             
‘Element’                            *note Element Objects: 1a88.            Element nodes in the document
                                                                             hierarchy.
                                                                             
                                                                             
‘Attr’                               *note Attr Objects: 1a89.               Attribute value nodes on element
                                                                             nodes.
                                                                             
                                                                             
‘Comment’                            *note Comment Objects: 1a8a.            Representation of comments in the
                                                                             source document.
                                                                             
                                                                             
‘Text’                               *note Text and CDATASection Objects:    Nodes containing textual content
                                     1a8b.                                   from the document.
                                                                             
                                                                             
‘ProcessingInstruction’              *note ProcessingInstruction Objects:    Processing instruction
                                     1a8c.                                   representation.
                                                                             

  An additional section describes the exceptions defined for working
with the DOM in Python.

* Menu:

* DOMImplementation Objects:: 
* Node Objects:: 
* NodeList Objects:: 
* DocumentType Objects:: 
* Document Objects:: 
* Element Objects: Element Objects<2>. 
* Attr Objects:: 
* NamedNodeMap Objects:: 
* Comment Objects:: 
* Text and CDATASection Objects:: 
* ProcessingInstruction Objects:: 
* Exceptions: Exceptions<6>. 


File: python.info,  Node: DOMImplementation Objects,  Next: Node Objects,  Up: Objects in the DOM

5.19.8.3 DOMImplementation Objects
..................................

The ‘DOMImplementation’ interface provides a way for applications to
determine the availability of particular features in the DOM they are
using.  DOM Level 2 added the ability to create new ‘Document’ and
‘DocumentType’ objects using the ‘DOMImplementation’ as well.

 -- Method: DOMImplementation.hasFeature (feature, version)

     Return true if the feature identified by the pair of strings
     _feature_ and _version_ is implemented.

 -- Method: DOMImplementation.createDocument (namespaceUri,
          qualifiedName, doctype)

     Return a new ‘Document’ object (the root of the DOM), with a child
     ‘Element’ object having the given _namespaceUri_ and
     _qualifiedName_.  The _doctype_ must be a ‘DocumentType’ object
     created by *note createDocumentType(): 1a90, or ‘None’.  In the
     Python DOM API, the first two arguments can also be ‘None’ in order
     to indicate that no ‘Element’ child is to be created.

 -- Method: DOMImplementation.createDocumentType (qualifiedName,
          publicId, systemId)

     Return a new ‘DocumentType’ object that encapsulates the given
     _qualifiedName_, _publicId_, and _systemId_ strings, representing
     the information contained in an XML document type declaration.


File: python.info,  Node: Node Objects,  Next: NodeList Objects,  Prev: DOMImplementation Objects,  Up: Objects in the DOM

5.19.8.4 Node Objects
.....................

All of the components of an XML document are subclasses of ‘Node’.

 -- Attribute: Node.nodeType

     An integer representing the node type.  Symbolic constants for the
     types are on the ‘Node’ object: ‘ELEMENT_NODE’, ‘ATTRIBUTE_NODE’,
     ‘TEXT_NODE’, ‘CDATA_SECTION_NODE’, ‘ENTITY_NODE’,
     ‘PROCESSING_INSTRUCTION_NODE’, ‘COMMENT_NODE’, ‘DOCUMENT_NODE’,
     ‘DOCUMENT_TYPE_NODE’, ‘NOTATION_NODE’.  This is a read-only
     attribute.

 -- Attribute: Node.parentNode

     The parent of the current node, or ‘None’ for the document node.
     The value is always a ‘Node’ object or ‘None’.  For ‘Element’
     nodes, this will be the parent element, except for the root
     element, in which case it will be the ‘Document’ object.  For
     ‘Attr’ nodes, this is always ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.attributes

     A ‘NamedNodeMap’ of attribute objects.  Only elements have actual
     values for this; others provide ‘None’ for this attribute.  This is
     a read-only attribute.

 -- Attribute: Node.previousSibling

     The node that immediately precedes this one with the same parent.
     For instance the element with an end-tag that comes just before the
     _self_ element’s start-tag.  Of course, XML documents are made up
     of more than just elements so the previous sibling could be text, a
     comment, or something else.  If this node is the first child of the
     parent, this attribute will be ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.nextSibling

     The node that immediately follows this one with the same parent.
     See also *note previousSibling: 1a95.  If this is the last child of
     the parent, this attribute will be ‘None’.  This is a read-only
     attribute.

 -- Attribute: Node.childNodes

     A list of nodes contained within this node.  This is a read-only
     attribute.

 -- Attribute: Node.firstChild

     The first child of the node, if there are any, or ‘None’.  This is
     a read-only attribute.

 -- Attribute: Node.lastChild

     The last child of the node, if there are any, or ‘None’.  This is a
     read-only attribute.

 -- Attribute: Node.localName

     The part of the ‘tagName’ following the colon if there is one, else
     the entire ‘tagName’.  The value is a string.

 -- Attribute: Node.prefix

     The part of the ‘tagName’ preceding the colon if there is one, else
     the empty string.  The value is a string, or ‘None’

 -- Attribute: Node.namespaceURI

     The namespace associated with the element name.  This will be a
     string or ‘None’.  This is a read-only attribute.

 -- Attribute: Node.nodeName

     This has a different meaning for each node type; see the DOM
     specification for details.  You can always get the information you
     would get here from another property such as the ‘tagName’ property
     for elements or the ‘name’ property for attributes.  For all node
     types, the value of this attribute will be either a string or
     ‘None’.  This is a read-only attribute.

 -- Attribute: Node.nodeValue

     This has a different meaning for each node type; see the DOM
     specification for details.  The situation is similar to that with
     *note nodeName: 1a9d.  The value is a string or ‘None’.

 -- Method: Node.hasAttributes ()

     Returns true if the node has any attributes.

 -- Method: Node.hasChildNodes ()

     Returns true if the node has any child nodes.

 -- Method: Node.isSameNode (other)

     Returns true if _other_ refers to the same node as this node.  This
     is especially useful for DOM implementations which use any sort of
     proxy architecture (because more than one object can refer to the
     same node).

          Note: This is based on a proposed DOM Level 3 API which is
          still in the "working draft" stage, but this particular
          interface appears uncontroversial.  Changes from the W3C will
          not necessarily affect this method in the Python DOM interface
          (though any new W3C API for this would also be supported).

 -- Method: Node.appendChild (newChild)

     Add a new child node to this node at the end of the list of
     children, returning _newChild_.  If the node was already in the
     tree, it is removed first.

 -- Method: Node.insertBefore (newChild, refChild)

     Insert a new child node before an existing child.  It must be the
     case that _refChild_ is a child of this node; if not, *note
     ValueError: 236. is raised.  _newChild_ is returned.  If _refChild_
     is ‘None’, it inserts _newChild_ at the end of the children’s list.

 -- Method: Node.removeChild (oldChild)

     Remove a child node.  _oldChild_ must be a child of this node; if
     not, *note ValueError: 236. is raised.  _oldChild_ is returned on
     success.  If _oldChild_ will not be used further, its ‘unlink()’
     method should be called.

 -- Method: Node.replaceChild (newChild, oldChild)

     Replace an existing node with a new node.  It must be the case that
     _oldChild_ is a child of this node; if not, *note ValueError: 236.
     is raised.

 -- Method: Node.normalize ()

     Join adjacent text nodes so that all stretches of text are stored
     as single ‘Text’ instances.  This simplifies processing text from a
     DOM tree for many applications.

     New in version 2.1.

 -- Method: Node.cloneNode (deep)

     Clone this node.  Setting _deep_ means to clone all child nodes as
     well.  This returns the clone.


File: python.info,  Node: NodeList Objects,  Next: DocumentType Objects,  Prev: Node Objects,  Up: Objects in the DOM

5.19.8.5 NodeList Objects
.........................

A ‘NodeList’ represents a sequence of nodes.  These objects are used in
two ways in the DOM Core recommendation: the ‘Element’ objects provides
one as its list of child nodes, and the ‘getElementsByTagName()’ and
‘getElementsByTagNameNS()’ methods of ‘Node’ return objects with this
interface to represent query results.

  The DOM Level 2 recommendation defines one method and one attribute
for these objects:

 -- Method: NodeList.item (i)

     Return the _i_’th item from the sequence, if there is one, or
     ‘None’.  The index _i_ is not allowed to be less then zero or
     greater than or equal to the length of the sequence.

 -- Attribute: NodeList.length

     The number of nodes in the sequence.

  In addition, the Python DOM interface requires that some additional
support is provided to allow ‘NodeList’ objects to be used as Python
sequences.  All ‘NodeList’ implementations must include support for
*note __len__(): 40a. and *note __getitem__(): 44f.; this allows
iteration over the ‘NodeList’ in *note for: 2f0. statements and proper
support for the *note len(): 520. built-in function.

  If a DOM implementation supports modification of the document, the
‘NodeList’ implementation must also support the *note __setitem__():
465. and *note __delitem__(): 466. methods.


File: python.info,  Node: DocumentType Objects,  Next: Document Objects,  Prev: NodeList Objects,  Up: Objects in the DOM

5.19.8.6 DocumentType Objects
.............................

Information about the notations and entities declared by a document
(including the external subset if the parser uses it and can provide the
information) is available from a ‘DocumentType’ object.  The
‘DocumentType’ for a document is available from the ‘Document’ object’s
‘doctype’ attribute; if there is no ‘DOCTYPE’ declaration for the
document, the document’s ‘doctype’ attribute will be set to ‘None’
instead of an instance of this interface.

  ‘DocumentType’ is a specialization of ‘Node’, and adds the following
attributes:

 -- Attribute: DocumentType.publicId

     The public identifier for the external subset of the document type
     definition.  This will be a string or ‘None’.

 -- Attribute: DocumentType.systemId

     The system identifier for the external subset of the document type
     definition.  This will be a URI as a string, or ‘None’.

 -- Attribute: DocumentType.internalSubset

     A string giving the complete internal subset from the document.
     This does not include the brackets which enclose the subset.  If
     the document has no internal subset, this should be ‘None’.

 -- Attribute: DocumentType.name

     The name of the root element as given in the ‘DOCTYPE’ declaration,
     if present.

 -- Attribute: DocumentType.entities

     This is a ‘NamedNodeMap’ giving the definitions of external
     entities.  For entity names defined more than once, only the first
     definition is provided (others are ignored as required by the XML
     recommendation).  This may be ‘None’ if the information is not
     provided by the parser, or if no entities are defined.

 -- Attribute: DocumentType.notations

     This is a ‘NamedNodeMap’ giving the definitions of notations.  For
     notation names defined more than once, only the first definition is
     provided (others are ignored as required by the XML
     recommendation).  This may be ‘None’ if the information is not
     provided by the parser, or if no notations are defined.


File: python.info,  Node: Document Objects,  Next: Element Objects<2>,  Prev: DocumentType Objects,  Up: Objects in the DOM

5.19.8.7 Document Objects
.........................

A ‘Document’ represents an entire XML document, including its
constituent elements, attributes, processing instructions, comments etc.
Remember that it inherits properties from ‘Node’.

 -- Attribute: Document.documentElement

     The one and only root element of the document.

 -- Method: Document.createElement (tagName)

     Create and return a new element node.  The element is not inserted
     into the document when it is created.  You need to explicitly
     insert it with one of the other methods such as ‘insertBefore()’ or
     ‘appendChild()’.

 -- Method: Document.createElementNS (namespaceURI, tagName)

     Create and return a new element with a namespace.  The _tagName_
     may have a prefix.  The element is not inserted into the document
     when it is created.  You need to explicitly insert it with one of
     the other methods such as ‘insertBefore()’ or ‘appendChild()’.

 -- Method: Document.createTextNode (data)

     Create and return a text node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createComment (data)

     Create and return a comment node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createProcessingInstruction (target, data)

     Create and return a processing instruction node containing the
     _target_ and _data_ passed as parameters.  As with the other
     creation methods, this one does not insert the node into the tree.

 -- Method: Document.createAttribute (name)

     Create and return an attribute node.  This method does not
     associate the attribute node with any particular element.  You must
     use ‘setAttributeNode()’ on the appropriate ‘Element’ object to use
     the newly created attribute instance.

 -- Method: Document.createAttributeNS (namespaceURI, qualifiedName)

     Create and return an attribute node with a namespace.  The
     _tagName_ may have a prefix.  This method does not associate the
     attribute node with any particular element.  You must use
     ‘setAttributeNode()’ on the appropriate ‘Element’ object to use the
     newly created attribute instance.

 -- Method: Document.getElementsByTagName (tagName)

     Search for all descendants (direct children, children’s children,
     etc.)  with a particular element type name.

 -- Method: Document.getElementsByTagNameNS (namespaceURI, localName)

     Search for all descendants (direct children, children’s children,
     etc.)  with a particular namespace URI and localname.  The
     localname is the part of the namespace after the prefix.


File: python.info,  Node: Element Objects<2>,  Next: Attr Objects,  Prev: Document Objects,  Up: Objects in the DOM

5.19.8.8 Element Objects
........................

‘Element’ is a subclass of ‘Node’, so inherits all the attributes of
that class.

 -- Attribute: Element.tagName

     The element type name.  In a namespace-using document it may have
     colons in it.  The value is a string.

 -- Method: Element.getElementsByTagName (tagName)

     Same as equivalent method in the ‘Document’ class.

 -- Method: Element.getElementsByTagNameNS (namespaceURI, localName)

     Same as equivalent method in the ‘Document’ class.

 -- Method: Element.hasAttribute (name)

     Returns true if the element has an attribute named by _name_.

 -- Method: Element.hasAttributeNS (namespaceURI, localName)

     Returns true if the element has an attribute named by
     _namespaceURI_ and _localName_.

 -- Method: Element.getAttribute (name)

     Return the value of the attribute named by _name_ as a string.  If
     no such attribute exists, an empty string is returned, as if the
     attribute had no value.

 -- Method: Element.getAttributeNode (attrname)

     Return the ‘Attr’ node for the attribute named by _attrname_.

 -- Method: Element.getAttributeNS (namespaceURI, localName)

     Return the value of the attribute named by _namespaceURI_ and
     _localName_ as a string.  If no such attribute exists, an empty
     string is returned, as if the attribute had no value.

 -- Method: Element.getAttributeNodeNS (namespaceURI, localName)

     Return an attribute value as a node, given a _namespaceURI_ and
     _localName_.

 -- Method: Element.removeAttribute (name)

     Remove an attribute by name.  If there is no matching attribute, a
     *note NotFoundErr: 1ac8. is raised.

 -- Method: Element.removeAttributeNode (oldAttr)

     Remove and return _oldAttr_ from the attribute list, if present.
     If _oldAttr_ is not present, *note NotFoundErr: 1ac8. is raised.

 -- Method: Element.removeAttributeNS (namespaceURI, localName)

     Remove an attribute by name.  Note that it uses a localName, not a
     qname.  No exception is raised if there is no matching attribute.

 -- Method: Element.setAttribute (name, value)

     Set an attribute value from a string.

 -- Method: Element.setAttributeNode (newAttr)

     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the ‘name’ attribute matches.  If a
     replacement occurs, the old attribute node will be returned.  If
     _newAttr_ is already in use, *note InuseAttributeErr: 1acd. will be
     raised.

 -- Method: Element.setAttributeNodeNS (newAttr)

     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the ‘namespaceURI’ and ‘localName’
     attributes match.  If a replacement occurs, the old attribute node
     will be returned.  If _newAttr_ is already in use, *note
     InuseAttributeErr: 1acd. will be raised.

 -- Method: Element.setAttributeNS (namespaceURI, qname, value)

     Set an attribute value from a string, given a _namespaceURI_ and a
     _qname_.  Note that a qname is the whole attribute name.  This is
     different than above.


File: python.info,  Node: Attr Objects,  Next: NamedNodeMap Objects,  Prev: Element Objects<2>,  Up: Objects in the DOM

5.19.8.9 Attr Objects
.....................

‘Attr’ inherits from ‘Node’, so inherits all its attributes.

 -- Attribute: Attr.name

     The attribute name.  In a namespace-using document it may include a
     colon.

 -- Attribute: Attr.localName

     The part of the name following the colon if there is one, else the
     entire name.  This is a read-only attribute.

 -- Attribute: Attr.prefix

     The part of the name preceding the colon if there is one, else the
     empty string.

 -- Attribute: Attr.value

     The text value of the attribute.  This is a synonym for the
     ‘nodeValue’ attribute.


File: python.info,  Node: NamedNodeMap Objects,  Next: Comment Objects,  Prev: Attr Objects,  Up: Objects in the DOM

5.19.8.10 NamedNodeMap Objects
..............................

‘NamedNodeMap’ does _not_ inherit from ‘Node’.

 -- Attribute: NamedNodeMap.length

     The length of the attribute list.

 -- Method: NamedNodeMap.item (index)

     Return an attribute with a particular index.  The order you get the
     attributes in is arbitrary but will be consistent for the life of a
     DOM. Each item is an attribute node.  Get its value with the
     ‘value’ attribute.

  There are also experimental methods that give this class more mapping
behavior.  You can use them or you can use the standardized
‘getAttribute*()’ family of methods on the ‘Element’ objects.


File: python.info,  Node: Comment Objects,  Next: Text and CDATASection Objects,  Prev: NamedNodeMap Objects,  Up: Objects in the DOM

5.19.8.11 Comment Objects
.........................

‘Comment’ represents a comment in the XML document.  It is a subclass of
‘Node’, but cannot have child nodes.

 -- Attribute: Comment.data

     The content of the comment as a string.  The attribute contains all
     characters between the leading ‘<!-’‘-’ and trailing ‘-’‘->’, but
     does not include them.


File: python.info,  Node: Text and CDATASection Objects,  Next: ProcessingInstruction Objects,  Prev: Comment Objects,  Up: Objects in the DOM

5.19.8.12 Text and CDATASection Objects
.......................................

The ‘Text’ interface represents text in the XML document.  If the parser
and DOM implementation support the DOM’s XML extension, portions of the
text enclosed in CDATA marked sections are stored in ‘CDATASection’
objects.  These two interfaces are identical, but provide different
values for the ‘nodeType’ attribute.

  These interfaces extend the ‘Node’ interface.  They cannot have child
nodes.

 -- Attribute: Text.data

     The content of the text node as a string.

     Note: The use of a ‘CDATASection’ node does not indicate that the
     node represents a complete CDATA marked section, only that the
     content of the node was part of a CDATA section.  A single CDATA
     section may be represented by more than one node in the document
     tree.  There is no way to determine whether two adjacent
     ‘CDATASection’ nodes represent different CDATA marked sections.


File: python.info,  Node: ProcessingInstruction Objects,  Next: Exceptions<6>,  Prev: Text and CDATASection Objects,  Up: Objects in the DOM

5.19.8.13 ProcessingInstruction Objects
.......................................

Represents a processing instruction in the XML document; this inherits
from the ‘Node’ interface and cannot have child nodes.

 -- Attribute: ProcessingInstruction.target

     The content of the processing instruction up to the first
     whitespace character.  This is a read-only attribute.

 -- Attribute: ProcessingInstruction.data

     The content of the processing instruction following the first
     whitespace character.


File: python.info,  Node: Exceptions<6>,  Prev: ProcessingInstruction Objects,  Up: Objects in the DOM

5.19.8.14 Exceptions
....................

New in version 2.1.

  The DOM Level 2 recommendation defines a single exception, *note
DOMException: 1ae2, and a number of constants that allow applications to
determine what sort of error occurred.  *note DOMException: 1ae2.
instances carry a *note code: 62. attribute that provides the
appropriate value for the specific exception.

  The Python DOM interface provides the constants, but also expands the
set of exceptions so that a specific exception exists for each of the
exception codes defined by the DOM. The implementations must raise the
appropriate specific exception, each of which carries the appropriate
value for the *note code: 62. attribute.

 -- Exception: xml.dom.DOMException

     Base exception class used for all specific DOM exceptions.  This
     exception class cannot be directly instantiated.

 -- Exception: xml.dom.DomstringSizeErr

     Raised when a specified range of text does not fit into a string.
     This is not known to be used in the Python DOM implementations, but
     may be received from DOM implementations not written in Python.

 -- Exception: xml.dom.HierarchyRequestErr

     Raised when an attempt is made to insert a node where the node type
     is not allowed.

 -- Exception: xml.dom.IndexSizeErr

     Raised when an index or size parameter to a method is negative or
     exceeds the allowed values.

 -- Exception: xml.dom.InuseAttributeErr

     Raised when an attempt is made to insert an ‘Attr’ node that is
     already present elsewhere in the document.

 -- Exception: xml.dom.InvalidAccessErr

     Raised if a parameter or an operation is not supported on the
     underlying object.

 -- Exception: xml.dom.InvalidCharacterErr

     This exception is raised when a string parameter contains a
     character that is not permitted in the context it’s being used in
     by the XML 1.0 recommendation.  For example, attempting to create
     an ‘Element’ node with a space in the element type name will cause
     this error to be raised.

 -- Exception: xml.dom.InvalidModificationErr

     Raised when an attempt is made to modify the type of a node.

 -- Exception: xml.dom.InvalidStateErr

     Raised when an attempt is made to use an object that is not defined
     or is no longer usable.

 -- Exception: xml.dom.NamespaceErr

     If an attempt is made to change any object in a way that is not
     permitted with regard to the Namespaces in XML(1) recommendation,
     this exception is raised.

 -- Exception: xml.dom.NotFoundErr

     Exception when a node does not exist in the referenced context.
     For example, ‘NamedNodeMap.removeNamedItem()’ will raise this if
     the node passed in does not exist in the map.

 -- Exception: xml.dom.NotSupportedErr

     Raised when the implementation does not support the requested type
     of object or operation.

 -- Exception: xml.dom.NoDataAllowedErr

     This is raised if data is specified for a node which does not
     support data.

 -- Exception: xml.dom.NoModificationAllowedErr

     Raised on attempts to modify an object where modifications are not
     allowed (such as for read-only nodes).

 -- Exception: xml.dom.SyntaxErr

     Raised when an invalid or illegal string is specified.

 -- Exception: xml.dom.WrongDocumentErr

     Raised when a node is inserted in a different document than it
     currently belongs to, and the implementation does not support
     migrating the node from one document to the other.

  The exception codes defined in the DOM recommendation map to the
exceptions described above according to this table:

Constant                                   Exception
                                           
---------------------------------------------------------------------------------
                                           
‘DOMSTRING_SIZE_ERR’                       *note DomstringSizeErr: 1ae3.
                                           
                                           
‘HIERARCHY_REQUEST_ERR’                    *note HierarchyRequestErr: 1ae4.
                                           
                                           
‘INDEX_SIZE_ERR’                           *note IndexSizeErr: 1ae5.
                                           
                                           
‘INUSE_ATTRIBUTE_ERR’                      *note InuseAttributeErr: 1acd.
                                           
                                           
‘INVALID_ACCESS_ERR’                       *note InvalidAccessErr: 1ae6.
                                           
                                           
‘INVALID_CHARACTER_ERR’                    *note InvalidCharacterErr: 1ae7.
                                           
                                           
‘INVALID_MODIFICATION_ERR’                 *note InvalidModificationErr: 1ae8.
                                           
                                           
‘INVALID_STATE_ERR’                        *note InvalidStateErr: 1ae9.
                                           
                                           
‘NAMESPACE_ERR’                            *note NamespaceErr: 1aea.
                                           
                                           
‘NOT_FOUND_ERR’                            *note NotFoundErr: 1ac8.
                                           
                                           
‘NOT_SUPPORTED_ERR’                        *note NotSupportedErr: 1aeb.
                                           
                                           
‘NO_DATA_ALLOWED_ERR’                      *note NoDataAllowedErr: 1aec.
                                           
                                           
‘NO_MODIFICATION_ALLOWED_ERR’              *note NoModificationAllowedErr:
                                           1aed.
                                           
                                           
‘SYNTAX_ERR’                               *note SyntaxErr: 1aee.
                                           
                                           
‘WRONG_DOCUMENT_ERR’                       *note WrongDocumentErr: 1aef.
                                           

   ---------- Footnotes ----------

   (1) http://www.w3.org/TR/REC-xml-names/


File: python.info,  Node: Conformance,  Prev: Objects in the DOM,  Up: xml dom --- The Document Object Model API

5.19.8.15 Conformance
.....................

This section describes the conformance requirements and relationships
between the Python DOM API, the W3C DOM recommendations, and the OMG IDL
mapping for Python.

* Menu:

* Type Mapping:: 
* Accessor Methods:: 


File: python.info,  Node: Type Mapping,  Next: Accessor Methods,  Up: Conformance

5.19.8.16 Type Mapping
......................

The primitive IDL types used in the DOM specification are mapped to
Python types according to the following table.

IDL Type               Python Type
                       
-----------------------------------------------------------------------
                       
‘boolean’              ‘IntegerType’ (with a value of ‘0’ or ‘1’)
                       
                       
‘int’                  ‘IntegerType’
                       
                       
‘long int’             ‘IntegerType’
                       
                       
‘unsigned int’         ‘IntegerType’
                       

  Additionally, the ‘DOMString’ defined in the recommendation is mapped
to a Python string or Unicode string.  Applications should be able to
handle Unicode whenever a string is returned from the DOM.

  The IDL ‘null’ value is mapped to ‘None’, which may be accepted or
provided by the implementation whenever ‘null’ is allowed by the API.


File: python.info,  Node: Accessor Methods,  Prev: Type Mapping,  Up: Conformance

5.19.8.17 Accessor Methods
..........................

The mapping from OMG IDL to Python defines accessor functions for IDL
‘attribute’ declarations in much the way the Java mapping does.  Mapping
the IDL declarations

     readonly attribute string someValue;
              attribute string anotherValue;

  yields three accessor functions: a "get" method for ‘someValue’
(‘_get_someValue()’), and "get" and "set" methods for ‘anotherValue’
(‘_get_anotherValue()’ and ‘_set_anotherValue()’).  The mapping, in
particular, does not require that the IDL attributes are accessible as
normal Python attributes: ‘object.someValue’ is _not_ required to work,
and may raise an *note AttributeError: 1f8.

  The Python DOM API, however, _does_ require that normal attribute
access work.  This means that the typical surrogates generated by Python
IDL compilers are not likely to work, and wrapper objects may be needed
on the client if the DOM objects are accessed via CORBA. While this does
require some additional consideration for CORBA DOM clients, the
implementers with experience using DOM over CORBA from Python do not
consider this a problem.  Attributes that are declared ‘readonly’ may
not restrict write access in all DOM implementations.

  In the Python DOM API, accessor functions are not required.  If
provided, they should take the form defined by the Python IDL mapping,
but these methods are considered unnecessary since the attributes are
accessible directly from Python.  "Set" accessors should never be
provided for ‘readonly’ attributes.

  The IDL definitions do not fully embody the requirements of the W3C
DOM API, such as the notion of certain objects, such as the return value
of ‘getElementsByTagName()’, being "live".  The Python DOM API does not
require implementations to enforce such requirements.


File: python.info,  Node: xml dom minidom --- Minimal DOM implementation,  Next: xml dom pulldom --- Support for building partial DOM trees,  Prev: xml dom --- The Document Object Model API,  Up: Structured Markup Processing Tools

5.19.9 ‘xml.dom.minidom’ — Minimal DOM implementation
-----------------------------------------------------

New in version 2.0.

  *Source code:* Lib/xml/dom/minidom.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  *note xml.dom.minidom: 1a2. is a minimal implementation of the
Document Object Model interface, with an API similar to that in other
languages.  It is intended to be simpler than the full DOM and also
significantly smaller.  Users who are not already proficient with the
DOM should consider using the *note xml.etree.ElementTree: 1a4. module
for their XML processing instead

     Warning: The *note xml.dom.minidom: 1a2. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     1a24.

  DOM applications typically start by parsing some XML into a DOM. With
*note xml.dom.minidom: 1a2, this is done through the parse functions:

     from xml.dom.minidom import parse, parseString

     dom1 = parse('c:\\temp\\mydata.xml') # parse an XML file by name

     datasource = open('c:\\temp\\mydata.xml')
     dom2 = parse(datasource)   # parse an open file

     dom3 = parseString('<myxml>Some data<empty/> some more data</myxml>')

  The *note parse(): 1af7. function can take either a filename or an
open file object.

 -- Function: xml.dom.minidom.parse (filename_or_file[, parser[,
          bufsize]])

     Return a ‘Document’ from the given input.  _filename_or_file_ may
     be either a file name, or a file-like object.  _parser_, if given,
     must be a SAX2 parser object.  This function will change the
     document handler of the parser and activate namespace support;
     other parser configuration (like setting an entity resolver) must
     have been done in advance.

  If you have XML in a string, you can use the *note parseString():
1af8. function instead:

 -- Function: xml.dom.minidom.parseString (string[, parser])

     Return a ‘Document’ that represents the _string_.  This method
     creates a *note StringIO: 2dd. object for the string and passes
     that on to *note parse(): 1af7.

  Both functions return a ‘Document’ object representing the content of
the document.

  What the *note parse(): 1af7. and *note parseString(): 1af8. functions
do is connect an XML parser with a "DOM builder" that can accept parse
events from any SAX parser and convert them into a DOM tree.  The name
of the functions are perhaps misleading, but are easy to grasp when
learning the interfaces.  The parsing of the document will be completed
before these functions return; it’s simply that these functions do not
provide a parser implementation themselves.

  You can also create a ‘Document’ by calling a method on a "DOM
Implementation" object.  You can get this object either by calling the
‘getDOMImplementation()’ function in the *note xml.dom: 1a1. package or
the *note xml.dom.minidom: 1a2. module.  Using the implementation from
the *note xml.dom.minidom: 1a2. module will always return a ‘Document’
instance from the minidom implementation, while the version from *note
xml.dom: 1a1. may provide an alternate implementation (this is likely if
you have the PyXML package(2) installed).  Once you have a ‘Document’,
you can add child nodes to it to populate the DOM:

     from xml.dom.minidom import getDOMImplementation

     impl = getDOMImplementation()

     newdoc = impl.createDocument(None, "some_tag", None)
     top_element = newdoc.documentElement
     text = newdoc.createTextNode('Some textual content.')
     top_element.appendChild(text)

  Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification.  The main property of the document
object is the ‘documentElement’ property.  It gives you the main element
in the XML document: the one that holds all others.  Here is an example
program:

     dom3 = parseString("<myxml>Some data</myxml>")
     assert dom3.documentElement.tagName == "myxml"

  When you are finished with a DOM tree, you may optionally call the
‘unlink()’ method to encourage early cleanup of the now-unneeded
objects.  ‘unlink()’ is a *note xml.dom.minidom: 1a2.-specific extension
to the DOM API that renders the node and its descendants are essentially
useless.  Otherwise, Python’s garbage collector will eventually take
care of the objects in the tree.

See also
........

Document Object Model (DOM) Level 1 Specification(3)

     The W3C recommendation for the DOM supported by *note
     xml.dom.minidom: 1a2.

* Menu:

* DOM Objects:: 
* DOM Example:: 
* minidom and the DOM standard:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/xml/dom/minidom.py

   (2) http://pyxml.sourceforge.net/

   (3) http://www.w3.org/TR/REC-DOM-Level-1/


File: python.info,  Node: DOM Objects,  Next: DOM Example,  Up: xml dom minidom --- Minimal DOM implementation

5.19.9.1 DOM Objects
....................

The definition of the DOM API for Python is given as part of the *note
xml.dom: 1a1. module documentation.  This section lists the differences
between the API and *note xml.dom.minidom: 1a2.

 -- Method: Node.unlink ()

     Break internal references within the DOM so that it will be garbage
     collected on versions of Python without cyclic GC. Even when cyclic
     GC is available, using this can make large amounts of memory
     available sooner, so calling this on DOM objects as soon as they
     are no longer needed is good practice.  This only needs to be
     called on the ‘Document’ object, but may be called on child nodes
     to discard children of that node.

 -- Method: Node.writexml (writer, indent="", addindent="", newl="")

     Write XML to the writer object.  The writer should have a ‘write()’
     method which matches that of the file object interface.  The
     _indent_ parameter is the indentation of the current node.  The
     _addindent_ parameter is the incremental indentation to use for
     subnodes of the current one.  The _newl_ parameter specifies the
     string to use to terminate newlines.

     For the ‘Document’ node, an additional keyword argument _encoding_
     can be used to specify the encoding field of the XML header.

     Changed in version 2.1: The optional keyword parameters _indent_,
     _addindent_, and _newl_ were added to support pretty output.

     Changed in version 2.3: For the ‘Document’ node, an additional
     keyword argument _encoding_ can be used to specify the encoding
     field of the XML header.

 -- Method: Node.toxml ([encoding])

     Return the XML that the DOM represents as a string.

     With no argument, the XML header does not specify an encoding, and
     the result is Unicode string if the default encoding cannot
     represent all characters in the document.  Encoding this string in
     an encoding other than UTF-8 is likely incorrect, since UTF-8 is
     the default encoding of XML.

     With an explicit _encoding_ (1) argument, the result is a byte
     string in the specified encoding.  It is recommended that this
     argument is always specified.  To avoid *note UnicodeError: 433.
     exceptions in case of unrepresentable text data, the encoding
     argument should be specified as "utf-8".

     Changed in version 2.3: the _encoding_ argument was introduced; see
     *note writexml(): 1afc.

 -- Method: Node.toprettyxml ([indent=""[, newl=""[, encoding=""]]])

     Return a pretty-printed version of the document.  _indent_
     specifies the indentation string and defaults to a tabulator;
     _newl_ specifies the string emitted at the end of each line and
     defaults to ‘\n’.

     New in version 2.1.

     Changed in version 2.3: the encoding argument was introduced; see
     *note writexml(): 1afc.

  The following standard DOM methods have special considerations with
*note xml.dom.minidom: 1a2.:

 -- Method: Node.cloneNode (deep)

     Although this method was present in the version of *note
     xml.dom.minidom: 1a2. packaged with Python 2.0, it was seriously
     broken.  This has been corrected for subsequent releases.

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.


File: python.info,  Node: DOM Example,  Next: minidom and the DOM standard,  Prev: DOM Objects,  Up: xml dom minidom --- Minimal DOM implementation

5.19.9.2 DOM Example
....................

This example program is a fairly realistic example of a simple program.
In this particular case, we do not take much advantage of the
flexibility of the DOM.

     import xml.dom.minidom

     document = """\
     <slideshow>
     <title>Demo slideshow</title>
     <slide><title>Slide title</title>
     <point>This is a demo</point>
     <point>Of a program for processing slides</point>
     </slide>

     <slide><title>Another demo slide</title>
     <point>It is important</point>
     <point>To have more than</point>
     <point>one slide</point>
     </slide>
     </slideshow>
     """

     dom = xml.dom.minidom.parseString(document)

     def getText(nodelist):
         rc = []
         for node in nodelist:
             if node.nodeType == node.TEXT_NODE:
                 rc.append(node.data)
         return ''.join(rc)

     def handleSlideshow(slideshow):
         print "<html>"
         handleSlideshowTitle(slideshow.getElementsByTagName("title")[0])
         slides = slideshow.getElementsByTagName("slide")
         handleToc(slides)
         handleSlides(slides)
         print "</html>"

     def handleSlides(slides):
         for slide in slides:
             handleSlide(slide)

     def handleSlide(slide):
         handleSlideTitle(slide.getElementsByTagName("title")[0])
         handlePoints(slide.getElementsByTagName("point"))

     def handleSlideshowTitle(title):
         print "<title>%s</title>" % getText(title.childNodes)

     def handleSlideTitle(title):
         print "<h2>%s</h2>" % getText(title.childNodes)

     def handlePoints(points):
         print "<ul>"
         for point in points:
             handlePoint(point)
         print "</ul>"

     def handlePoint(point):
         print "<li>%s</li>" % getText(point.childNodes)

     def handleToc(slides):
         for slide in slides:
             title = slide.getElementsByTagName("title")[0]
             print "<p>%s</p>" % getText(title.childNodes)

     handleSlideshow(dom)



File: python.info,  Node: minidom and the DOM standard,  Prev: DOM Example,  Up: xml dom minidom --- Minimal DOM implementation

5.19.9.3 minidom and the DOM standard
.....................................

The *note xml.dom.minidom: 1a2. module is essentially a DOM
1.0-compatible DOM with some DOM 2 features (primarily namespace
features).

  Usage of the DOM interface in Python is straight-forward.  The
following mapping rules apply:

   * Interfaces are accessed through instance objects.  Applications
     should not instantiate the classes themselves; they should use the
     creator functions available on the ‘Document’ object.  Derived
     interfaces support all operations (and attributes) from the base
     interfaces, plus any new operations.

   * Operations are used as methods.  Since the DOM uses only *note in:
     428. parameters, the arguments are passed in normal order (from
     left to right).  There are no optional arguments.  ‘void’
     operations return ‘None’.

   * IDL attributes map to instance attributes.  For compatibility with
     the OMG IDL language mapping for Python, an attribute ‘foo’ can
     also be accessed through accessor methods ‘_get_foo()’ and
     ‘_set_foo()’.  ‘readonly’ attributes must not be changed; this is
     not enforced at runtime.

   * The types ‘short int’, ‘unsigned int’, ‘unsigned long long’, and
     ‘boolean’ all map to Python integer objects.

   * The type ‘DOMString’ maps to Python strings.  *note
     xml.dom.minidom: 1a2. supports either byte or Unicode strings, but
     will normally produce Unicode strings.  Values of type ‘DOMString’
     may also be ‘None’ where allowed to have the IDL ‘null’ value by
     the DOM specification from the W3C.

   * ‘const’ declarations map to variables in their respective scope
     (e.g.  ‘xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE’); they
     must not be changed.

   * ‘DOMException’ is currently not supported in *note xml.dom.minidom:
     1a2.  Instead, *note xml.dom.minidom: 1a2. uses standard Python
     exceptions such as *note TypeError: 218. and *note AttributeError:
     1f8.

   * ‘NodeList’ objects are implemented using Python’s built-in list
     type.  Starting with Python 2.2, these objects provide the
     interface defined in the DOM specification, but with earlier
     versions of Python they do not support the official API. They are,
     however, much more "Pythonic" than the interface defined in the W3C
     recommendations.

  The following interfaces have no implementation in *note
xml.dom.minidom: 1a2.:

   * ‘DOMTimeStamp’

   * ‘DocumentType’ (added in Python 2.1)

   * ‘DOMImplementation’ (added in Python 2.1)

   * ‘CharacterData’

   * ‘CDATASection’

   * ‘Notation’

   * ‘Entity’

   * ‘EntityReference’

   * ‘DocumentFragment’

  Most of these reflect information in the XML document that is not of
general utility to most DOM users.


File: python.info,  Node: xml dom pulldom --- Support for building partial DOM trees,  Next: xml sax --- Support for SAX2 parsers,  Prev: xml dom minidom --- Minimal DOM implementation,  Up: Structured Markup Processing Tools

5.19.10 ‘xml.dom.pulldom’ — Support for building partial DOM trees
------------------------------------------------------------------

New in version 2.0.

  *Source code:* Lib/xml/dom/pulldom.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  *note xml.dom.pulldom: 1a3. allows building only selected portions of
a Document Object Model representation of a document from SAX events.

     Warning: The *note xml.dom.pulldom: 1a3. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *note XML vulnerabilities:
     1a24.

 -- Class: xml.dom.pulldom.PullDOM ([documentFactory])

     *note xml.sax.handler.ContentHandler: 1b07. implementation that ...

 -- Class: xml.dom.pulldom.DOMEventStream (stream, parser, bufsize)

     ...

 -- Class: xml.dom.pulldom.SAX2DOM ([documentFactory])

     *note xml.sax.handler.ContentHandler: 1b07. implementation that ...

 -- Function: xml.dom.pulldom.parse (stream_or_string[, parser[,
          bufsize]])

     ...

 -- Function: xml.dom.pulldom.parseString (string[, parser])

     ...

 -- Data: xml.dom.pulldom.default_bufsize

     Default value for the _bufsize_ parameter to *note parse(): 1b0a.

     Changed in version 2.1: The value of this variable can be changed
     before calling *note parse(): 1b0a. and the new value will take
     effect.

* Menu:

* DOMEventStream Objects:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/xml/dom/pulldom.py


File: python.info,  Node: DOMEventStream Objects,  Up: xml dom pulldom --- Support for building partial DOM trees

5.19.10.1 DOMEventStream Objects
................................

 -- Method: DOMEventStream.getEvent ()

     ...

 -- Method: DOMEventStream.expandNode (node)

     ...

 -- Method: DOMEventStream.reset ()

     ...


File: python.info,  Node: xml sax --- Support for SAX2 parsers,  Next: xml sax handler --- Base classes for SAX handlers,  Prev: xml dom pulldom --- Support for building partial DOM trees,  Up: Structured Markup Processing Tools

5.19.11 ‘xml.sax’ — Support for SAX2 parsers
--------------------------------------------

New in version 2.0.

  The *note xml.sax: 1a6. package provides a number of modules which
implement the Simple API for XML (SAX) interface for Python.  The
package itself provides the SAX exceptions and the convenience functions
which will be most used by users of the SAX API.

     Warning: The *note xml.sax: 1a6. module is not secure against
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see *note XML vulnerabilities: 1a24.

  The convenience functions are:

 -- Function: xml.sax.make_parser ([parser_list])

     Create and return a SAX *note XMLReader: 1b15. object.  The first
     parser found will be used.  If _parser_list_ is provided, it must
     be a sequence of strings which name modules that have a function
     named ‘create_parser()’.  Modules listed in _parser_list_ will be
     used before modules in the default list of parsers.

 -- Function: xml.sax.parse (filename_or_stream, handler[,
          error_handler])

     Create a SAX parser and use it to parse a document.  The document,
     passed in as _filename_or_stream_, can be a filename or a file
     object.  The _handler_ parameter needs to be a SAX *note
     ContentHandler: 1b07. instance.  If _error_handler_ is given, it
     must be a SAX *note ErrorHandler: 1b17. instance; if omitted, *note
     SAXParseException: 1b18. will be raised on all errors.  There is no
     return value; all work must be done by the _handler_ passed in.

 -- Function: xml.sax.parseString (string, handler[, error_handler])

     Similar to *note parse(): 1b16, but parses from a buffer _string_
     received as a parameter.

  A typical SAX application uses three kinds of objects: readers,
handlers and input sources.  "Reader" in this context is another term
for parser, i.e.  some piece of code that reads the bytes or characters
from the input source, and produces a sequence of events.  The events
then get distributed to the handler objects, i.e.  the reader invokes a
method on the handler.  A SAX application must therefore obtain a reader
object, create or open the input sources, create the handlers, and
connect these objects all together.  As the final step of preparation,
the reader is called to parse the input.  During parsing, methods on the
handler objects are called based on structural and syntactic events from
the input data.

  For these objects, only the interfaces are relevant; they are normally
not instantiated by the application itself.  Since Python does not have
an explicit notion of interface, they are formally introduced as
classes, but applications may use implementations which do not inherit
from the provided classes.  The *note InputSource: 1b1a, *note Locator:
1b1b, ‘Attributes’, ‘AttributesNS’, and *note XMLReader: 1b15.
interfaces are defined in the module *note xml.sax.xmlreader: 1a9.  The
handler interfaces are defined in *note xml.sax.handler: 1a7.  For
convenience, *note InputSource: 1b1a. (which is often instantiated
directly) and the handler classes are also available from *note xml.sax:
1a6.  These interfaces are described below.

  In addition to these classes, *note xml.sax: 1a6. provides the
following exception classes.

 -- Exception: xml.sax.SAXException (msg[, exception])

     Encapsulate an XML error or warning.  This class can contain basic
     error or warning information from either the XML parser or the
     application: it can be subclassed to provide additional
     functionality or to add localization.  Note that although the
     handlers defined in the *note ErrorHandler: 1b17. interface receive
     instances of this exception, it is not required to actually raise
     the exception — it is also useful as a container for information.

     When instantiated, _msg_ should be a human-readable description of
     the error.  The optional _exception_ parameter, if given, should be
     ‘None’ or an exception that was caught by the parsing code and is
     being passed along as information.

     This is the base class for the other SAX exception classes.

 -- Exception: xml.sax.SAXParseException (msg, exception, locator)

     Subclass of *note SAXException: 1b1c. raised on parse errors.
     Instances of this class are passed to the methods of the SAX *note
     ErrorHandler: 1b17. interface to provide information about the
     parse error.  This class supports the SAX *note Locator: 1b1b.
     interface as well as the *note SAXException: 1b1c. interface.

 -- Exception: xml.sax.SAXNotRecognizedException (msg[, exception])

     Subclass of *note SAXException: 1b1c. raised when a SAX *note
     XMLReader: 1b15. is confronted with an unrecognized feature or
     property.  SAX applications and extensions may use this class for
     similar purposes.

 -- Exception: xml.sax.SAXNotSupportedException (msg[, exception])

     Subclass of *note SAXException: 1b1c. raised when a SAX *note
     XMLReader: 1b15. is asked to enable a feature that is not
     supported, or to set a property to a value that the implementation
     does not support.  SAX applications and extensions may use this
     class for similar purposes.

See also
........

SAX: The Simple API for XML(1)

     This site is the focal point for the definition of the SAX API. It
     provides a Java implementation and online documentation.  Links to
     implementations and historical information are also available.

Module *note xml.sax.handler: 1a7.

     Definitions of the interfaces for application-provided objects.

Module *note xml.sax.saxutils: 1a8.

     Convenience functions for use in SAX applications.

Module *note xml.sax.xmlreader: 1a9.

     Definitions of the interfaces for parser-provided objects.

* Menu:

* SAXException Objects:: 

   ---------- Footnotes ----------

   (1) http://www.saxproject.org/


File: python.info,  Node: SAXException Objects,  Up: xml sax --- Support for SAX2 parsers

5.19.11.1 SAXException Objects
..............................

The *note SAXException: 1b1c. exception class supports the following
methods:

 -- Method: SAXException.getMessage ()

     Return a human-readable message describing the error condition.

 -- Method: SAXException.getException ()

     Return an encapsulated exception object, or ‘None’.


File: python.info,  Node: xml sax handler --- Base classes for SAX handlers,  Next: xml sax saxutils --- SAX Utilities,  Prev: xml sax --- Support for SAX2 parsers,  Up: Structured Markup Processing Tools

5.19.12 ‘xml.sax.handler’ — Base classes for SAX handlers
---------------------------------------------------------

New in version 2.0.

  The SAX API defines four kinds of handlers: content handlers, DTD
handlers, error handlers, and entity resolvers.  Applications normally
only need to implement those interfaces whose events they are interested
in; they can implement the interfaces in a single object or in multiple
objects.  Handler implementations should inherit from the base classes
provided in the module *note xml.sax.handler: 1a7, so that all methods
get default implementations.

 -- Class: xml.sax.handler.ContentHandler

     This is the main callback interface in SAX, and the one most
     important to applications.  The order of events in this interface
     mirrors the order of the information in the document.

 -- Class: xml.sax.handler.DTDHandler

     Handle DTD events.

     This interface specifies only those DTD events required for basic
     parsing (unparsed entities and attributes).

 -- Class: xml.sax.handler.EntityResolver

     Basic interface for resolving entities.  If you create an object
     implementing this interface, then register the object with your
     Parser, the parser will call the method in your object to resolve
     all external entities.

 -- Class: xml.sax.handler.ErrorHandler

     Interface used by the parser to present error and warning messages
     to the application.  The methods of this object control whether
     errors are immediately converted to exceptions or are handled in
     some other way.

  In addition to these classes, *note xml.sax.handler: 1a7. provides
symbolic constants for the feature and property names.

 -- Data: xml.sax.handler.feature_namespaces

          value: ‘"http://xml.org/sax/features/namespaces"’ 
          true: Perform Namespace processing. 
          false: Optionally do not perform Namespace processing (implies namespace-prefixes; default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_namespace_prefixes

          value: ‘"http://xml.org/sax/features/namespace-prefixes"’ 
          true: Report the original prefixed names and attributes used for Namespace declarations. 
          false: Do not report attributes used for Namespace declarations, and optionally do not report original prefixed names (default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_string_interning

          value: ‘"http://xml.org/sax/features/string-interning"’ 
          true: All element names, prefixes, attribute names, Namespace URIs, and local names are interned using the built-in intern function. 
          false: Names are not necessarily interned, although they may be (default). 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_validation

          value: ‘"http://xml.org/sax/features/validation"’ 
          true: Report all validation errors (implies external-general-entities and external-parameter-entities). 
          false: Do not report validation errors. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_external_ges

          value: ‘"http://xml.org/sax/features/external-general-entities"’ 
          true: Include all external general (text) entities. 
          false: Do not include external general entities. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.feature_external_pes

          value: ‘"http://xml.org/sax/features/external-parameter-entities"’ 
          true: Include all external parameter entities, including the external DTD subset. 
          false: Do not include any external parameter entities, even the external DTD subset. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.all_features

     List of all features.

 -- Data: xml.sax.handler.property_lexical_handler

          value: ‘"http://xml.org/sax/properties/lexical-handler"’ 
          data type: xml.sax.sax2lib.LexicalHandler (not supported in Python 2) 
          description: An optional extension handler for lexical events like comments. 
          access: read/write 

 -- Data: xml.sax.handler.property_declaration_handler

          value: ‘"http://xml.org/sax/properties/declaration-handler"’ 
          data type: xml.sax.sax2lib.DeclHandler (not supported in Python 2) 
          description: An optional extension handler for DTD-related events other than notations and unparsed entities. 
          access: read/write 

 -- Data: xml.sax.handler.property_dom_node

          value: ‘"http://xml.org/sax/properties/dom-node"’ 
          data type: org.w3c.dom.Node (not supported in Python 2) 
          description: When parsing, the current DOM node being visited if this is a DOM iterator; when not parsing, the root DOM node for iteration. 
          access: (parsing) read-only; (not parsing) read/write 

 -- Data: xml.sax.handler.property_xml_string

          value: ‘"http://xml.org/sax/properties/xml-string"’ 
          data type: String 
          description: The literal string of characters that was the source for the current event. 
          access: read-only 

 -- Data: xml.sax.handler.all_properties

     List of all known property names.

* Menu:

* ContentHandler Objects:: 
* DTDHandler Objects:: 
* EntityResolver Objects:: 
* ErrorHandler Objects:: 


File: python.info,  Node: ContentHandler Objects,  Next: DTDHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.19.12.1 ContentHandler Objects
................................

Users are expected to subclass *note ContentHandler: 1b07. to support
their application.  The following methods are called by the parser on
the appropriate events in the input document:

 -- Method: ContentHandler.setDocumentLocator (locator)

     Called by the parser to give the application a locator for locating
     the origin of document events.

     SAX parsers are strongly encouraged (though not absolutely
     required) to supply a locator: if it does so, it must supply the
     locator to the application by invoking this method before invoking
     any of the other methods in the DocumentHandler interface.

     The locator allows the application to determine the end position of
     any document-related event, even if the parser is not reporting an
     error.  Typically, the application will use this information for
     reporting its own errors (such as character content that does not
     match an application’s business rules).  The information returned
     by the locator is probably not sufficient for use with a search
     engine.

     Note that the locator will return correct information only during
     the invocation of the events in this interface.  The application
     should not attempt to use it at any other time.

 -- Method: ContentHandler.startDocument ()

     Receive notification of the beginning of a document.

     The SAX parser will invoke this method only once, before any other
     methods in this interface or in DTDHandler (except for *note
     setDocumentLocator(): 1b35.).

 -- Method: ContentHandler.endDocument ()

     Receive notification of the end of a document.

     The SAX parser will invoke this method only once, and it will be
     the last method invoked during the parse.  The parser shall not
     invoke this method until it has either abandoned parsing (because
     of an unrecoverable error) or reached the end of input.

 -- Method: ContentHandler.startPrefixMapping (prefix, uri)

     Begin the scope of a prefix-URI Namespace mapping.

     The information from this event is not necessary for normal
     Namespace processing: the SAX XML reader will automatically replace
     prefixes for element and attribute names when the
     ‘feature_namespaces’ feature is enabled (the default).

     There are cases, however, when applications need to use prefixes in
     character data or in attribute values, where they cannot safely be
     expanded automatically; the *note startPrefixMapping(): 1b38. and
     *note endPrefixMapping(): 1b39. events supply the information to
     the application to expand prefixes in those contexts itself, if
     necessary.

     Note that *note startPrefixMapping(): 1b38. and *note
     endPrefixMapping(): 1b39. events are not guaranteed to be properly
     nested relative to each-other: all *note startPrefixMapping():
     1b38. events will occur before the corresponding *note
     startElement(): 1b3a. event, and all *note endPrefixMapping():
     1b39. events will occur after the corresponding *note endElement():
     1b3b. event, but their order is not guaranteed.

 -- Method: ContentHandler.endPrefixMapping (prefix)

     End the scope of a prefix-URI mapping.

     See *note startPrefixMapping(): 1b38. for details.  This event will
     always occur after the corresponding *note endElement(): 1b3b.
     event, but the order of *note endPrefixMapping(): 1b39. events is
     not otherwise guaranteed.

 -- Method: ContentHandler.startElement (name, attrs)

     Signals the start of an element in non-namespace mode.

     The _name_ parameter contains the raw XML 1.0 name of the element
     type as a string and the _attrs_ parameter holds an object of the
     ‘Attributes’ interface (see *note The Attributes Interface: 1b3c.)
     containing the attributes of the element.  The object passed as
     _attrs_ may be re-used by the parser; holding on to a reference to
     it is not a reliable way to keep a copy of the attributes.  To keep
     a copy of the attributes, use the *note copy(): 71. method of the
     _attrs_ object.

 -- Method: ContentHandler.endElement (name)

     Signals the end of an element in non-namespace mode.

     The _name_ parameter contains the name of the element type, just as
     with the *note startElement(): 1b3a. event.

 -- Method: ContentHandler.startElementNS (name, qname, attrs)

     Signals the start of an element in namespace mode.

     The _name_ parameter contains the name of the element type as a
     ‘(uri, localname)’ tuple, the _qname_ parameter contains the raw
     XML 1.0 name used in the source document, and the _attrs_ parameter
     holds an instance of the ‘AttributesNS’ interface (see *note The
     AttributesNS Interface: 1b3e.) containing the attributes of the
     element.  If no namespace is associated with the element, the _uri_
     component of _name_ will be ‘None’.  The object passed as _attrs_
     may be re-used by the parser; holding on to a reference to it is
     not a reliable way to keep a copy of the attributes.  To keep a
     copy of the attributes, use the *note copy(): 71. method of the
     _attrs_ object.

     Parsers may set the _qname_ parameter to ‘None’, unless the
     ‘feature_namespace_prefixes’ feature is activated.

 -- Method: ContentHandler.endElementNS (name, qname)

     Signals the end of an element in namespace mode.

     The _name_ parameter contains the name of the element type, just as
     with the *note startElementNS(): 1b3d. method, likewise the _qname_
     parameter.

 -- Method: ContentHandler.characters (content)

     Receive notification of character data.

     The Parser will call this method to report each chunk of character
     data.  SAX parsers may return all contiguous character data in a
     single chunk, or they may split it into several chunks; however,
     all of the characters in any single event must come from the same
     external entity so that the Locator provides useful information.

     _content_ may be a Unicode string or a byte string; the ‘expat’
     reader module produces always Unicode strings.

          Note: The earlier SAX 1 interface provided by the Python XML
          Special Interest Group used a more Java-like interface for
          this method.  Since most parsers used from Python did not take
          advantage of the older interface, the simpler signature was
          chosen to replace it.  To convert old code to the new
          interface, use _content_ instead of slicing content with the
          old _offset_ and _length_ parameters.

 -- Method: ContentHandler.ignorableWhitespace (whitespace)

     Receive notification of ignorable whitespace in element content.

     Validating Parsers must use this method to report each chunk of
     ignorable whitespace (see the W3C XML 1.0 recommendation, section
     2.10): non-validating parsers may also use this method if they are
     capable of parsing and using content models.

     SAX parsers may return all contiguous whitespace in a single chunk,
     or they may split it into several chunks; however, all of the
     characters in any single event must come from the same external
     entity, so that the Locator provides useful information.

 -- Method: ContentHandler.processingInstruction (target, data)

     Receive notification of a processing instruction.

     The Parser will invoke this method once for each processing
     instruction found: note that processing instructions may occur
     before or after the main document element.

     A SAX parser should never report an XML declaration (XML 1.0,
     section 2.8) or a text declaration (XML 1.0, section 4.3.1) using
     this method.

 -- Method: ContentHandler.skippedEntity (name)

     Receive notification of a skipped entity.

     The Parser will invoke this method once for each entity skipped.
     Non-validating processors may skip entities if they have not seen
     the declarations (because, for example, the entity was declared in
     an external DTD subset).  All processors may skip external
     entities, depending on the values of the ‘feature_external_ges’ and
     the ‘feature_external_pes’ properties.


File: python.info,  Node: DTDHandler Objects,  Next: EntityResolver Objects,  Prev: ContentHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.19.12.2 DTDHandler Objects
............................

*note DTDHandler: 1b25. instances provide the following methods:

 -- Method: DTDHandler.notationDecl (name, publicId, systemId)

     Handle a notation declaration event.

 -- Method: DTDHandler.unparsedEntityDecl (name, publicId, systemId,
          ndata)

     Handle an unparsed entity declaration event.


File: python.info,  Node: EntityResolver Objects,  Next: ErrorHandler Objects,  Prev: DTDHandler Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.19.12.3 EntityResolver Objects
................................

 -- Method: EntityResolver.resolveEntity (publicId, systemId)

     Resolve the system identifier of an entity and return either the
     system identifier to read from as a string, or an InputSource to
     read from.  The default implementation returns _systemId_.


File: python.info,  Node: ErrorHandler Objects,  Prev: EntityResolver Objects,  Up: xml sax handler --- Base classes for SAX handlers

5.19.12.4 ErrorHandler Objects
..............................

Objects with this interface are used to receive error and warning
information from the *note XMLReader: 1b15.  If you create an object
that implements this interface, then register the object with your *note
XMLReader: 1b15, the parser will call the methods in your object to
report all warnings and errors.  There are three levels of errors
available: warnings, (possibly) recoverable errors, and unrecoverable
errors.  All methods take a ‘SAXParseException’ as the only parameter.
Errors and warnings may be converted to an exception by raising the
passed-in exception object.

 -- Method: ErrorHandler.error (exception)

     Called when the parser encounters a recoverable error.  If this
     method does not raise an exception, parsing may continue, but
     further document information should not be expected by the
     application.  Allowing the parser to continue may allow additional
     errors to be discovered in the input document.

 -- Method: ErrorHandler.fatalError (exception)

     Called when the parser encounters an error it cannot recover from;
     parsing is expected to terminate when this method returns.

 -- Method: ErrorHandler.warning (exception)

     Called when the parser presents minor warning information to the
     application.  Parsing is expected to continue when this method
     returns, and document information will continue to be passed to the
     application.  Raising an exception in this method will cause
     parsing to end.


File: python.info,  Node: xml sax saxutils --- SAX Utilities,  Next: xml sax xmlreader --- Interface for XML parsers,  Prev: xml sax handler --- Base classes for SAX handlers,  Up: Structured Markup Processing Tools

5.19.13 ‘xml.sax.saxutils’ — SAX Utilities
------------------------------------------

New in version 2.0.

  The module *note xml.sax.saxutils: 1a8. contains a number of classes
and functions that are commonly useful when creating SAX applications,
either in direct use, or as base classes.

 -- Function: xml.sax.saxutils.escape (data[, entities])

     Escape ‘'&'’, ‘'<'’, and ‘'>'’ in a string of data.

     You can escape other strings of data by passing a dictionary as the
     optional _entities_ parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.
     The characters ‘'&'’, ‘'<'’ and ‘'>'’ are always escaped, even if
     _entities_ is provided.

 -- Function: xml.sax.saxutils.unescape (data[, entities])

     Unescape ‘'&amp;'’, ‘'&lt;'’, and ‘'&gt;'’ in a string of data.

     You can unescape other strings of data by passing a dictionary as
     the optional _entities_ parameter.  The keys and values must all be
     strings; each key will be replaced with its corresponding value.
     ‘'&amp'’, ‘'&lt;'’, and ‘'&gt;'’ are always unescaped, even if
     _entities_ is provided.

     New in version 2.3.

 -- Function: xml.sax.saxutils.quoteattr (data[, entities])

     Similar to *note escape(): 1b52, but also prepares _data_ to be
     used as an attribute value.  The return value is a quoted version
     of _data_ with any additional required replacements.  *note
     quoteattr(): 1b54. will select a quote character based on the
     content of _data_, attempting to avoid encoding any quote
     characters in the string.  If both single- and double-quote
     characters are already in _data_, the double-quote characters will
     be encoded and _data_ will be wrapped in double-quotes.  The
     resulting string can be used directly as an attribute value:

          >>> print "<element attr=%s>" % quoteattr("ab ' cd \" ef")
          <element attr="ab ' cd &quot; ef">

     This function is useful when generating attribute values for HTML
     or any SGML using the reference concrete syntax.

     New in version 2.2.

 -- Class: xml.sax.saxutils.XMLGenerator ([out[, encoding]])

     This class implements the *note ContentHandler: 1b07. interface by
     writing SAX events back into an XML document.  In other words,
     using an *note XMLGenerator: 1b55. as the content handler will
     reproduce the original document being parsed.  _out_ should be a
     file-like object which will default to _sys.stdout_.  _encoding_ is
     the encoding of the output stream which defaults to ‘'iso-8859-1'’.

 -- Class: xml.sax.saxutils.XMLFilterBase (base)

     This class is designed to sit between an *note XMLReader: 1b15. and
     the client application’s event handlers.  By default, it does
     nothing but pass requests up to the reader and events on to the
     handlers unmodified, but subclasses can override specific methods
     to modify the event stream or the configuration requests as they
     pass through.

 -- Function: xml.sax.saxutils.prepare_input_source (source[, base])

     This function takes an input source and an optional base URL and
     returns a fully resolved *note InputSource: 1b1a. object ready for
     reading.  The input source can be given as a string, a file-like
     object, or an *note InputSource: 1b1a. object; parsers will use
     this function to implement the polymorphic _source_ argument to
     their ‘parse()’ method.


File: python.info,  Node: xml sax xmlreader --- Interface for XML parsers,  Next: xml parsers expat --- Fast XML parsing using Expat,  Prev: xml sax saxutils --- SAX Utilities,  Up: Structured Markup Processing Tools

5.19.14 ‘xml.sax.xmlreader’ — Interface for XML parsers
-------------------------------------------------------

New in version 2.0.

  SAX parsers implement the *note XMLReader: 1b15. interface.  They are
implemented in a Python module, which must provide a function
‘create_parser()’.  This function is invoked by *note
xml.sax.make_parser(): 1b14. with no arguments to create a new parser
object.

 -- Class: xml.sax.xmlreader.XMLReader

     Base class which can be inherited by SAX parsers.

 -- Class: xml.sax.xmlreader.IncrementalParser

     In some cases, it is desirable not to parse an input source at
     once, but to feed chunks of the document as they get available.
     Note that the reader will normally not read the entire file, but
     read it in chunks as well; still ‘parse()’ won’t return until the
     entire document is processed.  So these interfaces should be used
     if the blocking behaviour of ‘parse()’ is not desirable.

     When the parser is instantiated it is ready to begin accepting data
     from the feed method immediately.  After parsing has been finished
     with a call to close the reset method must be called to make the
     parser ready to accept new data, either from feed or using the
     parse method.

     Note that these methods must _not_ be called during parsing, that
     is, after parse has been called and before it returns.

     By default, the class also implements the parse method of the
     XMLReader interface using the feed, close and reset methods of the
     IncrementalParser interface as a convenience to SAX 2.0 driver
     writers.

 -- Class: xml.sax.xmlreader.Locator

     Interface for associating a SAX event with a document location.  A
     locator object will return valid results only during calls to
     DocumentHandler methods; at any other time, the results are
     unpredictable.  If information is not available, methods may return
     ‘None’.

 -- Class: xml.sax.xmlreader.InputSource ([systemId])

     Encapsulation of the information needed by the *note XMLReader:
     1b15. to read entities.

     This class may include information about the public identifier,
     system identifier, byte stream (possibly with character encoding
     information) and/or the character stream of an entity.

     Applications will create objects of this class for use in the *note
     XMLReader.parse(): 1b5b. method and for returning from
     EntityResolver.resolveEntity.

     An *note InputSource: 1b1a. belongs to the application, the *note
     XMLReader: 1b15. is not allowed to modify *note InputSource: 1b1a.
     objects passed to it from the application, although it may make
     copies and modify those.

 -- Class: xml.sax.xmlreader.AttributesImpl (attrs)

     This is an implementation of the ‘Attributes’ interface (see
     section *note The Attributes Interface: 1b3c.).  This is a
     dictionary-like object which represents the element attributes in a
     ‘startElement()’ call.  In addition to the most useful dictionary
     operations, it supports a number of other methods as described by
     the interface.  Objects of this class should be instantiated by
     readers; _attrs_ must be a dictionary-like object containing a
     mapping from attribute names to attribute values.

 -- Class: xml.sax.xmlreader.AttributesNSImpl (attrs, qnames)

     Namespace-aware variant of *note AttributesImpl: 1b5c, which will
     be passed to ‘startElementNS()’.  It is derived from *note
     AttributesImpl: 1b5c, but understands attribute names as two-tuples
     of _namespaceURI_ and _localname_.  In addition, it provides a
     number of methods expecting qualified names as they appear in the
     original document.  This class implements the ‘AttributesNS’
     interface (see section *note The AttributesNS Interface: 1b3e.).

* Menu:

* XMLReader Objects:: 
* IncrementalParser Objects:: 
* Locator Objects:: 
* InputSource Objects:: 
* The Attributes Interface:: 
* The AttributesNS Interface:: 


File: python.info,  Node: XMLReader Objects,  Next: IncrementalParser Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.1 XMLReader Objects
...........................

The *note XMLReader: 1b15. interface supports the following methods:

 -- Method: XMLReader.parse (source)

     Process an input source, producing SAX events.  The _source_ object
     can be a system identifier (a string identifying the input source –
     typically a file name or an URL), a file-like object, or an *note
     InputSource: 1b1a. object.  When *note parse(): 1b5b. returns, the
     input is completely processed, and the parser object can be
     discarded or reset.  As a limitation, the current implementation
     only accepts byte streams; processing of character streams is for
     further study.

 -- Method: XMLReader.getContentHandler ()

     Return the current *note ContentHandler: 1b07.

 -- Method: XMLReader.setContentHandler (handler)

     Set the current *note ContentHandler: 1b07.  If no *note
     ContentHandler: 1b07. is set, content events will be discarded.

 -- Method: XMLReader.getDTDHandler ()

     Return the current *note DTDHandler: 1b25.

 -- Method: XMLReader.setDTDHandler (handler)

     Set the current *note DTDHandler: 1b25.  If no *note DTDHandler:
     1b25. is set, DTD events will be discarded.

 -- Method: XMLReader.getEntityResolver ()

     Return the current *note EntityResolver: 1b26.

 -- Method: XMLReader.setEntityResolver (handler)

     Set the current *note EntityResolver: 1b26.  If no *note
     EntityResolver: 1b26. is set, attempts to resolve an external
     entity will result in opening the system identifier for the entity,
     and fail if it is not available.

 -- Method: XMLReader.getErrorHandler ()

     Return the current *note ErrorHandler: 1b17.

 -- Method: XMLReader.setErrorHandler (handler)

     Set the current error handler.  If no *note ErrorHandler: 1b17. is
     set, errors will be raised as exceptions, and warnings will be
     printed.

 -- Method: XMLReader.setLocale (locale)

     Allow an application to set the locale for errors and warnings.

     SAX parsers are not required to provide localization for errors and
     warnings; if they cannot support the requested locale, however,
     they must raise a SAX exception.  Applications may request a locale
     change in the middle of a parse.

 -- Method: XMLReader.getFeature (featurename)

     Return the current setting for feature _featurename_.  If the
     feature is not recognized, ‘SAXNotRecognizedException’ is raised.
     The well-known featurenames are listed in the module *note
     xml.sax.handler: 1a7.

 -- Method: XMLReader.setFeature (featurename, value)

     Set the _featurename_ to _value_.  If the feature is not
     recognized, ‘SAXNotRecognizedException’ is raised.  If the feature
     or its setting is not supported by the parser,
     _SAXNotSupportedException_ is raised.

 -- Method: XMLReader.getProperty (propertyname)

     Return the current setting for property _propertyname_.  If the
     property is not recognized, a ‘SAXNotRecognizedException’ is
     raised.  The well-known propertynames are listed in the module
     *note xml.sax.handler: 1a7.

 -- Method: XMLReader.setProperty (propertyname, value)

     Set the _propertyname_ to _value_.  If the property is not
     recognized, ‘SAXNotRecognizedException’ is raised.  If the property
     or its setting is not supported by the parser,
     _SAXNotSupportedException_ is raised.


File: python.info,  Node: IncrementalParser Objects,  Next: Locator Objects,  Prev: XMLReader Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.2 IncrementalParser Objects
...................................

Instances of *note IncrementalParser: 1b5a. offer the following
additional methods:

 -- Method: IncrementalParser.feed (data)

     Process a chunk of _data_.

 -- Method: IncrementalParser.close ()

     Assume the end of the document.  That will check well-formedness
     conditions that can be checked only at the end, invoke handlers,
     and may clean up resources allocated during parsing.

 -- Method: IncrementalParser.reset ()

     This method is called after close has been called to reset the
     parser so that it is ready to parse new documents.  The results of
     calling parse or feed after close without calling reset are
     undefined.


File: python.info,  Node: Locator Objects,  Next: InputSource Objects,  Prev: IncrementalParser Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.3 Locator Objects
.........................

Instances of *note Locator: 1b1b. provide these methods:

 -- Method: Locator.getColumnNumber ()

     Return the column number where the current event ends.

 -- Method: Locator.getLineNumber ()

     Return the line number where the current event ends.

 -- Method: Locator.getPublicId ()

     Return the public identifier for the current event.

 -- Method: Locator.getSystemId ()

     Return the system identifier for the current event.


File: python.info,  Node: InputSource Objects,  Next: The Attributes Interface,  Prev: Locator Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.4 InputSource Objects
.............................

 -- Method: InputSource.setPublicId (id)

     Sets the public identifier of this *note InputSource: 1b1a.

 -- Method: InputSource.getPublicId ()

     Returns the public identifier of this *note InputSource: 1b1a.

 -- Method: InputSource.setSystemId (id)

     Sets the system identifier of this *note InputSource: 1b1a.

 -- Method: InputSource.getSystemId ()

     Returns the system identifier of this *note InputSource: 1b1a.

 -- Method: InputSource.setEncoding (encoding)

     Sets the character encoding of this *note InputSource: 1b1a.

     The encoding must be a string acceptable for an XML encoding
     declaration (see section 4.3.3 of the XML recommendation).

     The encoding attribute of the *note InputSource: 1b1a. is ignored
     if the *note InputSource: 1b1a. also contains a character stream.

 -- Method: InputSource.getEncoding ()

     Get the character encoding of this InputSource.

 -- Method: InputSource.setByteStream (bytefile)

     Set the byte stream (a Python file-like object which does not
     perform byte-to-character conversion) for this input source.

     The SAX parser will ignore this if there is also a character stream
     specified, but it will use a byte stream in preference to opening a
     URI connection itself.

     If the application knows the character encoding of the byte stream,
     it should set it with the setEncoding method.

 -- Method: InputSource.getByteStream ()

     Get the byte stream for this input source.

     The getEncoding method will return the character encoding for this
     byte stream, or None if unknown.

 -- Method: InputSource.setCharacterStream (charfile)

     Set the character stream for this input source.  (The stream must
     be a Python 1.6 Unicode-wrapped file-like that performs conversion
     to Unicode strings.)

     If there is a character stream specified, the SAX parser will
     ignore any byte stream and will not attempt to open a URI
     connection to the system identifier.

 -- Method: InputSource.getCharacterStream ()

     Get the character stream for this input source.


File: python.info,  Node: The Attributes Interface,  Next: The AttributesNS Interface,  Prev: InputSource Objects,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.5 The ‘Attributes’ Interface
....................................

‘Attributes’ objects implement a portion of the mapping protocol,
including the methods ‘copy()’, ‘get()’, ‘has_key()’, ‘items()’,
‘keys()’, and ‘values()’.  The following methods are also provided:

 -- Method: Attributes.getLength ()

     Return the number of attributes.

 -- Method: Attributes.getNames ()

     Return the names of the attributes.

 -- Method: Attributes.getType (name)

     Returns the type of the attribute _name_, which is normally
     ‘'CDATA'’.

 -- Method: Attributes.getValue (name)

     Return the value of attribute _name_.


File: python.info,  Node: The AttributesNS Interface,  Prev: The Attributes Interface,  Up: xml sax xmlreader --- Interface for XML parsers

5.19.14.6 The ‘AttributesNS’ Interface
......................................

This interface is a subtype of the ‘Attributes’ interface (see section
*note The Attributes Interface: 1b3c.).  All methods supported by that
interface are also available on ‘AttributesNS’ objects.

  The following methods are also available:

 -- Method: AttributesNS.getValueByQName (name)

     Return the value for a qualified name.

 -- Method: AttributesNS.getNameByQName (name)

     Return the ‘(namespace, localname)’ pair for a qualified _name_.

 -- Method: AttributesNS.getQNameByName (name)

     Return the qualified name for a ‘(namespace, localname)’ pair.

 -- Method: AttributesNS.getQNames ()

     Return the qualified names of all attributes.


File: python.info,  Node: xml parsers expat --- Fast XML parsing using Expat,  Prev: xml sax xmlreader --- Interface for XML parsers,  Up: Structured Markup Processing Tools

5.19.15 ‘xml.parsers.expat’ — Fast XML parsing using Expat
----------------------------------------------------------

     Warning: The ‘pyexpat’ module is not secure against maliciously
     constructed data.  If you need to parse untrusted or
     unauthenticated data see *note XML vulnerabilities: 1a24.

  New in version 2.0.

  The *note xml.parsers.expat: 1a5. module is a Python interface to the
Expat non-validating XML parser.  The module provides a single extension
type, ‘xmlparser’, that represents the current state of an XML parser.
After an ‘xmlparser’ object has been created, various attributes of the
object can be set to handler functions.  When an XML document is then
fed to the parser, the handler functions are called for the character
data and markup in the XML document.

  This module uses the ‘pyexpat’ module to provide access to the Expat
parser.  Direct use of the ‘pyexpat’ module is deprecated.

  This module provides one exception and one type object:

 -- Exception: xml.parsers.expat.ExpatError

     The exception raised when Expat reports an error.  See section
     *note ExpatError Exceptions: 1b91. for more information on
     interpreting Expat errors.

 -- Exception: xml.parsers.expat.error

     Alias for *note ExpatError: 1b90.

 -- Data: xml.parsers.expat.XMLParserType

     The type of the return values from the *note ParserCreate(): 1b94.
     function.

  The *note xml.parsers.expat: 1a5. module contains two functions:

 -- Function: xml.parsers.expat.ErrorString (errno)

     Returns an explanatory string for a given error number _errno_.

 -- Function: xml.parsers.expat.ParserCreate ([encoding[,
          namespace_separator]])

     Creates and returns a new ‘xmlparser’ object.  _encoding_, if
     specified, must be a string naming the encoding used by the XML
     data.  Expat doesn’t support as many encodings as Python does, and
     its repertoire of encodings can’t be extended; it supports UTF-8,
     UTF-16, ISO-8859-1 (Latin1), and ASCII. If _encoding_ (1) is given
     it will override the implicit or explicit encoding of the document.

     Expat can optionally do XML namespace processing for you, enabled
     by providing a value for _namespace_separator_.  The value must be
     a one-character string; a *note ValueError: 236. will be raised if
     the string has an illegal length (‘None’ is considered the same as
     omission).  When namespace processing is enabled, element type
     names and attribute names that belong to a namespace will be
     expanded.  The element name passed to the element handlers
     ‘StartElementHandler’ and ‘EndElementHandler’ will be the
     concatenation of the namespace URI, the namespace separator
     character, and the local part of the name.  If the namespace
     separator is a zero byte (‘chr(0)’) then the namespace URI and the
     local part will be concatenated without any separator.

     For example, if _namespace_separator_ is set to a space character
     (‘' '’) and the following document is parsed:

          <?xml version="1.0"?>
          <root xmlns    = "http://default-namespace.org/"
                xmlns:py = "http://www.python.org/ns/">
            <py:elem1 />
            <elem2 xmlns="" />
          </root>

     ‘StartElementHandler’ will receive the following strings for each
     element:

          http://default-namespace.org/ root
          http://www.python.org/ns/ elem1
          elem2

     Due to limitations in the ‘Expat’ library used by ‘pyexpat’, the
     ‘xmlparser’ instance returned can only be used to parse a single
     XML document.  Call ‘ParserCreate’ for each document to provide
     unique parser instances.

See also
........

The Expat XML Parser(2)

     Home page of the Expat project.

* Menu:

* XMLParser Objects: XMLParser Objects<2>. 
* ExpatError Exceptions:: 
* Example: Example<11>. 
* Content Model Descriptions:: 
* Expat error constants:: 

   ---------- Footnotes ----------

   (1) The encoding string included in XML output should conform to the
appropriate standards.  For example, "UTF-8" is valid, but "UTF8" is
not.  See
‘http://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl’ and
‘http://www.iana.org/assignments/character-sets’.

   (2) http://www.libexpat.org/


File: python.info,  Node: XMLParser Objects<2>,  Next: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.15.1 XMLParser Objects
...........................

‘xmlparser’ objects have the following methods:

 -- Method: xmlparser.Parse (data[, isfinal])

     Parses the contents of the string _data_, calling the appropriate
     handler functions to process the parsed data.  _isfinal_ must be
     true on the final call to this method; it allows the parsing of a
     single file in fragments, not the submission of multiple files.
     _data_ can be the empty string at any time.

 -- Method: xmlparser.ParseFile (file)

     Parse XML data reading from the object _file_.  _file_ only needs
     to provide the ‘read(nbytes)’ method, returning the empty string
     when there’s no more data.

 -- Method: xmlparser.SetBase (base)

     Sets the base to be used for resolving relative URIs in system
     identifiers in declarations.  Resolving relative identifiers is
     left to the application: this value will be passed through as the
     _base_ argument to the *note ExternalEntityRefHandler(): 1b9b,
     *note NotationDeclHandler(): 1b9c, and *note
     UnparsedEntityDeclHandler(): 1b9d. functions.

 -- Method: xmlparser.GetBase ()

     Returns a string containing the base set by a previous call to
     *note SetBase(): 1b9a, or ‘None’ if *note SetBase(): 1b9a. hasn’t
     been called.

 -- Method: xmlparser.GetInputContext ()

     Returns the input data that generated the current event as a
     string.  The data is in the encoding of the entity which contains
     the text.  When called while an event handler is not active, the
     return value is ‘None’.

     New in version 2.1.

 -- Method: xmlparser.ExternalEntityParserCreate (context[, encoding])

     Create a "child" parser which can be used to parse an external
     parsed entity referred to by content parsed by the parent parser.
     The _context_ parameter should be the string passed to the *note
     ExternalEntityRefHandler(): 1b9b. handler function, described
     below.  The child parser is created with the *note
     ordered_attributes: 1ba1, *note returns_unicode: 1ba2. and *note
     specified_attributes: 1ba3. set to the values of this parser.

 -- Method: xmlparser.SetParamEntityParsing (flag)

     Control parsing of parameter entities (including the external DTD
     subset).  Possible _flag_ values are
     ‘XML_PARAM_ENTITY_PARSING_NEVER’,
     ‘XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE’ and
     ‘XML_PARAM_ENTITY_PARSING_ALWAYS’.  Return true if setting the flag
     was successful.

 -- Method: xmlparser.UseForeignDTD ([flag])

     Calling this with a true value for _flag_ (the default) will cause
     Expat to call the *note ExternalEntityRefHandler: 1b9b. with *note
     None: 39a. for all arguments to allow an alternate DTD to be
     loaded.  If the document does not contain a document type
     declaration, the *note ExternalEntityRefHandler: 1b9b. will still
     be called, but the *note StartDoctypeDeclHandler: 1ba6. and *note
     EndDoctypeDeclHandler: 1ba7. will not be called.

     Passing a false value for _flag_ will cancel a previous call that
     passed a true value, but otherwise has no effect.

     This method can only be called before the *note Parse(): 1b98. or
     *note ParseFile(): 1b99. methods are called; calling it after
     either of those have been called causes *note ExpatError: 1b90. to
     be raised with the *note code: 62. attribute set to
     ‘errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING’.

     New in version 2.3.

  ‘xmlparser’ objects have the following attributes:

 -- Attribute: xmlparser.buffer_size

     The size of the buffer used when *note buffer_text: 1ba9. is true.
     A new buffer size can be set by assigning a new integer value to
     this attribute.  When the size is changed, the buffer will be
     flushed.

     New in version 2.3.

     Changed in version 2.6: The buffer size can now be changed.

 -- Attribute: xmlparser.buffer_text

     Setting this to true causes the ‘xmlparser’ object to buffer
     textual content returned by Expat to avoid multiple calls to the
     *note CharacterDataHandler(): 1baa. callback whenever possible.
     This can improve performance substantially since Expat normally
     breaks character data into chunks at every line ending.  This
     attribute is false by default, and may be changed at any time.

     New in version 2.3.

 -- Attribute: xmlparser.buffer_used

     If *note buffer_text: 1ba9. is enabled, the number of bytes stored
     in the buffer.  These bytes represent UTF-8 encoded text.  This
     attribute has no meaningful interpretation when *note buffer_text:
     1ba9. is false.

     New in version 2.3.

 -- Attribute: xmlparser.ordered_attributes

     Setting this attribute to a non-zero integer causes the attributes
     to be reported as a list rather than a dictionary.  The attributes
     are presented in the order found in the document text.  For each
     attribute, two list entries are presented: the attribute name and
     the attribute value.  (Older versions of this module also used this
     format.)  By default, this attribute is false; it may be changed at
     any time.

     New in version 2.1.

 -- Attribute: xmlparser.returns_unicode

     If this attribute is set to a non-zero integer, the handler
     functions will be passed Unicode strings.  If *note
     returns_unicode: 1ba2. is *note False: 3b1, 8-bit strings
     containing UTF-8 encoded data will be passed to the handlers.  This
     is *note True: 3b0. by default when Python is built with Unicode
     support.

     Changed in version 1.6: Can be changed at any time to affect the
     result type.

 -- Attribute: xmlparser.specified_attributes

     If set to a non-zero integer, the parser will report only those
     attributes which were specified in the document instance and not
     those which were derived from attribute declarations.  Applications
     which set this need to be especially careful to use what additional
     information is available from the declarations as needed to comply
     with the standards for the behavior of XML processors.  By default,
     this attribute is false; it may be changed at any time.

     New in version 2.1.

  The following attributes contain values relating to the most recent
error encountered by an ‘xmlparser’ object, and will only have correct
values once a call to ‘Parse()’ or ‘ParseFile()’ has raised a *note
xml.parsers.expat.ExpatError: 1b90. exception.

 -- Attribute: xmlparser.ErrorByteIndex

     Byte index at which an error occurred.

 -- Attribute: xmlparser.ErrorCode

     Numeric code specifying the problem.  This value can be passed to
     the *note ErrorString(): 1b95. function, or compared to one of the
     constants defined in the ‘errors’ object.

 -- Attribute: xmlparser.ErrorColumnNumber

     Column number at which an error occurred.

 -- Attribute: xmlparser.ErrorLineNumber

     Line number at which an error occurred.

  The following attributes contain values relating to the current parse
location in an ‘xmlparser’ object.  During a callback reporting a parse
event they indicate the location of the first of the sequence of
characters that generated the event.  When called outside of a callback,
the position indicated will be just past the last parse event
(regardless of whether there was an associated callback).

  New in version 2.4.

 -- Attribute: xmlparser.CurrentByteIndex

     Current byte index in the parser input.

 -- Attribute: xmlparser.CurrentColumnNumber

     Current column number in the parser input.

 -- Attribute: xmlparser.CurrentLineNumber

     Current line number in the parser input.

  Here is the list of handlers that can be set.  To set a handler on an
‘xmlparser’ object _o_, use ‘o.handlername = func’.  _handlername_ must
be taken from the following list, and _func_ must be a callable object
accepting the correct number of arguments.  The arguments are all
strings, unless otherwise stated.

 -- Method: xmlparser.XmlDeclHandler (version, encoding, standalone)

     Called when the XML declaration is parsed.  The XML declaration is
     the (optional) declaration of the applicable version of the XML
     recommendation, the encoding of the document text, and an optional
     "standalone" declaration.  _version_ and _encoding_ will be strings
     of the type dictated by the *note returns_unicode: 1ba2. attribute,
     and _standalone_ will be ‘1’ if the document is declared
     standalone, ‘0’ if it is declared not to be standalone, or ‘-1’ if
     the standalone clause was omitted.  This is only available with
     Expat version 1.95.0 or newer.

     New in version 2.1.

 -- Method: xmlparser.StartDoctypeDeclHandler (doctypeName, systemId,
          publicId, has_internal_subset)

     Called when Expat begins parsing the document type declaration
     (‘<!DOCTYPE ...’).  The _doctypeName_ is provided exactly as
     presented.  The _systemId_ and _publicId_ parameters give the
     system and public identifiers if specified, or ‘None’ if omitted.
     _has_internal_subset_ will be true if the document contains and
     internal document declaration subset.  This requires Expat version
     1.2 or newer.

 -- Method: xmlparser.EndDoctypeDeclHandler ()

     Called when Expat is done parsing the document type declaration.
     This requires Expat version 1.2 or newer.

 -- Method: xmlparser.ElementDeclHandler (name, model)

     Called once for each element type declaration.  _name_ is the name
     of the element type, and _model_ is a representation of the content
     model.

 -- Method: xmlparser.AttlistDeclHandler (elname, attname, type,
          default, required)

     Called for each declared attribute for an element type.  If an
     attribute list declaration declares three attributes, this handler
     is called three times, once for each attribute.  _elname_ is the
     name of the element to which the declaration applies and _attname_
     is the name of the attribute declared.  The attribute type is a
     string passed as _type_; the possible values are ‘'CDATA'’, ‘'ID'’,
     ‘'IDREF'’, ...  _default_ gives the default value for the attribute
     used when the attribute is not specified by the document instance,
     or ‘None’ if there is no default value (‘#IMPLIED’ values).  If the
     attribute is required to be given in the document instance,
     _required_ will be true.  This requires Expat version 1.95.0 or
     newer.

 -- Method: xmlparser.StartElementHandler (name, attributes)

     Called for the start of every element.  _name_ is a string
     containing the element name, and _attributes_ is a dictionary
     mapping attribute names to their values.

 -- Method: xmlparser.EndElementHandler (name)

     Called for the end of every element.

 -- Method: xmlparser.ProcessingInstructionHandler (target, data)

     Called for every processing instruction.

 -- Method: xmlparser.CharacterDataHandler (data)

     Called for character data.  This will be called for normal
     character data, CDATA marked content, and ignorable whitespace.
     Applications which must distinguish these cases can use the *note
     StartCdataSectionHandler: 1bb9, *note EndCdataSectionHandler: 1bba,
     and *note ElementDeclHandler: 1bb4. callbacks to collect the
     required information.

 -- Method: xmlparser.UnparsedEntityDeclHandler (entityName, base,
          systemId, publicId, notationName)

     Called for unparsed (NDATA) entity declarations.  This is only
     present for version 1.2 of the Expat library; for more recent
     versions, use *note EntityDeclHandler: 1bbb. instead.  (The
     underlying function in the Expat library has been declared
     obsolete.)

 -- Method: xmlparser.EntityDeclHandler (entityName,
          is_parameter_entity, value, base, systemId, publicId,
          notationName)

     Called for all entity declarations.  For parameter and internal
     entities, _value_ will be a string giving the declared contents of
     the entity; this will be ‘None’ for external entities.  The
     _notationName_ parameter will be ‘None’ for parsed entities, and
     the name of the notation for unparsed entities.
     _is_parameter_entity_ will be true if the entity is a parameter
     entity or false for general entities (most applications only need
     to be concerned with general entities).  This is only available
     starting with version 1.95.0 of the Expat library.

     New in version 2.1.

 -- Method: xmlparser.NotationDeclHandler (notationName, base, systemId,
          publicId)

     Called for notation declarations.  _notationName_, _base_, and
     _systemId_, and _publicId_ are strings if given.  If the public
     identifier is omitted, _publicId_ will be ‘None’.

 -- Method: xmlparser.StartNamespaceDeclHandler (prefix, uri)

     Called when an element contains a namespace declaration.  Namespace
     declarations are processed before the *note StartElementHandler:
     1bb6. is called for the element on which declarations are placed.

 -- Method: xmlparser.EndNamespaceDeclHandler (prefix)

     Called when the closing tag is reached for an element that
     contained a namespace declaration.  This is called once for each
     namespace declaration on the element in the reverse of the order
     for which the *note StartNamespaceDeclHandler: 1bbc. was called to
     indicate the start of each namespace declaration’s scope.  Calls to
     this handler are made after the corresponding *note
     EndElementHandler: 1bb7. for the end of the element.

 -- Method: xmlparser.CommentHandler (data)

     Called for comments.  _data_ is the text of the comment, excluding
     the leading ‘'<!-’‘-'’ and trailing ‘'-’‘->'’.

 -- Method: xmlparser.StartCdataSectionHandler ()

     Called at the start of a CDATA section.  This and *note
     EndCdataSectionHandler: 1bba. are needed to be able to identify the
     syntactical start and end for CDATA sections.

 -- Method: xmlparser.EndCdataSectionHandler ()

     Called at the end of a CDATA section.

 -- Method: xmlparser.DefaultHandler (data)

     Called for any characters in the XML document for which no
     applicable handler has been specified.  This means characters that
     are part of a construct which could be reported, but for which no
     handler has been supplied.

 -- Method: xmlparser.DefaultHandlerExpand (data)

     This is the same as the *note DefaultHandler(): 1bbf, but doesn’t
     inhibit expansion of internal entities.  The entity reference will
     not be passed to the default handler.

 -- Method: xmlparser.NotStandaloneHandler ()

     Called if the XML document hasn’t been declared as being a
     standalone document.  This happens when there is an external subset
     or a reference to a parameter entity, but the XML declaration does
     not set standalone to ‘yes’ in an XML declaration.  If this handler
     returns ‘0’, then the parser will raise an
     ‘XML_ERROR_NOT_STANDALONE’ error.  If this handler is not set, no
     exception is raised by the parser for this condition.

 -- Method: xmlparser.ExternalEntityRefHandler (context, base, systemId,
          publicId)

     Called for references to external entities.  _base_ is the current
     base, as set by a previous call to *note SetBase(): 1b9a.  The
     public and system identifiers, _systemId_ and _publicId_, are
     strings if given; if the public identifier is not given, _publicId_
     will be ‘None’.  The _context_ value is opaque and should only be
     used as described below.

     For external entities to be parsed, this handler must be
     implemented.  It is responsible for creating the sub-parser using
     ‘ExternalEntityParserCreate(context)’, initializing it with the
     appropriate callbacks, and parsing the entity.  This handler should
     return an integer; if it returns ‘0’, the parser will raise an
     ‘XML_ERROR_EXTERNAL_ENTITY_HANDLING’ error, otherwise parsing will
     continue.

     If this handler is not provided, external entities are reported by
     the *note DefaultHandler: 1bbf. callback, if provided.


File: python.info,  Node: ExpatError Exceptions,  Next: Example<11>,  Prev: XMLParser Objects<2>,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.15.2 ExpatError Exceptions
...............................

*note ExpatError: 1b90. exceptions have a number of interesting
attributes:

 -- Attribute: ExpatError.code

     Expat’s internal error number for the specific error.  This will
     match one of the constants defined in the ‘errors’ object from this
     module.

     New in version 2.1.

 -- Attribute: ExpatError.lineno

     Line number on which the error was detected.  The first line is
     numbered ‘1’.

     New in version 2.1.

 -- Attribute: ExpatError.offset

     Character offset into the line where the error occurred.  The first
     column is numbered ‘0’.

     New in version 2.1.


File: python.info,  Node: Example<11>,  Next: Content Model Descriptions,  Prev: ExpatError Exceptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.15.3 Example
.................

The following program defines three handlers that just print out their
arguments.

     import xml.parsers.expat

     # 3 handler functions
     def start_element(name, attrs):
         print 'Start element:', name, attrs
     def end_element(name):
         print 'End element:', name
     def char_data(data):
         print 'Character data:', repr(data)

     p = xml.parsers.expat.ParserCreate()

     p.StartElementHandler = start_element
     p.EndElementHandler = end_element
     p.CharacterDataHandler = char_data

     p.Parse("""<?xml version="1.0"?>
     <parent id="top"><child1 name="paul">Text goes here</child1>
     <child2 name="fred">More text</child2>
     </parent>""", 1)

  The output from this program is:

     Start element: parent {'id': 'top'}
     Start element: child1 {'name': 'paul'}
     Character data: 'Text goes here'
     End element: child1
     Character data: '\n'
     Start element: child2 {'name': 'fred'}
     Character data: 'More text'
     End element: child2
     Character data: '\n'
     End element: parent


File: python.info,  Node: Content Model Descriptions,  Next: Expat error constants,  Prev: Example<11>,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.15.4 Content Model Descriptions
....................................

Content modules are described using nested tuples.  Each tuple contains
four values: the type, the quantifier, the name, and a tuple of
children.  Children are simply additional content module descriptions.

  The values of the first two fields are constants defined in the
‘model’ object of the *note xml.parsers.expat: 1a5. module.  These
constants can be collected in two groups: the model type group and the
quantifier group.

  The constants in the model type group are:

 -- Data: xml.parsers.expat.XML_CTYPE_ANY

     The element named by the model name was declared to have a content
     model of ‘ANY’.

 -- Data: xml.parsers.expat.XML_CTYPE_CHOICE

     The named element allows a choice from a number of options; this is
     used for content models such as ‘(A | B | C)’.

 -- Data: xml.parsers.expat.XML_CTYPE_EMPTY

     Elements which are declared to be ‘EMPTY’ have this model type.

 -- Data: xml.parsers.expat.XML_CTYPE_MIXED

 -- Data: xml.parsers.expat.XML_CTYPE_NAME

 -- Data: xml.parsers.expat.XML_CTYPE_SEQ

     Models which represent a series of models which follow one after
     the other are indicated with this model type.  This is used for
     models such as ‘(A, B, C)’.

  The constants in the quantifier group are:

 -- Data: xml.parsers.expat.XML_CQUANT_NONE

     No modifier is given, so it can appear exactly once, as for ‘A’.

 -- Data: xml.parsers.expat.XML_CQUANT_OPT

     The model is optional: it can appear once or not at all, as for
     ‘A?’.

 -- Data: xml.parsers.expat.XML_CQUANT_PLUS

     The model must occur one or more times (like ‘A+’).

 -- Data: xml.parsers.expat.XML_CQUANT_REP

     The model must occur zero or more times, as for ‘A*’.


File: python.info,  Node: Expat error constants,  Prev: Content Model Descriptions,  Up: xml parsers expat --- Fast XML parsing using Expat

5.19.15.5 Expat error constants
...............................

The following constants are provided in the ‘errors’ object of the *note
xml.parsers.expat: 1a5. module.  These constants are useful in
interpreting some of the attributes of the *note ExpatError: 1b90.
exception objects raised when an error has occurred.

  The ‘errors’ object has the following attributes:

 -- Data: xml.parsers.expat.XML_ERROR_ASYNC_ENTITY

 -- Data: xml.parsers.expat.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF

     An entity reference in an attribute value referred to an external
     entity instead of an internal entity.

 -- Data: xml.parsers.expat.XML_ERROR_BAD_CHAR_REF

     A character reference referred to a character which is illegal in
     XML (for example, character ‘0’, or ’‘&#0;’’).

 -- Data: xml.parsers.expat.XML_ERROR_BINARY_ENTITY_REF

     An entity reference referred to an entity which was declared with a
     notation, so cannot be parsed.

 -- Data: xml.parsers.expat.XML_ERROR_DUPLICATE_ATTRIBUTE

     An attribute was used more than once in a start tag.

 -- Data: xml.parsers.expat.XML_ERROR_INCORRECT_ENCODING

 -- Data: xml.parsers.expat.XML_ERROR_INVALID_TOKEN

     Raised when an input byte could not properly be assigned to a
     character; for example, a NUL byte (value ‘0’) in a UTF-8 input
     stream.

 -- Data: xml.parsers.expat.XML_ERROR_JUNK_AFTER_DOC_ELEMENT

     Something other than whitespace occurred after the document
     element.

 -- Data: xml.parsers.expat.XML_ERROR_MISPLACED_XML_PI

     An XML declaration was found somewhere other than the start of the
     input data.

 -- Data: xml.parsers.expat.XML_ERROR_NO_ELEMENTS

     The document contains no elements (XML requires all documents to
     contain exactly one top-level element)..

 -- Data: xml.parsers.expat.XML_ERROR_NO_MEMORY

     Expat was not able to allocate memory internally.

 -- Data: xml.parsers.expat.XML_ERROR_PARAM_ENTITY_REF

     A parameter entity reference was found where it was not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_PARTIAL_CHAR

     An incomplete character was found in the input.

 -- Data: xml.parsers.expat.XML_ERROR_RECURSIVE_ENTITY_REF

     An entity reference contained another reference to the same entity;
     possibly via a different name, and possibly indirectly.

 -- Data: xml.parsers.expat.XML_ERROR_SYNTAX

     Some unspecified syntax error was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_TAG_MISMATCH

     An end tag did not match the innermost open start tag.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_TOKEN

     Some token (such as a start tag) was not closed before the end of
     the stream or the next token was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_UNDEFINED_ENTITY

     A reference was made to a entity which was not defined.

 -- Data: xml.parsers.expat.XML_ERROR_UNKNOWN_ENCODING

     The document encoding is not supported by Expat.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_CDATA_SECTION

     A CDATA marked section was not closed.

 -- Data: xml.parsers.expat.XML_ERROR_EXTERNAL_ENTITY_HANDLING

 -- Data: xml.parsers.expat.XML_ERROR_NOT_STANDALONE

     The parser determined that the document was not "standalone" though
     it declared itself to be in the XML declaration, and the
     ‘NotStandaloneHandler’ was set and returned ‘0’.

 -- Data: xml.parsers.expat.XML_ERROR_UNEXPECTED_STATE

 -- Data: xml.parsers.expat.XML_ERROR_ENTITY_DECLARED_IN_PE

 -- Data: xml.parsers.expat.XML_ERROR_FEATURE_REQUIRES_XML_DTD

     An operation was requested that requires DTD support to be compiled
     in, but Expat was configured without DTD support.  This should
     never be reported by a standard build of the *note
     xml.parsers.expat: 1a5. module.

 -- Data: xml.parsers.expat.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING

     A behavioral change was requested after parsing started that can
     only be changed before parsing has started.  This is (currently)
     only raised by ‘UseForeignDTD()’.

 -- Data: xml.parsers.expat.XML_ERROR_UNBOUND_PREFIX

     An undeclared prefix was found when namespace processing was
     enabled.

 -- Data: xml.parsers.expat.XML_ERROR_UNDECLARING_PREFIX

     The document attempted to remove the namespace declaration
     associated with a prefix.

 -- Data: xml.parsers.expat.XML_ERROR_INCOMPLETE_PE

     A parameter entity contained incomplete markup.

 -- Data: xml.parsers.expat.XML_ERROR_XML_DECL

     The document contained no document element at all.

 -- Data: xml.parsers.expat.XML_ERROR_TEXT_DECL

     There was an error parsing a text declaration in an external
     entity.

 -- Data: xml.parsers.expat.XML_ERROR_PUBLICID

     Characters were found in the public id that are not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPENDED

     The requested operation was made on a suspended parser, but isn’t
     allowed.  This includes attempts to provide additional input or to
     stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_NOT_SUSPENDED

     An attempt to resume the parser was made when the parser had not
     been suspended.

 -- Data: xml.parsers.expat.XML_ERROR_ABORTED

     This should not be reported to Python applications.

 -- Data: xml.parsers.expat.XML_ERROR_FINISHED

     The requested operation was made on a parser which was finished
     parsing input, but isn’t allowed.  This includes attempts to
     provide additional input or to stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPEND_PE


File: python.info,  Node: Internet Protocols and Support,  Next: Multimedia Services,  Prev: Structured Markup Processing Tools,  Up: The Python Standard Library

5.20 Internet Protocols and Support
===================================

The modules described in this chapter implement Internet protocols and
support for related technology.  They are all implemented in Python.
Most of these modules require the presence of the system-dependent
module *note socket: 15c, which is currently supported on most popular
platforms.  Here is an overview:

* Menu:

* webbrowser: webbrowser --- Convenient Web-browser controller. Convenient Web-browser controller
* cgi: cgi --- Common Gateway Interface support. Common Gateway Interface support
* cgitb: cgitb --- Traceback manager for CGI scripts. Traceback manager for CGI scripts
* wsgiref: wsgiref --- WSGI Utilities and Reference Implementation. WSGI Utilities and Reference Implementation
* urllib: urllib --- Open arbitrary resources by URL. Open arbitrary resources by URL
* urllib2: urllib2 --- extensible library for opening URLs. extensible library for opening URLs
* httplib: httplib --- HTTP protocol client. HTTP protocol client
* ftplib: ftplib --- FTP protocol client. FTP protocol client
* poplib: poplib --- POP3 protocol client. POP3 protocol client
* imaplib: imaplib --- IMAP4 protocol client. IMAP4 protocol client
* nntplib: nntplib --- NNTP protocol client. NNTP protocol client
* smtplib: smtplib --- SMTP protocol client. SMTP protocol client
* smtpd: smtpd --- SMTP Server. SMTP Server
* telnetlib: telnetlib --- Telnet client. Telnet client
* uuid: uuid --- UUID objects according to RFC 4122. UUID objects according to RFC 4122
* urlparse: urlparse --- Parse URLs into components. Parse URLs into components
* SocketServer: SocketServer --- A framework for network servers. A framework for network servers
* BaseHTTPServer: BaseHTTPServer --- Basic HTTP server. Basic HTTP server
* SimpleHTTPServer: SimpleHTTPServer --- Simple HTTP request handler. Simple HTTP request handler
* CGIHTTPServer: CGIHTTPServer --- CGI-capable HTTP request handler. CGI-capable HTTP request handler
* cookielib: cookielib --- Cookie handling for HTTP clients. Cookie handling for HTTP clients
* Cookie: Cookie --- HTTP state management. HTTP state management
* xmlrpclib: xmlrpclib --- XML-RPC client access. XML-RPC client access
* SimpleXMLRPCServer: SimpleXMLRPCServer --- Basic XML-RPC server. Basic XML-RPC server
* DocXMLRPCServer: DocXMLRPCServer --- Self-documenting XML-RPC server. Self-documenting XML-RPC server

webbrowser — Convenient Web-browser controller

* Browser Controller Objects:: 

cgi — Common Gateway Interface support

* Introduction: Introduction<8>. 
* Using the cgi module:: 
* Higher Level Interface:: 
* Old classes:: 
* Functions: Functions<5>. 
* Caring about security:: 
* Installing your CGI script on a Unix system:: 
* Testing your CGI script:: 
* Debugging CGI scripts:: 
* Common problems and solutions:: 

wsgiref — WSGI Utilities and Reference Implementation

* wsgiref.util: wsgiref util -- WSGI environment utilities. WSGI environment utilities
* wsgiref.headers: wsgiref headers -- WSGI response header tools. WSGI response header tools
* wsgiref.simple_server: wsgiref simple_server -- a simple WSGI HTTP server. a simple WSGI HTTP server
* wsgiref.validate: wsgiref validate --- WSGI conformance checker. WSGI conformance checker
* wsgiref.handlers: wsgiref handlers -- server/gateway base classes. server/gateway base classes
* Examples: Examples<11>. 

urllib — Open arbitrary resources by URL

* High-level interface:: 
* Utility functions: Utility functions<2>. 
* URL Opener objects:: 
* urllib Restrictions:: 
* Examples: Examples<12>. 

urllib2 — extensible library for opening URLs

* Request Objects:: 
* OpenerDirector Objects:: 
* BaseHandler Objects:: 
* HTTPRedirectHandler Objects:: 
* HTTPCookieProcessor Objects:: 
* ProxyHandler Objects:: 
* HTTPPasswordMgr Objects:: 
* AbstractBasicAuthHandler Objects:: 
* HTTPBasicAuthHandler Objects:: 
* ProxyBasicAuthHandler Objects:: 
* AbstractDigestAuthHandler Objects:: 
* HTTPDigestAuthHandler Objects:: 
* ProxyDigestAuthHandler Objects:: 
* HTTPHandler Objects:: 
* HTTPSHandler Objects:: 
* FileHandler Objects:: 
* FTPHandler Objects:: 
* CacheFTPHandler Objects:: 
* UnknownHandler Objects:: 
* HTTPErrorProcessor Objects:: 
* Examples: Examples<13>. 

httplib — HTTP protocol client

* HTTPConnection Objects:: 
* HTTPResponse Objects:: 
* Examples: Examples<14>. 

ftplib — FTP protocol client

* FTP Objects:: 
* FTP_TLS Objects:: 

poplib — POP3 protocol client

* POP3 Objects:: 
* POP3 Example:: 

imaplib — IMAP4 protocol client

* IMAP4 Objects:: 
* IMAP4 Example:: 

nntplib — NNTP protocol client

* NNTP Objects:: 

smtplib — SMTP protocol client

* SMTP Objects:: 
* SMTP Example:: 

smtpd — SMTP Server

* SMTPServer Objects:: 
* DebuggingServer Objects:: 
* PureProxy Objects:: 
* MailmanProxy Objects:: 

telnetlib — Telnet client

* Telnet Objects:: 
* Telnet Example:: 

uuid — UUID objects according to RFC 4122

* Example: Example<12>. 

urlparse — Parse URLs into components

* Results of urlparse() and urlsplit(): Results of urlparse and urlsplit. 

SocketServer — A framework for network servers

* Server Creation Notes:: 
* Server Objects:: 
* RequestHandler Objects:: 
* Examples: Examples<15>. 

Examples

* SocketServer.TCPServer Example: SocketServer TCPServer Example. 
* SocketServer.UDPServer Example: SocketServer UDPServer Example. 
* Asynchronous Mixins:: 

BaseHTTPServer — Basic HTTP server

* More examples:: 

cookielib — Cookie handling for HTTP clients

* CookieJar and FileCookieJar Objects:: 
* FileCookieJar subclasses and co-operation with web browsers:: 
* CookiePolicy Objects:: 
* DefaultCookiePolicy Objects:: 
* Cookie Objects:: 
* Examples: Examples<16>. 

Cookie — HTTP state management

* Cookie Objects: Cookie Objects<2>. 
* Morsel Objects:: 
* Example: Example<13>. 

xmlrpclib — XML-RPC client access

* ServerProxy Objects:: 
* Boolean Objects:: 
* DateTime Objects:: 
* Binary Objects:: 
* Fault Objects:: 
* ProtocolError Objects:: 
* MultiCall Objects:: 
* Convenience Functions:: 
* Example of Client Usage:: 
* Example of Client and Server Usage:: 

SimpleXMLRPCServer — Basic XML-RPC server

* SimpleXMLRPCServer Objects:: 
* CGIXMLRPCRequestHandler:: 

SimpleXMLRPCServer Objects

* SimpleXMLRPCServer Example:: 

DocXMLRPCServer — Self-documenting XML-RPC server

* DocXMLRPCServer Objects:: 
* DocCGIXMLRPCRequestHandler:: 


File: python.info,  Node: webbrowser --- Convenient Web-browser controller,  Next: cgi --- Common Gateway Interface support,  Up: Internet Protocols and Support

5.20.1 ‘webbrowser’ — Convenient Web-browser controller
-------------------------------------------------------

*Source code:* Lib/webbrowser.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  The *note webbrowser: 196. module provides a high-level interface to
allow displaying Web-based documents to users.  Under most
circumstances, simply calling the *note open(): 1bd1. function from this
module will do the right thing.

  Under Unix, graphical browsers are preferred under X11, but text-mode
browsers will be used if graphical browsers are not available or an X11
display isn’t available.  If text-mode browsers are used, the calling
process will block until the user exits the browser.

  If the environment variable ‘BROWSER’ exists, it is interpreted to
override the platform default list of browsers, as a *note os.pathsep:
64d.-separated list of browsers to try in order.  When the value of a
list part contains the string ‘%s’, then it is interpreted as a literal
browser command line to be used with the argument URL substituted for
‘%s’; if the part does not contain ‘%s’, it is simply interpreted as the
name of the browser to launch.  (2)

  For non-Unix platforms, or when a remote browser is available on Unix,
the controlling process will not wait for the user to finish with the
browser, but allow the remote browser to maintain its own windows on the
display.  If remote browsers are not available on Unix, the controlling
process will launch a new browser and wait.

  The script *webbrowser* can be used as a command-line interface for
the module.  It accepts an URL as the argument.  It accepts the
following optional parameters: ‘-n’ opens the URL in a new browser
window, if possible; ‘-t’ opens the URL in a new browser page ("tab").
The options are, naturally, mutually exclusive.  Usage example:

     python -m webbrowser -t "http://www.python.org"

  The following exception is defined:

 -- Exception: webbrowser.Error

     Exception raised when a browser control error occurs.

  The following functions are defined:

 -- Function: webbrowser.open (url, new=0, autoraise=True)

     Display _url_ using the default browser.  If _new_ is 0, the _url_
     is opened in the same browser window if possible.  If _new_ is 1, a
     new browser window is opened if possible.  If _new_ is 2, a new
     browser page ("tab") is opened if possible.  If _autoraise_ is
     ‘True’, the window is raised if possible (note that under many
     window managers this will occur regardless of the setting of this
     variable).

     Note that on some platforms, trying to open a filename using this
     function, may work and start the operating system’s associated
     program.  However, this is neither supported nor portable.

     Changed in version 2.5: _new_ can now be 2.

 -- Function: webbrowser.open_new (url)

     Open _url_ in a new window of the default browser, if possible,
     otherwise, open _url_ in the only browser window.

 -- Function: webbrowser.open_new_tab (url)

     Open _url_ in a new page ("tab") of the default browser, if
     possible, otherwise equivalent to *note open_new(): 1bd3.

     New in version 2.5.

 -- Function: webbrowser.get ([name])

     Return a controller object for the browser type _name_.  If _name_
     is empty, return a controller for a default browser appropriate to
     the caller’s environment.

 -- Function: webbrowser.register (name, constructor[, instance])

     Register the browser type _name_.  Once a browser type is
     registered, the *note get(): 1bd5. function can return a controller
     for that browser type.  If _instance_ is not provided, or is
     ‘None’, _constructor_ will be called without parameters to create
     an instance when needed.  If _instance_ is provided, _constructor_
     will never be called, and may be ‘None’.

     This entry point is only useful if you plan to either set the
     ‘BROWSER’ variable or call *note get(): 1bd5. with a nonempty
     argument matching the name of a handler you declare.

  A number of browser types are predefined.  This table gives the type
names that may be passed to the *note get(): 1bd5. function and the
corresponding instantiations for the controller classes, all defined in
this module.

Type Name                   Class Name                                    Notes
                                                                          
--------------------------------------------------------------------------------------
                                                                          
‘'mozilla'’                 ‘Mozilla('mozilla')’
                            
                                                                          
‘'firefox'’                 ‘Mozilla('mozilla')’
                            
                                                                          
‘'netscape'’                ‘Mozilla('netscape')’
                            
                                                                          
‘'galeon'’                  ‘Galeon('galeon')’
                            
                                                                          
‘'epiphany'’                ‘Galeon('epiphany')’
                            
                                                                          
‘'skipstone'’               ‘BackgroundBrowser('skipstone')’
                            
                                                                          
‘'kfmclient'’               ‘Konqueror()’                                 (1)
                                                                          
                                                                          
‘'konqueror'’               ‘Konqueror()’                                 (1)
                                                                          
                                                                          
‘'kfm'’                     ‘Konqueror()’                                 (1)
                                                                          
                                                                          
‘'mosaic'’                  ‘BackgroundBrowser('mosaic')’
                            
                                                                          
‘'opera'’                   ‘Opera()’
                            
                                                                          
‘'grail'’                   ‘Grail()’
                            
                                                                          
‘'links'’                   ‘GenericBrowser('links')’
                            
                                                                          
‘'elinks'’                  ‘Elinks('elinks')’
                            
                                                                          
‘'lynx'’                    ‘GenericBrowser('lynx')’
                            
                                                                          
‘'w3m'’                     ‘GenericBrowser('w3m')’
                            
                                                                          
‘'windows-default'’         ‘WindowsDefault’                              (2)
                                                                          
                                                                          
‘'macosx'’                  ‘MacOSX('default')’                           (3)
                                                                          
                                                                          
‘'safari'’                  ‘MacOSX('safari')’                            (3)
                                                                          

  Notes:

  1. "Konqueror" is the file manager for the KDE desktop environment for
     Unix, and only makes sense to use if KDE is running.  Some way of
     reliably detecting KDE would be nice; the ‘KDEDIR’ variable is not
     sufficient.  Note also that the name "kfm" is used even when using
     the *konqueror* command with KDE 2 — the implementation selects the
     best strategy for running Konqueror.

  2. Only on Windows platforms.

  3. Only on Mac OS X platform.

  Here are some simple examples:

     url = 'http://www.python.org/'

     # Open URL in a new tab, if a browser window is already open.
     webbrowser.open_new_tab(url + 'doc/')

     # Open URL in new window, raising the window if possible.
     webbrowser.open_new(url)

* Menu:

* Browser Controller Objects:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/webbrowser.py

   (2) Executables named here without a full path will be searched in
the directories given in the ‘PATH’ environment variable.


File: python.info,  Node: Browser Controller Objects,  Up: webbrowser --- Convenient Web-browser controller

5.20.1.1 Browser Controller Objects
...................................

Browser controllers provide these methods which parallel three of the
module-level convenience functions:

 -- Method: controller.open (url, new=0, autoraise=True)

     Display _url_ using the browser handled by this controller.  If
     _new_ is 1, a new browser window is opened if possible.  If _new_
     is 2, a new browser page ("tab") is opened if possible.

 -- Method: controller.open_new (url)

     Open _url_ in a new window of the browser handled by this
     controller, if possible, otherwise, open _url_ in the only browser
     window.  Alias *note open_new(): 1bd3.

 -- Method: controller.open_new_tab (url)

     Open _url_ in a new page ("tab") of the browser handled by this
     controller, if possible, otherwise equivalent to *note open_new():
     1bd3.

     New in version 2.5.


File: python.info,  Node: cgi --- Common Gateway Interface support,  Next: cgitb --- Traceback manager for CGI scripts,  Prev: webbrowser --- Convenient Web-browser controller,  Up: Internet Protocols and Support

5.20.2 ‘cgi’ — Common Gateway Interface support
-----------------------------------------------

*Source code:* Lib/cgi.py(1)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 

  Support module for Common Gateway Interface (CGI) scripts.

  This module defines a number of utilities for use by CGI scripts
written in Python.

* Menu:

* Introduction: Introduction<8>. 
* Using the cgi module:: 
* Higher Level Interface:: 
* Old classes:: 
* Functions: Functions<5>. 
* Caring about security:: 
* Installing your CGI script on a Unix system:: 
* Testing your CGI script:: 
* Debugging CGI scripts:: 
* Common problems and solutions:: 

   ---------- Footnotes ----------

   (1) http://hg.python.org/cpython/file/2.7/Lib/cgi.py


File: python.info,  Node: Introduction<8>,  Next: Using the cgi module,  Up: cgi --- Common Gateway Interface support

5.20.2.1 Introduction
.....................

A CGI script is invoked by an HTTP server, usually to process user input
submitted through an HTML ‘<FORM>’ or ‘<ISINDEX>’ element.

  Most often, CGI scripts live in the server’s special ‘cgi-bin’
directory.  The HTTP server places all sorts of information about the
request (such as the client’s hostname, the requested URL, the query
string, and lots of other goodies) in the script’s shell environment,
executes the script, and sends the script’s output back to the client.

  The script’s input is connected to the client too, and sometimes the
form data is read this way; at other times the form data is passed via
the "query string" part of the URL. This module is intended to take care
of the different cases and provide a simpler interface to the Python
script.  It also provides a number of utilities that help in debugging
scripts, and the latest addition is support for file uploads from a form
(if your browser supports it).

  The output of a CGI script should consist of two sections, separated
by a blank line.  The first section contains a number of headers,
telling the client what kind of data is following.  Python code to
generate a minimal header section looks like this:

     print "Content-Type: text/html"     # HTML is following
     print                               # blank line, end of headers

  The second section is usually HTML, which allows the client software
to display nicely formatted text with header, in-line images, etc.
Here’s Python code that prints a simple piece of HTML:

     print "<TITLE>CGI script output</TITLE>"
     print "<H1>This is my first CGI script</H1>"
     print "Hello, world!"


File: python.info,  Node: Using the cgi module,  Next: Higher Level Interface,  Prev: Introduction<8>,  Up: cgi --- Common Gateway Interface support

5.20.2.2 Using the cgi module
.............................

Begin by writing ‘import cgi’.  Do not use ‘from cgi import *’ — the
module defines all sorts of names for its own use or for backward
compatibility that you don’t want in your namespace.

  When you write a new script, consider adding these lines:

     import cgitb
     cgitb.enable()

  This activates a special exception handler that will display detailed
reports in the Web browser if any errors occur.  If you’d rather not
show the guts of your program to users of your script, you can have the
reports saved to files instead, with code like this:

     import cgitb
     cgitb.enable(display=0, logdir="/path/to/logdir")

  It’s very helpful to use this feature during script development.  The
reports produced by *note cgitb: 5e. provide information that can save
you a lot of time in tracking down bugs.  You can always remove the
‘cgitb’ line later when you have tested your script and are confident
that it works correctly.

  To get at submitted form data, it’s best to use the ‘FieldStorage’
class.  The other classes defined in this module are provided mostly for
backward compatibility.  Instantiate it exactly once, without arguments.
This reads the form contents from standard input or the environment
(depending on the value of various environment variables set according
to the CGI standard).  Since it may consume standard input, it should be
instantiated only once.

  The ‘FieldStorage’ instance can be indexed like a Python dictionary.
It allows membership testing with the *note in: 428. operator, and also
supports the standard dictionary method *note keys(): 1e1. and the
built-in function *note len(): 520.  Form fields containing empty
strings are ignored and do not appear in the dictionary; to keep such
values, provide a true value for the optional _keep_blank_values_
keyword parameter when creating the ‘FieldStorage’ instance.

  For instance, the following code (which assumes that the
‘Content-Type’ header and blank line have already been printed) checks
that the fields ‘name’ and ‘addr’ are both set to a non-empty string:

     form = cgi.FieldStorage()
     if "name" not in form or "addr" not in form:
         print "<H1>Error</H1>"
         print "Please fill in the name and addr fields."
         return
     print "<p>name:", form["name"].value
     print "<p>addr:", form["addr"].value
     ...further form processing here...

  Here the fields, accessed through ‘form[key]’, are themselves
instances of ‘FieldStorage’ (or ‘MiniFieldStorage’, depending on the
form encoding).  The ‘value’ attribute of the instance yields the string
value of the field.  The ‘getvalue()’ method returns this string value
directly; it also accepts an optional second argument as a default to
return if the requested key is not present.

  If the submitted form data contains more than one field with the same
name, the object retrieved by ‘form[key]’ is not a ‘FieldStorage’ or
‘MiniFieldStorage’ instance but a list of such instances.  Similarly, in
this situation, ‘form.getvalue(key)’ would return a list of strings.  If
you expect this possibility (when your HTML form contains multiple
fields with the same name), use the *note getlist(): 1be2. method, which
always returns a list of values (so that you do not need to special-case
the single item case).  For example, this code concatenates any number
of username fields, separated by commas:

     value = form.getlist("username")
     usernames = ",".join(value)

  If a field represents an uploaded file, accessing the value via the
‘value’ attribute or the ‘getvalue()’ method reads the entire file in
memory as a string.  This may not be what you want.  You can test for an
uploaded file by testing either the ‘filename’ attribute or the ‘file’
attribute.  You can then read the data at leisure from the ‘file’
attribute:

     fileitem = form["userfile"]
     if fileitem.file:
         # It's an uploaded file; count lines
         linecount = 0
         while 1:
             line = fileitem.file.readline()
             if not line: break
             linecount = linecount + 1

  If an error is encountered when obtaining the contents of an uploaded
file (for example, when the user interrupts the form submission by
clicking on a Back or Cancel button) the ‘done’ attribute of the object
for the field will be set to the value -1.

  The file upload draft standard entertains the possibility of uploading
multiple files from one field (using a recursive ‘multipart/*’
encoding).  When this occurs, the item will be a dictionary-like
‘FieldStorage’ item.  This can be determined by testing its ‘type’
attribute, which should be ‘multipart/form-data’ (or perhaps another
MIME type matching ‘multipart/*’).  In this case, it can be iterated
over recursively just like the top-level form object.

  When a form is submitted in the "old" format (as the query string or
as a single data part of type ‘application/x-www-form-urlencoded’), the
items will actually be instances of the class ‘MiniFieldStorage’.  In
this case, the ‘list’, ‘file’, and ‘filename’ attributes are always
‘None’.

  A form submitted via POST that also has a query string will contain
both ‘FieldStorage’ and ‘MiniFieldStorage’ items.


File: python.info,  Node: Higher Level Interface,  Next: Old classes,  Prev: Using the cgi module,  Up: cgi --- Common Gateway Interface support

5.20.2.3 Higher Level Interface
...............................

New in version 2.2.

  The previous section explains how to read CGI form data using the
‘FieldStorage’ class.  This section describes a higher level interface
which was added to this class to allow one to do it in a more readable
and intuitive way.  The interface doesn’t make the techniques described
in previous sections obsolete — they are still useful to process file
uploads efficiently, for example.

  The interface consists of two simple methods.  Using the methods you
can process form data in a generic way, without the need to worry
whether only one or more values were posted under one name.

  In the previous section, you learned to write following code anytime
you expected a user to post more than one value under one name:

     item = form.getvalue("item")
     if isinstance(item, list):
         # The user is requesting more than one item.
     else:
         # The user is requesting only one item.

  This situation is common for example when a form contains a group of
multiple checkboxes with the same name:

     <input type="checkbox" name="item" value="1" />
     <input type="checkbox" name="item" value="2" />

  In most situations, however, there’s only one form control with a
particular name in a form and then you expect and need only one value
associated with this name.  So you write a script containing for example
this code:

     user = form.getvalue("user").upper()

  The problem with the code is that you should never expect that a
client will provide valid input to your scripts.  For example, if a
curious user appends another ‘user=foo’ pair to the query string, then
the script would crash, because in this situation the ‘getvalue("user")’
method call returns a list instead of a string.  Calling the *note
upper(): 8de. method on a list is not valid (since lists do not have a
method of this name) and results in an *note AttributeError: 1f8.
exception.

  Therefore, the appropriate way to read form data values was to always
use the code which checks whether the obtained value is a single value
or a list of values.  That’s annoying and leads to less readable
scripts.

  A more convenient approach is to use the methods *note getfirst():
1be4. and *note getlist(): 1be2. provided by this higher level
interface.

 -- Method: FieldStorage.getfirst (name[, default])

     This method always returns only one value associated with form
     field _name_.  The method returns only the first value in case that
     more values were posted under such name.  Please note that the
     order in which the values are received may vary from browser to
     browser and should not be counted on.  (1) If no such form field or
     value exists then the method returns the value specified by the
     optional parameter _default_.  This parameter defaults to ‘None’ if
     not specified.

 -- Method: FieldStorage.getlist (name)

     This method always returns a list of values associated with form
     field _name_.  The method returns an empty list if no such form
     field or value exists for _name_.  It returns a list consisting of
     one item if only one such value exists.

  Using these methods you can write nice compact code:

     import cgi
     form = cgi.FieldStorage()
     user = form.getfirst("user", "").upper()    # This way it's safe.
     for item in form.getlist("item"):
         do_something(item)

   ---------- Footnotes ----------

   (1) Note that some recent versions of the HTML specification do state
what order the field values should be supplied in, but knowing whether a
request was received from a conforming browser, or even from a browser
at all, is tedious and error-prone.


File: python.info,  Node: Old classes,  Next: Functions<5>,  Prev: Higher Level Interface,  Up: cgi --- Common Gateway Interface support

5.20.2.4 Old classes
....................

Deprecated since version 2.6.

  ‘SvFormContentDict’ stores single value form content as dictionary; it
assumes each field name occurs in the form only once.

  ‘FormContentDict’ stores multiple value form content as a dictionary
(the form items are lists of values).  Useful if your form contains
multiple fields with the same name.

  Other classes (‘FormContent’, ‘InterpFormContentDict’) are present for
backwards compatibility with really old applications only.


File: python.info,  Node: Functions<5>,  Next: Caring about security,  Prev: Old classes,  Up: cgi --- Common Gateway Interface support

5.20.2.5 Functions
..................

These are useful if you want more control, or if you want to employ some
of the algorithms implemented in this module in other circumstances.

 -- Function: cgi.parse (fp[, environ[, keep_blank_values[,
          strict_parsing]]])

     Parse a query in the environment or from a file (the file defaults
     to ‘sys.stdin’ and environment defaults to ‘os.environ’).  The
     _keep_blank_values_ and _strict_parsing_ parameters are passed to
     *note urlparse.parse_qs(): 1be9. unchanged.

 -- Function: cgi.parse_qs (qs[, keep_blank_values[, strict_parsing]])

     This function is deprecated in this module.  Use *note
     urlparse.parse_qs(): 1be9. instead.  It is maintained here only for
     backward compatiblity.

 -- Function: cgi.parse_qsl (qs[, keep_blank_values[, strict_parsing]])

     This function is deprecated in this module.  Use *note
     urlparse.parse_qsl(): 1bec. instead.  It is maintained here only
     for backward compatiblity.

 -- Function: cgi.parse_multipart (fp, pdict)

     Parse input of type ‘multipart/form-data’ (for file uploads).
     Arguments are _fp_ for the input file and _pdict_ for a dictionary
     containing other parameters in the ‘Content-Type’ header.

     Returns a dictionary just like *note urlparse.parse_qs(): 1be9.
     keys are the field names, each value is a list of values for that
     field.  This is easy to use but not much good if you are expecting
     megabytes to be uploaded — in that case, use the ‘FieldStorage’
     class instead which is much more flexible.

     Note that this does not parse nested multipart parts — use
     ‘FieldStorage’ for that.

 -- Function: cgi.parse_header (string)

     Parse a MIME header (such as ‘Content-Type’) into a main value and
     a dictionary of parameters.

 -- Function: cgi.test ()

     Robust test CGI script, usable as main program.  Writes minimal
     HTTP headers and formats all information provided to the script in
     HTML form.

 -- Function: cgi.print_environ ()

     Format the shell environment in HTML.

 -- Function: cgi.print_form (form)

     Format a form in HTML.

 -- Function: cgi.print_directory ()

     Format the current directory in HTML.

 -- Function: cgi.print_environ_usage ()

     Print a list of useful (used by CGI) environment variables in HTML.

 -- Function: cgi.escape (s[, quote])

     Convert the characters ‘'&'’, ‘'<'’ and ‘'>'’ in string _s_ to
     HTML-safe sequences.  Use this if you need to display text that
     might contain such characters in HTML. If the optional flag _quote_
     is true, the quotation mark character (‘"’) is also translated;
     this helps for inclusion in an HTML attribute value delimited by
     double quotes, as in ‘<a href="...">’.  Note that single quotes are
     never translated.

     If the value to be quoted might include single- or double-quote
     characters, or both, consider using the *note quoteattr(): 1b54.
     function in the *note xml.sax.saxutils: 1a8. module instead.


File: python.info,  Node: Caring about security,  Next: Installing your CGI script on a Unix system,  Prev: Functions<5>,  Up: cgi --- Common Gateway Interface support

5.20.2.6 Caring about security
..............................

There’s one important rule: if you invoke an external program (via the
*note os.system(): 3fa. or *note os.popen(): 700. functions.  or others
with similar functionality), make very sure you don’t pass arbitrary
strings received from the client to the shell.  This is a well-known
security hole whereby clever hackers anywhere on the Web can exploit a
gullible CGI script to invoke arbitrary shell commands.  Even parts of
the URL or field names cannot be trusted, since the request doesn’t have
to come from your form!

  To be on the safe side, if you must pass a string gotten from a form
to a shell command, you should make sure the string contains only
alphanumeric characters, dashes, underscores, and periods.


File: python.info,  Node: Installing your CGI script on a Unix system,  Next: Testing your CGI script,  Prev: Caring about security,  Up: cgi --- Common Gateway Interface support

5.20.2.7 Installing your CGI script on a Unix system
....................................................

Read the documentation for your HTTP server and check with your local
system administrator to find the directory where CGI scripts should be
installed; usually this is in a directory ‘cgi-bin’ in the server tree.

  Make sure that your script is readable and executable by "others"; the
Unix file mode should be ‘0755’ octal (use ‘chmod 0755 filename’).  Make
sure that the first line of the script contains ‘#!’ starting in column
1 followed by the pathname of the Python interpreter, for instance:

     #!/usr/local/bin/python

  Make sure the Python interpreter exists and is executable by "others".

  Make sure that any files your script needs to read or write are
readable or writable, respectively, by "others" — their mode should be
‘0644’ for readable and ‘0666’ for writable.  This is because, for
security reasons, the HTTP server executes your script as user "nobody",
without any special privileges.  It can only read (write, execute) files
that everybody can read (write, execute).  The current directory at
execution time is also different (it is usually the server’s cgi-bin
directory) and the set of environment variables is also different from
what you get when you log in.  In particular, don’t count on the shell’s
search path for executables ( ‘PATH’) or the Python module search path (
*note PYTHONPATH: 580.) to be set to anything interesting.

  If you need to load modules from a directory which is not on Python’s
default module search path, you can change the path in your script,
before importing other modules.  For example:

     import sys
     sys.path.insert(0, "/usr/home/joe/lib/python")
     sys.path.insert(0, "/usr/local/lib/python")

  (This way, the directory inserted last will be searched first!)

  Instructions for non-Unix systems will vary; check your HTTP server’s
documentation (it will usually have a section on CGI scripts).


File: python.info,  Node: Testing your CGI script,  Next: Debugging CGI scripts,  Prev: Installing your CGI script on a Unix system,  Up: cgi --- Common Gateway Interface support

5.20.2.8 Testing your CGI script
................................

Unfortunately, a CGI script will generally not run when you try it from
the command line, and a script that works perfectly from the command
line may fail mysteriously when run from the server.  There’s one reason
why you should still test your script from the command line: if it
contains a syntax error, the Python interpreter won’t execute it at all,
and the HTTP server will most likely send a cryptic error to the client.

  Assuming your script has no syntax errors, yet it does not work, you
have no choice but to read the next section.


File: python.info,  Node: Debugging CGI scripts,  Next: Common problems and solutions,  Prev: Testing your CGI script,  Up: cgi --- Common Gateway Interface support

5.20.2.9 Debugging CGI scripts
..............................

First of all, check for trivial installation errors — reading the
section above on installing your CGI script carefully can save you a lot
of time.  If you wonder whether you have understood the installation
procedure correctly, try installing a copy of this module file
(‘cgi.py’) as a CGI script.  When invoked as a script, the file will
dump its environment and the contents of the form in HTML form.  Give it
the right mode etc, and send it a request.  If it’s installed in the
standard ‘cgi-bin’ directory, it should be possible to send it a request
by entering a URL into your browser of the form:

     http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&addr=At+Home

  If this gives an error of type 404, the server cannot find the script
– perhaps you need to install it in a different directory.  If it gives
another error, there’s an installation problem that you should fix
before trying to go any further.  If you get a nicely formatted listing
of the environment and form content (in this example, the fields should
be listed as "addr" with value "At Home" and "name" with value "Joe
Blow"), the ‘cgi.py’ script has been installed correctly.  If you follow
the same procedure for your own script, you should now be able to debug
it.

  The next step could be to call the *note cgi: 5c. module’s *note
test(): 175. function from your script: replace its main code with the
single statement

     cgi.test()

  This should produce the same results as those gotten from installing
the ‘cgi.py’ file itself.

  When an ordinary Python script raises an unhandled exception (for
whatever reason: of a typo in a module name, a file that can’t be
opened, etc.), the Python interpreter prints a nice traceback and exits.
While the Python interpreter will still do this when your CGI script
raises an exception, most likely the traceback will end up in one of the
HTTP server’s log files, or be discarded altogether.

  Fortunately, once you have managed to get your script to execute
_some_ code, you can easily send tracebacks to the Web browser using the
*note cgitb: 5e. module.  If you haven’t done so already, just add the
lines:

     import cgitb
     cgitb.enable()

  to the top of your script.  Then try running it again; when a problem
occurs, you should see a detailed report that will likely make apparent
the cause of the crash.

  If you suspect that there may be a problem in importing the *note
cgitb: 5e. module, you can use an even more robust approach (which only
uses built-in modules):

     import sys
     sys.stderr = sys.stdout
     print "Content-Type: text/plain"
     print
     ...your code here...

  This relies on the Python interpreter to print the traceback.  The
content type of the output is set to plain text, which disables all HTML
processing.  If your script works, the raw HTML will be displayed by
your client.  If it raises an exception, most likely after the first two
lines have been printed, a traceback will be displayed.  Because no HTML
interpretation is going on, the traceback will be readable.


File: python.info,  Node: Common problems and solutions,  Prev: Debugging CGI scripts,  Up: cgi --- Common Gateway Interface support

5.20.2.10 Common problems and solutions
.......................................

   * Most HTTP servers buffer the output from CGI scripts until the
     script is completed.  This means that it is not possible to display
     a progress report on the client’s display while the script is
     running.

   * Check the installation instructions above.

   * Check the HTTP server’s log files.  (‘tail -f logfile’ in a
     separate window may be useful!)

   * Always check a script for syntax errors first, by doing something
     like ‘python script.py’.

   * If your script does not have any syntax errors, try adding ‘import
     cgitb; cgitb.enable()’ to the top of the script.

   * When invoking external programs, make sure they can be found.
     Usually, this means using absolute path names — ‘PATH’ is usually
     not set to a very useful value in a CGI script.

   * When reading or writing external files, make sure they can be read
     or written by the userid under which your CGI script will be
     running: this is typically the userid under which the web server is
     running, or some explicitly specified userid for a web server’s
     ‘suexec’ feature.

   * Don’t try to give a CGI script a set-uid mode.  This doesn’t work
     on most systems, and is a security liability as well.


File: python.info,  Node: cgitb --- Traceback manager for CGI scripts,  Next: wsgiref --- WSGI Utilities and Reference Implementation,  Prev: cgi --- Common Gateway Interface support,  Up: Internet Protocols and Support

5.20.3 ‘cgitb’ — Traceback manager for CGI scripts
--------------------------------------------------

New in version 2.2.

  The *note cgitb: 5e. module provides a special exception handler for
Python scripts.  (Its name is a bit misleading.  It was originally
designed to display extensive traceback information in HTML for CGI
scripts.  It was later generalized to also display this information in
plain text.)  After this module is activated, if an uncaught exception
occurs, a detailed, formatted report will be displayed.  The report
includes a traceback showing excerpts of the source code for each level,
as well as the values of the arguments and local variables to currently
running functions, to help you debug the problem.  Optionally, you can
save this information to a file instead of sending it to the browser.

  To enable this feature, simply add this to the top of your CGI script:

     import cgitb
     cgitb.enable()

  The options to the *note enable(): 1bfd. function control whether the
report is displayed in the browser and whether the report is logged to a
file for later analysis.

 -- Function: cgitb.enable ([display[, logdir[, context[, format]]]])

     This function causes the *note cgitb: 5e. module to take over the
     interpreter’s default handling for exceptions by setting the value
     of *note sys.excepthook: 4cc.

     The optional argument _display_ defaults to ‘1’ and can be set to
     ‘0’ to suppress sending the traceback to the browser.  If the
     argument _logdir_ is present, the traceback reports are written to
     files.  The value of _logdir_ should be a directory where these
     files will be placed.  The optional argument _context_ is the
     number of lines of context to display around the current line of
     source code in the traceback; this defaults to ‘5’.  If the
     optional argument _format_ is ‘"html"’, the output is formatted as
     HTML. Any other value forces plain text output.  The default value
     is ‘"html"’.

 -- Function: cgitb.handler ([info])

     This function handles an exception using the default settings (that
     is, show a report in the browser, but don’t log to a file).  This
     can be used when you’ve caught an exception and want to report it
     using *note cgitb: 5e.  The optional _info_ argument should be a
     3-tuple containing an exception type, exception value, and
     traceback object, exactly like the tuple returned by *note
     sys.exc_info(): 2f3.  If the _info_ argument is not supplied, the
     current exception is obtained from *note sys.exc_info(): 2f3.


File: python.info,  Node: wsgiref --- WSGI Utilities and Reference Implementation,  Next: urllib --- Open arbitrary resources by URL,  Prev: cgitb --- Traceback manager for CGI scripts,  Up: Internet Protocols and Support

5.20.4 ‘wsgiref’ — WSGI Utilities and Reference Implementation
--------------------------------------------------------------

New in version 2.5.

  The Web Server Gateway Interface (WSGI) is a standard interface
between web server software and web applications written in Python.
Having a standard interface makes it easy to use an application that
supports WSGI with a number of different web servers.

  Only authors of web servers and programming frameworks need to know
every detail and corner case of the WSGI design.  You don’t need to
understand every detail of WSGI just to install a WSGI application or to
write a web application using an existing framework.

  *note wsgiref: 199. is a reference implementation of the WSGI
specification that can be used to add WSGI support to a web server or
framework.  It provides utilities for manipulating WSGI environment
variables and response headers, base classes for implementing WSGI
servers, a demo HTTP server that serves WSGI applications, and a
validation tool that checks WSGI servers and applications for
conformance to the WSGI specification ( PEP 333(1)).

  See ‘http://www.wsgi.org’ for more information about WSGI, and links
to tutorials and other resources.

* Menu:

* wsgiref.util: wsgiref util -- WSGI environment utilities. WSGI environment utilities
* wsgiref.headers: wsgiref headers -- WSGI response header tools. WSGI response header tools
* wsgiref.simple_server: wsgiref simple_server -- a simple WSGI HTTP server. a simple WSGI HTTP server
* wsgiref.validate: wsgiref validate --- WSGI conformance checker. WSGI conformance checker
* wsgiref.handlers: wsgiref handlers -- server/gateway base classes. server/gateway base classes
* Examples: Examples<11>. 

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333


File: python.info,  Node: wsgiref util -- WSGI environment utilities,  Next: wsgiref headers -- WSGI response header tools,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.1 ‘wsgiref.util’ – WSGI environment utilities
....................................................

This module provides a variety of utility functions for working with
WSGI environments.  A WSGI environment is a dictionary containing HTTP
request variables as described in PEP 333(1).  All of the functions
taking an _environ_ parameter expect a WSGI-compliant dictionary to be
supplied; please see PEP 333(2) for a detailed specification.

 -- Function: wsgiref.util.guess_scheme (environ)

     Return a guess for whether ‘wsgi.url_scheme’ should be "http" or
     "https", by checking for a ‘HTTPS’ environment variable in the
     _environ_ dictionary.  The return value is a string.

     This function is useful when creating a gateway that wraps CGI or a
     CGI-like protocol such as FastCGI. Typically, servers providing
     such protocols will include a ‘HTTPS’ variable with a value of "1"
     "yes", or "on" when a request is received via SSL. So, this
     function returns "https" if such a value is found, and "http"
     otherwise.

 -- Function: wsgiref.util.request_uri (environ, include_query=1)

     Return the full request URI, optionally including the query string,
     using the algorithm found in the "URL Reconstruction" section of
     PEP 333(3).  If _include_query_ is false, the query string is not
     included in the resulting URI.

 -- Function: wsgiref.util.application_uri (environ)

     Similar to *note request_uri(): 1c03, except that the ‘PATH_INFO’
     and ‘QUERY_STRING’ variables are ignored.  The result is the base
     URI of the application object addressed by the request.

 -- Function: wsgiref.util.shift_path_info (environ)

     Shift a single name from ‘PATH_INFO’ to ‘SCRIPT_NAME’ and return
     the name.  The _environ_ dictionary is _modified_ in-place; use a
     copy if you need to keep the original ‘PATH_INFO’ or ‘SCRIPT_NAME’
     intact.

     If there are no remaining path segments in ‘PATH_INFO’, ‘None’ is
     returned.

     Typically, this routine is used to process each portion of a
     request URI path, for example to treat the path as a series of
     dictionary keys.  This routine modifies the passed-in environment
     to make it suitable for invoking another WSGI application that is
     located at the target URI. For example, if there is a WSGI
     application at ‘/foo’, and the request URI path is ‘/foo/bar/baz’,
     and the WSGI application at ‘/foo’ calls *note shift_path_info():
     1c05, it will receive the string "bar", and the environment will be
     updated to be suitable for passing to a WSGI application at
     ‘/foo/bar’.  That is, ‘SCRIPT_NAME’ will change from ‘/foo’ to
     ‘/foo/bar’, and ‘PATH_INFO’ will change from ‘/bar/baz’ to ‘/baz’.

     When ‘PATH_INFO’ is just a "/", this routine returns an empty
     string and appends a trailing slash to ‘SCRIPT_NAME’, even though
     empty path segments are normally ignored, and ‘SCRIPT_NAME’ doesn’t
     normally end in a slash.  This is intentional behavior, to ensure
     that an application can tell the difference between URIs ending in
     ‘/x’ from ones ending in ‘/x/’ when using this routine to do object
     traversal.

 -- Function: wsgiref.util.setup_testing_defaults (environ)

     Update _environ_ with trivial defaults for testing purposes.

     This routine adds various parameters required for WSGI, including
     ‘HTTP_HOST’, ‘SERVER_NAME’, ‘SERVER_PORT’, ‘REQUEST_METHOD’,
     ‘SCRIPT_NAME’, ‘PATH_INFO’, and all of the PEP 333(4)-defined
     ‘wsgi.*’ variables.  It only supplies default values, and does not
     replace any existing settings for these variables.

     This routine is intended to make it easier for unit tests of WSGI
     servers and applications to set up dummy environments.  It should
     NOT be used by actual WSGI servers or applications, since the data
     is fake!

     Example usage:

          from wsgiref.util import setup_testing_defaults
          from wsgiref.simple_server import make_server

          # A relatively simple WSGI application. It's going to print out the
          # environment dictionary after being updated by setup_testing_defaults
          def simple_app(environ, start_response):
              setup_testing_defaults(environ)

              status = '200 OK'
              headers = [('Content-type', 'text/plain')]

              start_response(status, headers)

              ret = ["%s: %s\n" % (key, value)
                     for key, value in environ.iteritems()]
              return ret

          httpd = make_server('', 8000, simple_app)
          print "Serving on port 8000..."
          httpd.serve_forever()

  In addition to the environment functions above, the *note
wsgiref.util: 19d. module also provides these miscellaneous utilities:

 -- Function: wsgiref.util.is_hop_by_hop (header_name)

     Return true if ’header_name’ is an HTTP/1.1 "Hop-by-Hop" header, as
     defined by RFC 2616(5).

 -- Class: wsgiref.util.FileWrapper (filelike, blksize=8192)

     A wrapper to convert a file-like object to an *note iterator: 87f.
     The resulting objects support both *note __getitem__(): 44f. and
     *note __iter__(): 321. iteration styles, for compatibility with
     Python 2.1 and Jython.  As the object is iterated over, the
     optional _blksize_ parameter will be repeatedly passed to the
     _filelike_ object’s ‘read()’ method to obtain strings to yield.
     When ‘read()’ returns an empty string, iteration is ended and is
     not resumable.

     If _filelike_ has a ‘close()’ method, the returned object will also
     have a ‘close()’ method, and it will invoke the _filelike_ object’s
     ‘close()’ method when called.

     Example usage:

          from StringIO import StringIO
          from wsgiref.util import FileWrapper

          # We're using a StringIO-buffer for as the file-like object
          filelike = StringIO("This is an example file-like object"*10)
          wrapper = FileWrapper(filelike, blksize=5)

          for chunk in wrapper:
              print chunk

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333

   (2) http://www.python.org/dev/peps/pep-0333

   (3) http://www.python.org/dev/peps/pep-0333

   (4) http://www.python.org/dev/peps/pep-0333

   (5) http://tools.ietf.org/html/rfc2616.html


File: python.info,  Node: wsgiref headers -- WSGI response header tools,  Next: wsgiref simple_server -- a simple WSGI HTTP server,  Prev: wsgiref util -- WSGI environment utilities,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.2 ‘wsgiref.headers’ – WSGI response header tools
.......................................................

This module provides a single class, *note Headers: 1c0a, for convenient
manipulation of WSGI response headers using a mapping-like interface.

 -- Class: wsgiref.headers.Headers (headers)

     Create a mapping-like object wrapping _headers_, which must be a
     list of header name/value tuples as described in PEP 333(1).  Any
     changes made to the new *note Headers: 1c0a. object will directly
     update the _headers_ list it was created with.

     *note Headers: 1c0a. objects support typical mapping operations
     including *note __getitem__(): 44f, ‘get()’, *note __setitem__():
     465, ‘setdefault()’, *note __delitem__(): 466, *note
     __contains__(): 322. and ‘has_key()’.  For each of these methods,
     the key is the header name (treated case-insensitively), and the
     value is the first value associated with that header name.  Setting
     a header deletes any existing values for that header, then adds a
     new value at the end of the wrapped header list.  Headers’ existing
     order is generally maintained, with new headers added to the end of
     the wrapped list.

     Unlike a dictionary, *note Headers: 1c0a. objects do not raise an
     error when you try to get or delete a key that isn’t in the wrapped
     header list.  Getting a nonexistent header just returns ‘None’, and
     deleting a nonexistent header does nothing.

     *note Headers: 1c0a. objects also support ‘keys()’, ‘values()’, and
     ‘items()’ methods.  The lists returned by ‘keys()’ and ‘items()’
     can include the same key more than once if there is a multi-valued
     header.  The ‘len()’ of a *note Headers: 1c0a. object is the same
     as the length of its ‘items()’, which is the same as the length of
     the wrapped header list.  In fact, the ‘items()’ method just
     returns a copy of the wrapped header list.

     Calling ‘str()’ on a *note Headers: 1c0a. object returns a
     formatted string suitable for transmission as HTTP response
     headers.  Each header is placed on a line with its value, separated
     by a colon and a space.  Each line is terminated by a carriage
     return and line feed, and the string is terminated with a blank
     line.

     In addition to their mapping interface and formatting features,
     *note Headers: 1c0a. objects also have the following methods for
     querying and adding multi-valued headers, and for adding headers
     with MIME parameters:

      -- Method: get_all (name)

          Return a list of all the values for the named header.

          The returned list will be sorted in the order they appeared in
          the original header list or were added to this instance, and
          may contain duplicates.  Any fields deleted and re-inserted
          are always appended to the header list.  If no fields exist
          with the given name, returns an empty list.

      -- Method: add_header (name, value, **_params)

          Add a (possibly multi-valued) header, with optional MIME
          parameters specified via keyword arguments.

          _name_ is the header field to add.  Keyword arguments can be
          used to set MIME parameters for the header field.  Each
          parameter must be a string or ‘None’.  Underscores in
          parameter names are converted to dashes, since dashes are
          illegal in Python identifiers, but many MIME parameter names
          include dashes.  If the parameter value is a string, it is
          added to the header value parameters in the form
          ‘name="value"’.  If it is ‘None’, only the parameter name is
          added.  (This is used for MIME parameters without a value.)
          Example usage:

               h.add_header('content-disposition', 'attachment', filename='bud.gif')

          The above will add a header that looks like this:

               Content-Disposition: attachment; filename="bud.gif"

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333


File: python.info,  Node: wsgiref simple_server -- a simple WSGI HTTP server,  Next: wsgiref validate --- WSGI conformance checker,  Prev: wsgiref headers -- WSGI response header tools,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.3 ‘wsgiref.simple_server’ – a simple WSGI HTTP server
............................................................

This module implements a simple HTTP server (based on *note
BaseHTTPServer: 16.) that serves WSGI applications.  Each server
instance serves a single WSGI application on a given host and port.  If
you want to serve multiple applications on a single host and port, you
should create a WSGI application that parses ‘PATH_INFO’ to select which
application to invoke for each request.  (E.g., using the
‘shift_path_info()’ function from *note wsgiref.util: 19d.)

 -- Function: wsgiref.simple_server.make_server (host, port, app,
          server_class=WSGIServer, handler_class=WSGIRequestHandler)

     Create a new WSGI server listening on _host_ and _port_, accepting
     connections for _app_.  The return value is an instance of the
     supplied _server_class_, and will process requests using the
     specified _handler_class_.  _app_ must be a WSGI application
     object, as defined by PEP 333(1).

     Example usage:

          from wsgiref.simple_server import make_server, demo_app

          httpd = make_server('', 8000, demo_app)
          print "Serving HTTP on port 8000..."

          # Respond to requests until process is killed
          httpd.serve_forever()

          # Alternative: serve one request, then exit
          httpd.handle_request()

 -- Function: wsgiref.simple_server.demo_app (environ, start_response)

     This function is a small but complete WSGI application that returns
     a text page containing the message "Hello world!"  and a list of
     the key/value pairs provided in the _environ_ parameter.  It’s
     useful for verifying that a WSGI server (such as *note
     wsgiref.simple_server: 19c.) is able to run a simple WSGI
     application correctly.

 -- Class: wsgiref.simple_server.WSGIServer (server_address,
          RequestHandlerClass)

     Create a *note WSGIServer: 1c10. instance.  _server_address_ should
     be a ‘(host,port)’ tuple, and _RequestHandlerClass_ should be the
     subclass of *note BaseHTTPServer.BaseHTTPRequestHandler: 1c11. that
     will be used to process requests.

     You do not normally need to call this constructor, as the *note
     make_server(): 1c0e. function can handle all the details for you.

     *note WSGIServer: 1c10. is a subclass of *note
     BaseHTTPServer.HTTPServer: 1c12, so all of its methods (such as
     ‘serve_forever()’ and ‘handle_request()’) are available.  *note
     WSGIServer: 1c10. also provides these WSGI-specific methods:

      -- Method: set_app (application)

          Sets the callable _application_ as the WSGI application that
          will receive requests.

      -- Method: get_app ()

          Returns the currently-set application callable.

     Normally, however, you do not need to use these additional methods,
     as *note set_app(): 1c13. is normally called by *note
     make_server(): 1c0e, and the *note get_app(): 1c14. exists mainly
     for the benefit of request handler instances.

 -- Class: wsgiref.simple_server.WSGIRequestHandler (request,
          client_address, server)

     Create an HTTP handler for the given _request_ (i.e.  a socket),
     _client_address_ (a ‘(host,port)’ tuple), and _server_ (*note
     WSGIServer: 1c10. instance).

     You do not need to create instances of this class directly; they
     are automatically created as needed by *note WSGIServer: 1c10.
     objects.  You can, however, subclass this class and supply it as a
     _handler_class_ to the *note make_server(): 1c0e. function.  Some
     possibly relevant methods for overriding in subclasses:

      -- Method: get_environ ()

          Returns a dictionary containing the WSGI environment for a
          request.  The default implementation copies the contents of
          the *note WSGIServer: 1c10. object’s ‘base_environ’ dictionary
          attribute and then adds various headers derived from the HTTP
          request.  Each call to this method should return a new
          dictionary containing all of the relevant CGI environment
          variables as specified in PEP 333(2).

      -- Method: get_stderr ()

          Return the object that should be used as the ‘wsgi.errors’
          stream.  The default implementation just returns ‘sys.stderr’.

      -- Method: handle ()

          Process the HTTP request.  The default implementation creates
          a handler instance using a *note wsgiref.handlers: 19a. class
          to implement the actual WSGI application interface.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333

   (2) http://www.python.org/dev/peps/pep-0333


File: python.info,  Node: wsgiref validate --- WSGI conformance checker,  Next: wsgiref handlers -- server/gateway base classes,  Prev: wsgiref simple_server -- a simple WSGI HTTP server,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.4 ‘wsgiref.validate’ — WSGI conformance checker
......................................................

When creating new WSGI application objects, frameworks, servers, or
middleware, it can be useful to validate the new code’s conformance
using *note wsgiref.validate: 19e.  This module provides a function that
creates WSGI application objects that validate communications between a
WSGI server or gateway and a WSGI application object, to check both
sides for protocol conformance.

  Note that this utility does not guarantee complete PEP 333(1)
compliance; an absence of errors from this module does not necessarily
mean that errors do not exist.  However, if this module does produce an
error, then it is virtually certain that either the server or
application is not 100% compliant.

  This module is based on the ‘paste.lint’ module from Ian Bicking’s
"Python Paste" library.

 -- Function: wsgiref.validate.validator (application)

     Wrap _application_ and return a new WSGI application object.  The
     returned application will forward all requests to the original
     _application_, and will check that both the _application_ and the
     server invoking it are conforming to the WSGI specification and to
     RFC 2616.

     Any detected nonconformance results in an *note AssertionError:
     80c. being raised; note, however, that how these errors are handled
     is server-dependent.  For example, *note wsgiref.simple_server:
     19c. and other servers based on *note wsgiref.handlers: 19a. (that
     don’t override the error handling methods to do something else)
     will simply output a message that an error has occurred, and dump
     the traceback to ‘sys.stderr’ or some other error stream.

     This wrapper may also generate output using the *note warnings:
     193. module to indicate behaviors that are questionable but which
     may not actually be prohibited by PEP 333(2).  Unless they are
     suppressed using Python command-line options or the *note warnings:
     193. API, any such warnings will be written to ‘sys.stderr’ (_not_
     ‘wsgi.errors’, unless they happen to be the same object).

     Example usage:

          from wsgiref.validate import validator
          from wsgiref.simple_server import make_server

          # Our callable object which is intentionally not compliant to the
          # standard, so the validator is going to break
          def simple_app(environ, start_response):
              status = '200 OK' # HTTP Status
              headers = [('Content-type', 'text/plain')] # HTTP Headers
              start_response(status, headers)

              # This is going to break because we need to return a list, and
              # the validator is going to inform us
              return "Hello World"

          # This is the application wrapped in a validator
          validator_app = validator(simple_app)

          httpd = make_server('', 8000, validator_app)
          print "Listening on port 8000...."
          httpd.serve_forever()

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333

   (2) http://www.python.org/dev/peps/pep-0333


File: python.info,  Node: wsgiref handlers -- server/gateway base classes,  Next: Examples<11>,  Prev: wsgiref validate --- WSGI conformance checker,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.5 ‘wsgiref.handlers’ – server/gateway base classes
.........................................................

This module provides base handler classes for implementing WSGI servers
and gateways.  These base classes handle most of the work of
communicating with a WSGI application, as long as they are given a
CGI-like environment, along with input, output, and error streams.

 -- Class: wsgiref.handlers.CGIHandler

     CGI-based invocation via ‘sys.stdin’, ‘sys.stdout’, ‘sys.stderr’
     and ‘os.environ’.  This is useful when you have a WSGI application
     and want to run it as a CGI script.  Simply invoke
     ‘CGIHandler().run(app)’, where ‘app’ is the WSGI application object
     you wish to invoke.

     This class is a subclass of *note BaseCGIHandler: 1c1d. that sets
     ‘wsgi.run_once’ to true, ‘wsgi.multithread’ to false, and
     ‘wsgi.multiprocess’ to true, and always uses *note sys: 16d. and
     *note os: 128. to obtain the necessary CGI streams and environment.

 -- Class: wsgiref.handlers.BaseCGIHandler (stdin, stdout, stderr,
          environ, multithread=True, multiprocess=False)

     Similar to *note CGIHandler: 1c1c, but instead of using the *note
     sys: 16d. and *note os: 128. modules, the CGI environment and I/O
     streams are specified explicitly.  The _multithread_ and
     _multiprocess_ values are used to set the ‘wsgi.multithread’ and
     ‘wsgi.multiprocess’ flags for any applications run by the handler
     instance.

     This class is a subclass of *note SimpleHandler: 1c1e. intended for
     use with software other than HTTP "origin servers".  If you are
     writing a gateway protocol implementation (such as CGI, FastCGI,
     SCGI, etc.)  that uses a ‘Status:’ header to send an HTTP status,
     you probably want to subclass this instead of *note SimpleHandler:
     1c1e.

 -- Class: wsgiref.handlers.SimpleHandler (stdin, stdout, stderr,
          environ, multithread=True, multiprocess=False)

     Similar to *note BaseCGIHandler: 1c1d, but designed for use with
     HTTP origin servers.  If you are writing an HTTP server
     implementation, you will probably want to subclass this instead of
     *note BaseCGIHandler: 1c1d.

     This class is a subclass of *note BaseHandler: 1c1f.  It overrides
     the *note __init__(): 37c, ‘get_stdin()’, ‘get_stderr()’,
     ‘add_cgi_vars()’, ‘_write()’, and ‘_flush()’ methods to support
     explicitly setting the environment and streams via the constructor.
     The supplied environment and streams are stored in the ‘stdin’,
     ‘stdout’, ‘stderr’, and ‘environ’ attributes.

 -- Class: wsgiref.handlers.BaseHandler

     This is an abstract base class for running WSGI applications.  Each
     instance will handle a single HTTP request, although in principle
     you could create a subclass that was reusable for multiple
     requests.

     *note BaseHandler: 1c1f. instances have only one method intended
     for external use:

      -- Method: run (app)

          Run the specified WSGI application, _app_.

     All of the other *note BaseHandler: 1c1f. methods are invoked by
     this method in the process of running the application, and thus
     exist primarily to allow customizing the process.

     The following methods MUST be overridden in a subclass:

      -- Method: _write (data)

          Buffer the string _data_ for transmission to the client.  It’s
          okay if this method actually transmits the data; *note
          BaseHandler: 1c1f. just separates write and flush operations
          for greater efficiency when the underlying system actually has
          such a distinction.

      -- Method: _flush ()

          Force buffered data to be transmitted to the client.  It’s
          okay if this method is a no-op (i.e., if *note _write(): 1c21.
          actually sends the data).

      -- Method: get_stdin ()

          Return an input stream object suitable for use as the
          ‘wsgi.input’ of the request currently being processed.

      -- Method: get_stderr ()

          Return an output stream object suitable for use as the
          ‘wsgi.errors’ of the request currently being processed.

      -- Method: add_cgi_vars ()

          Insert CGI variables for the current request into the
          ‘environ’ attribute.

     Here are some other methods and attributes you may wish to
     override.  This list is only a summary, however, and does not
     include every method that can be overridden.  You should consult
     the docstrings and source code for additional information before
     attempting to create a customized *note BaseHandler: 1c1f.
     subclass.

     Attributes and methods for customizing the WSGI environment:

      -- Attribute: wsgi_multithread

          The value to be used for the ‘wsgi.multithread’ environment
          variable.  It defaults to true in *note BaseHandler: 1c1f, but
          may have a different default (or be set by the constructor) in
          the other subclasses.

      -- Attribute: wsgi_multiprocess

          The value to be used for the ‘wsgi.multiprocess’ environment
          variable.  It defaults to true in *note BaseHandler: 1c1f, but
          may have a different default (or be set by the constructor) in
          the other subclasses.

      -- Attribute: wsgi_run_once

          The value to be used for the ‘wsgi.run_once’ environment
          variable.  It defaults to false in *note BaseHandler: 1c1f,
          but *note CGIHandler: 1c1c. sets it to true by default.

      -- Attribute: os_environ

          The default environment variables to be included in every
          request’s WSGI environment.  By default, this is a copy of
          ‘os.environ’ at the time that *note wsgiref.handlers: 19a. was
          imported, but subclasses can either create their own at the
          class or instance level.  Note that the dictionary should be
          considered read-only, since the default value is shared
          between multiple classes and instances.

      -- Attribute: server_software

          If the *note origin_server: 1c2b. attribute is set, this
          attribute’s value is used to set the default ‘SERVER_SOFTWARE’
          WSGI environment variable, and also to set a default ‘Server:’
          header in HTTP responses.  It is ignored for handlers (such as
          *note BaseCGIHandler: 1c1d. and *note CGIHandler: 1c1c.) that
          are not HTTP origin servers.

      -- Method: get_scheme ()

          Return the URL scheme being used for the current request.  The
          default implementation uses the ‘guess_scheme()’ function from
          *note wsgiref.util: 19d. to guess whether the scheme should be
          "http" or "https", based on the current request’s ‘environ’
          variables.

      -- Method: setup_environ ()

          Set the ‘environ’ attribute to a fully-populated WSGI
          environment.  The default implementation uses all of the above
          methods and attributes, plus the *note get_stdin(): 1c23,
          *note get_stderr(): 1c24, and *note add_cgi_vars(): 1c25.
          methods and the *note wsgi_file_wrapper: 1c2e. attribute.  It
          also inserts a ‘SERVER_SOFTWARE’ key if not present, as long
          as the *note origin_server: 1c2b. attribute is a true value
          and the *note server_software: 1c2a. attribute is set.

     Methods and attributes for customizing exception handling:

      -- Method: log_exception (exc_info)

          Log the _exc_info_ tuple in the server log.  _exc_info_ is a
          ‘(type, value, traceback)’ tuple.  The default implementation
          simply writes the traceback to the request’s ‘wsgi.errors’
          stream and flushes it.  Subclasses can override this method to
          change the format or retarget the output, mail the traceback
          to an administrator, or whatever other action may be deemed
          suitable.

      -- Attribute: traceback_limit

          The maximum number of frames to include in tracebacks output
          by the default *note log_exception(): 1c2f. method.  If
          ‘None’, all frames are included.

      -- Method: error_output (environ, start_response)

          This method is a WSGI application to generate an error page
          for the user.  It is only invoked if an error occurs before
          headers are sent to the client.

          This method can access the current error information using
          ‘sys.exc_info()’, and should pass that information to
          _start_response_ when calling it (as described in the "Error
          Handling" section of PEP 333(1)).

          The default implementation just uses the *note error_status:
          1c32, *note error_headers: 1c33, and *note error_body: 1c34.
          attributes to generate an output page.  Subclasses can
          override this to produce more dynamic error output.

          Note, however, that it’s not recommended from a security
          perspective to spit out diagnostics to any old user; ideally,
          you should have to do something special to enable diagnostic
          output, which is why the default implementation doesn’t
          include any.

      -- Attribute: error_status

          The HTTP status used for error responses.  This should be a
          status string as defined in PEP 333(2); it defaults to a 500
          code and message.

      -- Attribute: error_headers

          The HTTP headers used for error responses.  This should be a
          list of WSGI response headers (‘(name, value)’ tuples), as
          described in PEP 333(3).  The default list just sets the
          content type to ‘text/plain’.

      -- Attribute: error_body

          The error response body.  This should be an HTTP response body
          string.  It defaults to the plain text, "A server error
          occurred.  Please contact the administrator."

     Methods and attributes for PEP 333(4)’s "Optional Platform-Specific
     File Handling" feature:

      -- Attribute: wsgi_file_wrapper

          A ‘wsgi.file_wrapper’ factory, or ‘None’.  The default value
          of this attribute is the ‘FileWrapper’ class from *note
          wsgiref.util: 19d.

      -- Method: sendfile ()

          Override to implement platform-specific file transmission.
          This method is called only if the application’s return value
          is an instance of the class specified by the *note
          wsgi_file_wrapper: 1c2e. attribute.  It should return a true
          value if it was able to successfully transmit the file, so
          that the default transmission code will not be executed.  The
          default implementation of this method just returns a false
          value.

     Miscellaneous methods and attributes:

      -- Attribute: origin_server

          This attribute should be set to a true value if the handler’s
          *note _write(): 1c21. and *note _flush(): 1c22. are being used
          to communicate directly to the client, rather than via a
          CGI-like gateway protocol that wants the HTTP status in a
          special ‘Status:’ header.

          This attribute’s default value is true in *note BaseHandler:
          1c1f, but false in *note BaseCGIHandler: 1c1d. and *note
          CGIHandler: 1c1c.

      -- Attribute: http_version

          If *note origin_server: 1c2b. is true, this string attribute
          is used to set the HTTP version of the response set to the
          client.  It defaults to ‘"1.0"’.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333

   (2) http://www.python.org/dev/peps/pep-0333

   (3) http://www.python.org/dev/peps/pep-0333

   (4) http://www.python.org/dev/peps/pep-0333


File: python.info,  Node: Examples<11>,  Prev: wsgiref handlers -- server/gateway base classes,  Up: wsgiref --- WSGI Utilities and Reference Implementation

5.20.4.6 Examples
.................

This is a working "Hello World" WSGI application:

     from wsgiref.simple_server import make_server

     # Every WSGI application must have an application object - a callable
     # object that accepts two arguments. For that purpose, we're going to
     # use a function (note that you're not limited to a function, you can
     # use a class for example). The first argument passed to the function
     # is a dictionary containing CGI-style envrironment variables and the
     # second variable is the callable object (see PEP 333).
     def hello_world_app(environ, start_response):
         status = '200 OK' # HTTP Status
         headers = [('Content-type', 'text/plain')] # HTTP Headers
         start_response(status, headers)

         # The returned object is going to be printed
         return ["Hello World"]

     httpd = make_server('', 8000, hello_world_app)
     print "Serving on port 8000..."

     # Serve until process is killed
     httpd.serve_forever()


File: python.info,  Node: urllib --- Open arbitrary resources by URL,  Next: urllib2 --- extensible library for opening URLs,  Prev: wsgiref --- WSGI Utilities and Reference Implementation,  Up: Internet Protocols and Support

5.20.5 ‘urllib’ — Open arbitrary resources by URL
-------------------------------------------------

     Note: The *note urllib: 188. module has been split into parts and
     renamed in Python 3 to ‘urllib.request’, ‘urllib.parse’, and
     ‘urllib.error’.  The *note 2to3: bdb. tool will automatically adapt
     imports when converting your sources to Python 3.  Also note that
     the ‘urllib.request.urlopen()’ function in Python 3 is equivalent
     to *note urllib2.urlopen(): 35c. and that *note urllib.urlopen():
     35b. has been removed.

  This module provides a high-level interface for fetching data across
the World Wide Web.  In particular, the *note urlopen(): 35b. function
is similar to the built-in function *note open(): 2d6, but accepts
Universal Resource Locators (URLs) instead of filenames.  Some
restrictions apply — it can only open URLs for reading, and no seek
operations are available.

     Warning: When opening HTTPS URLs, it does not attempt to validate
     the server certificate.  Use at your own risk!

* Menu:

* High-level interface:: 
* Utility functions: Utility functions<2>. 
* URL Opener objects:: 
* urllib Restrictions:: 
* Examples: Examples<12>. 


File: python.info,  Node: High-level interface,  Next: Utility functions<2>,  Up: urllib --- Open arbitrary resources by URL

5.20.5.1 High-level interface
.............................

 -- Function: urllib.urlopen (url[, data[, proxies]])

     Open a network object denoted by a URL for reading.  If the URL
     does not have a scheme identifier, or if it has ‘file:’ as its
     scheme identifier, this opens a local file (without *note universal
     newlines: 315.); otherwise it opens a socket to a server somewhere
     on the network.  If the connection cannot be made the *note
     IOError: 1fa. exception is raised.  If all went well, a file-like
     object is returned.  This supports the following methods: ‘read()’,
     *note readline(): 144, ‘readlines()’, ‘fileno()’, ‘close()’,
     ‘info()’, ‘getcode()’ and ‘geturl()’.  It also has proper support
     for the *note iterator: 87f. protocol.  One caveat: the ‘read()’
     method, if the size argument is omitted or negative, may not read
     until the end of the data stream; there is no good way to determine
     that the entire stream from a socket has been read in the general
     case.

     Except for the ‘info()’, ‘getcode()’ and ‘geturl()’ methods, these
     methods have the same interface as for file objects — see section
     *note File Objects: 643. in this manual.  (It is not a built-in
     file object, however, so it can’t be used at those few places where
     a true built-in file object is required.)

     The ‘info()’ method returns an instance of the class *note
     mimetools.Message: 1915. containing meta-information associated
     with the URL. When the method is HTTP, these headers are those
     returned by the server at the head of the retrieved HTML page
     (including Content-Length and Content-Type).  When the method is
     FTP, a Content-Length header will be present if (as is now usual)
     the server passed back a file length in response to the FTP
     retrieval request.  A Content-Type header will be present if the
     MIME type can be guessed.  When the method is local-file, returned
     headers will include a Date representing the file’s last-modified
     time, a Content-Length giving file size, and a Content-Type
     containing a guess at the file’s type.  See also the description of
     the *note mimetools: 10f. module.

     The ‘geturl()’ method returns the real URL of the page.  In some
     cases, the HTTP server redirects a client to another URL. The *note
     urlopen(): 35b. function handles this transparently, but in some
     cases the caller needs to know which URL the client was redirected
     to.  The ‘geturl()’ method can be used to get at this redirected
     URL.

     The ‘getcode()’ method returns the HTTP status code that was sent
     with the response, or ‘None’ if the URL is no HTTP URL.

     If the _url_ uses the ‘http:’ scheme identifier, the optional
     _data_ argument may be given to specify a ‘POST’ request (normally
     the request type is ‘GET’).  The _data_ argument must be in
     standard ‘application/x-www-form-urlencoded’ format; see the *note
     urlencode(): 1383. function below.

     The *note urlopen(): 35b. function works transparently with proxies
     which do not require authentication.  In a Unix or Windows
     environment, set the ‘http_proxy’, or ‘ftp_proxy’ environment
     variables to a URL that identifies the proxy server before starting
     the Python interpreter.  For example (the ‘'%'’ is the command
     prompt):

          % http_proxy="http://www.someproxy.com:3128"
          % export http_proxy
          % python
          ...

     The ‘no_proxy’ environment variable can be used to specify hosts
     which shouldn’t be reached via proxy; if set, it should be a
     comma-separated list of hostname suffixes, optionally with ‘:port’
     appended, for example ‘cern.ch,ncsa.uiuc.edu,some.host:8080’.

     In a Windows environment, if no proxy environment variables are
     set, proxy settings are obtained from the registry’s Internet
     Settings section.

     In a Mac OS X environment, *note urlopen(): 35b. will retrieve
     proxy information from the OS X System Configuration Framework,
     which can be managed with Network System Preferences panel.

     Alternatively, the optional _proxies_ argument may be used to
     explicitly specify proxies.  It must be a dictionary mapping scheme
     names to proxy URLs, where an empty dictionary causes no proxies to
     be used, and ‘None’ (the default value) causes environmental proxy
     settings to be used as discussed above.  For example:

          # Use http://www.someproxy.com:3128 for http proxying
          proxies = {'http': 'http://www.someproxy.com:3128'}
          filehandle = urllib.urlopen(some_url, proxies=proxies)
          # Don't use any proxies
          filehandle = urllib.urlopen(some_url, proxies={})
          # Use proxies from environment - both versions are equivalent
          filehandle = urllib.urlopen(some_url, proxies=None)
          filehandle = urllib.urlopen(some_url)

     Proxies which require authentication for use are not currently
     supported; this is considered an implementation limitation.

     Changed in version 2.3: Added the _proxies_ support.

     Changed in version 2.6: Added ‘getcode()’ to returned object and
     support for the

     ‘no_proxy’ environment variable.

     Deprecated since version 2.6: The *note urlopen(): 35b. function
     has been removed in Python 3 in favor of *note urllib2.urlopen():
     35c.

 -- Function: urllib.urlretrieve (url[, filename[, reporthook[, data]]])

     Copy a network object denoted by a URL to a local file, if
     necessary.  If the URL points to a local file, or a valid cached
     copy of the object exists, the object is not copied.  Return a
     tuple ‘(filename, headers)’ where _filename_ is the local file name
     under which the object can be found, and _headers_ is whatever the
     ‘info()’ method of the object returned by *note urlopen(): 35b.
     returned (for a remote object, possibly cached).  Exceptions are
     the same as for *note urlopen(): 35b.

     The second argument, if present, specifies the file location to
     copy to (if absent, the location will be a tempfile with a
     generated name).  The third argument, if present, is a hook
     function that will be called once on establishment of the network
     connection and once after each block read thereafter.  The hook
     will be passed three arguments; a count of blocks transferred so
     far, a block size in bytes, and the total size of the file.  The
     third argument may be ‘-1’ on older FTP servers which do not return
     a file size in response to a retrieval request.

     If the _url_ uses the ‘http:’ scheme identifier, the optional
     _data_ argument may be given to specify a ‘POST’ request (normally
     the request type is ‘GET’).  The _data_ argument must in standard
     ‘application/x-www-form-urlencoded’ format; see the *note
     urlencode(): 1383. function below.

     Changed in version 2.5: *note urlretrieve(): 1c3b. will raise *note
     ContentTooShortError: 1c3c. when it detects that the amount of data
     available was less than the expected amount (which is the size
     reported by a _Content-Length_ header).  This can occur, for
     example, when the download is interrupted.  The _Content-Length_ is
     treated as a lower bound: if there’s more data to read, *note
     urlretrieve(): 1c3b. reads more data, but if less data is
     available, it raises the exception.

     You can still retrieve the downloaded data in this case, it is
     stored in the ‘content’ attribute of the exception instance.

     If no _Content-Length_ header was supplied, *note urlretrieve():
     1c3b. can not check the size of the data it has downloaded, and
     just returns it.  In this case you just have to assume that the
     download was successful.

 -- Data: urllib._urlopener

     The public functions *note urlopen(): 35b. and *note urlretrieve():
     1c3b. create an instance of the *note FancyURLopener: 1c3e. class
     and use it to perform their requested actions.  To override this
     functionality, programmers can create a subclass of *note
     URLopener: 1c3f. or *note FancyURLopener: 1c3e, then assign an
     instance of that class to the ‘urllib._urlopener’ variable before
     calling the desired function.  For example, applications may want
     to specify a different ‘User-Agent’ header than *note URLopener:
     1c3f. defines.  This can be accomplished with the following code:

          import urllib

          class AppURLopener(urllib.FancyURLopener):
              version = "App/1.7"

          urllib._urlopener = AppURLopener()

 -- Function: urllib.urlcleanup ()

     Clear the cache that may have been built up by previous calls to
     *note urlretrieve(): 1c3b.


File: python.info,  Node: Utility functions<2>,  Next: URL Opener objects,  Prev: High-level interface,  Up: urllib --- Open arbitrary resources by URL

5.20.5.2 Utility functions
..........................

 -- Function: urllib.quote (string[, safe])

     Replace special characters in _string_ using the ‘%xx’ escape.
     Letters, digits, and the characters ‘'_.-'’ are never quoted.  By
     default, this function is intended for quoting the path section of
     the URL. The optional _safe_ parameter specifies additional
     characters that should not be quoted — its default value is ‘'/'’.

     Example: ‘quote('/~connolly/')’ yields ‘'/%7econnolly/'’.

 -- Function: urllib.quote_plus (string[, safe])

     Like *note quote(): 1c42, but also replaces spaces by plus signs,
     as required for quoting HTML form values when building up a query
     string to go into a URL. Plus signs in the original string are
     escaped unless they are included in _safe_.  It also does not have
     _safe_ default to ‘'/'’.

 -- Function: urllib.unquote (string)

     Replace ‘%xx’ escapes by their single-character equivalent.

     Example: ‘unquote('/%7Econnolly/')’ yields ‘'/~connolly/'’.

 -- Function: urllib.unquote_plus (string)

     Like *note unquote(): 1c44, but also replaces plus signs by spaces,
     as required for unquoting HTML form values.

 -- Function: urllib.urlencode (query[, doseq])

     Convert a mapping object or a sequence of two-element tuples to a
     "percent-encoded" string, suitable to pass to *note urlopen(): 35b.
     above as the optional _data_ argument.  This is useful to pass a
     dictionary of form fields to a ‘POST’ request.  The resulting
     string is a series of ‘key=value’ pairs separated by ‘'&'’
     characters, where both _key_ and _value_ are quoted using *note
     quote_plus(): 1c43. above.  When a sequence of two-element tuples
     is used as the _query_ argument, the first element of each tuple is
     a key and the second is a value.  The value element in itself can
     be a sequence and in that case, if the optional parameter _doseq_
     is evaluates to _True_, individual ‘key=value’ pairs separated by
     ‘'&'’ are generated for each element of the value sequence for the
     key.  The order of parameters in the encoded string will match the
     order of parameter tuples in the sequence.  The *note urlparse:
     18a. module provides the functions ‘parse_qs()’ and ‘parse_qsl()’
     which are used to parse query strings into Python data structures.

 -- Function: urllib.pathname2url (path)

     Convert the pathname _path_ from the local syntax for a path to the
     form used in the path component of a URL. This does not produce a
     complete URL. The return value will already be quoted using the
     *note quote(): 1c42. function.

 -- Function: urllib.url2pathname (path)

     Convert the path component _path_ from an percent-encoded URL to
     the local syntax for a path.  This does not accept a complete URL.
     This function uses *note unquote(): 1c44. to decode _path_.

 -- Function: urllib.getproxies ()

     This helper function returns a dictionary of scheme to proxy server
     URL mappings.  It scans the environment for variables named
     ‘<scheme>_proxy’, in case insensitive way, for all operating
     systems first, and when it cannot find it, looks for proxy
     information from Mac OSX System Configuration for Mac OS X and
     Windows Systems Registry for Windows.

     Note: urllib also exposes certain utility functions like splittype,
     splithost and others parsing url into various components.  But it
     is recommended to use *note urlparse: 18a. for parsing urls than
     using these functions directly.  Python 3 does not expose these
     helper functions from ‘urllib.parse’ module.


File: python.info,  Node: URL Opener objects,  Next: urllib Restrictions,  Prev: Utility functions<2>,  Up: urllib --- Open arbitrary resources by URL

5.20.5.3 URL Opener objects
...........................

 -- Class: urllib.URLopener ([proxies[, **x509]])

     Base class for opening and reading URLs.  Unless you need to
     support opening objects using schemes other than ‘http:’, ‘ftp:’,
     or ‘file:’, you probably want to use *note FancyURLopener: 1c3e.

     By default, the *note URLopener: 1c3f. class sends a ‘User-Agent’
     header of ‘urllib/VVV’, where _VVV_ is the *note urllib: 188.
     version number.  Applications can define their own ‘User-Agent’
     header by subclassing *note URLopener: 1c3f. or *note
     FancyURLopener: 1c3e. and setting the class attribute *note
     version: 1c4a. to an appropriate string value in the subclass
     definition.

     The optional _proxies_ parameter should be a dictionary mapping
     scheme names to proxy URLs, where an empty dictionary turns proxies
     off completely.  Its default value is ‘None’, in which case
     environmental proxy settings will be used if present, as discussed
     in the definition of *note urlopen(): 35b, above.

     Additional keyword parameters, collected in _x509_, may be used for
     authentication of the client when using the ‘https:’ scheme.  The
     keywords _key_file_ and _cert_file_ are supported to provide an SSL
     key and certificate; both are needed to support client
     authentication.

     *note URLopener: 1c3f. objects will raise an *note IOError: 1fa.
     exception if the server returns an error code.

           -- Method: open (fullurl[, data])

               Open _fullurl_ using the appropriate protocol.  This
               method sets up cache and proxy information, then calls
               the appropriate open method with its input arguments.  If
               the scheme is not recognized, *note open_unknown(): 1c4c.
               is called.  The _data_ argument has the same meaning as
               the _data_ argument of *note urlopen(): 35b.

           -- Method: open_unknown (fullurl[, data])

               Overridable interface to open unknown URL types.

           -- Method: retrieve (url[, filename[, reporthook[, data]]])

               Retrieves the contents of _url_ and places it in
               _filename_.  The return value is a tuple consisting of a
               local filename and either a *note mimetools.Message:
               1915. object containing the response headers (for remote
               URLs) or ‘None’ (for local URLs).  The caller must then
               open and read the contents of _filename_.  If _filename_
               is not given and the URL refers to a local file, the
               input filename is returned.  If the URL is non-local and
               _filename_ is not given, the filename is the output of
               *note tempfile.mktemp(): e8a. with a suffix that matches
               the suffix of the last path component of the input URL.
               If _reporthook_ is given, it must be a function accepting
               three numeric parameters.  It will be called after each
               chunk of data is read from the network.  _reporthook_ is
               ignored for local URLs.

               If the _url_ uses the ‘http:’ scheme identifier, the
               optional _data_ argument may be given to specify a ‘POST’
               request (normally the request type is ‘GET’).  The _data_
               argument must in standard
               ‘application/x-www-form-urlencoded’ format; see the *note
               urlencode(): 1383. function below.

           -- Attribute: version

               Variable that specifies the user agent of the opener
               object.  To get *note urllib: 188. to tell servers that
               it is a particular user agent, set this in a subclass as
               a class variable or in the constructor before calling the
               base constructor.

 -- Class: urllib.FancyURLopener (...)

     *note FancyURLopener: 1c3e. subclasses *note URLopener: 1c3f.
     providing default handling for the following HTTP response codes:
     301, 302, 303, 307 and 401.  For the 30x response codes listed
     above, the ‘Location’ header is used to fetch the actual URL. For
     401 response codes (authentication required), basic HTTP
     authentication is performed.  For the 30x response codes, recursion
     is bounded by the value of the _maxtries_ attribute, which defaults
     to 10.

     For all other response codes, the method ‘http_error_default()’ is
     called which you can override in subclasses to handle the error
     appropriately.

          Note: According to the letter of RFC 2616(1), 301 and 302
          responses to POST requests must not be automatically
          redirected without confirmation by the user.  In reality,
          browsers do allow automatic redirection of these responses,
          changing the POST to a GET, and *note urllib: 188. reproduces
          this behaviour.

     The parameters to the constructor are the same as those for *note
     URLopener: 1c3f.

          Note: 
               When performing basic authentication, a *note
               FancyURLopener: 1c3e. instance calls its *note
               prompt_user_passwd(): 1c4e. method.  The default
               implementation asks the users for the required
               information on the controlling terminal.  A subclass may
               override this method to support more appropriate behavior
               if needed.

          The *note FancyURLopener: 1c3e. class offers one additional
          method that should be overloaded to provide the appropriate
          behavior:

           -- Method: prompt_user_passwd (host, realm)

               Return information needed to authenticate the user at the
               given host in the specified security realm.  The return
               value should be a tuple, ‘(user, password)’, which can be
               used for basic authentication.

               The implementation prompts for this information on the
               terminal; an application should override this method to
               use an appropriate interaction model in the local
               environment.

 -- Exception: urllib.ContentTooShortError (msg[, content])

     This exception is raised when the *note urlretrieve(): 1c3b.
     function detects that the amount of the downloaded data is less
     than the expected amount (given by the _Content-Length_ header).
     The ‘content’ attribute stores the downloaded (and supposedly
     truncated) data.

     New in version 2.5.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc2616.html


File: python.info,  Node: urllib Restrictions,  Next: Examples<12>,  Prev: URL Opener objects,  Up: urllib --- Open arbitrary resources by URL

5.20.5.4 ‘urllib’ Restrictions
..............................

   * Currently, only the following protocols are supported: HTTP,
     (versions 0.9 and 1.0), FTP, and local files.

   * The caching feature of *note urlretrieve(): 1c3b. has been disabled
     until I find the time to hack proper processing of Expiration time
     headers.

   * There should be a function to query whether a particular URL is in
     the cache.

   * For backward compatibility, if a URL appears to point to a local
     file but the file can’t be opened, the URL is re-interpreted using
     the FTP protocol.  This can sometimes cause confusing error
     messages.

   * The *note urlopen(): 35b. and *note urlretrieve(): 1c3b. functions
     can cause arbitrarily long delays while waiting for a network
     connection to be set up.  This means that it is difficult to build
     an interactive Web client using these functions without using
     threads.

   * The data returned by *note urlopen(): 35b. or *note urlretrieve():
     1c3b. is the raw data returned by the server.  This may be binary
     data (such as an image), plain text or (for example) HTML. The HTTP
     protocol provides type information in the reply header, which can
     be inspected by looking at the ‘Content-Type’ header.  If the
     returned data is HTML, you can use the module *note htmllib: ec. to
     parse it.

   * The code handling the FTP protocol cannot differentiate between a
     file and a directory.  This can lead to unexpected behavior when
     attempting to read a URL that points to a file that is not
     accessible.  If the URL ends in a ‘/’, it is assumed to refer to a
     directory and will be handled accordingly.  But if an attempt to
     read a file leads to a 550 error (meaning the URL cannot be found
     or is not accessible, often for permission reasons), then the path
     is treated as a directory in order to handle the case when a
     directory is specified by a URL but the trailing ‘/’ has been left
     off.  This can cause misleading results when you try to fetch a
     file whose read permissions make it inaccessible; the FTP code will
     try to read it, fail with a 550 error, and then perform a directory
     listing for the unreadable file.  If fine-grained control is
     needed, consider using the *note ftplib: d8. module, subclassing
     *note FancyURLopener: 1c3e, or changing __urlopener_ to meet your
     needs.

   * This module does not support the use of proxies which require
     authentication.  This may be implemented in the future.

   * Although the *note urllib: 188. module contains (undocumented)
     routines to parse and unparse URL strings, the recommended
     interface for URL manipulation is in module *note urlparse: 18a.


File: python.info,  Node: Examples<12>,  Prev: urllib Restrictions,  Up: urllib --- Open arbitrary resources by URL

5.20.5.5 Examples
.................

Here is an example session that uses the ‘GET’ method to retrieve a URL
containing parameters:

     >>> import urllib
     >>> params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
     >>> f = urllib.urlopen("http://www.musi-cal.com/cgi-bin/query?%s" % params)
     >>> print f.read()

  The following example uses the ‘POST’ method instead:

     >>> import urllib
     >>> params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
     >>> f = urllib.urlopen("http://www.musi-cal.com/cgi-bin/query", params)
     >>> print f.read()

  The following example uses an explicitly specified HTTP proxy,
overriding environment settings:

     >>> import urllib
     >>> proxies = {'http': 'http://proxy.example.com:8080/'}
     >>> opener = urllib.FancyURLopener(proxies)
     >>> f = opener.open("http://www.python.org")
     >>> f.read()

  The following example uses no proxies at all, overriding environment
settings:

     >>> import urllib
     >>> opener = urllib.FancyURLopener({})
     >>> f = opener.open("http://www.python.org/")
     >>> f.read()


File: python.info,  Node: urllib2 --- extensible library for opening URLs,  Next: httplib --- HTTP protocol client,  Prev: urllib --- Open arbitrary resources by URL,  Up: Internet Protocols and Support

5.20.6 ‘urllib2’ — extensible library for opening URLs
------------------------------------------------------

     Note: The *note urllib2: 189. module has been split across several
     modules in Python 3 named ‘urllib.request’ and ‘urllib.error’.  The
     *note 2to3: bdb. tool will automatically adapt imports when
     converting your sources to Python 3.

  The *note urllib2: 189. module defines functions and classes which
help in opening URLs (mostly HTTP) in a complex world — basic and digest
authentication, redirections, cookies and more.

  The *note urllib2: 189. module defines the following functions:

 -- Function: urllib2.urlopen (url[, data][, timeout])

     Open the URL _url_, which can be either a string or a *note
     Request: 1c54. object.

          Warning: HTTPS requests do not do any verification of the
          server’s certificate.

     _data_ may be a string specifying additional data to send to the
     server, or ‘None’ if no such data is needed.  Currently HTTP
     requests are the only ones that use _data_; the HTTP request will
     be a POST instead of a GET when the _data_ parameter is provided.
     _data_ should be a buffer in the standard
     ‘application/x-www-form-urlencoded’ format.  The *note
     urllib.urlencode(): 1383. function takes a mapping or sequence of
     2-tuples and returns a string in this format.  urllib2 module sends
     HTTP/1.1 requests with ‘Connection:close’ header included.

     The optional _timeout_ parameter specifies a timeout in seconds for
     blocking operations like the connection attempt (if not specified,
     the global default timeout setting will be used).  This actually
     only works for HTTP, HTTPS and FTP connections.

     This function returns a file-like object with three additional
     methods:

        * ‘geturl()’ — return the URL of the resource retrieved,
          commonly used to determine if a redirect was followed

        * ‘info()’ — return the meta-information of the page, such as
          headers, in the form of an *note mimetools.Message: 1915.
          instance (see Quick Reference to HTTP Headers(1))

        * ‘getcode()’ — return the HTTP status code of the response.

     Raises *note URLError: 1c55. on errors.

     Note that ‘None’ may be returned if no handler handles the request
     (though the default installed global *note OpenerDirector: 1c56.
     uses *note UnknownHandler: 1c57. to ensure this never happens).

     In addition, if proxy settings are detected (for example, when a
     ‘*_proxy’ environment variable like ‘http_proxy’ is set), *note
     ProxyHandler: 1c58. is default installed and makes sure the
     requests are handled through the proxy.

     Changed in version 2.6: _timeout_ was added.

 -- Function: urllib2.install_opener (opener)

     Install an *note OpenerDirector: 1c56. instance as the default
     global opener.  Installing an opener is only necessary if you want
     urlopen to use that opener; otherwise, simply call *note
     OpenerDirector.open(): 1c5a. instead of *note urlopen(): 35c.  The
     code does not check for a real *note OpenerDirector: 1c56, and any
     class with the appropriate interface will work.

 -- Function: urllib2.build_opener ([handler, ...])

     Return an *note OpenerDirector: 1c56. instance, which chains the
     handlers in the order given.  _handler_s can be either instances of
     *note BaseHandler: 1c5c, or subclasses of *note BaseHandler: 1c5c.
     (in which case it must be possible to call the constructor without
     any parameters).  Instances of the following classes will be in
     front of the _handler_s, unless the _handler_s contain them,
     instances of them or subclasses of them: *note ProxyHandler: 1c58.
     (if proxy settings are detected), *note UnknownHandler: 1c57, *note
     HTTPHandler: 1c5d, *note HTTPDefaultErrorHandler: 1c5e, *note
     HTTPRedirectHandler: 1c5f, *note FTPHandler: 1c60, *note
     FileHandler: 1c61, *note HTTPErrorProcessor: 1c62.

     If the Python installation has SSL support (i.e., if the *note ssl:
     160. module can be imported), *note HTTPSHandler: 1c63. will also
     be added.

     Beginning in Python 2.3, a *note BaseHandler: 1c5c. subclass may
     also change its ‘handler_order’ attribute to modify its position in
     the handlers list.

  The following exceptions are raised as appropriate:

 -- Exception: urllib2.URLError

     The handlers raise this exception (or derived exceptions) when they
     run into a problem.  It is a subclass of *note IOError: 1fa.

      -- Attribute: reason

          The reason for this error.  It can be a message string or
          another exception instance (*note socket.error: 381. for
          remote URLs, *note OSError: 231. for local URLs).

 -- Exception: urllib2.HTTPError

     Though being an exception (a subclass of *note URLError: 1c55.), an
     *note HTTPError: 1c65. can also function as a non-exceptional
     file-like return value (the same thing that *note urlopen(): 35c.
     returns).  This is useful when handling exotic HTTP errors, such as
     requests for authentication.

      -- Attribute: code

          An HTTP status code as defined in RFC 2616(2).  This numeric
          value corresponds to a value found in the dictionary of codes
          as found in *note
          BaseHTTPServer.BaseHTTPRequestHandler.responses: 1c67.

      -- Attribute: reason

          The reason for this error.  It can be a message string or
          another exception instance.

  The following classes are provided:

 -- Class: urllib2.Request (url[, data][, headers][, origin_req_host][,
          unverifiable])

     This class is an abstraction of a URL request.

     _url_ should be a string containing a valid URL.

     _data_ may be a string specifying additional data to send to the
     server, or ‘None’ if no such data is needed.  Currently HTTP
     requests are the only ones that use _data_; the HTTP request will
     be a POST instead of a GET when the _data_ parameter is provided.
     _data_ should be a buffer in the standard
     ‘application/x-www-form-urlencoded’ format.  The *note
     urllib.urlencode(): 1383. function takes a mapping or sequence of
     2-tuples and returns a string in this format.

     _headers_ should be a dictionary, and will be treated as if *note
     add_header(): 1c69. was called with each key and value as
     arguments.  This is often used to "spoof" the ‘User-Agent’ header,
     which is used by a browser to identify itself – some HTTP servers
     only allow requests coming from common browsers as opposed to
     scripts.  For example, Mozilla Firefox may identify itself as
     ‘"Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127
     Firefox/2.0.0.11"’, while *note urllib2: 189.’s default user agent
     string is ‘"Python-urllib/2.6"’ (on Python 2.6).

     The final two arguments are only of interest for correct handling
     of third-party HTTP cookies:

     _origin_req_host_ should be the request-host of the origin
     transaction, as defined by RFC 2965(3).  It defaults to
     ‘cookielib.request_host(self)’.  This is the host name or IP
     address of the original request that was initiated by the user.
     For example, if the request is for an image in an HTML document,
     this should be the request-host of the request for the page
     containing the image.

     _unverifiable_ should indicate whether the request is unverifiable,
     as defined by RFC 2965.  It defaults to ‘False’.  An unverifiable
     request is one whose URL the user did not have the option to
     approve.  For example, if the request is for an image in an HTML
     document, and the user had no option to approve the automatic
     fetching of the image, this should be true.

 -- Class: urllib2.OpenerDirector

     The *note OpenerDirector: 1c56. class opens URLs via *note
     BaseHandler: 1c5c.s chained together.  It manages the chaining of
     handlers, and recovery from errors.

 -- Class: urllib2.BaseHandler

     This is the base class for all registered handlers — and handles
     only the simple mechanics of registration.

 -- Class: urllib2.HTTPDefaultErrorHandler

     A class which defines a default handler for HTTP error responses;
     all responses are turned into *note HTTPError: 1c65. exceptions.

 -- Class: urllib2.HTTPRedirectHandler

     A class to handle redirections.

 -- Class: urllib2.HTTPCookieProcessor ([cookiejar])

     A class to handle HTTP Cookies.

 -- Class: urllib2.ProxyHandler ([proxies])

     Cause requests to go through a proxy.  If _proxies_ is given, it
     must be a dictionary mapping protocol names to URLs of proxies.
     The default is to read the list of proxies from the environment
     variables ‘<protocol>_proxy’.  If no proxy environment variables
     are set, then in a Windows environment proxy settings are obtained
     from the registry’s Internet Settings section, and in a Mac OS X
     environment proxy information is retrieved from the OS X System
     Configuration Framework.

     To disable autodetected proxy pass an empty dictionary.

 -- Class: urllib2.HTTPPasswordMgr

     Keep a database of ‘(realm, uri) -> (user, password)’ mappings.

 -- Class: urllib2.HTTPPasswordMgrWithDefaultRealm

     Keep a database of ‘(realm, uri) -> (user, password)’ mappings.  A
     realm of ‘None’ is considered a catch-all realm, which is searched
     if no other realm fits.

 -- Class: urllib2.AbstractBasicAuthHandler ([password_mgr])

     This is a mixin class that helps with HTTP authentication, both to
     the remote host and to a proxy.  _password_mgr_, if given, should
     be something that is compatible with *note HTTPPasswordMgr: 1c6b.;
     refer to section *note HTTPPasswordMgr Objects: 1c6e. for
     information on the interface that must be supported.

 -- Class: urllib2.HTTPBasicAuthHandler ([password_mgr])

     Handle authentication with the remote host.  _password_mgr_, if
     given, should be something that is compatible with *note
     HTTPPasswordMgr: 1c6b.; refer to section *note HTTPPasswordMgr
     Objects: 1c6e. for information on the interface that must be
     supported.

 -- Class: urllib2.ProxyBasicAuthHandler ([password_mgr])

     Handle authentication with the proxy.  _password_mgr_, if given,
     should be something that is compatible with *note HTTPPasswordMgr:
     1c6b.; refer to section *note HTTPPasswordMgr Objects: 1c6e. for
     information on the interface that must be supported.

 -- Class: urllib2.AbstractDigestAuthHandler ([password_mgr])

     This is a mixin class that helps with HTTP authentication, both to
     the remote host and to a proxy.  _password_mgr_, if given, should
     be something that is compatible with *note HTTPPasswordMgr: 1c6b.;
     refer to section *note HTTPPasswordMgr Objects: 1c6e. for
     information on the interface that must be supported.

 -- Class: urllib2.HTTPDigestAuthHandler ([password_mgr])

     Handle authentication with the remote host.  _password_mgr_, if
     given, should be something that is compatible with *note
     HTTPPasswordMgr: 1c6b.; refer to section *note HTTPPasswordMgr
     Objects: 1c6e. for information on the interface that must be
     supported.

 -- Class: urllib2.ProxyDigestAuthHandler ([password_mgr])

     Handle authentication with the proxy.  _password_mgr_, if given,
     should be something that is compatible with *note HTTPPasswordMgr:
     1c6b.; refer to section *note HTTPPasswordMgr Objects: 1c6e. for
     information on the interface that must be supported.

 -- Class: urllib2.HTTPHandler

     A class to handle opening of HTTP URLs.

 -- Class: urllib2.HTTPSHandler

     A class to handle opening of HTTPS URLs.

 -- Class: urllib2.FileHandler

     Open local files.

 -- Class: urllib2.FTPHandler

     Open FTP URLs.

 -- Class: urllib2.CacheFTPHandler

     Open FTP URLs, keeping a cache of open FTP connections to minimize
     delays.

 -- Class: urllib2.UnknownHandler

     A catch-all class to handle unknown URLs.

 -- Class: urllib2.HTTPErrorProcessor

     Process HTTP error responses.

* Menu:

* Request Objects:: 
* OpenerDirector Objects:: 
* BaseHandler Objects:: 
* HTTPRedirectHandler Objects:: 
* HTTPCookieProcessor Objects:: 
* ProxyHandler Objects:: 
* HTTPPasswordMgr Objects:: 
* AbstractBasicAuthHandler Objects:: 
* HTTPBasicAuthHandler Objects:: 
* ProxyBasicAuthHandler Objects:: 
* AbstractDigestAuthHandler Objects:: 
* HTTPDigestAuthHandler Objects:: 
* ProxyDigestAuthHandler Objects:: 
* HTTPHandler Objects:: 
* HTTPSHandler Objects:: 
* FileHandler Objects:: 
* FTPHandler Objects:: 
* CacheFTPHandler Objects:: 
* UnknownHandler Objects:: 
* HTTPErrorProcessor Objects:: 
* Examples: Examples<13>. 

   ---------- Footnotes ----------

   (1) http://www.cs.tut.fi/~jkorpela/http.html

   (2) http://www.faqs.org/rfcs/rfc2616.html

   (3) http://tools.ietf.org/html/rfc2965.html

