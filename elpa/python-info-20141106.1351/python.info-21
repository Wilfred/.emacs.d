This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: MacOS --- Access to Mac OS interpreter features,  Next: macostools --- Convenience routines for file manipulation,  Prev: ic --- Access to the Mac OS X Internet Config,  Up: Mac OS X specific services

5.36.2 ‘MacOS’ — Access to Mac OS interpreter features
------------------------------------------------------

This module provides access to MacOS specific functionality in the
Python interpreter, such as how the interpreter eventloop functions and
the like.  Use with care.

     Note: This module has been removed in Python 3.x.

  Note the capitalization of the module name; this is a historical
artifact.

 -- Data: MacOS.runtimemodel

     Always ‘'macho'’, from Python 2.4 on.  In earlier versions of
     Python the value could also be ‘'ppc'’ for the classic Mac OS 8
     runtime model or ‘'carbon'’ for the Mac OS 9 runtime model.

 -- Data: MacOS.linkmodel

     The way the interpreter has been linked.  As extension modules may
     be incompatible between linking models, packages could use this
     information to give more decent error messages.  The value is one
     of ‘'static'’ for a statically linked Python, ‘'framework'’ for
     Python in a Mac OS X framework, ‘'shared'’ for Python in a standard
     Unix shared library.  Older Pythons could also have the value
     ‘'cfm'’ for Mac OS 9-compatible Python.

 -- Exception: MacOS.Error

     This exception is raised on MacOS generated errors, either from
     functions in this module or from other mac-specific modules like
     the toolbox interfaces.  The arguments are the integer error code
     (the ‘OSErr’ value) and a textual description of the error code.
     Symbolic names for all known error codes are defined in the
     standard module *note macerrors: 104.

 -- Function: MacOS.GetErrorString (errno)

     Return the textual description of MacOS error code _errno_.

 -- Function: MacOS.DebugStr (message[, object])

     On Mac OS X the string is simply printed to stderr (on older Mac OS
     systems more elaborate functionality was available), but it
     provides a convenient location to attach a breakpoint in a
     low-level debugger like *gdb*.

          Note: Not available in 64-bit mode.

 -- Function: MacOS.SysBeep ()

     Ring the bell.

          Note: Not available in 64-bit mode.

 -- Function: MacOS.GetTicks ()

     Get the number of clock ticks (1/60th of a second) since system
     boot.

 -- Function: MacOS.GetCreatorAndType (file)

     Return the file creator and file type as two four-character
     strings.  The _file_ parameter can be a pathname or an ‘FSSpec’ or
     ‘FSRef’ object.

          Note: It is not possible to use an ‘FSSpec’ in 64-bit mode.

 -- Function: MacOS.SetCreatorAndType (file, creator, type)

     Set the file creator and file type.  The _file_ parameter can be a
     pathname or an ‘FSSpec’ or ‘FSRef’ object.  _creator_ and _type_
     must be four character strings.

          Note: It is not possible to use an ‘FSSpec’ in 64-bit mode.

 -- Function: MacOS.openrf (name[, mode])

     Open the resource fork of a file.  Arguments are the same as for
     the built-in function *note open(): 2d6.  The object returned has
     file-like semantics, but it is not a Python file object, so there
     may be subtle differences.

 -- Function: MacOS.WMAvailable ()

     Checks whether the current process has access to the window
     manager.  The method will return ‘False’ if the window manager is
     not available, for instance when running on Mac OS X Server or when
     logged in via ssh, or when the current interpreter is not running
     from a fullblown application bundle.  A script runs from an
     application bundle either when it has been started with *pythonw*
     instead of *python* or when running as an applet.

 -- Function: MacOS.splash ([resourceid])

     Opens a splash screen by resource id.  Use resourceid ‘0’ to close
     the splash screen.

          Note: Not available in 64-bit mode.


File: python.info,  Node: macostools --- Convenience routines for file manipulation,  Next: findertools --- The finder's Apple Events interface,  Prev: MacOS --- Access to Mac OS interpreter features,  Up: Mac OS X specific services

5.36.3 ‘macostools’ — Convenience routines for file manipulation
----------------------------------------------------------------

This module contains some convenience routines for file-manipulation on
the Macintosh.  All file parameters can be specified as pathnames,
‘FSRef’ or ‘FSSpec’ objects.  This module expects a filesystem which
supports forked files, so it should not be used on UFS partitions.

     Note: This module has been removed in Python 3.

  The *note macostools: 106. module defines the following functions:

 -- Function: macostools.copy (src, dst[, createpath[, copytimes]])

     Copy file _src_ to _dst_.  If _createpath_ is non-zero the folders
     leading to _dst_ are created if necessary.  The method copies data
     and resource fork and some finder information (creator, type,
     flags) and optionally the creation, modification and backup times
     (default is to copy them).  Custom icons, comments and icon
     position are not copied.

          Note: This function does not work in 64-bit code because it
          uses APIs that are not available in 64-bit mode.

 -- Function: macostools.copytree (src, dst)

     Recursively copy a file tree from _src_ to _dst_, creating folders
     as needed.  _src_ and _dst_ should be specified as pathnames.

          Note: This function does not work in 64-bit code because it
          uses APIs that are not available in 64-bit mode.

 -- Function: macostools.mkalias (src, dst)

     Create a finder alias _dst_ pointing to _src_.

          Note: This function does not work in 64-bit code because it
          uses APIs that are not available in 64-bit mode.

 -- Function: macostools.touched (dst)

     Tell the finder that some bits of finder-information such as
     creator or type for file _dst_ has changed.  The file can be
     specified by pathname or fsspec.  This call should tell the finder
     to redraw the files icon.

     Deprecated since version 2.6: The function is a no-op on OS X.

 -- Data: macostools.BUFSIZ

     The buffer size for ‘copy’, default 1 megabyte.

  Note that the process of creating finder aliases is not specified in
the Apple documentation.  Hence, aliases created with *note mkalias():
281f. could conceivably have incompatible behaviour in some cases.


File: python.info,  Node: findertools --- The finder's Apple Events interface,  Next: EasyDialogs --- Basic Macintosh dialogs,  Prev: macostools --- Convenience routines for file manipulation,  Up: Mac OS X specific services

5.36.4 ‘findertools’ — The *finder*’s Apple Events interface
------------------------------------------------------------

This module contains routines that give Python programs access to some
functionality provided by the finder.  They are implemented as wrappers
around the AppleEvent interface to the finder.

  All file and folder parameters can be specified either as full
pathnames, or as ‘FSRef’ or ‘FSSpec’ objects.

  The *note findertools: cd. module defines the following functions:

 -- Function: findertools.launch (file)

     Tell the finder to launch _file_.  What launching means depends on
     the file: applications are started, folders are opened and
     documents are opened in the correct application.

 -- Function: findertools.Print (file)

     Tell the finder to print a file.  The behaviour is identical to
     selecting the file and using the print command in the finder’s file
     menu.

 -- Function: findertools.copy (file, destdir)

     Tell the finder to copy a file or folder _file_ to folder
     _destdir_.  The function returns an ‘Alias’ object pointing to the
     new file.

 -- Function: findertools.move (file, destdir)

     Tell the finder to move a file or folder _file_ to folder
     _destdir_.  The function returns an ‘Alias’ object pointing to the
     new file.

 -- Function: findertools.sleep ()

     Tell the finder to put the Macintosh to sleep, if your machine
     supports it.

 -- Function: findertools.restart ()

     Tell the finder to perform an orderly restart of the machine.

 -- Function: findertools.shutdown ()

     Tell the finder to perform an orderly shutdown of the machine.


File: python.info,  Node: EasyDialogs --- Basic Macintosh dialogs,  Next: FrameWork --- Interactive application framework,  Prev: findertools --- The finder's Apple Events interface,  Up: Mac OS X specific services

5.36.5 ‘EasyDialogs’ — Basic Macintosh dialogs
----------------------------------------------

The *note EasyDialogs: ba. module contains some simple dialogs for the
Macintosh.  The dialogs get launched in a separate application which
appears in the dock and must be clicked on for the dialogs be displayed.
All routines take an optional resource ID parameter _id_ with which one
can override the ‘DLOG’ resource used for the dialog, provided that the
dialog items correspond (both type and item number) to those in the
default ‘DLOG’ resource.  See source code for details.

     Note: This module has been removed in Python 3.x.

  The *note EasyDialogs: ba. module defines the following functions:

 -- Function: EasyDialogs.Message (str[, id[, ok]])

     Displays a modal dialog with the message text _str_, which should
     be at most 255 characters long.  The button text defaults to "OK",
     but is set to the string argument _ok_ if the latter is supplied.
     Control is returned when the user clicks the "OK" button.

 -- Function: EasyDialogs.AskString (prompt[, default[, id[, ok[,
          cancel]]]])

     Asks the user to input a string value via a modal dialog.  _prompt_
     is the prompt message, and the optional _default_ supplies the
     initial value for the string (otherwise ‘""’ is used).  The text of
     the "OK" and "Cancel" buttons can be changed with the _ok_ and
     _cancel_ arguments.  All strings can be at most 255 bytes long.
     *note AskString(): 282c. returns the string entered or *note None:
     39a. in case the user cancelled.

 -- Function: EasyDialogs.AskPassword (prompt[, default[, id[, ok[,
          cancel]]]])

     Asks the user to input a string value via a modal dialog.  Like
     *note AskString(): 282c, but with the text shown as bullets.  The
     arguments have the same meaning as for *note AskString(): 282c.

 -- Function: EasyDialogs.AskYesNoCancel (question[, default[, yes[,
          no[, cancel[, id]]]]])

     Presents a dialog with prompt _question_ and three buttons labelled
     "Yes", "No", and "Cancel".  Returns ‘1’ for "Yes", ‘0’ for "No" and
     ‘-1’ for "Cancel".  The value of _default_ (or ‘0’ if _default_ is
     not supplied) is returned when the ‘RETURN’ key is pressed.  The
     text of the buttons can be changed with the _yes_, _no_, and
     _cancel_ arguments; to prevent a button from appearing, supply ‘""’
     for the corresponding argument.

 -- Function: EasyDialogs.ProgressBar ([title[, maxval[, label[, id]]]])

     Displays a modeless progress-bar dialog.  This is the constructor
     for the *note ProgressBar: 282f. class described below.  _title_ is
     the text string displayed (default "Working..."), _maxval_ is the
     value at which progress is complete (default ‘0’, indicating that
     an indeterminate amount of work remains to be done), and _label_ is
     the text that is displayed above the progress bar itself.

 -- Function: EasyDialogs.GetArgv ([optionlist[ commandlist[,
          addoldfile[, addnewfile[, addfolder[, id]]]]]])

     Displays a dialog which aids the user in constructing a
     command-line argument list.  Returns the list in ‘sys.argv’ format,
     suitable for passing as an argument to *note getopt.getopt(): 12b5.
     _addoldfile_, _addnewfile_, and _addfolder_ are boolean arguments.
     When nonzero, they enable the user to insert into the command line
     paths to an existing file, a (possibly) not-yet-existent file, and
     a folder, respectively.  (Note: Option arguments must appear in the
     command line before file and folder arguments in order to be
     recognized by *note getopt.getopt(): 12b5.)  Arguments containing
     spaces can be specified by enclosing them within single or double
     quotes.  A *note SystemExit: 332. exception is raised if the user
     presses the "Cancel" button.

     _optionlist_ is a list that determines a popup menu from which the
     allowed options are selected.  Its items can take one of two forms:
     _optstr_ or ‘(optstr, descr)’.  When present, _descr_ is a short
     descriptive string that is displayed in the dialog while this
     option is selected in the popup menu.  The correspondence between
     _optstr_s and command-line arguments is:

     _optstr_ format            Command-line format
                                
     --------------------------------------------------------------------------
                                
     ‘x’                        *note -x: 648. (short option)
                                
                                
     ‘x:’ or ‘x=’               *note -x: 648. (short option with value)
                                
                                
     ‘xyz’                      ‘--xyz’ (long option)
                                
                                
     ‘xyz:’ or ‘xyz=’           ‘--xyz’ (long option with value)
                                

     _commandlist_ is a list of items of the form _cmdstr_ or ‘(cmdstr,
     descr)’, where _descr_ is as above.  The _cmdstr_s will appear in a
     popup menu.  When chosen, the text of _cmdstr_ will be appended to
     the command line as is, except that a trailing ‘':'’ or ‘'='’ (if
     present) will be trimmed off.

     New in version 2.0.

 -- Function: EasyDialogs.AskFileForOpen ( [message] [, typeList] [,
          defaultLocation] [, defaultOptionFlags] [, location] [,
          clientName] [, windowTitle] [, actionButtonLabel] [,
          cancelButtonLabel] [, preferenceKey] [, popupExtension] [,
          eventProc] [, previewProc] [, filterProc] [, wanted] )

     Post a dialog asking the user for a file to open, and return the
     file selected or *note None: 39a. if the user cancelled.  _message_
     is a text message to display, _typeList_ is a list of 4-char
     filetypes allowable, _defaultLocation_ is the pathname, ‘FSSpec’ or
     ‘FSRef’ of the folder to show initially, _location_ is the ‘(x, y)’
     position on the screen where the dialog is shown,
     _actionButtonLabel_ is a string to show instead of "Open" in the OK
     button, _cancelButtonLabel_ is a string to show instead of "Cancel"
     in the cancel button, _wanted_ is the type of value wanted as a
     return: *note str: 1ea, *note unicode: 1f5, ‘FSSpec’, ‘FSRef’ and
     subtypes thereof are acceptable.

     For a description of the other arguments please see the Apple
     Navigation Services documentation and the *note EasyDialogs: ba.
     source code.

 -- Function: EasyDialogs.AskFileForSave ( [message] [, savedFileName]
          [, defaultLocation] [, defaultOptionFlags] [, location] [,
          clientName] [, windowTitle] [, actionButtonLabel] [,
          cancelButtonLabel] [, preferenceKey] [, popupExtension] [,
          fileType] [, fileCreator] [, eventProc] [, wanted] )

     Post a dialog asking the user for a file to save to, and return the
     file selected or *note None: 39a. if the user cancelled.
     _savedFileName_ is the default for the file name to save to (the
     return value).  See *note AskFileForOpen(): 2831. for a description
     of the other arguments.

 -- Function: EasyDialogs.AskFolder ( [message] [, defaultLocation] [,
          defaultOptionFlags] [, location] [, clientName] [,
          windowTitle] [, actionButtonLabel] [, cancelButtonLabel] [,
          preferenceKey] [, popupExtension] [, eventProc] [, filterProc]
          [, wanted] )

     Post a dialog asking the user to select a folder, and return the
     folder selected or *note None: 39a. if the user cancelled.  See
     *note AskFileForOpen(): 2831. for a description of the arguments.

See also
........

Navigation Services Reference(1)

     Programmer’s reference documentation for the Navigation Services, a
     part of the Carbon framework.

* Menu:

* ProgressBar Objects:: 

   ---------- Footnotes ----------

   (1) 
http://developer.apple.com/legacy/mac/library/#documentation/Carbon/Conceptual/NavServicesIntro/ns_intro_carb/ns_into_carb.html


File: python.info,  Node: ProgressBar Objects,  Up: EasyDialogs --- Basic Macintosh dialogs

5.36.5.1 ProgressBar Objects
............................

*note ProgressBar: 282f. objects provide support for modeless
progress-bar dialogs.  Both determinate (thermometer style) and
indeterminate (barber-pole style) progress bars are supported.  The bar
will be determinate if its maximum value is greater than zero; otherwise
it will be indeterminate.

  Changed in version 2.2: Support for indeterminate-style progress bars
was added.

  The dialog is displayed immediately after creation.  If the dialog’s
"Cancel" button is pressed, or if ‘Cmd-.’ or ‘ESC’ is typed, the dialog
window is hidden and *note KeyboardInterrupt: 251. is raised (but note
that this response does not occur until the progress bar is next
updated, typically via a call to ‘inc()’ or *note set(): 36a.).
Otherwise, the bar remains visible until the *note ProgressBar: 282f.
object is discarded.

  *note ProgressBar: 282f. objects possess the following attributes and
methods:

 -- Attribute: ProgressBar.curval

     The current value (of type integer or long integer) of the progress
     bar.  The normal access methods coerce *note curval: 2836. between
     ‘0’ and *note maxval: 2837.  This attribute should not be altered
     directly.

 -- Attribute: ProgressBar.maxval

     The maximum value (of type integer or long integer) of the progress
     bar; the progress bar (thermometer style) is full when *note
     curval: 2836. equals *note maxval: 2837.  If *note maxval: 2837. is
     ‘0’, the bar will be indeterminate (barber-pole).  This attribute
     should not be altered directly.

 -- Method: ProgressBar.title ([newstr])

     Sets the text in the title bar of the progress dialog to _newstr_.

 -- Method: ProgressBar.label ([newstr])

     Sets the text in the progress box of the progress dialog to
     _newstr_.

 -- Method: ProgressBar.set (value[, max])

     Sets the progress bar’s *note curval: 2836. to _value_, and also
     *note maxval: 2837. to _max_ if the latter is provided.  _value_ is
     first coerced between 0 and *note maxval: 2837.  The thermometer
     bar is updated to reflect the changes, including a change from
     indeterminate to determinate or vice versa.

 -- Method: ProgressBar.inc ([n])

     Increments the progress bar’s *note curval: 2836. by _n_, or by ‘1’
     if _n_ is not provided.  (Note that _n_ may be negative, in which
     case the effect is a decrement.)  The progress bar is updated to
     reflect the change.  If the bar is indeterminate, this causes one
     "spin" of the barber pole.  The resulting *note curval: 2836. is
     coerced between 0 and *note maxval: 2837. if incrementing causes it
     to fall outside this range.


File: python.info,  Node: FrameWork --- Interactive application framework,  Next: autoGIL --- Global Interpreter Lock handling in event loops,  Prev: EasyDialogs --- Basic Macintosh dialogs,  Up: Mac OS X specific services

5.36.6 ‘FrameWork’ — Interactive application framework
------------------------------------------------------

The *note FrameWork: d7. module contains classes that together provide a
framework for an interactive Macintosh application.  The programmer
builds an application by creating subclasses that override various
methods of the bases classes, thereby implementing the functionality
wanted.  Overriding functionality can often be done on various different
levels, i.e.  to handle clicks in a single dialog window in a
non-standard way it is not necessary to override the complete event
handling.

     Note: This module has been removed in Python 3.x.

  Work on the *note FrameWork: d7. has pretty much stopped, now that
‘PyObjC’ is available for full Cocoa access from Python, and the
documentation describes only the most important functionality, and not
in the most logical manner at that.  Examine the source or the examples
for more details.  The following are some comments posted on the
MacPython newsgroup about the strengths and limitations of *note
FrameWork: d7.:

     The strong point of *note FrameWork: d7. is that it allows you to
     break into the control-flow at many different places.  *note W:
     192, for instance, uses a different way to enable/disable menus and
     that plugs right in leaving the rest intact.  The weak points of
     *note FrameWork: d7. are that it has no abstract command interface
     (but that shouldn’t be difficult), that its dialog support is
     minimal and that its control/toolbar support is non-existent.

  The *note FrameWork: d7. module defines the following functions:

 -- Function: FrameWork.Application ()

     An object representing the complete application.  See below for a
     description of the methods.  The default *note __init__(): 37c.
     routine creates an empty window dictionary and a menu bar with an
     apple menu.

 -- Function: FrameWork.MenuBar ()

     An object representing the menubar.  This object is usually not
     created by the user.

 -- Function: FrameWork.Menu (bar, title[, after])

     An object representing a menu.  Upon creation you pass the
     ‘MenuBar’ the menu appears in, the _title_ string and a position
     (1-based) _after_ where the menu should appear (default: at the
     end).

 -- Function: FrameWork.MenuItem (menu, title[, shortcut, callback])

     Create a menu item object.  The arguments are the menu to create,
     the item title string and optionally the keyboard shortcut and a
     callback routine.  The callback is called with the arguments
     menu-id, item number within menu (1-based), current front window
     and the event record.

     Instead of a callable object the callback can also be a string.  In
     this case menu selection causes the lookup of a method in the
     topmost window and the application.  The method name is the
     callback string with ‘'domenu_'’ prepended.

     Calling the ‘MenuBar’ ‘fixmenudimstate()’ method sets the correct
     dimming for all menu items based on the current front window.

 -- Function: FrameWork.Separator (menu)

     Add a separator to the end of a menu.

 -- Function: FrameWork.SubMenu (menu, label)

     Create a submenu named _label_ under menu _menu_.  The menu object
     is returned.

 -- Function: FrameWork.Window (parent)

     Creates a (modeless) window.  _Parent_ is the application object to
     which the window belongs.  The window is not displayed until later.

 -- Function: FrameWork.DialogWindow (parent)

     Creates a modeless dialog window.

 -- Function: FrameWork.windowbounds (width, height)

     Return a ‘(left, top, right, bottom)’ tuple suitable for creation
     of a window of given width and height.  The window will be
     staggered with respect to previous windows, and an attempt is made
     to keep the whole window on-screen.  However, the window will
     however always be the exact size given, so parts may be offscreen.

 -- Function: FrameWork.setwatchcursor ()

     Set the mouse cursor to a watch.

 -- Function: FrameWork.setarrowcursor ()

     Set the mouse cursor to an arrow.

* Menu:

* Application Objects:: 
* Window Objects: Window Objects<2>. 
* ControlsWindow Object:: 
* ScrolledWindow Object:: 
* DialogWindow Objects:: 


File: python.info,  Node: Application Objects,  Next: Window Objects<2>,  Up: FrameWork --- Interactive application framework

5.36.6.1 Application Objects
............................

Application objects have the following methods, among others:

 -- Method: Application.makeusermenus ()

     Override this method if you need menus in your application.  Append
     the menus to the attribute ‘menubar’.

 -- Method: Application.getabouttext ()

     Override this method to return a text string describing your
     application.  Alternatively, override the ‘do_about()’ method for
     more elaborate "about" messages.

 -- Method: Application.mainloop ([mask[, wait]])

     This routine is the main event loop, call it to set your
     application rolling.  _Mask_ is the mask of events you want to
     handle, _wait_ is the number of ticks you want to leave to other
     concurrent application (default 0, which is probably not a good
     idea).  While raising _self_ to exit the mainloop is still
     supported it is not recommended: call ‘self._quit()’ instead.

     The event loop is split into many small parts, each of which can be
     overridden.  The default methods take care of dispatching events to
     windows and dialogs, handling drags and resizes, Apple Events,
     events for non-FrameWork windows, etc.

     In general, all event handlers should return ‘1’ if the event is
     fully handled and ‘0’ otherwise (because the front window was not a
     FrameWork window, for instance).  This is needed so that update
     events and such can be passed on to other windows like the Sioux
     console window.  Calling ‘MacOS.HandleEvent()’ is not allowed
     within _our_dispatch_ or its callees, since this may result in an
     infinite loop if the code is called through the Python inner-loop
     event handler.

 -- Method: Application.asyncevents (onoff)

     Call this method with a nonzero parameter to enable asynchronous
     event handling.  This will tell the inner interpreter loop to call
     the application event handler _async_dispatch_ whenever events are
     available.  This will cause FrameWork window updates and the user
     interface to remain working during long computations, but will slow
     the interpreter down and may cause surprising results in
     non-reentrant code (such as FrameWork itself).  By default
     _async_dispatch_ will immediately call _our_dispatch_ but you may
     override this to handle only certain events asynchronously.  Events
     you do not handle will be passed to Sioux and such.

     The old on/off value is returned.

 -- Method: Application._quit ()

     Terminate the running *note mainloop(): 284d. call at the next
     convenient moment.

 -- Method: Application.do_char (c, event)

     The user typed character _c_.  The complete details of the event
     can be found in the _event_ structure.  This method can also be
     provided in a ‘Window’ object, which overrides the application-wide
     handler if the window is frontmost.

 -- Method: Application.do_dialogevent (event)

     Called early in the event loop to handle modeless dialog events.
     The default method simply dispatches the event to the relevant
     dialog (not through the ‘DialogWindow’ object involved).  Override
     if you need special handling of dialog events (keyboard shortcuts,
     etc).

 -- Method: Application.idle (event)

     Called by the main event loop when no events are available.  The
     null-event is passed (so you can look at mouse position, etc).


File: python.info,  Node: Window Objects<2>,  Next: ControlsWindow Object,  Prev: Application Objects,  Up: FrameWork --- Interactive application framework

5.36.6.2 Window Objects
.......................

Window objects have the following methods, among others:

 -- Method: Window.open ()

     Override this method to open a window.  Store the Mac OS window-id
     in ‘self.wid’ and call the ‘do_postopen()’ method to register the
     window with the parent application.

 -- Method: Window.close ()

     Override this method to do any special processing on window close.
     Call the ‘do_postclose()’ method to cleanup the parent state.

 -- Method: Window.do_postresize (width, height, macoswindowid)

     Called after the window is resized.  Override if more needs to be
     done than calling ‘InvalRect’.

 -- Method: Window.do_contentclick (local, modifiers, event)

     The user clicked in the content part of a window.  The arguments
     are the coordinates (window-relative), the key modifiers and the
     raw event.

 -- Method: Window.do_update (macoswindowid, event)

     An update event for the window was received.  Redraw the window.

 -- Method: Window.do_activate (activate, event)

     The window was activated (‘activate == 1’) or deactivated
     (‘activate == 0’).  Handle things like focus highlighting, etc.


File: python.info,  Node: ControlsWindow Object,  Next: ScrolledWindow Object,  Prev: Window Objects<2>,  Up: FrameWork --- Interactive application framework

5.36.6.3 ControlsWindow Object
..............................

ControlsWindow objects have the following methods besides those of
‘Window’ objects:

 -- Method: ControlsWindow.do_controlhit (window, control, pcode, event)

     Part _pcode_ of control _control_ was hit by the user.  Tracking
     and such has already been taken care of.


File: python.info,  Node: ScrolledWindow Object,  Next: DialogWindow Objects,  Prev: ControlsWindow Object,  Up: FrameWork --- Interactive application framework

5.36.6.4 ScrolledWindow Object
..............................

ScrolledWindow objects are ControlsWindow objects with the following
extra methods:

 -- Method: ScrolledWindow.scrollbars ([wantx[, wanty]])

     Create (or destroy) horizontal and vertical scrollbars.  The
     arguments specify which you want (default: both).  The scrollbars
     always have minimum ‘0’ and maximum ‘32767’.

 -- Method: ScrolledWindow.getscrollbarvalues ()

     You must supply this method.  It should return a tuple ‘(x, y)’
     giving the current position of the scrollbars (between ‘0’ and
     ‘32767’).  You can return ‘None’ for either to indicate the whole
     document is visible in that direction.

 -- Method: ScrolledWindow.updatescrollbars ()

     Call this method when the document has changed.  It will call *note
     getscrollbarvalues(): 2861. and update the scrollbars.

 -- Method: ScrolledWindow.scrollbar_callback (which, what, value)

     Supplied by you and called after user interaction.  _which_ will be
     ‘'x'’ or ‘'y'’, _what_ will be ‘'-'’, ‘'--'’, ‘'set'’, ‘'++'’ or
     ‘'+'’.  For ‘'set'’, _value_ will contain the new scrollbar
     position.

 -- Method: ScrolledWindow.scalebarvalues (absmin, absmax, curmin,
          curmax)

     Auxiliary method to help you calculate values to return from *note
     getscrollbarvalues(): 2861.  You pass document minimum and maximum
     value and topmost (leftmost) and bottommost (rightmost) visible
     values and it returns the correct number or ‘None’.

 -- Method: ScrolledWindow.do_activate (onoff, event)

     Takes care of dimming/highlighting scrollbars when a window becomes
     frontmost.  If you override this method, call this one at the end
     of your method.

 -- Method: ScrolledWindow.do_postresize (width, height, window)

     Moves scrollbars to the correct position.  Call this method
     initially if you override it.

 -- Method: ScrolledWindow.do_controlhit (window, control, pcode, event)

     Handles scrollbar interaction.  If you override it call this method
     first, a nonzero return value indicates the hit was in the
     scrollbars and has been handled.


File: python.info,  Node: DialogWindow Objects,  Prev: ScrolledWindow Object,  Up: FrameWork --- Interactive application framework

5.36.6.5 DialogWindow Objects
.............................

DialogWindow objects have the following methods besides those of
‘Window’ objects:

 -- Method: DialogWindow.open (resid)

     Create the dialog window, from the DLOG resource with id _resid_.
     The dialog object is stored in ‘self.wid’.

 -- Method: DialogWindow.do_itemhit (item, event)

     Item number _item_ was hit.  You are responsible for redrawing
     toggle buttons, etc.


File: python.info,  Node: autoGIL --- Global Interpreter Lock handling in event loops,  Next: Mac OS Toolbox Modules,  Prev: FrameWork --- Interactive application framework,  Up: Mac OS X specific services

5.36.7 ‘autoGIL’ — Global Interpreter Lock handling in event loops
------------------------------------------------------------------

The *note autoGIL: 14. module provides a function *note
installAutoGIL(): 286e. that automatically locks and unlocks Python’s
*note Global Interpreter Lock: 154e. when running an event loop.

     Note: This module has been removed in Python 3.x.

 -- Exception: autoGIL.AutoGILError

     Raised if the observer callback cannot be installed, for example
     because the current thread does not have a run loop.

 -- Function: autoGIL.installAutoGIL ()

     Install an observer callback in the event loop (CFRunLoop) for the
     current thread, that will lock and unlock the Global Interpreter
     Lock (GIL) at appropriate times, allowing other Python threads to
     run while the event loop is idle.

     Availability: OSX 10.1 or later.


File: python.info,  Node: Mac OS Toolbox Modules,  Next: ColorPicker --- Color selection dialog,  Prev: autoGIL --- Global Interpreter Lock handling in event loops,  Up: Mac OS X specific services

5.36.8 Mac OS Toolbox Modules
-----------------------------

These are a set of modules that provide interfaces to various legacy Mac
OS toolboxes.  If applicable the module will define a number of Python
objects for the various structures declared by the toolbox, and
operations will be implemented as methods of the object.  Other
operations will be implemented as functions in the module.  Not all
operations possible in C will also be possible in Python (callbacks are
often a problem), and parameters will occasionally be different in
Python (input and output buffers, especially).  All methods and
functions have a ‘__doc__’ string describing their arguments and return
values, and for additional description you are referred to Inside
Macintosh(1) or similar works.

  These modules all live in a package called ‘Carbon’.  Despite that
name they are not all part of the Carbon framework: CF is really in the
CoreFoundation framework and Qt is in the QuickTime framework.  The
normal use pattern is

     from Carbon import AE

     Note: Most of the OS X APIs that these modules use are deprecated
     or removed in recent versions of OS X. Many are not available when
     Python is executing in 64-bit mode.  The Carbon modules have been
     removed in Python 3.  You should avoid using them in Python 2.

* Menu:

* Carbon.AE: Carbon AE --- Apple Events. Apple Events
* Carbon.AH: Carbon AH --- Apple Help. Apple Help
* Carbon.App: Carbon App --- Appearance Manager. Appearance Manager
* Carbon.Appearance: Carbon Appearance --- Appearance Manager constants. Appearance Manager constants
* Carbon.CF: Carbon CF --- Core Foundation. Core Foundation
* Carbon.CG: Carbon CG --- Core Graphics. Core Graphics
* Carbon.CarbonEvt: Carbon CarbonEvt --- Carbon Event Manager. Carbon Event Manager
* Carbon.CarbonEvents: Carbon CarbonEvents --- Carbon Event Manager constants. Carbon Event Manager constants
* Carbon.Cm: Carbon Cm --- Component Manager. Component Manager
* Carbon.Components: Carbon Components --- Component Manager constants. Component Manager constants
* Carbon.ControlAccessor: Carbon ControlAccessor --- Control Manager accssors. Control Manager accssors
* Carbon.Controls: Carbon Controls --- Control Manager constants. Control Manager constants
* Carbon.CoreFounation: Carbon CoreFounation --- CoreFounation constants. CoreFounation constants
* Carbon.CoreGraphics: Carbon CoreGraphics --- CoreGraphics constants. CoreGraphics constants
* Carbon.Ctl: Carbon Ctl --- Control Manager. Control Manager
* Carbon.Dialogs: Carbon Dialogs --- Dialog Manager constants. Dialog Manager constants
* Carbon.Dlg: Carbon Dlg --- Dialog Manager. Dialog Manager
* Carbon.Drag: Carbon Drag --- Drag and Drop Manager. Drag and Drop Manager
* Carbon.Dragconst: Carbon Dragconst --- Drag and Drop Manager constants. Drag and Drop Manager constants
* Carbon.Events: Carbon Events --- Event Manager constants. Event Manager constants
* Carbon.Evt: Carbon Evt --- Event Manager. Event Manager
* Carbon.File: Carbon File --- File Manager. File Manager
* Carbon.Files: Carbon Files --- File Manager constants. File Manager constants
* Carbon.Fm: Carbon Fm --- Font Manager. Font Manager
* Carbon.Folder: Carbon Folder --- Folder Manager. Folder Manager
* Carbon.Folders: Carbon Folders --- Folder Manager constants. Folder Manager constants
* Carbon.Fonts: Carbon Fonts --- Font Manager constants. Font Manager constants
* Carbon.Help: Carbon Help --- Help Manager. Help Manager
* Carbon.IBCarbon: Carbon IBCarbon --- Carbon InterfaceBuilder. Carbon InterfaceBuilder
* Carbon.IBCarbonRuntime: Carbon IBCarbonRuntime --- Carbon InterfaceBuilder constants. Carbon InterfaceBuilder constants
* Carbon.Icn: Carbon Icn --- Carbon Icon Manager. Carbon Icon Manager
* Carbon.Icons: Carbon Icons --- Carbon Icon Manager constants. Carbon Icon Manager constants
* Carbon.Launch: Carbon Launch --- Carbon Launch Services. Carbon Launch Services
* Carbon.LaunchServices: Carbon LaunchServices --- Carbon Launch Services constants. Carbon Launch Services constants
* Carbon.List: Carbon List --- List Manager. List Manager
* Carbon.Lists: Carbon Lists --- List Manager constants. List Manager constants
* Carbon.MacHelp: Carbon MacHelp --- Help Manager constants. Help Manager constants
* Carbon.MediaDescr: Carbon MediaDescr --- Parsers and generators for Quicktime Media descriptors. Parsers and generators for Quicktime Media descriptors
* Carbon.Menu: Carbon Menu --- Menu Manager. Menu Manager
* Carbon.Menus: Carbon Menus --- Menu Manager constants. Menu Manager constants
* Carbon.Mlte: Carbon Mlte --- MultiLingual Text Editor. MultiLingual Text Editor
* Carbon.OSA: Carbon OSA --- Carbon OSA Interface. Carbon OSA Interface
* Carbon.OSAconst: Carbon OSAconst --- Carbon OSA Interface constants. Carbon OSA Interface constants
* Carbon.QDOffscreen: Carbon QDOffscreen --- QuickDraw Offscreen constants. QuickDraw Offscreen constants
* Carbon.Qd: Carbon Qd --- QuickDraw. QuickDraw
* Carbon.Qdoffs: Carbon Qdoffs --- QuickDraw Offscreen. QuickDraw Offscreen
* Carbon.Qt: Carbon Qt --- QuickTime. QuickTime
* Carbon.QuickDraw: Carbon QuickDraw --- QuickDraw constants. QuickDraw constants
* Carbon.QuickTime: Carbon QuickTime --- QuickTime constants. QuickTime constants
* Carbon.Res: Carbon Res --- Resource Manager and Handles. Resource Manager and Handles
* Carbon.Resources: Carbon Resources --- Resource Manager and Handles constants. Resource Manager and Handles constants
* Carbon.Scrap: Carbon Scrap --- Scrap Manager. Scrap Manager
* Carbon.Snd: Carbon Snd --- Sound Manager. Sound Manager
* Carbon.Sound: Carbon Sound --- Sound Manager constants. Sound Manager constants
* Carbon.TE: Carbon TE --- TextEdit. TextEdit
* Carbon.TextEdit: Carbon TextEdit --- TextEdit constants. TextEdit constants
* Carbon.Win: Carbon Win --- Window Manager. Window Manager
* Carbon.Windows: Carbon Windows --- Window Manager constants. Window Manager constants

   ---------- Footnotes ----------

   (1) 
http://developer.apple.com/legacy/mac/library/#documentation/macos8/mac8.html


File: python.info,  Node: Carbon AE --- Apple Events,  Next: Carbon AH --- Apple Help,  Up: Mac OS Toolbox Modules

5.36.8.1 ‘Carbon.AE’ — Apple Events
...................................


File: python.info,  Node: Carbon AH --- Apple Help,  Next: Carbon App --- Appearance Manager,  Prev: Carbon AE --- Apple Events,  Up: Mac OS Toolbox Modules

5.36.8.2 ‘Carbon.AH’ — Apple Help
.................................


File: python.info,  Node: Carbon App --- Appearance Manager,  Next: Carbon Appearance --- Appearance Manager constants,  Prev: Carbon AH --- Apple Help,  Up: Mac OS Toolbox Modules

5.36.8.3 ‘Carbon.App’ — Appearance Manager
..........................................


File: python.info,  Node: Carbon Appearance --- Appearance Manager constants,  Next: Carbon CF --- Core Foundation,  Prev: Carbon App --- Appearance Manager,  Up: Mac OS Toolbox Modules

5.36.8.4 ‘Carbon.Appearance’ — Appearance Manager constants
...........................................................


File: python.info,  Node: Carbon CF --- Core Foundation,  Next: Carbon CG --- Core Graphics,  Prev: Carbon Appearance --- Appearance Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.5 ‘Carbon.CF’ — Core Foundation
......................................

The ‘CFBase’, ‘CFArray’, ‘CFData’, ‘CFDictionary’, ‘CFString’ and
‘CFURL’ objects are supported, some only partially.


File: python.info,  Node: Carbon CG --- Core Graphics,  Next: Carbon CarbonEvt --- Carbon Event Manager,  Prev: Carbon CF --- Core Foundation,  Up: Mac OS Toolbox Modules

5.36.8.6 ‘Carbon.CG’ — Core Graphics
....................................


File: python.info,  Node: Carbon CarbonEvt --- Carbon Event Manager,  Next: Carbon CarbonEvents --- Carbon Event Manager constants,  Prev: Carbon CG --- Core Graphics,  Up: Mac OS Toolbox Modules

5.36.8.7 ‘Carbon.CarbonEvt’ — Carbon Event Manager
..................................................


File: python.info,  Node: Carbon CarbonEvents --- Carbon Event Manager constants,  Next: Carbon Cm --- Component Manager,  Prev: Carbon CarbonEvt --- Carbon Event Manager,  Up: Mac OS Toolbox Modules

5.36.8.8 ‘Carbon.CarbonEvents’ — Carbon Event Manager constants
...............................................................


File: python.info,  Node: Carbon Cm --- Component Manager,  Next: Carbon Components --- Component Manager constants,  Prev: Carbon CarbonEvents --- Carbon Event Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.9 ‘Carbon.Cm’ — Component Manager
........................................


File: python.info,  Node: Carbon Components --- Component Manager constants,  Next: Carbon ControlAccessor --- Control Manager accssors,  Prev: Carbon Cm --- Component Manager,  Up: Mac OS Toolbox Modules

5.36.8.10 ‘Carbon.Components’ — Component Manager constants
...........................................................


File: python.info,  Node: Carbon ControlAccessor --- Control Manager accssors,  Next: Carbon Controls --- Control Manager constants,  Prev: Carbon Components --- Component Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.11 ‘Carbon.ControlAccessor’ — Control Manager accssors
.............................................................


File: python.info,  Node: Carbon Controls --- Control Manager constants,  Next: Carbon CoreFounation --- CoreFounation constants,  Prev: Carbon ControlAccessor --- Control Manager accssors,  Up: Mac OS Toolbox Modules

5.36.8.12 ‘Carbon.Controls’ — Control Manager constants
.......................................................


File: python.info,  Node: Carbon CoreFounation --- CoreFounation constants,  Next: Carbon CoreGraphics --- CoreGraphics constants,  Prev: Carbon Controls --- Control Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.13 ‘Carbon.CoreFounation’ — CoreFounation constants
..........................................................


File: python.info,  Node: Carbon CoreGraphics --- CoreGraphics constants,  Next: Carbon Ctl --- Control Manager,  Prev: Carbon CoreFounation --- CoreFounation constants,  Up: Mac OS Toolbox Modules

5.36.8.14 ‘Carbon.CoreGraphics’ — CoreGraphics constants
........................................................


File: python.info,  Node: Carbon Ctl --- Control Manager,  Next: Carbon Dialogs --- Dialog Manager constants,  Prev: Carbon CoreGraphics --- CoreGraphics constants,  Up: Mac OS Toolbox Modules

5.36.8.15 ‘Carbon.Ctl’ — Control Manager
........................................


File: python.info,  Node: Carbon Dialogs --- Dialog Manager constants,  Next: Carbon Dlg --- Dialog Manager,  Prev: Carbon Ctl --- Control Manager,  Up: Mac OS Toolbox Modules

5.36.8.16 ‘Carbon.Dialogs’ — Dialog Manager constants
.....................................................


File: python.info,  Node: Carbon Dlg --- Dialog Manager,  Next: Carbon Drag --- Drag and Drop Manager,  Prev: Carbon Dialogs --- Dialog Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.17 ‘Carbon.Dlg’ — Dialog Manager
.......................................


File: python.info,  Node: Carbon Drag --- Drag and Drop Manager,  Next: Carbon Dragconst --- Drag and Drop Manager constants,  Prev: Carbon Dlg --- Dialog Manager,  Up: Mac OS Toolbox Modules

5.36.8.18 ‘Carbon.Drag’ — Drag and Drop Manager
...............................................


File: python.info,  Node: Carbon Dragconst --- Drag and Drop Manager constants,  Next: Carbon Events --- Event Manager constants,  Prev: Carbon Drag --- Drag and Drop Manager,  Up: Mac OS Toolbox Modules

5.36.8.19 ‘Carbon.Dragconst’ — Drag and Drop Manager constants
..............................................................


File: python.info,  Node: Carbon Events --- Event Manager constants,  Next: Carbon Evt --- Event Manager,  Prev: Carbon Dragconst --- Drag and Drop Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.20 ‘Carbon.Events’ — Event Manager constants
...................................................


File: python.info,  Node: Carbon Evt --- Event Manager,  Next: Carbon File --- File Manager,  Prev: Carbon Events --- Event Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.21 ‘Carbon.Evt’ — Event Manager
......................................


File: python.info,  Node: Carbon File --- File Manager,  Next: Carbon Files --- File Manager constants,  Prev: Carbon Evt --- Event Manager,  Up: Mac OS Toolbox Modules

5.36.8.22 ‘Carbon.File’ — File Manager
......................................


File: python.info,  Node: Carbon Files --- File Manager constants,  Next: Carbon Fm --- Font Manager,  Prev: Carbon File --- File Manager,  Up: Mac OS Toolbox Modules

5.36.8.23 ‘Carbon.Files’ — File Manager constants
.................................................


File: python.info,  Node: Carbon Fm --- Font Manager,  Next: Carbon Folder --- Folder Manager,  Prev: Carbon Files --- File Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.24 ‘Carbon.Fm’ — Font Manager
....................................


File: python.info,  Node: Carbon Folder --- Folder Manager,  Next: Carbon Folders --- Folder Manager constants,  Prev: Carbon Fm --- Font Manager,  Up: Mac OS Toolbox Modules

5.36.8.25 ‘Carbon.Folder’ — Folder Manager
..........................................


File: python.info,  Node: Carbon Folders --- Folder Manager constants,  Next: Carbon Fonts --- Font Manager constants,  Prev: Carbon Folder --- Folder Manager,  Up: Mac OS Toolbox Modules

5.36.8.26 ‘Carbon.Folders’ — Folder Manager constants
.....................................................


File: python.info,  Node: Carbon Fonts --- Font Manager constants,  Next: Carbon Help --- Help Manager,  Prev: Carbon Folders --- Folder Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.27 ‘Carbon.Fonts’ — Font Manager constants
.................................................


File: python.info,  Node: Carbon Help --- Help Manager,  Next: Carbon IBCarbon --- Carbon InterfaceBuilder,  Prev: Carbon Fonts --- Font Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.28 ‘Carbon.Help’ — Help Manager
......................................


File: python.info,  Node: Carbon IBCarbon --- Carbon InterfaceBuilder,  Next: Carbon IBCarbonRuntime --- Carbon InterfaceBuilder constants,  Prev: Carbon Help --- Help Manager,  Up: Mac OS Toolbox Modules

5.36.8.29 ‘Carbon.IBCarbon’ — Carbon InterfaceBuilder
.....................................................


File: python.info,  Node: Carbon IBCarbonRuntime --- Carbon InterfaceBuilder constants,  Next: Carbon Icn --- Carbon Icon Manager,  Prev: Carbon IBCarbon --- Carbon InterfaceBuilder,  Up: Mac OS Toolbox Modules

5.36.8.30 ‘Carbon.IBCarbonRuntime’ — Carbon InterfaceBuilder constants
......................................................................


File: python.info,  Node: Carbon Icn --- Carbon Icon Manager,  Next: Carbon Icons --- Carbon Icon Manager constants,  Prev: Carbon IBCarbonRuntime --- Carbon InterfaceBuilder constants,  Up: Mac OS Toolbox Modules

5.36.8.31 ‘Carbon.Icn’ — Carbon Icon Manager
............................................


File: python.info,  Node: Carbon Icons --- Carbon Icon Manager constants,  Next: Carbon Launch --- Carbon Launch Services,  Prev: Carbon Icn --- Carbon Icon Manager,  Up: Mac OS Toolbox Modules

5.36.8.32 ‘Carbon.Icons’ — Carbon Icon Manager constants
........................................................


File: python.info,  Node: Carbon Launch --- Carbon Launch Services,  Next: Carbon LaunchServices --- Carbon Launch Services constants,  Prev: Carbon Icons --- Carbon Icon Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.33 ‘Carbon.Launch’ — Carbon Launch Services
..................................................


File: python.info,  Node: Carbon LaunchServices --- Carbon Launch Services constants,  Next: Carbon List --- List Manager,  Prev: Carbon Launch --- Carbon Launch Services,  Up: Mac OS Toolbox Modules

5.36.8.34 ‘Carbon.LaunchServices’ — Carbon Launch Services constants
....................................................................


File: python.info,  Node: Carbon List --- List Manager,  Next: Carbon Lists --- List Manager constants,  Prev: Carbon LaunchServices --- Carbon Launch Services constants,  Up: Mac OS Toolbox Modules

5.36.8.35 ‘Carbon.List’ — List Manager
......................................


File: python.info,  Node: Carbon Lists --- List Manager constants,  Next: Carbon MacHelp --- Help Manager constants,  Prev: Carbon List --- List Manager,  Up: Mac OS Toolbox Modules

5.36.8.36 ‘Carbon.Lists’ — List Manager constants
.................................................


File: python.info,  Node: Carbon MacHelp --- Help Manager constants,  Next: Carbon MediaDescr --- Parsers and generators for Quicktime Media descriptors,  Prev: Carbon Lists --- List Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.37 ‘Carbon.MacHelp’ — Help Manager constants
...................................................


File: python.info,  Node: Carbon MediaDescr --- Parsers and generators for Quicktime Media descriptors,  Next: Carbon Menu --- Menu Manager,  Prev: Carbon MacHelp --- Help Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.38 ‘Carbon.MediaDescr’ — Parsers and generators for Quicktime Media descriptors
......................................................................................


File: python.info,  Node: Carbon Menu --- Menu Manager,  Next: Carbon Menus --- Menu Manager constants,  Prev: Carbon MediaDescr --- Parsers and generators for Quicktime Media descriptors,  Up: Mac OS Toolbox Modules

5.36.8.39 ‘Carbon.Menu’ — Menu Manager
......................................


File: python.info,  Node: Carbon Menus --- Menu Manager constants,  Next: Carbon Mlte --- MultiLingual Text Editor,  Prev: Carbon Menu --- Menu Manager,  Up: Mac OS Toolbox Modules

5.36.8.40 ‘Carbon.Menus’ — Menu Manager constants
.................................................


File: python.info,  Node: Carbon Mlte --- MultiLingual Text Editor,  Next: Carbon OSA --- Carbon OSA Interface,  Prev: Carbon Menus --- Menu Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.41 ‘Carbon.Mlte’ — MultiLingual Text Editor
..................................................


File: python.info,  Node: Carbon OSA --- Carbon OSA Interface,  Next: Carbon OSAconst --- Carbon OSA Interface constants,  Prev: Carbon Mlte --- MultiLingual Text Editor,  Up: Mac OS Toolbox Modules

5.36.8.42 ‘Carbon.OSA’ — Carbon OSA Interface
.............................................


File: python.info,  Node: Carbon OSAconst --- Carbon OSA Interface constants,  Next: Carbon QDOffscreen --- QuickDraw Offscreen constants,  Prev: Carbon OSA --- Carbon OSA Interface,  Up: Mac OS Toolbox Modules

5.36.8.43 ‘Carbon.OSAconst’ — Carbon OSA Interface constants
............................................................


File: python.info,  Node: Carbon QDOffscreen --- QuickDraw Offscreen constants,  Next: Carbon Qd --- QuickDraw,  Prev: Carbon OSAconst --- Carbon OSA Interface constants,  Up: Mac OS Toolbox Modules

5.36.8.44 ‘Carbon.QDOffscreen’ — QuickDraw Offscreen constants
..............................................................


File: python.info,  Node: Carbon Qd --- QuickDraw,  Next: Carbon Qdoffs --- QuickDraw Offscreen,  Prev: Carbon QDOffscreen --- QuickDraw Offscreen constants,  Up: Mac OS Toolbox Modules

5.36.8.45 ‘Carbon.Qd’ — QuickDraw
.................................


File: python.info,  Node: Carbon Qdoffs --- QuickDraw Offscreen,  Next: Carbon Qt --- QuickTime,  Prev: Carbon Qd --- QuickDraw,  Up: Mac OS Toolbox Modules

5.36.8.46 ‘Carbon.Qdoffs’ — QuickDraw Offscreen
...............................................


File: python.info,  Node: Carbon Qt --- QuickTime,  Next: Carbon QuickDraw --- QuickDraw constants,  Prev: Carbon Qdoffs --- QuickDraw Offscreen,  Up: Mac OS Toolbox Modules

5.36.8.47 ‘Carbon.Qt’ — QuickTime
.................................


File: python.info,  Node: Carbon QuickDraw --- QuickDraw constants,  Next: Carbon QuickTime --- QuickTime constants,  Prev: Carbon Qt --- QuickTime,  Up: Mac OS Toolbox Modules

5.36.8.48 ‘Carbon.QuickDraw’ — QuickDraw constants
..................................................


File: python.info,  Node: Carbon QuickTime --- QuickTime constants,  Next: Carbon Res --- Resource Manager and Handles,  Prev: Carbon QuickDraw --- QuickDraw constants,  Up: Mac OS Toolbox Modules

5.36.8.49 ‘Carbon.QuickTime’ — QuickTime constants
..................................................


File: python.info,  Node: Carbon Res --- Resource Manager and Handles,  Next: Carbon Resources --- Resource Manager and Handles constants,  Prev: Carbon QuickTime --- QuickTime constants,  Up: Mac OS Toolbox Modules

5.36.8.50 ‘Carbon.Res’ — Resource Manager and Handles
.....................................................


File: python.info,  Node: Carbon Resources --- Resource Manager and Handles constants,  Next: Carbon Scrap --- Scrap Manager,  Prev: Carbon Res --- Resource Manager and Handles,  Up: Mac OS Toolbox Modules

5.36.8.51 ‘Carbon.Resources’ — Resource Manager and Handles constants
.....................................................................


File: python.info,  Node: Carbon Scrap --- Scrap Manager,  Next: Carbon Snd --- Sound Manager,  Prev: Carbon Resources --- Resource Manager and Handles constants,  Up: Mac OS Toolbox Modules

5.36.8.52 ‘Carbon.Scrap’ — Scrap Manager
........................................

This module is only fully available on Mac OS 9 and earlier under
classic PPC MacPython.  Very limited functionality is available under
Carbon MacPython.

  The Scrap Manager supports the simplest form of cut & paste operations
on the Macintosh.  It can be use for both inter- and intra-application
clipboard operations.

  The ‘Scrap’ module provides low-level access to the functions of the
Scrap Manager.  It contains the following functions:

 -- Function: Carbon.Scrap.InfoScrap ()

     Return current information about the scrap.  The information is
     encoded as a tuple containing the fields ‘(size, handle, count,
     state, path)’.

     Field          Meaning
                    
     -----------------------------------------------------------------
                    
     _size_         Size of the scrap in bytes.
                    
                    
     _handle_       Resource object representing the scrap.
                    
                    
     _count_        Serial number of the scrap contents.
                    
                    
     _state_        Integer; positive if in memory, ‘0’ if on disk,
                    negative if uninitialized.
                    
                    
     _path_         Filename of the scrap when stored on disk.
                    

See also
........

Scrap Manager(1)

     Apple’s documentation for the Scrap Manager gives a lot of useful
     information about using the Scrap Manager in applications.

   ---------- Footnotes ----------

   (1) 
http://developer.apple.com/legacy/mac/library/documentation/mac/MoreToolbox/MoreToolbox-109.html


File: python.info,  Node: Carbon Snd --- Sound Manager,  Next: Carbon Sound --- Sound Manager constants,  Prev: Carbon Scrap --- Scrap Manager,  Up: Mac OS Toolbox Modules

5.36.8.53 ‘Carbon.Snd’ — Sound Manager
......................................


File: python.info,  Node: Carbon Sound --- Sound Manager constants,  Next: Carbon TE --- TextEdit,  Prev: Carbon Snd --- Sound Manager,  Up: Mac OS Toolbox Modules

5.36.8.54 ‘Carbon.Sound’ — Sound Manager constants
..................................................


File: python.info,  Node: Carbon TE --- TextEdit,  Next: Carbon TextEdit --- TextEdit constants,  Prev: Carbon Sound --- Sound Manager constants,  Up: Mac OS Toolbox Modules

5.36.8.55 ‘Carbon.TE’ — TextEdit
................................


File: python.info,  Node: Carbon TextEdit --- TextEdit constants,  Next: Carbon Win --- Window Manager,  Prev: Carbon TE --- TextEdit,  Up: Mac OS Toolbox Modules

5.36.8.56 ‘Carbon.TextEdit’ — TextEdit constants
................................................


File: python.info,  Node: Carbon Win --- Window Manager,  Next: Carbon Windows --- Window Manager constants,  Prev: Carbon TextEdit --- TextEdit constants,  Up: Mac OS Toolbox Modules

5.36.8.57 ‘Carbon.Win’ — Window Manager
.......................................


File: python.info,  Node: Carbon Windows --- Window Manager constants,  Prev: Carbon Win --- Window Manager,  Up: Mac OS Toolbox Modules

5.36.8.58 ‘Carbon.Windows’ — Window Manager constants
.....................................................


File: python.info,  Node: ColorPicker --- Color selection dialog,  Prev: Mac OS Toolbox Modules,  Up: Mac OS X specific services

5.36.9 ‘ColorPicker’ — Color selection dialog
---------------------------------------------

The *note ColorPicker: 66. module provides access to the standard color
picker dialog.

     Note: This module has been removed in Python 3.x.

 -- Function: ColorPicker.GetColor (prompt, rgb)

     Show a standard color selection dialog and allow the user to select
     a color.  The user is given instruction by the _prompt_ string, and
     the default color is set to _rgb_.  _rgb_ must be a tuple giving
     the red, green, and blue components of the color.  *note
     GetColor(): 28b0. returns a tuple giving the user’s selected color
     and a flag indicating whether they accepted the selection of
     cancelled.


File: python.info,  Node: MacPython OSA Modules,  Next: SGI IRIX Specific Services,  Prev: Mac OS X specific services,  Up: The Python Standard Library

5.37 MacPython OSA Modules
==========================

This chapter describes the current implementation of the Open Scripting
Architecture (OSA, also commonly referred to as AppleScript) for Python,
allowing you to control scriptable applications from your Python
program, and with a fairly pythonic interface.  Development on this set
of modules has stopped.

  For a description of the various components of AppleScript and OSA,
and to get an understanding of the architecture and terminology, you
should read Apple’s documentation.  The "Applescript Language Guide"
explains the conceptual model and the terminology, and documents the
standard suite.  The "Open Scripting Architecture" document explains how
to use OSA from an application programmers point of view.  In the Apple
Help Viewer these books are located in the Developer Documentation, Core
Technologies section.

  As an example of scripting an application, the following piece of
AppleScript will get the name of the frontmost *Finder* window and print
it:

     tell application "Finder"
         get name of window 1
     end tell

  In Python, the following code fragment will do the same:

     import Finder

     f = Finder.Finder()
     print f.get(f.window(1).name)

  As distributed the Python library includes packages that implement the
standard suites, plus packages that interface to a small number of
common applications.

  To send AppleEvents to an application you must first create the Python
package interfacing to the terminology of the application (what *Script
Editor* calls the "Dictionary").  This can be done from within the
*PythonIDE* or by running the ‘gensuitemodule.py’ module as a standalone
program from the command line.

  The generated output is a package with a number of modules, one for
every suite used in the program plus an ‘__init__’ module to glue it all
together.  The Python inheritance graph follows the AppleScript
inheritance graph, so if a program’s dictionary specifies that it
includes support for the Standard Suite, but extends one or two verbs
with extra arguments then the output suite will contain a module
‘Standard_Suite’ that imports and re-exports everything from
‘StdSuites.Standard_Suite’ but overrides the methods that have extra
functionality.  The output of *note gensuitemodule: dd. is pretty
readable, and contains the documentation that was in the original
AppleScript dictionary in Python docstrings, so reading it is a good
source of documentation.

  The output package implements a main class with the same name as the
package which contains all the AppleScript verbs as methods, with the
direct object as the first argument and all optional parameters as
keyword arguments.  AppleScript classes are also implemented as Python
classes, as are comparisons and all the other thingies.

  The main Python class implementing the verbs also allows access to the
properties and elements declared in the AppleScript class "application".
In the current release that is as far as the object orientation goes, so
in the example above we need to use ‘f.get(f.window(1).name)’ instead of
the more Pythonic ‘f.window(1).name.get()’.

  If an AppleScript identifier is not a Python identifier the name is
mangled according to a small number of rules:

   * spaces are replaced with underscores

   * other non-alphanumeric characters are replaced with ‘_xx_’ where
     ‘xx’ is the hexadecimal character value

   * any Python reserved word gets an underscore appended

  Python also has support for creating scriptable applications in
Python, but The following modules are relevant to MacPython AppleScript
support:

* Menu:

* gensuitemodule: gensuitemodule --- Generate OSA stub packages. Generate OSA stub packages
* aetools: aetools --- OSA client support. OSA client support
* aepack: aepack --- Conversion between Python variables and AppleEvent data containers. Conversion between Python variables and AppleEvent
                        data containers
* aetypes: aetypes --- AppleEvent objects. AppleEvent objects
* MiniAEFrame: MiniAEFrame --- Open Scripting Architecture server support. Open Scripting Architecture server support


File: python.info,  Node: gensuitemodule --- Generate OSA stub packages,  Next: aetools --- OSA client support,  Up: MacPython OSA Modules

5.37.1 ‘gensuitemodule’ — Generate OSA stub packages
----------------------------------------------------

The *note gensuitemodule: dd. module creates a Python package
implementing stub code for the AppleScript suites that are implemented
by a specific application, according to its AppleScript dictionary.

  It is usually invoked by the user through the *PythonIDE*, but it can
also be run as a script from the command line (pass *note –help: 1d5.
for help on the options) or imported from Python code.  For an example
of its use see ‘Mac/scripts/genallsuites.py’ in a source distribution,
which generates the stub packages that are included in the standard
library.

  It defines the following public functions:

 -- Function: gensuitemodule.is_scriptable (application)

     Returns true if ‘application’, which should be passed as a
     pathname, appears to be scriptable.  Take the return value with a
     grain of salt: *Internet Explorer* appears not to be scriptable but
     definitely is.

 -- Function: gensuitemodule.processfile (application[, output,
          basepkgname, edit_modnames, creatorsignature, dump, verbose])

     Create a stub package for ‘application’, which should be passed as
     a full pathname.  For a ‘.app’ bundle this is the pathname to the
     bundle, not to the executable inside the bundle; for an unbundled
     CFM application you pass the filename of the application binary.

     This function asks the application for its OSA terminology
     resources, decodes these resources and uses the resultant data to
     create the Python code for the package implementing the client
     stubs.

     ‘output’ is the pathname where the resulting package is stored, if
     not specified a standard "save file as" dialog is presented to the
     user.  ‘basepkgname’ is the base package on which this package will
     build, and defaults to ‘StdSuites’.  Only when generating
     ‘StdSuites’ itself do you need to specify this.  ‘edit_modnames’ is
     a dictionary that can be used to change modulenames that are too
     ugly after name mangling.  ‘creator_signature’ can be used to
     override the 4-char creator code, which is normally obtained from
     the ‘PkgInfo’ file in the package or from the CFM file creator
     signature.  When ‘dump’ is given it should refer to a file object,
     and ‘processfile’ will stop after decoding the resources and dump
     the Python representation of the terminology resources to this
     file.  ‘verbose’ should also be a file object, and specifying it
     will cause ‘processfile’ to tell you what it is doing.

 -- Function: gensuitemodule.processfile_fromresource (application[,
          output, basepkgname, edit_modnames, creatorsignature, dump,
          verbose])

     This function does the same as ‘processfile’, except that it uses a
     different method to get the terminology resources.  It opens
     ‘application’ as a resource file and reads all ‘"aete"’ and
     ‘"aeut"’ resources from this file.


File: python.info,  Node: aetools --- OSA client support,  Next: aepack --- Conversion between Python variables and AppleEvent data containers,  Prev: gensuitemodule --- Generate OSA stub packages,  Up: MacPython OSA Modules

5.37.2 ‘aetools’ — OSA client support
-------------------------------------

The *note aetools: 6. module contains the basic functionality on which
Python AppleScript client support is built.  It also imports and
re-exports the core functionality of the *note aetypes: 7. and *note
aepack: 5. modules.  The stub packages generated by *note
gensuitemodule: dd. import the relevant portions of *note aetools: 6, so
usually you do not need to import it yourself.  The exception to this is
when you cannot use a generated suite package and need lower-level
access to scripting.

  The *note aetools: 6. module itself uses the AppleEvent support
provided by the *note Carbon.AE: 20. module.  This has one drawback: you
need access to the window manager, see section *note Running scripts
with a GUI: 681. for details.  This restriction may be lifted in future
releases.

     Note: This module has been removed in Python 3.x.

  The *note aetools: 6. module defines the following functions:

 -- Function: aetools.packevent (ae, parameters, attributes)

     Stores parameters and attributes in a pre-created
     ‘Carbon.AE.AEDesc’ object.  ‘parameters’ and ‘attributes’ are
     dictionaries mapping 4-character OSA parameter keys to Python
     objects.  The objects are packed using ‘aepack.pack()’.

 -- Function: aetools.unpackevent (ae[, formodulename])

     Recursively unpacks a ‘Carbon.AE.AEDesc’ event to Python objects.
     The function returns the parameter dictionary and the attribute
     dictionary.  The ‘formodulename’ argument is used by generated stub
     packages to control where AppleScript classes are looked up.

 -- Function: aetools.keysubst (arguments, keydict)

     Converts a Python keyword argument dictionary ‘arguments’ to the
     format required by ‘packevent’ by replacing the keys, which are
     Python identifiers, by the four-character OSA keys according to the
     mapping specified in ‘keydict’.  Used by the generated suite
     packages.

 -- Function: aetools.enumsubst (arguments, key, edict)

     If the ‘arguments’ dictionary contains an entry for ‘key’ convert
     the value for that entry according to dictionary ‘edict’.  This
     converts human-readable Python enumeration names to the OSA
     4-character codes.  Used by the generated suite packages.

  The *note aetools: 6. module defines the following class:

 -- Class: aetools.TalkTo ([signature=None, start=0, timeout=0])

     Base class for the proxy used to talk to an application.
     ‘signature’ overrides the class attribute ‘_signature’ (which is
     usually set by subclasses) and is the 4-char creator code defining
     the application to talk to.  ‘start’ can be set to true to enable
     running the application on class instantiation.  ‘timeout’ can be
     specified to change the default timeout used while waiting for an
     AppleEvent reply.

 -- Method: TalkTo._start ()

     Test whether the application is running, and attempt to start it if
     not.

 -- Method: TalkTo.send (code, subcode[, parameters, attributes])

     Create the AppleEvent ‘Carbon.AE.AEDesc’ for the verb with the OSA
     designation ‘code, subcode’ (which are the usual 4-character
     strings), pack the ‘parameters’ and ‘attributes’ into it, send it
     to the target application, wait for the reply, unpack the reply
     with ‘unpackevent’ and return the reply appleevent, the unpacked
     return values as a dictionary and the return attributes.


File: python.info,  Node: aepack --- Conversion between Python variables and AppleEvent data containers,  Next: aetypes --- AppleEvent objects,  Prev: aetools --- OSA client support,  Up: MacPython OSA Modules

5.37.3 ‘aepack’ — Conversion between Python variables and AppleEvent data containers
------------------------------------------------------------------------------------

The *note aepack: 5. module defines functions for converting (packing)
Python variables to AppleEvent descriptors and back (unpacking).  Within
Python the AppleEvent descriptor is handled by Python objects of
built-in type ‘AEDesc’, defined in module *note Carbon.AE: 20.

     Note: This module has been removed in Python 3.x.

  The *note aepack: 5. module defines the following functions:

 -- Function: aepack.pack (x[, forcetype])

     Returns an ‘AEDesc’ object containing a conversion of Python value
     x.  If _forcetype_ is provided it specifies the descriptor type of
     the result.  Otherwise, a default mapping of Python types to Apple
     Event descriptor types is used, as follows:

     Python type           descriptor type
                           
     --------------------------------------------------------------
                           
     ‘FSSpec’              typeFSS
                           
                           
     ‘FSRef’               typeFSRef
                           
                           
     ‘Alias’               typeAlias
                           
                           
     integer               typeLong (32 bit integer)
                           
                           
     float                 typeFloat (64 bit floating point)
                           
                           
     string                typeText
                           
                           
     unicode               typeUnicodeText
                           
                           
     list                  typeAEList
                           
                           
     dictionary            typeAERecord
                           
                           
     instance              _see below_
                           

     If _x_ is a Python instance then this function attempts to call an
     ‘__aepack__()’ method.  This method should return an ‘AEDesc’
     object.

     If the conversion _x_ is not defined above, this function returns
     the Python string representation of a value (the repr() function)
     encoded as a text descriptor.

 -- Function: aepack.unpack (x[, formodulename])

     _x_ must be an object of type ‘AEDesc’.  This function returns a
     Python object representation of the data in the Apple Event
     descriptor _x_.  Simple AppleEvent data types (integer, text,
     float) are returned as their obvious Python counterparts.  Apple
     Event lists are returned as Python lists, and the list elements are
     recursively unpacked.  Object references (ex.  ‘line 3 of document
     1’) are returned as instances of *note aetypes.ObjectSpecifier:
     28c5, unless ‘formodulename’ is specified.  AppleEvent descriptors
     with descriptor type typeFSS are returned as ‘FSSpec’ objects.
     AppleEvent record descriptors are returned as Python dictionaries,
     with 4-character string keys and elements recursively unpacked.

     The optional ‘formodulename’ argument is used by the stub packages
     generated by *note gensuitemodule: dd, and ensures that the OSA
     classes for object specifiers are looked up in the correct module.
     This ensures that if, say, the Finder returns an object specifier
     for a window you get an instance of ‘Finder.Window’ and not a
     generic ‘aetypes.Window’.  The former knows about all the
     properties and elements a window has in the Finder, while the
     latter knows no such things.

See also
........

Module *note Carbon.AE: 20.

     Built-in access to Apple Event Manager routines.

Module *note aetypes: 7.

     Python definitions of codes for Apple Event descriptor types.


File: python.info,  Node: aetypes --- AppleEvent objects,  Next: MiniAEFrame --- Open Scripting Architecture server support,  Prev: aepack --- Conversion between Python variables and AppleEvent data containers,  Up: MacPython OSA Modules

5.37.4 ‘aetypes’ — AppleEvent objects
-------------------------------------

The *note aetypes: 7. defines classes used to represent Apple Event data
descriptors and Apple Event object specifiers.

  Apple Event data is contained in descriptors, and these descriptors
are typed.  For many descriptors the Python representation is simply the
corresponding Python type: ‘typeText’ in OSA is a Python string,
‘typeFloat’ is a float, etc.  For OSA types that have no direct Python
counterpart this module declares classes.  Packing and unpacking
instances of these classes is handled automatically by *note aepack: 5.

  An object specifier is essentially an address of an object implemented
in a Apple Event server.  An Apple Event specifier is used as the direct
object for an Apple Event or as the argument of an optional parameter.
The *note aetypes: 7. module contains the base classes for OSA classes
and properties, which are used by the packages generated by *note
gensuitemodule: dd. to populate the classes and properties in a given
suite.

  For reasons of backward compatibility, and for cases where you need to
script an application for which you have not generated the stub package
this module also contains object specifiers for a number of common OSA
classes such as ‘Document’, ‘Window’, ‘Character’, etc.

     Note: This module has been removed in Python 3.x.

  The ‘AEObjects’ module defines the following classes to represent
Apple Event descriptor data:

 -- Class: aetypes.Unknown (type, data)

     The representation of OSA descriptor data for which the *note
     aepack: 5. and *note aetypes: 7. modules have no support, i.e.
     anything that is not represented by the other classes here and that
     is not equivalent to a simple Python value.

 -- Class: aetypes.Enum (enum)

     An enumeration value with the given 4-character string value.

 -- Class: aetypes.InsertionLoc (of, pos)

     Position ‘pos’ in object ‘of’.

 -- Class: aetypes.Boolean (bool)

     A boolean.

 -- Class: aetypes.StyledText (style, text)

     Text with style information (font, face, etc) included.

 -- Class: aetypes.AEText (script, style, text)

     Text with script system and style information included.

 -- Class: aetypes.IntlText (script, language, text)

     Text with script system and language information included.

 -- Class: aetypes.IntlWritingCode (script, language)

     Script system and language information.

 -- Class: aetypes.QDPoint (v, h)

     A quickdraw point.

 -- Class: aetypes.QDRectangle (v0, h0, v1, h1)

     A quickdraw rectangle.

 -- Class: aetypes.RGBColor (r, g, b)

     A color.

 -- Class: aetypes.Type (type)

     An OSA type value with the given 4-character name.

 -- Class: aetypes.Keyword (name)

     An OSA keyword with the given 4-character name.

 -- Class: aetypes.Range (start, stop)

     A range.

 -- Class: aetypes.Ordinal (abso)

     Non-numeric absolute positions, such as ‘"firs"’, first, or
     ‘"midd"’, middle.

 -- Class: aetypes.Logical (logc, term)

     The logical expression of applying operator ‘logc’ to ‘term’.

 -- Class: aetypes.Comparison (obj1, relo, obj2)

     The comparison ‘relo’ of ‘obj1’ to ‘obj2’.

  The following classes are used as base classes by the generated stub
packages to represent AppleScript classes and properties in Python:

 -- Class: aetypes.ComponentItem (which[, fr])

     Abstract baseclass for an OSA class.  The subclass should set the
     class attribute ‘want’ to the 4-character OSA class code.
     Instances of subclasses of this class are equivalent to AppleScript
     Object Specifiers.  Upon instantiation you should pass a selector
     in ‘which’, and optionally a parent object in ‘fr’.

 -- Class: aetypes.NProperty (fr)

     Abstract baseclass for an OSA property.  The subclass should set
     the class attributes ‘want’ and ‘which’ to designate which property
     we are talking about.  Instances of subclasses of this class are
     Object Specifiers.

 -- Class: aetypes.ObjectSpecifier (want, form, seld[, fr])

     Base class of ‘ComponentItem’ and ‘NProperty’, a general OSA Object
     Specifier.  See the Apple Open Scripting Architecture documentation
     for the parameters.  Note that this class is not abstract.


File: python.info,  Node: MiniAEFrame --- Open Scripting Architecture server support,  Prev: aetypes --- AppleEvent objects,  Up: MacPython OSA Modules

5.37.5 ‘MiniAEFrame’ — Open Scripting Architecture server support
-----------------------------------------------------------------

The module *note MiniAEFrame: 113. provides a framework for an
application that can function as an Open Scripting Architecture (OSA)
server, i.e.  receive and process AppleEvents.  It can be used in
conjunction with *note FrameWork: d7. or standalone.  As an example, it
is used in *PythonCGISlave*.

  The *note MiniAEFrame: 113. module defines the following classes:

 -- Class: MiniAEFrame.AEServer

     A class that handles AppleEvent dispatch.  Your application should
     subclass this class together with either *note MiniApplication:
     28de. or *note FrameWork.Application: 283e.  Your *note __init__():
     37c. method should call the *note __init__(): 37c. method for both
     classes.

 -- Class: MiniAEFrame.MiniApplication

     A class that is more or less compatible with *note
     FrameWork.Application: 283e. but with less functionality.  Its
     event loop supports the apple menu, command-dot and AppleEvents;
     other events are passed on to the Python interpreter and/or Sioux.
     Useful if your application wants to use *note AEServer: 28dd. but
     does not provide its own windows, etc.

* Menu:

* AEServer Objects:: 


File: python.info,  Node: AEServer Objects,  Up: MiniAEFrame --- Open Scripting Architecture server support

5.37.5.1 AEServer Objects
.........................

 -- Method: AEServer.installaehandler (classe, type, callback)

     Installs an AppleEvent handler.  _classe_ and _type_ are the
     four-character OSA Class and Type designators, ‘'****'’ wildcards
     are allowed.  When a matching AppleEvent is received the parameters
     are decoded and your callback is invoked.

 -- Method: AEServer.callback (_object, **kwargs)

     Your callback is called with the OSA Direct Object as first
     positional parameter.  The other parameters are passed as keyword
     arguments, with the 4-character designator as name.  Three extra
     keyword parameters are passed: ‘_class’ and ‘_type’ are the Class
     and Type designators and ‘_attributes’ is a dictionary with the
     AppleEvent attributes.

     The return value of your method is packed with *note
     aetools.packevent(): 28ba. and sent as reply.

  Note that there are some serious problems with the current design.
AppleEvents which have non-identifier 4-character designators for
arguments are not implementable, and it is not possible to return an
error to the originator.  This will be addressed in a future release.

  In addition, support modules have been pre-generated for ‘Finder’,
‘Terminal’, ‘Explorer’, ‘Netscape’, ‘CodeWarrior’, ‘SystemEvents’ and
‘StdSuites’.


File: python.info,  Node: SGI IRIX Specific Services,  Next: SunOS Specific Services,  Prev: MacPython OSA Modules,  Up: The Python Standard Library

5.38 SGI IRIX Specific Services
===============================

The modules described in this chapter provide interfaces to features
that are unique to SGI’s IRIX operating system (versions 4 and 5).

* Menu:

* al: al --- Audio functions on the SGI. Audio functions on the SGI
* AL: AL --- Constants used with the al module. Constants used with the al module
* cd: cd --- CD-ROM access on SGI systems. CD-ROM access on SGI systems
* fl: fl --- FORMS library for graphical user interfaces. FORMS library for graphical user interfaces
* FL: FL --- Constants used with the fl module. Constants used with the fl module
* flp: flp --- Functions for loading stored FORMS designs. Functions for loading stored FORMS designs
* fm: fm --- Font Manager interface. Font Manager interface
* gl: gl --- Graphics Library interface. Graphics Library interface
* DEVICE: DEVICE --- Constants used with the gl module. Constants used with the gl module
* GL: GL --- Constants used with the gl module. Constants used with the gl module
* imgfile: imgfile --- Support for SGI imglib files. Support for SGI imglib files
* jpeg: jpeg --- Read and write JPEG files. Read and write JPEG files

al — Audio functions on the SGI

* Configuration Objects:: 
* Port Objects:: 

cd — CD-ROM access on SGI systems

* Player Objects:: 
* Parser Objects:: 

fl — FORMS library for graphical user interfaces

* Functions Defined in Module fl:: 
* Form Objects:: 
* FORMS Objects:: 


File: python.info,  Node: al --- Audio functions on the SGI,  Next: AL --- Constants used with the al module,  Up: SGI IRIX Specific Services

5.38.1 ‘al’ — Audio functions on the SGI
----------------------------------------

Deprecated since version 2.6: The *note al: a. module has been removed
in Python 3.

  This module provides access to the audio facilities of the SGI Indy
and Indigo workstations.  See section 3A of the IRIX man pages for
details.  You’ll need to read those man pages to understand what these
functions do!  Some of the functions are not available in IRIX releases
before 4.0.5.  Again, see the manual to check whether a specific
function is available on your platform.

  All functions and methods defined in this module are equivalent to the
C functions with ‘AL’ prefixed to their name.

  Symbolic constants from the C header file ‘<audio.h>’ are defined in
the standard module *note AL: 9, see below.

     Warning: The current version of the audio library may dump core
     when bad argument values are passed rather than returning an error
     status.  Unfortunately, since the precise circumstances under which
     this may happen are undocumented and hard to check, the Python
     interface can provide no protection against this kind of problems.
     (One example is specifying an excessive queue size — there is no
     documented upper limit.)

  The module defines the following functions:

 -- Function: al.openport (name, direction[, config])

     The name and direction arguments are strings.  The optional
     _config_ argument is a configuration object as returned by *note
     newconfig(): 28e9.  The return value is an _audio port object_;
     methods of audio port objects are described below.

 -- Function: al.newconfig ()

     The return value is a new _audio configuration object_; methods of
     audio configuration objects are described below.

 -- Function: al.queryparams (device)

     The device argument is an integer.  The return value is a list of
     integers containing the data returned by ‘ALqueryparams()’.

 -- Function: al.getparams (device, list)

     The _device_ argument is an integer.  The list argument is a list
     such as returned by *note queryparams(): 28ea.; it is modified in
     place (!).

 -- Function: al.setparams (device, list)

     The _device_ argument is an integer.  The _list_ argument is a list
     such as returned by *note queryparams(): 28ea.

* Menu:

* Configuration Objects:: 
* Port Objects:: 


File: python.info,  Node: Configuration Objects,  Next: Port Objects,  Up: al --- Audio functions on the SGI

5.38.1.1 Configuration Objects
..............................

Configuration objects returned by *note newconfig(): 28e9. have the
following methods:

 -- Method: audio configuration.getqueuesize()

     Return the queue size.

 -- Method: audio configuration.setqueuesize(size)

     Set the queue size.

 -- Method: audio configuration.getwidth()

     Get the sample width.

 -- Method: audio configuration.setwidth(width)

     Set the sample width.

 -- Method: audio configuration.getchannels()

     Get the channel count.

 -- Method: audio configuration.setchannels(nchannels)

     Set the channel count.

 -- Method: audio configuration.getsampfmt()

     Get the sample format.

 -- Method: audio configuration.setsampfmt(sampfmt)

     Set the sample format.

 -- Method: audio configuration.getfloatmax()

     Get the maximum value for floating sample formats.

 -- Method: audio configuration.setfloatmax(floatmax)

     Set the maximum value for floating sample formats.


File: python.info,  Node: Port Objects,  Prev: Configuration Objects,  Up: al --- Audio functions on the SGI

5.38.1.2 Port Objects
.....................

Port objects, as returned by *note openport(): 28e8, have the following
methods:

 -- Method: audio port.closeport()

     Close the port.

 -- Method: audio port.getfd()

     Return the file descriptor as an int.

 -- Method: audio port.getfilled()

     Return the number of filled samples.

 -- Method: audio port.getfillable()

     Return the number of fillable samples.

 -- Method: audio port.readsamps(nsamples)

     Read a number of samples from the queue, blocking if necessary.
     Return the data as a string containing the raw data, (e.g., 2 bytes
     per sample in big-endian byte order (high byte, low byte) if you
     have set the sample width to 2 bytes).

 -- Method: audio port.writesamps(samples)

     Write samples into the queue, blocking if necessary.  The samples
     are encoded as described for the ‘readsamps()’ return value.

 -- Method: audio port.getfillpoint()

     Return the ’fill point’.

 -- Method: audio port.setfillpoint(fillpoint)

     Set the ’fill point’.

 -- Method: audio port.getconfig()

     Return a configuration object containing the current configuration
     of the port.

 -- Method: audio port.setconfig(config)

     Set the configuration from the argument, a configuration object.

 -- Method: audio port.getstatus(list)

     Get status information on last error.


File: python.info,  Node: AL --- Constants used with the al module,  Next: cd --- CD-ROM access on SGI systems,  Prev: al --- Audio functions on the SGI,  Up: SGI IRIX Specific Services

5.38.2 ‘AL’ — Constants used with the ‘al’ module
-------------------------------------------------

Deprecated since version 2.6: The *note AL: 9. module has been removed
in Python 3.

  This module defines symbolic constants needed to use the built-in
module *note al: a. (see above); they are equivalent to those defined in
the C header file ‘<audio.h>’ except that the name prefix ‘AL_’ is
omitted.  Read the module source for a complete list of the defined
names.  Suggested use:

     import al
     from AL import *


File: python.info,  Node: cd --- CD-ROM access on SGI systems,  Next: fl --- FORMS library for graphical user interfaces,  Prev: AL --- Constants used with the al module,  Up: SGI IRIX Specific Services

5.38.3 ‘cd’ — CD-ROM access on SGI systems
------------------------------------------

Deprecated since version 2.6: The *note cd: 5a. module has been removed
in Python 3.

  This module provides an interface to the Silicon Graphics CD library.
It is available only on Silicon Graphics systems.

  The way the library works is as follows.  A program opens the CD-ROM
device with *note open(): 28f4. and creates a parser to parse the data
from the CD with *note createparser(): 28f5.  The object returned by
*note open(): 28f4. can be used to read data from the CD, but also to
get status information for the CD-ROM device, and to get information
about the CD, such as the table of contents.  Data from the CD is passed
to the parser, which parses the frames, and calls any callback functions
that have previously been added.

  An audio CD is divided into _tracks_ or _programs_ (the terms are used
interchangeably).  Tracks can be subdivided into _indices_.  An audio CD
contains a _table of contents_ which gives the starts of the tracks on
the CD. Index 0 is usually the pause before the start of a track.  The
start of the track as given by the table of contents is normally the
start of index 1.

  Positions on a CD can be represented in two ways.  Either a frame
number or a tuple of three values, minutes, seconds and frames.  Most
functions use the latter representation.  Positions can be both relative
to the beginning of the CD, and to the beginning of the track.

  Module *note cd: 5a. defines the following functions and constants:

 -- Function: cd.createparser ()

     Create and return an opaque parser object.  The methods of the
     parser object are described below.

 -- Function: cd.msftoframe (minutes, seconds, frames)

     Converts a ‘(minutes, seconds, frames)’ triple representing time in
     absolute time code into the corresponding CD frame number.

 -- Function: cd.open ([device[, mode]])

     Open the CD-ROM device.  The return value is an opaque player
     object; methods of the player object are described below.  The
     device is the name of the SCSI device file, e.g.
     ‘'/dev/scsi/sc0d4l0'’, or ‘None’.  If omitted or ‘None’, the
     hardware inventory is consulted to locate a CD-ROM drive.  The
     _mode_, if not omitted, should be the string ‘'r'’.

  The module defines the following variables:

 -- Exception: cd.error

     Exception raised on various errors.

 -- Data: cd.DATASIZE

     The size of one frame’s worth of audio data.  This is the size of
     the audio data as passed to the callback of type ‘audio’.

 -- Data: cd.BLOCKSIZE

     The size of one uninterpreted frame of audio data.

  The following variables are states as returned by ‘getstatus()’:

 -- Data: cd.READY

     The drive is ready for operation loaded with an audio CD.

 -- Data: cd.NODISC

     The drive does not have a CD loaded.

 -- Data: cd.CDROM

     The drive is loaded with a CD-ROM. Subsequent play or read
     operations will return I/O errors.

 -- Data: cd.ERROR

     An error occurred while trying to read the disc or its table of
     contents.

 -- Data: cd.PLAYING

     The drive is in CD player mode playing an audio CD through its
     audio jacks.

 -- Data: cd.PAUSED

     The drive is in CD layer mode with play paused.

 -- Data: cd.STILL

     The equivalent of *note PAUSED: 28ff. on older (non 3301) model
     Toshiba CD-ROM drives.  Such drives have never been shipped by SGI.

 -- Data: cd.audio
 -- Data: cd.pnum
 -- Data: cd.index
 -- Data: cd.ptime
 -- Data: cd.atime
 -- Data: cd.catalog
 -- Data: cd.ident
 -- Data: cd.control

     Integer constants describing the various types of parser callbacks
     that can be set by the ‘addcallback()’ method of CD parser objects
     (see below).

* Menu:

* Player Objects:: 
* Parser Objects:: 


File: python.info,  Node: Player Objects,  Next: Parser Objects,  Up: cd --- CD-ROM access on SGI systems

5.38.3.1 Player Objects
.......................

Player objects (returned by *note open(): 28f4.) have the following
methods:

 -- Method: CD player.allowremoval()

     Unlocks the eject button on the CD-ROM drive permitting the user to
     eject the caddy if desired.

 -- Method: CD player.bestreadsize()

     Returns the best value to use for the _num_frames_ parameter of the
     ‘readda()’ method.  Best is defined as the value that permits a
     continuous flow of data from the CD-ROM drive.

 -- Method: CD player.close()

     Frees the resources associated with the player object.  After
     calling ‘close()’, the methods of the object should no longer be
     used.

 -- Method: CD player.eject()

     Ejects the caddy from the CD-ROM drive.

 -- Method: CD player.getstatus()

     Returns information pertaining to the current state of the CD-ROM
     drive.  The returned information is a tuple with the following
     values: _state_, _track_, _rtime_, _atime_, _ttime_, _first_,
     _last_, _scsi_audio_, _cur_block_.  _rtime_ is the time relative to
     the start of the current track; _atime_ is the time relative to the
     beginning of the disc; _ttime_ is the total time on the disc.  For
     more information on the meaning of the values, see the man page
     ‘CDgetstatus(3dm)’.  The value of _state_ is one of the following:
     *note ERROR: 28fd, *note NODISC: 28fb, *note READY: 28fa, *note
     PLAYING: 28fe, *note PAUSED: 28ff, *note STILL: 2900, or *note
     CDROM: 28fc.

 -- Method: CD player.gettrackinfo(track)

     Returns information about the specified track.  The returned
     information is a tuple consisting of two elements, the start time
     of the track and the duration of the track.

 -- Method: CD player.msftoblock(min, sec, frame)

     Converts a minutes, seconds, frames triple representing a time in
     absolute time code into the corresponding logical block number for
     the given CD-ROM drive.  You should use *note msftoframe(): 28f6.
     rather than ‘msftoblock()’ for comparing times.  The logical block
     number differs from the frame number by an offset required by
     certain CD-ROM drives.

 -- Method: CD player.play(start, play)

     Starts playback of an audio CD in the CD-ROM drive at the specified
     track.  The audio output appears on the CD-ROM drive’s headphone
     and audio jacks (if fitted).  Play stops at the end of the disc.
     _start_ is the number of the track at which to start playing the
     CD; if _play_ is 0, the CD will be set to an initial paused state.
     The method ‘togglepause()’ can then be used to commence play.

 -- Method: CD player.playabs(minutes, seconds, frames, play)

     Like ‘play()’, except that the start is given in minutes, seconds,
     and frames instead of a track number.

 -- Method: CD player.playtrack(start, play)

     Like ‘play()’, except that playing stops at the end of the track.

 -- Method: CD player.playtrackabs(track, minutes, seconds, frames,
          play)

     Like ‘play()’, except that playing begins at the specified absolute
     time and ends at the end of the specified track.

 -- Method: CD player.preventremoval()

     Locks the eject button on the CD-ROM drive thus preventing the user
     from arbitrarily ejecting the caddy.

 -- Method: CD player.readda(num_frames)

     Reads the specified number of frames from an audio CD mounted in
     the CD-ROM drive.  The return value is a string representing the
     audio frames.  This string can be passed unaltered to the
     ‘parseframe()’ method of the parser object.

 -- Method: CD player.seek(minutes, seconds, frames)

     Sets the pointer that indicates the starting point of the next read
     of digital audio data from a CD-ROM. The pointer is set to an
     absolute time code location specified in _minutes_, _seconds_, and
     _frames_.  The return value is the logical block number to which
     the pointer has been set.

 -- Method: CD player.seekblock(block)

     Sets the pointer that indicates the starting point of the next read
     of digital audio data from a CD-ROM. The pointer is set to the
     specified logical block number.  The return value is the logical
     block number to which the pointer has been set.

 -- Method: CD player.seektrack(track)

     Sets the pointer that indicates the starting point of the next read
     of digital audio data from a CD-ROM. The pointer is set to the
     specified track.  The return value is the logical block number to
     which the pointer has been set.

 -- Method: CD player.stop()

     Stops the current playing operation.

 -- Method: CD player.togglepause()

     Pauses the CD if it is playing, and makes it play if it is paused.


File: python.info,  Node: Parser Objects,  Prev: Player Objects,  Up: cd --- CD-ROM access on SGI systems

5.38.3.2 Parser Objects
.......................

Parser objects (returned by *note createparser(): 28f5.) have the
following methods:

 -- Method: CD parser.addcallback(type, func, arg)

     Adds a callback for the parser.  The parser has callbacks for eight
     different types of data in the digital audio data stream.
     Constants for these types are defined at the *note cd: 5a. module
     level (see above).  The callback is called as follows: ‘func(arg,
     type, data)’, where _arg_ is the user supplied argument, _type_ is
     the particular type of callback, and _data_ is the data returned
     for this _type_ of callback.  The type of the data depends on the
     _type_ of callback as follows:

     Type              Value
                       
     --------------------------------------------------------------------
                       
     ‘audio’           String which can be passed unmodified to
                       ‘al.writesamps()’.
                       
                       
     ‘pnum’            Integer giving the program (track) number.
                       
                       
     ‘index’           Integer giving the index number.
                       
                       
     ‘ptime’           Tuple consisting of the program time in
                       minutes, seconds, and frames.
                       
                       
     ‘atime’           Tuple consisting of the absolute time in
                       minutes, seconds, and frames.
                       
                       
     ‘catalog’         String of 13 characters, giving the catalog
                       number of the CD.
                       
                       
     ‘ident’           String of 12 characters, giving the ISRC
                       identification number of the recording.  The
                       string consists of two characters country code,
                       three characters owner code, two characters
                       giving the year, and five characters giving a
                       serial number.
                       
                       
     ‘control’         Integer giving the control bits from the CD
                       subcode data
                       

 -- Method: CD parser.deleteparser()

     Deletes the parser and frees the memory it was using.  The object
     should not be used after this call.  This call is done
     automatically when the last reference to the object is removed.

 -- Method: CD parser.parseframe(frame)

     Parses one or more frames of digital audio data from a CD such as
     returned by ‘readda()’.  It determines which subcodes are present
     in the data.  If these subcodes have changed since the last frame,
     then ‘parseframe()’ executes a callback of the appropriate type
     passing to it the subcode data found in the frame.  Unlike the C
     function, more than one frame of digital audio data can be passed
     to this method.

 -- Method: CD parser.removecallback(type)

     Removes the callback for the given _type_.

 -- Method: CD parser.resetparser()

     Resets the fields of the parser used for tracking subcodes to an
     initial state.  ‘resetparser()’ should be called after the disc has
     been changed.


File: python.info,  Node: fl --- FORMS library for graphical user interfaces,  Next: FL --- Constants used with the fl module,  Prev: cd --- CD-ROM access on SGI systems,  Up: SGI IRIX Specific Services

5.38.4 ‘fl’ — FORMS library for graphical user interfaces
---------------------------------------------------------

Deprecated since version 2.6: The *note fl: cf. module has been removed
in Python 3.

  This module provides an interface to the FORMS Library by Mark
Overmars.  The source for the library can be retrieved by anonymous ftp
from host ‘ftp.cs.ruu.nl’, directory ‘SGI/FORMS’.  It was last tested
with version 2.0b.

  Most functions are literal translations of their C equivalents,
dropping the initial ‘fl_’ from their name.  Constants used by the
library are defined in module *note FL: ce. described below.

  The creation of objects is a little different in Python than in C:
instead of the ’current form’ maintained by the library to which new
FORMS objects are added, all functions that add a FORMS object to a form
are methods of the Python object representing the form.  Consequently,
there are no Python equivalents for the C functions ‘fl_addto_form()’
and ‘fl_end_form()’, and the equivalent of ‘fl_bgn_form()’ is called
*note fl.make_form(): 290f.

  Watch out for the somewhat confusing terminology: FORMS uses the word
_object_ for the buttons, sliders etc.  that you can place in a form.
In Python, ’object’ means any value.  The Python interface to FORMS
introduces two new Python object types: form objects (representing an
entire form) and FORMS objects (representing one button, slider etc.).
Hopefully this isn’t too confusing.

  There are no ’free objects’ in the Python interface to FORMS, nor is
there an easy way to add object classes written in Python.  The FORMS
interface to GL event handling is available, though, so you can mix
FORMS with pure GL windows.

  *Please note:* importing *note fl: cf. implies a call to the GL
function ‘foreground()’ and to the FORMS routine ‘fl_init()’.

* Menu:

* Functions Defined in Module fl:: 
* Form Objects:: 
* FORMS Objects:: 


File: python.info,  Node: Functions Defined in Module fl,  Next: Form Objects,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.1 Functions Defined in Module ‘fl’
.........................................

Module *note fl: cf. defines the following functions.  For more
information about what they do, see the description of the equivalent C
function in the FORMS documentation:

 -- Function: fl.make_form (type, width, height)

     Create a form with given type, width and height.  This returns a
     _form_ object, whose methods are described below.

 -- Function: fl.do_forms ()

     The standard FORMS main loop.  Returns a Python object representing
     the FORMS object needing interaction, or the special value
     ‘FL.EVENT’.

 -- Function: fl.check_forms ()

     Check for FORMS events.  Returns what *note do_forms(): 2912. above
     returns, or ‘None’ if there is no event that immediately needs
     interaction.

 -- Function: fl.set_event_call_back (function)

     Set the event callback function.

 -- Function: fl.set_graphics_mode (rgbmode, doublebuffering)

     Set the graphics modes.

 -- Function: fl.get_rgbmode ()

     Return the current rgb mode.  This is the value of the C global
     variable ‘fl_rgbmode’.

 -- Function: fl.show_message (str1, str2, str3)

     Show a dialog box with a three-line message and an OK button.

 -- Function: fl.show_question (str1, str2, str3)

     Show a dialog box with a three-line message and YES and NO buttons.
     It returns ‘1’ if the user pressed YES, ‘0’ if NO.

 -- Function: fl.show_choice (str1, str2, str3, but1[, but2[, but3]])

     Show a dialog box with a three-line message and up to three
     buttons.  It returns the number of the button clicked by the user
     (‘1’, ‘2’ or ‘3’).

 -- Function: fl.show_input (prompt, default)

     Show a dialog box with a one-line prompt message and text field in
     which the user can enter a string.  The second argument is the
     default input string.  It returns the string value as edited by the
     user.

 -- Function: fl.show_file_selector (message, directory, pattern,
          default)

     Show a dialog box in which the user can select a file.  It returns
     the absolute filename selected by the user, or ‘None’ if the user
     presses Cancel.

 -- Function: fl.get_directory ()
 -- Function: fl.get_pattern ()
 -- Function: fl.get_filename ()

     These functions return the directory, pattern and filename (the
     tail part only) selected by the user in the last *note
     show_file_selector(): 291b. call.

 -- Function: fl.qdevice (dev)
 -- Function: fl.unqdevice (dev)
 -- Function: fl.isqueued (dev)
 -- Function: fl.qtest ()
 -- Function: fl.qread ()
 -- Function: fl.qreset ()
 -- Function: fl.qenter (dev, val)
 -- Function: fl.get_mouse ()
 -- Function: fl.tie (button, valuator1, valuator2)

     These functions are the FORMS interfaces to the corresponding GL
     functions.  Use these if you want to handle some GL events yourself
     when using ‘fl.do_events()’.  When a GL event is detected that
     FORMS cannot handle, *note fl.do_forms(): 2912. returns the special
     value ‘FL.EVENT’ and you should call *note fl.qread(): 2923. to
     read the event from the queue.  Don’t use the equivalent GL
     functions!

 -- Function: fl.color ()
 -- Function: fl.mapcolor ()
 -- Function: fl.getmcolor ()

     See the description in the FORMS documentation of ‘fl_color()’,
     ‘fl_mapcolor()’ and ‘fl_getmcolor()’.


File: python.info,  Node: Form Objects,  Next: FORMS Objects,  Prev: Functions Defined in Module fl,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.2 Form Objects
.....................

Form objects (returned by *note make_form(): 290f. above) have the
following methods.  Each method corresponds to a C function whose name
is prefixed with ‘fl_’; and whose first argument is a form pointer;
please refer to the official FORMS documentation for descriptions.

  All the ‘add_*()’ methods return a Python object representing the
FORMS object.  Methods of FORMS objects are described below.  Most kinds
of FORMS object also have some methods specific to that kind; these
methods are listed here.

 -- Method: form.show_form (placement, bordertype, name)

     Show the form.

 -- Method: form.hide_form ()

     Hide the form.

 -- Method: form.redraw_form ()

     Redraw the form.

 -- Method: form.set_form_position (x, y)

     Set the form’s position.

 -- Method: form.freeze_form ()

     Freeze the form.

 -- Method: form.unfreeze_form ()

     Unfreeze the form.

 -- Method: form.activate_form ()

     Activate the form.

 -- Method: form.deactivate_form ()

     Deactivate the form.

 -- Method: form.bgn_group ()

     Begin a new group of objects; return a group object.

 -- Method: form.end_group ()

     End the current group of objects.

 -- Method: form.find_first ()

     Find the first object in the form.

 -- Method: form.find_last ()

     Find the last object in the form.

 -- Method: form.add_box (type, x, y, w, h, name)

     Add a box object to the form.  No extra methods.

 -- Method: form.add_text (type, x, y, w, h, name)

     Add a text object to the form.  No extra methods.

 -- Method: form.add_clock (type, x, y, w, h, name)

     Add a clock object to the form.  — Method: ‘get_clock()’.

 -- Method: form.add_button (type, x, y, w, h, name)

     Add a button object to the form.  — Methods: ‘get_button()’,
     ‘set_button()’.

 -- Method: form.add_lightbutton (type, x, y, w, h, name)

     Add a lightbutton object to the form.  — Methods: ‘get_button()’,
     ‘set_button()’.

 -- Method: form.add_roundbutton (type, x, y, w, h, name)

     Add a roundbutton object to the form.  — Methods: ‘get_button()’,
     ‘set_button()’.

 -- Method: form.add_slider (type, x, y, w, h, name)

     Add a slider object to the form.  — Methods: ‘set_slider_value()’,
     ‘get_slider_value()’, ‘set_slider_bounds()’, ‘get_slider_bounds()’,
     ‘set_slider_return()’, ‘set_slider_size()’,
     ‘set_slider_precision()’, ‘set_slider_step()’.

 -- Method: form.add_valslider (type, x, y, w, h, name)

     Add a valslider object to the form.  — Methods:
     ‘set_slider_value()’, ‘get_slider_value()’, ‘set_slider_bounds()’,
     ‘get_slider_bounds()’, ‘set_slider_return()’, ‘set_slider_size()’,
     ‘set_slider_precision()’, ‘set_slider_step()’.

 -- Method: form.add_dial (type, x, y, w, h, name)

     Add a dial object to the form.  — Methods: ‘set_dial_value()’,
     ‘get_dial_value()’, ‘set_dial_bounds()’, ‘get_dial_bounds()’.

 -- Method: form.add_positioner (type, x, y, w, h, name)

     Add a positioner object to the form.  — Methods:
     ‘set_positioner_xvalue()’, ‘set_positioner_yvalue()’,
     ‘set_positioner_xbounds()’, ‘set_positioner_ybounds()’,
     ‘get_positioner_xvalue()’, ‘get_positioner_yvalue()’,
     ‘get_positioner_xbounds()’, ‘get_positioner_ybounds()’.

 -- Method: form.add_counter (type, x, y, w, h, name)

     Add a counter object to the form.  — Methods:
     ‘set_counter_value()’, ‘get_counter_value()’,
     ‘set_counter_bounds()’, ‘set_counter_step()’,
     ‘set_counter_precision()’, ‘set_counter_return()’.

 -- Method: form.add_input (type, x, y, w, h, name)

     Add a input object to the form.  — Methods: ‘set_input()’,
     ‘get_input()’, ‘set_input_color()’, ‘set_input_return()’.

 -- Method: form.add_menu (type, x, y, w, h, name)

     Add a menu object to the form.  — Methods: ‘set_menu()’,
     ‘get_menu()’, ‘addto_menu()’.

 -- Method: form.add_choice (type, x, y, w, h, name)

     Add a choice object to the form.  — Methods: ‘set_choice()’,
     ‘get_choice()’, ‘clear_choice()’, ‘addto_choice()’,
     ‘replace_choice()’, ‘delete_choice()’, ‘get_choice_text()’,
     ‘set_choice_fontsize()’, ‘set_choice_fontstyle()’.

 -- Method: form.add_browser (type, x, y, w, h, name)

     Add a browser object to the form.  — Methods:
     ‘set_browser_topline()’, ‘clear_browser()’, ‘add_browser_line()’,
     ‘addto_browser()’, ‘insert_browser_line()’,
     ‘delete_browser_line()’, ‘replace_browser_line()’,
     ‘get_browser_line()’, ‘load_browser()’, ‘get_browser_maxline()’,
     ‘select_browser_line()’, ‘deselect_browser_line()’,
     ‘deselect_browser()’, ‘isselected_browser_line()’, ‘get_browser()’,
     ‘set_browser_fontsize()’, ‘set_browser_fontstyle()’,
     ‘set_browser_specialkey()’.

 -- Method: form.add_timer (type, x, y, w, h, name)

     Add a timer object to the form.  — Methods: ‘set_timer()’,
     ‘get_timer()’.

  Form objects have the following data attributes; see the FORMS
documentation:

Name                      C Type                Meaning
                                                
-------------------------------------------------------------------------------------
                                                
‘window’                  int (read-only)       GL window id
                                                
                                                
‘w’                       float                 form width
                                                
                                                
‘h’                       float                 form height
                                                
                                                
‘x’                       float                 form x origin
                                                
                                                
‘y’                       float                 form y origin
                                                
                                                
‘deactivated’             int                   nonzero if form is deactivated
                                                
                                                
‘visible’                 int                   nonzero if form is visible
                                                
                                                
‘frozen’                  int                   nonzero if form is frozen
                                                
                                                
‘doublebuf’               int                   nonzero if double buffering on
                                                


File: python.info,  Node: FORMS Objects,  Prev: Form Objects,  Up: fl --- FORMS library for graphical user interfaces

5.38.4.3 FORMS Objects
......................

Besides methods specific to particular kinds of FORMS objects, all FORMS
objects also have the following methods:

 -- Method: FORMS object.set_call_back(function, argument)

     Set the object’s callback function and argument.  When the object
     needs interaction, the callback function will be called with two
     arguments: the object, and the callback argument.  (FORMS objects
     without a callback function are returned by *note fl.do_forms():
     2912. or *note fl.check_forms(): 2913. when they need interaction.)
     Call this method without arguments to remove the callback function.

 -- Method: FORMS object.delete_object()

     Delete the object.

 -- Method: FORMS object.show_object()

     Show the object.

 -- Method: FORMS object.hide_object()

     Hide the object.

 -- Method: FORMS object.redraw_object()

     Redraw the object.

 -- Method: FORMS object.freeze_object()

     Freeze the object.

 -- Method: FORMS object.unfreeze_object()

     Unfreeze the object.

  FORMS objects have these data attributes; see the FORMS documentation:

Name                     C Type                Meaning
                                               
----------------------------------------------------------------------
                                               
‘objclass’               int (read-only)       object class
                                               
                                               
*note type: 490.         int (read-only)       object type
                                               
                                               
‘boxtype’                int                   box type
                                               
                                               
‘x’                      float                 x origin
                                               
                                               
‘y’                      float                 y origin
                                               
                                               
‘w’                      float                 width
                                               
                                               
‘h’                      float                 height
                                               
                                               
‘col1’                   int                   primary color
                                               
                                               
‘col2’                   int                   secondary color
                                               
                                               
‘align’                  int                   alignment
                                               
                                               
‘lcol’                   int                   label color
                                               
                                               
‘lsize’                  float                 label font size
                                               
                                               
‘label’                  string                label string
                                               
                                               
‘lstyle’                 int                   label style
                                               
                                               
‘pushed’                 int (read-only)       (see FORMS docs)
                                               
                                               
‘focus’                  int (read-only)       (see FORMS docs)
                                               
                                               
‘belowmouse’             int (read-only)       (see FORMS docs)
                                               
                                               
‘frozen’                 int (read-only)       (see FORMS docs)
                                               
                                               
‘active’                 int (read-only)       (see FORMS docs)
                                               
                                               
*note input: 3bf.        int (read-only)       (see FORMS docs)
                                               
                                               
‘visible’                int (read-only)       (see FORMS docs)
                                               
                                               
‘radio’                  int (read-only)       (see FORMS docs)
                                               
                                               
‘automatic’              int (read-only)       (see FORMS docs)
                                               


File: python.info,  Node: FL --- Constants used with the fl module,  Next: flp --- Functions for loading stored FORMS designs,  Prev: fl --- FORMS library for graphical user interfaces,  Up: SGI IRIX Specific Services

5.38.5 ‘FL’ — Constants used with the ‘fl’ module
-------------------------------------------------

Deprecated since version 2.6: The *note FL: ce. module has been removed
in Python 3.

  This module defines symbolic constants needed to use the built-in
module *note fl: cf. (see above); they are equivalent to those defined
in the C header file ‘<forms.h>’ except that the name prefix ‘FL_’ is
omitted.  Read the module source for a complete list of the defined
names.  Suggested use:

     import fl
     from FL import *


File: python.info,  Node: flp --- Functions for loading stored FORMS designs,  Next: fm --- Font Manager interface,  Prev: FL --- Constants used with the fl module,  Up: SGI IRIX Specific Services

5.38.6 ‘flp’ — Functions for loading stored FORMS designs
---------------------------------------------------------

Deprecated since version 2.6: The *note flp: d0. module has been removed
in Python 3.

  This module defines functions that can read form definitions created
by the ’form designer’ (*fdesign*) program that comes with the FORMS
library (see module *note fl: cf. above).

  For now, see the file ‘flp.doc’ in the Python library source directory
for a description.

  XXX A complete description should be inserted here!


File: python.info,  Node: fm --- Font Manager interface,  Next: gl --- Graphics Library interface,  Prev: flp --- Functions for loading stored FORMS designs,  Up: SGI IRIX Specific Services

5.38.7 ‘fm’ — _Font Manager_ interface
--------------------------------------

Deprecated since version 2.6: The *note fm: d1. module has been removed
in Python 3.

  This module provides access to the IRIS _Font Manager_ library.  It is
available only on Silicon Graphics machines.  See also: _4Sight User’s
Guide_, section 1, chapter 5: "Using the IRIS Font Manager."

  This is not yet a full interface to the IRIS Font Manager.  Among the
unsupported features are: matrix operations; cache operations; character
operations (use string operations instead); some details of font info;
individual glyph metrics; and printer matching.

  It supports the following operations:

 -- Function: fm.init ()

     Initialization function.  Calls ‘fminit()’.  It is normally not
     necessary to call this function, since it is called automatically
     the first time the *note fm: d1. module is imported.

 -- Function: fm.findfont (fontname)

     Return a font handle object.  Calls ‘fmfindfont(fontname)’.

 -- Function: fm.enumerate ()

     Returns a list of available font names.  This is an interface to
     ‘fmenumerate()’.

 -- Function: fm.prstr (string)

     Render a string using the current font (see the ‘setfont()’ font
     handle method below).  Calls ‘fmprstr(string)’.

 -- Function: fm.setpath (string)

     Sets the font search path.  Calls ‘fmsetpath(string)’.  (XXX Does
     not work!?!)

 -- Function: fm.fontpath ()

     Returns the current font search path.

  Font handle objects support the following operations:

 -- Method: font handle.scalefont(factor)

     Returns a handle for a scaled version of this font.  Calls
     ‘fmscalefont(fh, factor)’.

 -- Method: font handle.setfont()

     Makes this font the current font.  Note: the effect is undone
     silently when the font handle object is deleted.  Calls
     ‘fmsetfont(fh)’.

 -- Method: font handle.getfontname()

     Returns this font’s name.  Calls ‘fmgetfontname(fh)’.

 -- Method: font handle.getcomment()

     Returns the comment string associated with this font.  Raises an
     exception if there is none.  Calls ‘fmgetcomment(fh)’.

 -- Method: font handle.getfontinfo()

     Returns a tuple giving some pertinent data about this font.  This
     is an interface to ‘fmgetfontinfo()’.  The returned tuple contains
     the following numbers: ‘(printermatched, fixed_width, xorig, yorig,
     xsize, ysize, height, nglyphs)’.

 -- Method: font handle.getstrwidth(string)

     Returns the width, in pixels, of _string_ when drawn in this font.
     Calls ‘fmgetstrwidth(fh, string)’.


File: python.info,  Node: gl --- Graphics Library interface,  Next: DEVICE --- Constants used with the gl module,  Prev: fm --- Font Manager interface,  Up: SGI IRIX Specific Services

5.38.8 ‘gl’ — _Graphics Library_ interface
------------------------------------------

Deprecated since version 2.6: The *note gl: e1. module has been removed
in Python 3.

  This module provides access to the Silicon Graphics _Graphics
Library_.  It is available only on Silicon Graphics machines.

     Warning: Some illegal calls to the GL library cause the Python
     interpreter to dump core.  In particular, the use of most GL calls
     is unsafe before the first window is opened.

  The module is too large to document here in its entirety, but the
following should help you to get started.  The parameter conventions for
the C functions are translated to Python as follows:

   * All (short, long, unsigned) int values are represented by Python
     integers.

   * All float and double values are represented by Python floating
     point numbers.  In most cases, Python integers are also allowed.

   * All arrays are represented by one-dimensional Python lists.  In
     most cases, tuples are also allowed.

   * All string and character arguments are represented by Python
     strings, for instance, ‘winopen('Hi There!')’ and ‘rotate(900,
     'z')’.

   * All (short, long, unsigned) integer arguments or return values that
     are only used to specify the length of an array argument are
     omitted.  For example, the C call

          lmdef(deftype, index, np, props)

     is translated to Python as

          lmdef(deftype, index, props)

   * Output arguments are omitted from the argument list; they are
     transmitted as function return values instead.  If more than one
     value must be returned, the return value is a tuple.  If the C
     function has both a regular return value (that is not omitted
     because of the previous rule) and an output argument, the return
     value comes first in the tuple.  Examples: the C call

          getmcolor(i, &red, &green, &blue)

     is translated to Python as

          red, green, blue = getmcolor(i)

  The following functions are non-standard or have special argument
conventions:

 -- Function: gl.varray (argument)

     Equivalent to but faster than a number of ‘v3d()’ calls.  The
     _argument_ is a list (or tuple) of points.  Each point must be a
     tuple of coordinates ‘(x, y, z)’ or ‘(x, y)’.  The points may be 2-
     or 3-dimensional but must all have the same dimension.  Float and
     int values may be mixed however.  The points are always converted
     to 3D double precision points by assuming ‘z = 0.0’ if necessary
     (as indicated in the man page), and for each point ‘v3d()’ is
     called.

 -- Function: gl.nvarray ()

     Equivalent to but faster than a number of ‘n3f’ and ‘v3f’ calls.
     The argument is an array (list or tuple) of pairs of normals and
     points.  Each pair is a tuple of a point and a normal for that
     point.  Each point or normal must be a tuple of coordinates ‘(x, y,
     z)’.  Three coordinates must be given.  Float and int values may be
     mixed.  For each pair, ‘n3f()’ is called for the normal, and then
     ‘v3f()’ is called for the point.

 -- Function: gl.vnarray ()

     Similar to ‘nvarray()’ but the pairs have the point first and the
     normal second.

 -- Function: gl.nurbssurface (s_k, t_k, ctl, s_ord, t_ord, type)

     Defines a nurbs surface.  The dimensions of ‘ctl[][]’ are computed
     as follows: ‘[len(s_k) - s_ord]’, ‘[len(t_k) - t_ord]’.

 -- Function: gl.nurbscurve (knots, ctlpoints, order, type)

     Defines a nurbs curve.  The length of ctlpoints is ‘len(knots) -
     order’.

 -- Function: gl.pwlcurve (points, type)

     Defines a piecewise-linear curve.  _points_ is a list of points.
     _type_ must be ‘N_ST’.

 -- Function: gl.pick (n)
 -- Function: gl.select (n)

     The only argument to these functions specifies the desired size of
     the pick or select buffer.

 -- Function: gl.endpick ()
 -- Function: gl.endselect ()

     These functions have no arguments.  They return a list of integers
     representing the used part of the pick/select buffer.  No method is
     provided to detect buffer overrun.

  Here is a tiny but complete example GL program in Python:

     import gl, GL, time

     def main():
         gl.foreground()
         gl.prefposition(500, 900, 500, 900)
         w = gl.winopen('CrissCross')
         gl.ortho2(0.0, 400.0, 0.0, 400.0)
         gl.color(GL.WHITE)
         gl.clear()
         gl.color(GL.RED)
         gl.bgnline()
         gl.v2f(0.0, 0.0)
         gl.v2f(400.0, 400.0)
         gl.endline()
         gl.bgnline()
         gl.v2f(400.0, 0.0)
         gl.v2f(0.0, 400.0)
         gl.endline()
         time.sleep(5)

     main()

See also
........

PyOpenGL: The Python OpenGL Binding(1)

     An interface to OpenGL is also available; see information about the
     *PyOpenGL* project online at ‘http://pyopengl.sourceforge.net/’.
     This may be a better option if support for SGI hardware from before
     about 1996 is not required.

   ---------- Footnotes ----------

   (1) http://pyopengl.sourceforge.net/


File: python.info,  Node: DEVICE --- Constants used with the gl module,  Next: GL --- Constants used with the gl module,  Prev: gl --- Graphics Library interface,  Up: SGI IRIX Specific Services

5.38.9 ‘DEVICE’ — Constants used with the ‘gl’ module
-----------------------------------------------------

Deprecated since version 2.6: The *note DEVICE: 81. module has been
removed in Python 3.

  This modules defines the constants used by the Silicon Graphics
_Graphics Library_ that C programmers find in the header file
‘<gl/device.h>’.  Read the module source file for details.


File: python.info,  Node: GL --- Constants used with the gl module,  Next: imgfile --- Support for SGI imglib files,  Prev: DEVICE --- Constants used with the gl module,  Up: SGI IRIX Specific Services

5.38.10 ‘GL’ — Constants used with the ‘gl’ module
--------------------------------------------------

Deprecated since version 2.6: The *note GL: e2. module has been removed
in Python 3.

  This module contains constants used by the Silicon Graphics _Graphics
Library_ from the C header file ‘<gl/gl.h>’.  Read the module source
file for details.


File: python.info,  Node: imgfile --- Support for SGI imglib files,  Next: jpeg --- Read and write JPEG files,  Prev: GL --- Constants used with the gl module,  Up: SGI IRIX Specific Services

5.38.11 ‘imgfile’ — Support for SGI imglib files
------------------------------------------------

Deprecated since version 2.6: The *note imgfile: f3. module has been
removed in Python 3.

  The *note imgfile: f3. module allows Python programs to access SGI
imglib image files (also known as ‘.rgb’ files).  The module is far from
complete, but is provided anyway since the functionality that there is
enough in some cases.  Currently, colormap files are not supported.

  The module defines the following variables and functions:

 -- Exception: imgfile.error

     This exception is raised on all errors, such as unsupported file
     type, etc.

 -- Function: imgfile.getsizes (file)

     This function returns a tuple ‘(x, y, z)’ where _x_ and _y_ are the
     size of the image in pixels and _z_ is the number of bytes per
     pixel.  Only 3 byte RGB pixels and 1 byte greyscale pixels are
     currently supported.

 -- Function: imgfile.read (file)

     This function reads and decodes the image on the specified file,
     and returns it as a Python string.  The string has either 1 byte
     greyscale pixels or 4 byte RGBA pixels.  The bottom left pixel is
     the first in the string.  This format is suitable to pass to
     ‘gl.lrectwrite()’, for instance.

 -- Function: imgfile.readscaled (file, x, y, filter[, blur])

     This function is identical to read but it returns an image that is
     scaled to the given _x_ and _y_ sizes.  If the _filter_ and _blur_
     parameters are omitted scaling is done by simply dropping or
     duplicating pixels, so the result will be less than perfect,
     especially for computer-generated images.

     Alternatively, you can specify a filter to use to smooth the image
     after scaling.  The filter forms supported are ‘'impulse'’,
     ‘'box'’, ‘'triangle'’, ‘'quadratic'’ and ‘'gaussian'’.  If a filter
     is specified _blur_ is an optional parameter specifying the
     blurriness of the filter.  It defaults to ‘1.0’.

     *note readscaled(): 2968. makes no attempt to keep the aspect ratio
     correct, so that is the users’ responsibility.

 -- Function: imgfile.ttob (flag)

     This function sets a global flag which defines whether the scan
     lines of the image are read or written from bottom to top (flag is
     zero, compatible with SGI GL) or from top to bottom(flag is one,
     compatible with X). The default is zero.

 -- Function: imgfile.write (file, data, x, y, z)

     This function writes the RGB or greyscale data in _data_ to image
     file _file_.  _x_ and _y_ give the size of the image, _z_ is 1 for
     1 byte greyscale images or 3 for RGB images (which are stored as 4
     byte values of which only the lower three bytes are used).  These
     are the formats returned by ‘gl.lrectread()’.


File: python.info,  Node: jpeg --- Read and write JPEG files,  Prev: imgfile --- Support for SGI imglib files,  Up: SGI IRIX Specific Services

5.38.12 ‘jpeg’ — Read and write JPEG files
------------------------------------------

Deprecated since version 2.6: The *note jpeg: fb. module has been
removed in Python 3.

  The module *note jpeg: fb. provides access to the jpeg compressor and
decompressor written by the Independent JPEG Group (IJG). JPEG is a
standard for compressing pictures; it is defined in ISO 10918.  For
details on JPEG or the Independent JPEG Group software refer to the JPEG
standard or the documentation provided with the software.

  A portable interface to JPEG image files is available with the Python
Imaging Library (PIL) by Fredrik Lundh.  Information on PIL is available
at ‘http://www.pythonware.com/products/pil/’.

  The *note jpeg: fb. module defines an exception and some functions.

 -- Exception: jpeg.error

     Exception raised by *note compress(): 296e. and *note decompress():
     296f. in case of errors.

 -- Function: jpeg.compress (data, w, h, b)

     Treat data as a pixmap of width _w_ and height _h_, with _b_ bytes
     per pixel.  The data is in SGI GL order, so the first pixel is in
     the lower-left corner.  This means that ‘gl.lrectread()’ return
     data can immediately be passed to *note compress(): 296e.
     Currently only 1 byte and 4 byte pixels are allowed, the former
     being treated as greyscale and the latter as RGB color.  *note
     compress(): 296e. returns a string that contains the compressed
     picture, in JFIF format.

 -- Function: jpeg.decompress (data)

     Data is a string containing a picture in JFIF format.  It returns a
     tuple ‘(data, width, height, bytesperpixel)’.  Again, the data is
     suitable to pass to ‘gl.lrectwrite()’.

 -- Function: jpeg.setoption (name, value)

     Set various options.  Subsequent *note compress(): 296e. and *note
     decompress(): 296f. calls will use these options.  The following
     options are available:

     Option                Effect
                           
     ------------------------------------------------------------------------
                           
     ‘'forcegray'’         Force output to be grayscale, even if input is
                           RGB.
                           
                           
     ‘'quality'’           Set the quality of the compressed image to a
                           value between ‘0’ and ‘100’ (default is ‘75’).
                           This only affects compression.
                           
                           
     ‘'optimize'’          Perform Huffman table optimization.  Takes
                           longer, but results in smaller compressed
                           image.  This only affects compression.
                           
                           
     ‘'smooth'’            Perform inter-block smoothing on uncompressed
                           image.  Only useful for low- quality images.
                           This only affects decompression.
                           

See also
........

JPEG Still Image Data Compression Standard

     The canonical reference for the JPEG image format, by Pennebaker
     and Mitchell.

Information Technology - Digital Compression and Coding of Continuous-tone Still Images - Requirements and Guidelines(1)

     The ISO standard for JPEG is also published as ITU T.81.  This is
     available online in PDF form.

   ---------- Footnotes ----------

   (1) http://www.w3.org/Graphics/JPEG/itu-t81.pdf


File: python.info,  Node: SunOS Specific Services,  Next: Undocumented Modules,  Prev: SGI IRIX Specific Services,  Up: The Python Standard Library

5.39 SunOS Specific Services
============================

The modules described in this chapter provide interfaces to features
that are unique to SunOS 5 (also known as Solaris version 2).

* Menu:

* sunaudiodev: sunaudiodev --- Access to Sun audio hardware. Access to Sun audio hardware
* SUNAUDIODEV: SUNAUDIODEV --- Constants used with sunaudiodev. Constants used with sunaudiodev

sunaudiodev — Access to Sun audio hardware

* Audio Device Objects: Audio Device Objects<2>. 


File: python.info,  Node: sunaudiodev --- Access to Sun audio hardware,  Next: SUNAUDIODEV --- Constants used with sunaudiodev,  Up: SunOS Specific Services

5.39.1 ‘sunaudiodev’ — Access to Sun audio hardware
---------------------------------------------------

Deprecated since version 2.6: The *note sunaudiodev: 169. module has
been removed in Python 3.

  This module allows you to access the Sun audio interface.  The Sun
audio hardware is capable of recording and playing back audio data in
u-LAW format with a sample rate of 8K per second.  A full description
can be found in the ‘audio(7I)’ manual page.

  The module *note SUNAUDIODEV: 16a. defines constants which may be used
with this module.

  This module defines the following variables and functions:

 -- Exception: sunaudiodev.error

     This exception is raised on all errors.  The argument is a string
     describing what went wrong.

 -- Function: sunaudiodev.open (mode)

     This function opens the audio device and returns a Sun audio device
     object.  This object can then be used to do I/O on.  The _mode_
     parameter is one of ‘'r'’ for record-only access, ‘'w'’ for
     play-only access, ‘'rw'’ for both and ‘'control'’ for access to the
     control device.  Since only one process is allowed to have the
     recorder or player open at the same time it is a good idea to open
     the device only for the activity needed.  See ‘audio(7I)’ for
     details.

     As per the manpage, this module first looks in the environment
     variable ‘AUDIODEV’ for the base audio device filename.  If not
     found, it falls back to ‘/dev/audio’.  The control device is
     calculated by appending "ctl" to the base audio device.

* Menu:

* Audio Device Objects: Audio Device Objects<2>. 


File: python.info,  Node: Audio Device Objects<2>,  Up: sunaudiodev --- Access to Sun audio hardware

5.39.1.1 Audio Device Objects
.............................

The audio device objects are returned by *note open(): 2977. define the
following methods (except ‘control’ objects which only provide
‘getinfo()’, ‘setinfo()’, ‘fileno()’, and ‘drain()’):

 -- Method: audio device.close()

     This method explicitly closes the device.  It is useful in
     situations where deleting the object does not immediately close it
     since there are other references to it.  A closed device should not
     be used again.

 -- Method: audio device.fileno()

     Returns the file descriptor associated with the device.  This can
     be used to set up ‘SIGPOLL’ notification, as described below.

 -- Method: audio device.drain()

     This method waits until all pending output is processed and then
     returns.  Calling this method is often not necessary: destroying
     the object will automatically close the audio device and this will
     do an implicit drain.

 -- Method: audio device.flush()

     This method discards all pending output.  It can be used avoid the
     slow response to a user’s stop request (due to buffering of up to
     one second of sound).

 -- Method: audio device.getinfo()

     This method retrieves status information like input and output
     volume, etc.  and returns it in the form of an audio status object.
     This object has no methods but it contains a number of attributes
     describing the current device status.  The names and meanings of
     the attributes are described in ‘<sun/audioio.h>’ and in the
     ‘audio(7I)’ manual page.  Member names are slightly different from
     their C counterparts: a status object is only a single structure.
     Members of the ‘play’ substructure have ‘o_’ prepended to their
     name and members of the ‘record’ structure have ‘i_’.  So, the C
     member ‘play.sample_rate’ is accessed as ‘o_sample_rate’,
     ‘record.gain’ as ‘i_gain’ and ‘monitor_gain’ plainly as
     ‘monitor_gain’.

 -- Method: audio device.ibufcount()

     This method returns the number of samples that are buffered on the
     recording side, i.e.  the program will not block on a ‘read()’ call
     of so many samples.

 -- Method: audio device.obufcount()

     This method returns the number of samples buffered on the playback
     side.  Unfortunately, this number cannot be used to determine a
     number of samples that can be written without blocking since the
     kernel output queue length seems to be variable.

 -- Method: audio device.read(size)

     This method reads _size_ samples from the audio input and returns
     them as a Python string.  The function blocks until enough data is
     available.

 -- Method: audio device.setinfo(status)

     This method sets the audio device status parameters.  The _status_
     parameter is an device status object as returned by ‘getinfo()’ and
     possibly modified by the program.

 -- Method: audio device.write(samples)

     Write is passed a Python string containing audio samples to be
     played.  If there is enough buffer space free it will immediately
     return, otherwise it will block.

  The audio device supports asynchronous notification of various events,
through the SIGPOLL signal.  Here’s an example of how you might enable
this in Python:

     def handle_sigpoll(signum, frame):
         print 'I got a SIGPOLL update'

     import fcntl, signal, STROPTS

     signal.signal(signal.SIGPOLL, handle_sigpoll)
     fcntl.ioctl(audio_obj.fileno(), STROPTS.I_SETSIG, STROPTS.S_MSG)


File: python.info,  Node: SUNAUDIODEV --- Constants used with sunaudiodev,  Prev: sunaudiodev --- Access to Sun audio hardware,  Up: SunOS Specific Services

5.39.2 ‘SUNAUDIODEV’ — Constants used with ‘sunaudiodev’
--------------------------------------------------------

Deprecated since version 2.6: The *note SUNAUDIODEV: 16a. module has
been removed in Python 3.

  This is a companion module to *note sunaudiodev: 169. which defines
useful symbolic constants like ‘MIN_GAIN’, ‘MAX_GAIN’, ‘SPEAKER’, etc.
The names of the constants are the same names as used in the C include
file ‘<sun/audioio.h>’, with the leading string ‘AUDIO_’ stripped.


File: python.info,  Node: Undocumented Modules,  Prev: SunOS Specific Services,  Up: The Python Standard Library

5.40 Undocumented Modules
=========================

Here’s a quick listing of modules that are currently undocumented, but
that should be documented.  Feel free to contribute documentation for
them!  (Send via email to <docs@python.org>.)

  The idea and original contents for this chapter were taken from a
posting by Fredrik Lundh; the specific contents of this chapter have
been substantially revised.

* Menu:

* Miscellaneous useful utilities:: 
* Platform specific modules:: 
* Multimedia:: 
* Undocumented Mac OS modules:: 
* Obsolete:: 
* SGI-specific Extension modules:: 


File: python.info,  Node: Miscellaneous useful utilities,  Next: Platform specific modules,  Up: Undocumented Modules

5.40.1 Miscellaneous useful utilities
-------------------------------------

Some of these are very old and/or not very robust; marked with "hmm."

‘ihooks’

     — Import hook support (for *note rexec: 147.; may become obsolete).
     Removed in Python 3.x.


File: python.info,  Node: Platform specific modules,  Next: Multimedia,  Prev: Miscellaneous useful utilities,  Up: Undocumented Modules

5.40.2 Platform specific modules
--------------------------------

These modules are used to implement the *note os.path: 129. module, and
are not documented beyond this mention.  There’s little need to document
these.

‘ntpath’

     — Implementation of *note os.path: 129. on Win32, Win64, WinCE, and
     OS/2 platforms.

‘posixpath’

     — Implementation of *note os.path: 129. on POSIX.

‘bsddb185’

     — Backwards compatibility module for systems which still use the
     Berkeley DB 1.85 module.  It is normally only available on certain
     BSD Unix-based systems.  It should never be used directly.


File: python.info,  Node: Multimedia,  Next: Undocumented Mac OS modules,  Prev: Platform specific modules,  Up: Undocumented Modules

5.40.3 Multimedia
-----------------

‘audiodev’

     — Platform-independent API for playing audio data.  Removed in
     Python 3.x.

‘linuxaudiodev’

     — Play audio data on the Linux audio device.  Replaced in Python
     2.3 by the *note ossaudiodev: 12a. module.  Removed in Python 3.x.

‘sunaudio’

     — Interpret Sun audio headers (may become obsolete or a tool/demo).
     Removed in Python 3.x.

‘toaiff’

     — Convert "arbitrary" sound files to AIFF files; should probably
     become a tool or demo.  Requires the external program *sox*.
     Removed in Python 3.x.


File: python.info,  Node: Undocumented Mac OS modules,  Next: Obsolete,  Prev: Multimedia,  Up: Undocumented Modules

5.40.4 Undocumented Mac OS modules
----------------------------------

* Menu:

* applesingle: applesingle --- AppleSingle decoder. AppleSingle decoder
* buildtools: buildtools --- Helper module for BuildApplet and Friends. Helper module for BuildApplet and Friends
* cfmfile: cfmfile --- Code Fragment Resource module. Code Fragment Resource module
* icopen: icopen --- Internet Config replacement for open. Internet Config replacement for open()
* macerrors: macerrors --- Mac OS Errors. Mac OS Errors
* macresource: macresource --- Locate script resources. Locate script resources
* Nav: Nav --- NavServices calls. NavServices calls
* PixMapWrapper: PixMapWrapper --- Wrapper for PixMap objects. Wrapper for PixMap objects
* videoreader: videoreader --- Read QuickTime movies. Read QuickTime movies
* W: W --- Widgets built on FrameWork. Widgets built on FrameWork


File: python.info,  Node: applesingle --- AppleSingle decoder,  Next: buildtools --- Helper module for BuildApplet and Friends,  Up: Undocumented Mac OS modules

5.40.4.1 ‘applesingle’ — AppleSingle decoder
............................................

Deprecated since version 2.6.


File: python.info,  Node: buildtools --- Helper module for BuildApplet and Friends,  Next: cfmfile --- Code Fragment Resource module,  Prev: applesingle --- AppleSingle decoder,  Up: Undocumented Mac OS modules

5.40.4.2 ‘buildtools’ — Helper module for BuildApplet and Friends
.................................................................

Deprecated since version 2.4.


File: python.info,  Node: cfmfile --- Code Fragment Resource module,  Next: icopen --- Internet Config replacement for open,  Prev: buildtools --- Helper module for BuildApplet and Friends,  Up: Undocumented Mac OS modules

5.40.4.3 ‘cfmfile’ — Code Fragment Resource module
..................................................

*note cfmfile: 5b. is a module that understands Code Fragments and the
accompanying "cfrg" resources.  It can parse them and merge them, and is
used by BuildApplication to combine all plugin modules to a single
executable.

  Deprecated since version 2.4.


File: python.info,  Node: icopen --- Internet Config replacement for open,  Next: macerrors --- Mac OS Errors,  Prev: cfmfile --- Code Fragment Resource module,  Up: Undocumented Mac OS modules

5.40.4.4 ‘icopen’ — Internet Config replacement for ‘open()’
............................................................

Importing *note icopen: f0. will replace the built-in *note open(): 2d6.
with a version that uses Internet Config to set file type and creator
for new files.

  Deprecated since version 2.6.


File: python.info,  Node: macerrors --- Mac OS Errors,  Next: macresource --- Locate script resources,  Prev: icopen --- Internet Config replacement for open,  Up: Undocumented Mac OS modules

5.40.4.5 ‘macerrors’ — Mac OS Errors
....................................

*note macerrors: 104. contains constant definitions for many Mac OS
error codes.

  Deprecated since version 2.6.


File: python.info,  Node: macresource --- Locate script resources,  Next: Nav --- NavServices calls,  Prev: macerrors --- Mac OS Errors,  Up: Undocumented Mac OS modules

5.40.4.6 ‘macresource’ — Locate script resources
................................................

*note macresource: 108. helps scripts finding their resources, such as
dialogs and menus, without requiring special case code for when the
script is run under MacPython, as a MacPython applet or under OSX
Python.

  Deprecated since version 2.6.


File: python.info,  Node: Nav --- NavServices calls,  Next: PixMapWrapper --- Wrapper for PixMap objects,  Prev: macresource --- Locate script resources,  Up: Undocumented Mac OS modules

5.40.4.7 ‘Nav’ — NavServices calls
..................................

A low-level interface to Navigation Services.

  Deprecated since version 2.6.


File: python.info,  Node: PixMapWrapper --- Wrapper for PixMap objects,  Next: videoreader --- Read QuickTime movies,  Prev: Nav --- NavServices calls,  Up: Undocumented Mac OS modules

5.40.4.8 ‘PixMapWrapper’ — Wrapper for PixMap objects
.....................................................

*note PixMapWrapper: 130. wraps a PixMap object with a Python object
that allows access to the fields by name.  It also has methods to
convert to and from ‘PIL’ images.

  Deprecated since version 2.6.


File: python.info,  Node: videoreader --- Read QuickTime movies,  Next: W --- Widgets built on FrameWork,  Prev: PixMapWrapper --- Wrapper for PixMap objects,  Up: Undocumented Mac OS modules

5.40.4.9 ‘videoreader’ — Read QuickTime movies
..............................................

*note videoreader: 191. reads and decodes QuickTime movies and passes a
stream of images to your program.  It also provides some support for
audio tracks.

  Deprecated since version 2.6.


File: python.info,  Node: W --- Widgets built on FrameWork,  Prev: videoreader --- Read QuickTime movies,  Up: Undocumented Mac OS modules

5.40.4.10 ‘W’ — Widgets built on ‘FrameWork’
............................................

The *note W: 192. widgets are used extensively in the *IDE*.

  Deprecated since version 2.6.


File: python.info,  Node: Obsolete,  Next: SGI-specific Extension modules,  Prev: Undocumented Mac OS modules,  Up: Undocumented Modules

5.40.5 Obsolete
---------------

These modules are not normally available for import; additional work
must be done to make them available.

  These extension modules written in C are not built by default.  Under
Unix, these must be enabled by uncommenting the appropriate lines in
‘Modules/Setup’ in the build tree and either rebuilding Python if the
modules are statically linked, or building and installing the shared
object if using dynamically-loaded extensions.

‘timing’

     — Measure time intervals to high resolution (use *note
     time.clock(): 11f6. instead).  Removed in Python 3.x.


File: python.info,  Node: SGI-specific Extension modules,  Prev: Obsolete,  Up: Undocumented Modules

5.40.6 SGI-specific Extension modules
-------------------------------------

The following are SGI specific, and may be out of touch with the current
version of reality.

‘cl’

     — Interface to the SGI compression library.

‘sv’

     — Interface to the "simple video" board on SGI Indigo (obsolete
     hardware).  Removed in Python 3.x.


File: python.info,  Node: Extending and Embedding the Python Interpreter,  Next: Python/C API Reference Manual,  Prev: The Python Standard Library,  Up: Top

6 Extending and Embedding the Python Interpreter
************************************************

This document describes how to write modules in C or C++ to extend the
Python interpreter with new modules.  Those modules can not only define
new functions but also new object types and their methods.  The document
also describes how to embed the Python interpreter in another
application, for use as an extension language.  Finally, it shows how to
compile and link extension modules so that they can be loaded
dynamically (at run time) into the interpreter, if the underlying
operating system supports this feature.

  This document assumes basic knowledge about Python.  For an informal
introduction to the language, see *note The Python Tutorial: 4f7.  *note
The Python Language Reference: 4f9. gives a more formal definition of
the language.  *note The Python Standard Library: 4f8. documents the
existing object types, functions and modules (both built-in and written
in Python) that give the language its wide application range.

  For a detailed description of the whole Python/C API, see the separate
*note Python/C API Reference Manual: 4fb.

     Note: This guide only covers the basic tools for creating
     extensions provided as part of this version of CPython.  Third
     party tools may offer simpler alternatives.  Refer to the binary
     extensions section(1) in the Python Packaging User Guide for more
     information.

* Menu:

* Extending Python with C or C++:: 
* Defining New Types:: 
* Building C and C++ Extensions with distutils:: 
* Building C and C++ Extensions on Windows:: 
* Embedding Python in Another Application:: 

Extending Python with C or C++

* A Simple Example:: 
* Intermezzo; Errors and Exceptions: Intermezzo Errors and Exceptions. 
* Back to the Example:: 
* The Module's Method Table and Initialization Function:: 
* Compilation and Linkage:: 
* Calling Python Functions from C:: 
* Extracting Parameters in Extension Functions:: 
* Keyword Parameters for Extension Functions:: 
* Building Arbitrary Values:: 
* Reference Counts:: 
* Writing Extensions in C++:: 
* Providing a C API for an Extension Module:: 

Reference Counts

* Reference Counting in Python:: 
* Ownership Rules:: 
* Thin Ice:: 
* NULL Pointers:: 

Defining New Types

* The Basics:: 
* Type Methods:: 

The Basics

* Adding data and methods to the Basic example:: 
* Providing finer control over data attributes:: 
* Supporting cyclic garbage collection:: 
* Subclassing other types:: 

Type Methods

* Finalization and De-allocation:: 
* Object Presentation:: 
* Attribute Management:: 
* Object Comparison:: 
* Abstract Protocol Support:: 
* Weak Reference Support:: 
* More Suggestions:: 

Attribute Management

* Generic Attribute Management:: 
* Type-specific Attribute Management:: 

Building C and C++ Extensions with distutils

* Distributing your extension modules:: 

Building C and C++ Extensions on Windows

* A Cookbook Approach:: 
* Differences Between Unix and Windows:: 
* Using DLLs in Practice:: 

Embedding Python in Another Application

* Very High Level Embedding:: 
* Beyond Very High Level Embedding; An overview: Beyond Very High Level Embedding An overview. 
* Pure Embedding:: 
* Extending Embedded Python:: 
* Embedding Python in C++:: 
* Compiling and Linking under Unix-like systems:: 

   ---------- Footnotes ----------

   (1) 
https://python-packaging-user-guide.readthedocs.org/en/latest/extensions.html


File: python.info,  Node: Extending Python with C or C++,  Next: Defining New Types,  Up: Extending and Embedding the Python Interpreter

6.1 Extending Python with C or C++
==================================

It is quite easy to add new built-in modules to Python, if you know how
to program in C. Such _extension modules_ can do two things that can’t
be done directly in Python: they can implement new built-in object
types, and they can call C library functions and system calls.

  To support extensions, the Python API (Application Programmers
Interface) defines a set of functions, macros and variables that provide
access to most aspects of the Python run-time system.  The Python API is
incorporated in a C source file by including the header ‘"Python.h"’.

  The compilation of an extension module depends on its intended use as
well as on your system setup; details are given in later chapters.

  Do note that if your use case is calling C library functions or system
calls, you should consider using the *note ctypes: 78. module rather
than writing custom C code.  Not only does *note ctypes: 78. let you
write Python code to interface with C code, but it is more portable
between implementations of Python than writing and compiling an
extension module which typically ties you to CPython.

* Menu:

* A Simple Example:: 
* Intermezzo; Errors and Exceptions: Intermezzo Errors and Exceptions. 
* Back to the Example:: 
* The Module's Method Table and Initialization Function:: 
* Compilation and Linkage:: 
* Calling Python Functions from C:: 
* Extracting Parameters in Extension Functions:: 
* Keyword Parameters for Extension Functions:: 
* Building Arbitrary Values:: 
* Reference Counts:: 
* Writing Extensions in C++:: 
* Providing a C API for an Extension Module:: 


File: python.info,  Node: A Simple Example,  Next: Intermezzo Errors and Exceptions,  Up: Extending Python with C or C++

6.1.1 A Simple Example
----------------------

Let’s create an extension module called ‘spam’ (the favorite food of
Monty Python fans...)  and let’s say we want to create a Python
interface to the C library function ‘system()’.  (1) This function takes
a null-terminated character string as argument and returns an integer.
We want this function to be callable from Python as follows:

     >>> import spam
     >>> status = spam.system("ls -l")

  Begin by creating a file ‘spammodule.c’.  (Historically, if a module
is called ‘spam’, the C file containing its implementation is called
‘spammodule.c’; if the module name is very long, like ‘spammify’, the
module name can be just ‘spammify.c’.)

  The first line of our file can be:

     #include <Python.h>

  which pulls in the Python API (you can add a comment describing the
purpose of the module and a copyright notice if you like).

     Note: Since Python may define some pre-processor definitions which
     affect the standard headers on some systems, you _must_ include
     ‘Python.h’ before any standard headers are included.

  All user-visible symbols defined by ‘Python.h’ have a prefix of ‘Py’
or ‘PY’, except those defined in standard header files.  For
convenience, and since they are used extensively by the Python
interpreter, ‘"Python.h"’ includes a few standard header files:
‘<stdio.h>’, ‘<string.h>’, ‘<errno.h>’, and ‘<stdlib.h>’.  If the latter
header file does not exist on your system, it declares the functions
‘malloc()’, ‘free()’ and ‘realloc()’ directly.

  The next thing we add to our module file is the C function that will
be called when the Python expression ‘spam.system(string)’ is evaluated
(we’ll see shortly how it ends up being called):

     static PyObject *
     spam_system(PyObject *self, PyObject *args)
     {
         const char *command;
         int sts;

         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;
         sts = system(command);
         return Py_BuildValue("i", sts);
     }

  There is a straightforward translation from the argument list in
Python (for example, the single expression ‘"ls -l"’) to the arguments
passed to the C function.  The C function always has two arguments,
conventionally named _self_ and _args_.

  The _self_ argument points to the module object for module-level
functions; for a method it would point to the object instance.

  The _args_ argument will be a pointer to a Python tuple object
containing the arguments.  Each item of the tuple corresponds to an
argument in the call’s argument list.  The arguments are Python objects
— in order to do anything with them in our C function we have to convert
them to C values.  The function *note PyArg_ParseTuple(): 31b. in the
Python API checks the argument types and converts them to C values.  It
uses a template string to determine the required types of the arguments
as well as the types of the C variables into which to store the
converted values.  More about this later.

  *note PyArg_ParseTuple(): 31b. returns true (nonzero) if all arguments
have the right type and its components have been stored in the variables
whose addresses are passed.  It returns false (zero) if an invalid
argument list was passed.  In the latter case it also raises an
appropriate exception so the calling function can return _NULL_
immediately (as we saw in the example).

   ---------- Footnotes ----------

   (1) An interface for this function already exists in the standard
module *note os: 128. — it was chosen as a simple and straightforward
example.


File: python.info,  Node: Intermezzo Errors and Exceptions,  Next: Back to the Example,  Prev: A Simple Example,  Up: Extending Python with C or C++

6.1.2 Intermezzo: Errors and Exceptions
---------------------------------------

An important convention throughout the Python interpreter is the
following: when a function fails, it should set an exception condition
and return an error value (usually a _NULL_ pointer).  Exceptions are
stored in a static global variable inside the interpreter; if this
variable is _NULL_ no exception has occurred.  A second global variable
stores the "associated value" of the exception (the second argument to
*note raise: 5b1.).  A third variable contains the stack traceback in
case the error originated in Python code.  These three variables are the
C equivalents of the Python variables ‘sys.exc_type’, ‘sys.exc_value’
and ‘sys.exc_traceback’ (see the section on module *note sys: 16d. in
the Python Library Reference).  It is important to know about them to
understand how errors are passed around.

  The Python API defines a number of functions to set various types of
exceptions.

  The most common one is *note PyErr_SetString(): 2998.  Its arguments
are an exception object and a C string.  The exception object is usually
a predefined object like ‘PyExc_ZeroDivisionError’.  The C string
indicates the cause of the error and is converted to a Python string
object and stored as the "associated value" of the exception.

  Another useful function is *note PyErr_SetFromErrno(): 2999, which
only takes an exception argument and constructs the associated value by
inspection of the global variable ‘errno’.  The most general function is
*note PyErr_SetObject(): 299a, which takes two object arguments, the
exception and its associated value.  You don’t need to *note
Py_INCREF(): 299b. the objects passed to any of these functions.

  You can test non-destructively whether an exception has been set with
*note PyErr_Occurred(): 299c.  This returns the current exception
object, or _NULL_ if no exception has occurred.  You normally don’t need
to call *note PyErr_Occurred(): 299c. to see whether an error occurred
in a function call, since you should be able to tell from the return
value.

  When a function _f_ that calls another function _g_ detects that the
latter fails, _f_ should itself return an error value (usually _NULL_ or
‘-1’).  It should _not_ call one of the ‘PyErr_*()’ functions — one has
already been called by _g_.  _f_’s caller is then supposed to also
return an error indication to _its_ caller, again _without_ calling
‘PyErr_*()’, and so on — the most detailed cause of the error was
already reported by the function that first detected it.  Once the error
reaches the Python interpreter’s main loop, this aborts the currently
executing Python code and tries to find an exception handler specified
by the Python programmer.

  (There are situations where a module can actually give a more detailed
error message by calling another ‘PyErr_*()’ function, and in such cases
it is fine to do so.  As a general rule, however, this is not necessary,
and can cause information about the cause of the error to be lost: most
operations can fail for a variety of reasons.)

  To ignore an exception set by a function call that failed, the
exception condition must be cleared explicitly by calling *note
PyErr_Clear(): 299d.  The only time C code should call *note
PyErr_Clear(): 299d. is if it doesn’t want to pass the error on to the
interpreter but wants to handle it completely by itself (possibly by
trying something else, or pretending nothing went wrong).

  Every failing ‘malloc()’ call must be turned into an exception — the
direct caller of ‘malloc()’ (or ‘realloc()’) must call *note
PyErr_NoMemory(): 299e. and return a failure indicator itself.  All the
object-creating functions (for example, *note PyInt_FromLong(): 299f.)
already do this, so this note is only relevant to those who call
‘malloc()’ directly.

  Also note that, with the important exception of *note
PyArg_ParseTuple(): 31b. and friends, functions that return an integer
status usually return a positive value or zero for success and ‘-1’ for
failure, like Unix system calls.

  Finally, be careful to clean up garbage (by making *note Py_XDECREF():
29a0. or *note Py_DECREF(): 29a1. calls for objects you have already
created) when you return an error indicator!

  The choice of which exception to raise is entirely yours.  There are
predeclared C objects corresponding to all built-in Python exceptions,
such as ‘PyExc_ZeroDivisionError’, which you can use directly.  Of
course, you should choose exceptions wisely — don’t use
‘PyExc_TypeError’ to mean that a file couldn’t be opened (that should
probably be ‘PyExc_IOError’).  If something’s wrong with the argument
list, the *note PyArg_ParseTuple(): 31b. function usually raises
‘PyExc_TypeError’.  If you have an argument whose value must be in a
particular range or must satisfy other conditions, ‘PyExc_ValueError’ is
appropriate.

  You can also define a new exception that is unique to your module.
For this, you usually declare a static object variable at the beginning
of your file:

     static PyObject *SpamError;

  and initialize it in your module’s initialization function
(‘initspam()’) with an exception object (leaving out the error checking
for now):

     PyMODINIT_FUNC
     initspam(void)
     {
         PyObject *m;

         m = Py_InitModule("spam", SpamMethods);
         if (m == NULL)
             return;

         SpamError = PyErr_NewException("spam.error", NULL, NULL);
         Py_INCREF(SpamError);
         PyModule_AddObject(m, "error", SpamError);
     }

  Note that the Python name for the exception object is ‘spam.error’.
The *note PyErr_NewException(): 2ba. function may create a class with
the base class being *note Exception: 339. (unless another class is
passed in instead of _NULL_), described in *note Built-in Exceptions:
5ad.

  Note also that the ‘SpamError’ variable retains a reference to the
newly created exception class; this is intentional!  Since the exception
could be removed from the module by external code, an owned reference to
the class is needed to ensure that it will not be discarded, causing
‘SpamError’ to become a dangling pointer.  Should it become a dangling
pointer, C code which raises the exception could cause a core dump or
other unintended side effects.

  We discuss the use of ‘PyMODINIT_FUNC’ as a function return type later
in this sample.

  The ‘spam.error’ exception can be raised in your extension module
using a call to *note PyErr_SetString(): 2998. as shown below:

     static PyObject *
     spam_system(PyObject *self, PyObject *args)
     {
         const char *command;
         int sts;

         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;
         sts = system(command);
         if (sts < 0) {
             PyErr_SetString(SpamError, "System command failed");
             return NULL;
         }
         return PyLong_FromLong(sts);
     }


File: python.info,  Node: Back to the Example,  Next: The Module's Method Table and Initialization Function,  Prev: Intermezzo Errors and Exceptions,  Up: Extending Python with C or C++

6.1.3 Back to the Example
-------------------------

Going back to our example function, you should now be able to understand
this statement:

     if (!PyArg_ParseTuple(args, "s", &command))
         return NULL;

  It returns _NULL_ (the error indicator for functions returning object
pointers) if an error is detected in the argument list, relying on the
exception set by *note PyArg_ParseTuple(): 31b.  Otherwise the string
value of the argument has been copied to the local variable ‘command’.
This is a pointer assignment and you are not supposed to modify the
string to which it points (so in Standard C, the variable ‘command’
should properly be declared as ‘const char *command’).

  The next statement is a call to the Unix function ‘system()’, passing
it the string we just got from *note PyArg_ParseTuple(): 31b.:

     sts = system(command);

  Our ‘spam.system()’ function must return the value of ‘sts’ as a
Python object.  This is done using the function *note Py_BuildValue():
3a8, which is something like the inverse of *note PyArg_ParseTuple():
31b.: it takes a format string and an arbitrary number of C values, and
returns a new Python object.  More info on *note Py_BuildValue(): 3a8.
is given later.

     return Py_BuildValue("i", sts);

  In this case, it will return an integer object.  (Yes, even integers
are objects on the heap in Python!)

  If you have a C function that returns no useful argument (a function
returning ‘void’), the corresponding Python function must return ‘None’.
You need this idiom to do so (which is implemented by the *note
Py_RETURN_NONE: 417. macro):

     Py_INCREF(Py_None);
     return Py_None;

  *note Py_None: 29a4. is the C name for the special Python object
‘None’.  It is a genuine Python object rather than a _NULL_ pointer,
which means "error" in most contexts, as we have seen.


File: python.info,  Node: The Module's Method Table and Initialization Function,  Next: Compilation and Linkage,  Prev: Back to the Example,  Up: Extending Python with C or C++

6.1.4 The Module’s Method Table and Initialization Function
-----------------------------------------------------------

I promised to show how ‘spam_system()’ is called from Python programs.
First, we need to list its name and address in a "method table":

     static PyMethodDef SpamMethods[] = {
         ...
         {"system",  spam_system, METH_VARARGS,
          "Execute a shell command."},
         ...
         {NULL, NULL, 0, NULL}        /* Sentinel */
     };

  Note the third entry (‘METH_VARARGS’).  This is a flag telling the
interpreter the calling convention to be used for the C function.  It
should normally always be ‘METH_VARARGS’ or ‘METH_VARARGS |
METH_KEYWORDS’; a value of ‘0’ means that an obsolete variant of *note
PyArg_ParseTuple(): 31b. is used.

  When using only ‘METH_VARARGS’, the function should expect the
Python-level parameters to be passed in as a tuple acceptable for
parsing via *note PyArg_ParseTuple(): 31b.; more information on this
function is provided below.

  The *note METH_KEYWORDS: 29a7. bit may be set in the third field if
keyword arguments should be passed to the function.  In this case, the C
function should accept a third ‘PyObject *’ parameter which will be a
dictionary of keywords.  Use *note PyArg_ParseTupleAndKeywords(): 41c.
to parse the arguments to such a function.

  The method table must be passed to the interpreter in the module’s
initialization function.  The initialization function must be named
‘initname()’, where _name_ is the name of the module, and should be the
only non-‘static’ item defined in the module file:

     PyMODINIT_FUNC
     initspam(void)
     {
         (void) Py_InitModule("spam", SpamMethods);
     }

  Note that PyMODINIT_FUNC declares the function as ‘void’ return type,
declares any special linkage declarations required by the platform, and
for C++ declares the function as ‘extern "C"’.

  When the Python program imports module ‘spam’ for the first time,
‘initspam()’ is called.  (See below for comments about embedding
Python.)  It calls *note Py_InitModule(): 29a8, which creates a "module
object" (which is inserted in the dictionary ‘sys.modules’ under the key
‘"spam"’), and inserts built-in function objects into the newly created
module based upon the table (an array of *note PyMethodDef: 472.
structures) that was passed as its second argument.  *note
Py_InitModule(): 29a8. returns a pointer to the module object that it
creates (which is unused here).  It may abort with a fatal error for
certain errors, or return _NULL_ if the module could not be initialized
satisfactorily.

  When embedding Python, the ‘initspam()’ function is not called
automatically unless there’s an entry in the ‘_PyImport_Inittab’ table.
The easiest way to handle this is to statically initialize your
statically-linked modules by directly calling ‘initspam()’ after the
call to *note Py_Initialize(): 29a9.:

     int
     main(int argc, char *argv[])
     {
         /* Pass argv[0] to the Python interpreter */
         Py_SetProgramName(argv[0]);

         /* Initialize the Python interpreter.  Required. */
         Py_Initialize();

         /* Add a static module */
         initspam();

         ...

  An example may be found in the file ‘Demo/embed/demo.c’ in the Python
source distribution.

     Note: Removing entries from ‘sys.modules’ or importing compiled
     modules into multiple interpreters within a process (or following a
     ‘fork()’ without an intervening ‘exec()’) can create problems for
     some extension modules.  Extension module authors should exercise
     caution when initializing internal data structures.  Note also that
     the *note reload(): 57a. function can be used with extension
     modules, and will call the module initialization function
     (‘initspam()’ in the example), but will not load the module again
     if it was loaded from a dynamically loadable object file (‘.so’ on
     Unix, ‘.dll’ on Windows).

  A more substantial example module is included in the Python source
distribution as ‘Modules/xxmodule.c’.  This file may be used as a
template or simply read as an example.


File: python.info,  Node: Compilation and Linkage,  Next: Calling Python Functions from C,  Prev: The Module's Method Table and Initialization Function,  Up: Extending Python with C or C++

6.1.5 Compilation and Linkage
-----------------------------

There are two more things to do before you can use your new extension:
compiling and linking it with the Python system.  If you use dynamic
loading, the details may depend on the style of dynamic loading your
system uses; see the chapters about building extension modules (chapter
*note Building C and C++ Extensions with distutils: 29ac.) and
additional information that pertains only to building on Windows
(chapter *note Building C and C++ Extensions on Windows: 677.) for more
information about this.

  If you can’t use dynamic loading, or if you want to make your module a
permanent part of the Python interpreter, you will have to change the
configuration setup and rebuild the interpreter.  Luckily, this is very
simple on Unix: just place your file (‘spammodule.c’ for example) in the
‘Modules/’ directory of an unpacked source distribution, add a line to
the file ‘Modules/Setup.local’ describing your file:

     spam spammodule.o

  and rebuild the interpreter by running *make* in the toplevel
directory.  You can also run *make* in the ‘Modules/’ subdirectory, but
then you must first rebuild ‘Makefile’ there by running ’*make*
Makefile’.  (This is necessary each time you change the ‘Setup’ file.)

  If your module requires additional libraries to link with, these can
be listed on the line in the configuration file as well, for instance:

     spam spammodule.o -lX11


File: python.info,  Node: Calling Python Functions from C,  Next: Extracting Parameters in Extension Functions,  Prev: Compilation and Linkage,  Up: Extending Python with C or C++

6.1.6 Calling Python Functions from C
-------------------------------------

So far we have concentrated on making C functions callable from Python.
The reverse is also useful: calling Python functions from C. This is
especially the case for libraries that support so-called "callback"
functions.  If a C interface makes use of callbacks, the equivalent
Python often needs to provide a callback mechanism to the Python
programmer; the implementation will require calling the Python callback
functions from a C callback.  Other uses are also imaginable.

  Fortunately, the Python interpreter is easily called recursively, and
there is a standard interface to call a Python function.  (I won’t dwell
on how to call the Python parser with a particular string as input — if
you’re interested, have a look at the implementation of the *note -c:
27b. command line option in ‘Modules/main.c’ from the Python source
code.)

  Calling a Python function is easy.  First, the Python program must
somehow pass you the Python function object.  You should provide a
function (or some other interface) to do this.  When this function is
called, save a pointer to the Python function object (be careful to
*note Py_INCREF(): 299b. it!)  in a global variable — or wherever you
see fit.  For example, the following function might be part of a module
definition:

     static PyObject *my_callback = NULL;

     static PyObject *
     my_set_callback(PyObject *dummy, PyObject *args)
     {
         PyObject *result = NULL;
         PyObject *temp;

         if (PyArg_ParseTuple(args, "O:set_callback", &temp)) {
             if (!PyCallable_Check(temp)) {
                 PyErr_SetString(PyExc_TypeError, "parameter must be callable");
                 return NULL;
             }
             Py_XINCREF(temp);         /* Add a reference to new callback */
             Py_XDECREF(my_callback);  /* Dispose of previous callback */
             my_callback = temp;       /* Remember new callback */
             /* Boilerplate to return "None" */
             Py_INCREF(Py_None);
             result = Py_None;
         }
         return result;
     }

  This function must be registered with the interpreter using the *note
METH_VARARGS: 4ac. flag; this is described in section *note The Module’s
Method Table and Initialization Function: 29a6.  The *note
PyArg_ParseTuple(): 31b. function and its arguments are documented in
section *note Extracting Parameters in Extension Functions: 29af.

  The macros *note Py_XINCREF(): 29b0. and *note Py_XDECREF(): 29a0.
increment/decrement the reference count of an object and are safe in the
presence of _NULL_ pointers (but note that _temp_ will not be _NULL_ in
this context).  More info on them in section *note Reference Counts:
29b1.

  Later, when it is time to call the function, you call the C function
*note PyObject_CallObject(): 29b2.  This function has two arguments,
both pointers to arbitrary Python objects: the Python function, and the
argument list.  The argument list must always be a tuple object, whose
length is the number of arguments.  To call the Python function with no
arguments, pass in NULL, or an empty tuple; to call it with one
argument, pass a singleton tuple.  *note Py_BuildValue(): 3a8. returns a
tuple when its format string consists of zero or more format codes
between parentheses.  For example:

     int arg;
     PyObject *arglist;
     PyObject *result;
     ...
     arg = 123;
     ...
     /* Time to call the callback */
     arglist = Py_BuildValue("(i)", arg);
     result = PyObject_CallObject(my_callback, arglist);
     Py_DECREF(arglist);

  *note PyObject_CallObject(): 29b2. returns a Python object pointer:
this is the return value of the Python function.  *note
PyObject_CallObject(): 29b2. is "reference-count-neutral" with respect
to its arguments.  In the example a new tuple was created to serve as
the argument list, which is *note Py_DECREF(): 29a1.-ed immediately
after the *note PyObject_CallObject(): 29b2. call.

  The return value of *note PyObject_CallObject(): 29b2. is "new":
either it is a brand new object, or it is an existing object whose
reference count has been incremented.  So, unless you want to save it in
a global variable, you should somehow *note Py_DECREF(): 29a1. the
result, even (especially!)  if you are not interested in its value.

  Before you do this, however, it is important to check that the return
value isn’t _NULL_. If it is, the Python function terminated by raising
an exception.  If the C code that called *note PyObject_CallObject():
29b2. is called from Python, it should now return an error indication to
its Python caller, so the interpreter can print a stack trace, or the
calling Python code can handle the exception.  If this is not possible
or desirable, the exception should be cleared by calling *note
PyErr_Clear(): 299d.  For example:

     if (result == NULL)
         return NULL; /* Pass error back */
     ...use result...
     Py_DECREF(result);

  Depending on the desired interface to the Python callback function,
you may also have to provide an argument list to *note
PyObject_CallObject(): 29b2.  In some cases the argument list is also
provided by the Python program, through the same interface that
specified the callback function.  It can then be saved and used in the
same manner as the function object.  In other cases, you may have to
construct a new tuple to pass as the argument list.  The simplest way to
do this is to call *note Py_BuildValue(): 3a8.  For example, if you want
to pass an integral event code, you might use the following code:

     PyObject *arglist;
     ...
     arglist = Py_BuildValue("(l)", eventcode);
     result = PyObject_CallObject(my_callback, arglist);
     Py_DECREF(arglist);
     if (result == NULL)
         return NULL; /* Pass error back */
     /* Here maybe use the result */
     Py_DECREF(result);

  Note the placement of ‘Py_DECREF(arglist)’ immediately after the call,
before the error check!  Also note that strictly speaking this code is
not complete: *note Py_BuildValue(): 3a8. may run out of memory, and
this should be checked.

  You may also call a function with keyword arguments by using *note
PyObject_Call(): 29b3, which supports arguments and keyword arguments.
As in the above example, we use *note Py_BuildValue(): 3a8. to construct
the dictionary.

     PyObject *dict;
     ...
     dict = Py_BuildValue("{s:i}", "name", val);
     result = PyObject_Call(my_callback, NULL, dict);
     Py_DECREF(dict);
     if (result == NULL)
         return NULL; /* Pass error back */
     /* Here maybe use the result */
     Py_DECREF(result);


File: python.info,  Node: Extracting Parameters in Extension Functions,  Next: Keyword Parameters for Extension Functions,  Prev: Calling Python Functions from C,  Up: Extending Python with C or C++

6.1.7 Extracting Parameters in Extension Functions
--------------------------------------------------

The *note PyArg_ParseTuple(): 31b. function is declared as follows:

     int PyArg_ParseTuple(PyObject *arg, char *format, ...);

  The _arg_ argument must be a tuple object containing an argument list
passed from Python to a C function.  The _format_ argument must be a
format string, whose syntax is explained in *note Parsing arguments and
building values: 29b5. in the Python/C API Reference Manual.  The
remaining arguments must be addresses of variables whose type is
determined by the format string.

  Note that while *note PyArg_ParseTuple(): 31b. checks that the Python
arguments have the required types, it cannot check the validity of the
addresses of C variables passed to the call: if you make mistakes there,
your code will probably crash or at least overwrite random bits in
memory.  So be careful!

  Note that any Python object references which are provided to the
caller are _borrowed_ references; do not decrement their reference
count!

  Some example calls:

     int ok;
     int i, j;
     long k, l;
     const char *s;
     int size;

     ok = PyArg_ParseTuple(args, ""); /* No arguments */
         /* Python call: f() */

     ok = PyArg_ParseTuple(args, "s", &s); /* A string */
         /* Possible Python call: f('whoops!') */

     ok = PyArg_ParseTuple(args, "lls", &k, &l, &s); /* Two longs and a string */
         /* Possible Python call: f(1, 2, 'three') */

     ok = PyArg_ParseTuple(args, "(ii)s#", &i, &j, &s, &size);
         /* A pair of ints and a string, whose size is also returned */
         /* Possible Python call: f((1, 2), 'three') */

     {
         const char *file;
         const char *mode = "r";
         int bufsize = 0;
         ok = PyArg_ParseTuple(args, "s|si", &file, &mode, &bufsize);
         /* A string, and optionally another string and an integer */
         /* Possible Python calls:
            f('spam')
            f('spam', 'w')
            f('spam', 'wb', 100000) */
     }

     {
         int left, top, right, bottom, h, v;
         ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",
                  &left, &top, &right, &bottom, &h, &v);
         /* A rectangle and a point */
         /* Possible Python call:
            f(((0, 0), (400, 300)), (10, 10)) */
     }

     {
         Py_complex c;
         ok = PyArg_ParseTuple(args, "D:myfunction", &c);
         /* a complex, also providing a function name for errors */
         /* Possible Python call: myfunction(1+2j) */
     }


File: python.info,  Node: Keyword Parameters for Extension Functions,  Next: Building Arbitrary Values,  Prev: Extracting Parameters in Extension Functions,  Up: Extending Python with C or C++

6.1.8 Keyword Parameters for Extension Functions
------------------------------------------------

The *note PyArg_ParseTupleAndKeywords(): 41c. function is declared as
follows:

     int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,
                                     char *format, char *kwlist[], ...);

  The _arg_ and _format_ parameters are identical to those of the *note
PyArg_ParseTuple(): 31b. function.  The _kwdict_ parameter is the
dictionary of keywords received as the third parameter from the Python
runtime.  The _kwlist_ parameter is a _NULL_-terminated list of strings
which identify the parameters; the names are matched with the type
information from _format_ from left to right.  On success, *note
PyArg_ParseTupleAndKeywords(): 41c. returns true, otherwise it returns
false and raises an appropriate exception.

     Note: Nested tuples cannot be parsed when using keyword arguments!
     Keyword parameters passed in which are not present in the _kwlist_
     will cause *note TypeError: 218. to be raised.

  Here is an example module which uses keywords, based on an example by
Geoff Philbrick (<philbrick@hks.com>):

     #include "Python.h"

     static PyObject *
     keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)
     {
         int voltage;
         char *state = "a stiff";
         char *action = "voom";
         char *type = "Norwegian Blue";

         static char *kwlist[] = {"voltage", "state", "action", "type", NULL};

         if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,
                                          &voltage, &state, &action, &type))
             return NULL;

         printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",
                action, voltage);
         printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);

         Py_INCREF(Py_None);

         return Py_None;
     }

     static PyMethodDef keywdarg_methods[] = {
         /* The cast of the function is necessary since PyCFunction values
          * only take two PyObject* parameters, and keywdarg_parrot() takes
          * three.
          */
         {"parrot", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,
          "Print a lovely skit to standard output."},
         {NULL, NULL, 0, NULL}   /* sentinel */
     };

     void
     initkeywdarg(void)
     {
       /* Create the module and add the functions */
       Py_InitModule("keywdarg", keywdarg_methods);
     }


File: python.info,  Node: Building Arbitrary Values,  Next: Reference Counts,  Prev: Keyword Parameters for Extension Functions,  Up: Extending Python with C or C++

6.1.9 Building Arbitrary Values
-------------------------------

This function is the counterpart to *note PyArg_ParseTuple(): 31b.  It
is declared as follows:

     PyObject *Py_BuildValue(char *format, ...);

  It recognizes a set of format units similar to the ones recognized by
*note PyArg_ParseTuple(): 31b, but the arguments (which are input to the
function, not output) must not be pointers, just values.  It returns a
new Python object, suitable for returning from a C function called from
Python.

  One difference with *note PyArg_ParseTuple(): 31b.: while the latter
requires its first argument to be a tuple (since Python argument lists
are always represented as tuples internally), *note Py_BuildValue():
3a8. does not always build a tuple.  It builds a tuple only if its
format string contains two or more format units.  If the format string
is empty, it returns ‘None’; if it contains exactly one format unit, it
returns whatever object is described by that format unit.  To force it
to return a tuple of size 0 or one, parenthesize the format string.

  Examples (to the left the call, to the right the resulting Python
value):

     Py_BuildValue("")                        None
     Py_BuildValue("i", 123)                  123
     Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789)
     Py_BuildValue("s", "hello")              'hello'
     Py_BuildValue("ss", "hello", "world")    ('hello', 'world')
     Py_BuildValue("s#", "hello", 4)          'hell'
     Py_BuildValue("()")                      ()
     Py_BuildValue("(i)", 123)                (123,)
     Py_BuildValue("(ii)", 123, 456)          (123, 456)
     Py_BuildValue("(i,i)", 123, 456)         (123, 456)
     Py_BuildValue("[i,i]", 123, 456)         [123, 456]
     Py_BuildValue("{s:i,s:i}",
                   "abc", 123, "def", 456)    {'abc': 123, 'def': 456}
     Py_BuildValue("((ii)(ii)) (ii)",
                   1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))


File: python.info,  Node: Reference Counts,  Next: Writing Extensions in C++,  Prev: Building Arbitrary Values,  Up: Extending Python with C or C++

6.1.10 Reference Counts
-----------------------

In languages like C or C++, the programmer is responsible for dynamic
allocation and deallocation of memory on the heap.  In C, this is done
using the functions ‘malloc()’ and ‘free()’.  In C++, the operators
‘new’ and ‘delete’ are used with essentially the same meaning and we’ll
restrict the following discussion to the C case.

  Every block of memory allocated with ‘malloc()’ should eventually be
returned to the pool of available memory by exactly one call to
‘free()’.  It is important to call ‘free()’ at the right time.  If a
block’s address is forgotten but ‘free()’ is not called for it, the
memory it occupies cannot be reused until the program terminates.  This
is called a _memory leak_.  On the other hand, if a program calls
‘free()’ for a block and then continues to use the block, it creates a
conflict with re-use of the block through another ‘malloc()’ call.  This
is called _using freed memory_.  It has the same bad consequences as
referencing uninitialized data — core dumps, wrong results, mysterious
crashes.

  Common causes of memory leaks are unusual paths through the code.  For
instance, a function may allocate a block of memory, do some
calculation, and then free the block again.  Now a change in the
requirements for the function may add a test to the calculation that
detects an error condition and can return prematurely from the function.
It’s easy to forget to free the allocated memory block when taking this
premature exit, especially when it is added later to the code.  Such
leaks, once introduced, often go undetected for a long time: the error
exit is taken only in a small fraction of all calls, and most modern
machines have plenty of virtual memory, so the leak only becomes
apparent in a long-running process that uses the leaking function
frequently.  Therefore, it’s important to prevent leaks from happening
by having a coding convention or strategy that minimizes this kind of
errors.

  Since Python makes heavy use of ‘malloc()’ and ‘free()’, it needs a
strategy to avoid memory leaks as well as the use of freed memory.  The
chosen method is called _reference counting_.  The principle is simple:
every object contains a counter, which is incremented when a reference
to the object is stored somewhere, and which is decremented when a
reference to it is deleted.  When the counter reaches zero, the last
reference to the object has been deleted and the object is freed.

  An alternative strategy is called _automatic garbage collection_.
(Sometimes, reference counting is also referred to as a garbage
collection strategy, hence my use of "automatic" to distinguish the
two.)  The big advantage of automatic garbage collection is that the
user doesn’t need to call ‘free()’ explicitly.  (Another claimed
advantage is an improvement in speed or memory usage — this is no hard
fact however.)  The disadvantage is that for C, there is no truly
portable automatic garbage collector, while reference counting can be
implemented portably (as long as the functions ‘malloc()’ and ‘free()’
are available — which the C Standard guarantees).  Maybe some day a
sufficiently portable automatic garbage collector will be available for
C. Until then, we’ll have to live with reference counts.

  While Python uses the traditional reference counting implementation,
it also offers a cycle detector that works to detect reference cycles.
This allows applications to not worry about creating direct or indirect
circular references; these are the weakness of garbage collection
implemented using only reference counting.  Reference cycles consist of
objects which contain (possibly indirect) references to themselves, so
that each object in the cycle has a reference count which is non-zero.
Typical reference counting implementations are not able to reclaim the
memory belonging to any objects in a reference cycle, or referenced from
the objects in the cycle, even though there are no further references to
the cycle itself.

  The cycle detector is able to detect garbage cycles and can reclaim
them so long as there are no finalizers implemented in Python (*note
__del__(): 709. methods).  When there are such finalizers, the detector
exposes the cycles through the *note gc: db. module (specifically, the
*note garbage: 242b. variable in that module).  The *note gc: db. module
also exposes a way to run the detector (the *note collect(): 3c0.
function), as well as configuration interfaces and the ability to
disable the detector at runtime.  The cycle detector is considered an
optional component; though it is included by default, it can be disabled
at build time using the ‘--without-cycle-gc’ option to the *configure*
script on Unix platforms (including Mac OS X) or by removing the
definition of ‘WITH_CYCLE_GC’ in the ‘pyconfig.h’ header on other
platforms.  If the cycle detector is disabled in this way, the *note gc:
db. module will not be available.

* Menu:

* Reference Counting in Python:: 
* Ownership Rules:: 
* Thin Ice:: 
* NULL Pointers:: 


File: python.info,  Node: Reference Counting in Python,  Next: Ownership Rules,  Up: Reference Counts

6.1.10.1 Reference Counting in Python
.....................................

There are two macros, ‘Py_INCREF(x)’ and ‘Py_DECREF(x)’, which handle
the incrementing and decrementing of the reference count.  *note
Py_DECREF(): 29a1. also frees the object when the count reaches zero.
For flexibility, it doesn’t call ‘free()’ directly — rather, it makes a
call through a function pointer in the object’s _type object_.  For this
purpose (and others), every object also contains a pointer to its type
object.

  The big question now remains: when to use ‘Py_INCREF(x)’ and
‘Py_DECREF(x)’?  Let’s first introduce some terms.  Nobody "owns" an
object; however, you can _own a reference_ to an object.  An object’s
reference count is now defined as the number of owned references to it.
The owner of a reference is responsible for calling *note Py_DECREF():
29a1. when the reference is no longer needed.  Ownership of a reference
can be transferred.  There are three ways to dispose of an owned
reference: pass it on, store it, or call *note Py_DECREF(): 29a1.
Forgetting to dispose of an owned reference creates a memory leak.

  It is also possible to _borrow_ (1) a reference to an object.  The
borrower of a reference should not call *note Py_DECREF(): 29a1.  The
borrower must not hold on to the object longer than the owner from which
it was borrowed.  Using a borrowed reference after the owner has
disposed of it risks using freed memory and should be avoided
completely.  (2)

  The advantage of borrowing over owning a reference is that you don’t
need to take care of disposing of the reference on all possible paths
through the code — in other words, with a borrowed reference you don’t
run the risk of leaking when a premature exit is taken.  The
disadvantage of borrowing over owning is that there are some subtle
situations where in seemingly correct code a borrowed reference can be
used after the owner from which it was borrowed has in fact disposed of
it.

  A borrowed reference can be changed into an owned reference by calling
*note Py_INCREF(): 299b.  This does not affect the status of the owner
from which the reference was borrowed — it creates a new owned
reference, and gives full owner responsibilities (the new owner must
dispose of the reference properly, as well as the previous owner).

   ---------- Footnotes ----------

   (1) The metaphor of "borrowing" a reference is not completely
correct: the owner still has a copy of the reference.

   (2) Checking that the reference count is at least 1 *does not work* —
the reference count itself could be in freed memory and may thus be
reused for another object!


File: python.info,  Node: Ownership Rules,  Next: Thin Ice,  Prev: Reference Counting in Python,  Up: Reference Counts

6.1.10.2 Ownership Rules
........................

Whenever an object reference is passed into or out of a function, it is
part of the function’s interface specification whether ownership is
transferred with the reference or not.

  Most functions that return a reference to an object pass on ownership
with the reference.  In particular, all functions whose function it is
to create a new object, such as *note PyInt_FromLong(): 299f. and *note
Py_BuildValue(): 3a8, pass ownership to the receiver.  Even if the
object is not actually new, you still receive ownership of a new
reference to that object.  For instance, *note PyInt_FromLong(): 299f.
maintains a cache of popular values and can return a reference to a
cached item.

  Many functions that extract objects from other objects also transfer
ownership with the reference, for instance *note
PyObject_GetAttrString(): 29bf.  The picture is less clear, here,
however, since a few common routines are exceptions: *note
PyTuple_GetItem(): 29c0, *note PyList_GetItem(): 29c1, *note
PyDict_GetItem(): 29c2, and *note PyDict_GetItemString(): 29c3. all
return references that you borrow from the tuple, list or dictionary.

  The function *note PyImport_AddModule(): 29c4. also returns a borrowed
reference, even though it may actually create the object it returns:
this is possible because an owned reference to the object is stored in
‘sys.modules’.

  When you pass an object reference into another function, in general,
the function borrows the reference from you — if it needs to store it,
it will use *note Py_INCREF(): 299b. to become an independent owner.
There are exactly two important exceptions to this rule: *note
PyTuple_SetItem(): 29c5. and *note PyList_SetItem(): 29c6.  These
functions take over ownership of the item passed to them — even if they
fail!  (Note that *note PyDict_SetItem(): 29c7. and friends don’t take
over ownership — they are "normal.")

  When a C function is called from Python, it borrows references to its
arguments from the caller.  The caller owns a reference to the object,
so the borrowed reference’s lifetime is guaranteed until the function
returns.  Only when such a borrowed reference must be stored or passed
on, it must be turned into an owned reference by calling *note
Py_INCREF(): 299b.

  The object reference returned from a C function that is called from
Python must be an owned reference — ownership is transferred from the
function to its caller.


File: python.info,  Node: Thin Ice,  Next: NULL Pointers,  Prev: Ownership Rules,  Up: Reference Counts

6.1.10.3 Thin Ice
.................

There are a few situations where seemingly harmless use of a borrowed
reference can lead to problems.  These all have to do with implicit
invocations of the interpreter, which can cause the owner of a reference
to dispose of it.

  The first and most important case to know about is using *note
Py_DECREF(): 29a1. on an unrelated object while borrowing a reference to
a list item.  For instance:

     void
     bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);

         PyList_SetItem(list, 1, PyInt_FromLong(0L));
         PyObject_Print(item, stdout, 0); /* BUG! */
     }

  This function first borrows a reference to ‘list[0]’, then replaces
‘list[1]’ with the value ‘0’, and finally prints the borrowed reference.
Looks harmless, right?  But it’s not!

  Let’s follow the control flow into *note PyList_SetItem(): 29c6.  The
list owns references to all its items, so when item 1 is replaced, it
has to dispose of the original item 1.  Now let’s suppose the original
item 1 was an instance of a user-defined class, and let’s further
suppose that the class defined a *note __del__(): 709. method.  If this
class instance has a reference count of 1, disposing of it will call its
*note __del__(): 709. method.

  Since it is written in Python, the *note __del__(): 709. method can
execute arbitrary Python code.  Could it perhaps do something to
invalidate the reference to ‘item’ in ‘bug()’?  You bet!  Assuming that
the list passed into ‘bug()’ is accessible to the *note __del__(): 709.
method, it could execute a statement to the effect of ‘del list[0]’, and
assuming this was the last reference to that object, it would free the
memory associated with it, thereby invalidating ‘item’.

  The solution, once you know the source of the problem, is easy:
temporarily increment the reference count.  The correct version of the
function reads:

     void
     no_bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);

         Py_INCREF(item);
         PyList_SetItem(list, 1, PyInt_FromLong(0L));
         PyObject_Print(item, stdout, 0);
         Py_DECREF(item);
     }

  This is a true story.  An older version of Python contained variants
of this bug and someone spent a considerable amount of time in a C
debugger to figure out why his *note __del__(): 709. methods would
fail...

  The second case of problems with a borrowed reference is a variant
involving threads.  Normally, multiple threads in the Python interpreter
can’t get in each other’s way, because there is a global lock protecting
Python’s entire object space.  However, it is possible to temporarily
release this lock using the macro *note Py_BEGIN_ALLOW_THREADS: 29ca,
and to re-acquire it using *note Py_END_ALLOW_THREADS: 29cb.  This is
common around blocking I/O calls, to let other threads use the processor
while waiting for the I/O to complete.  Obviously, the following
function has the same problem as the previous one:

     void
     bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);
         Py_BEGIN_ALLOW_THREADS
         ...some blocking I/O call...
         Py_END_ALLOW_THREADS
         PyObject_Print(item, stdout, 0); /* BUG! */
     }


File: python.info,  Node: NULL Pointers,  Prev: Thin Ice,  Up: Reference Counts

6.1.10.4 NULL Pointers
......................

In general, functions that take object references as arguments do not
expect you to pass them _NULL_ pointers, and will dump core (or cause
later core dumps) if you do so.  Functions that return object references
generally return _NULL_ only to indicate that an exception occurred.
The reason for not testing for _NULL_ arguments is that functions often
pass the objects they receive on to other function — if each function
were to test for _NULL_, there would be a lot of redundant tests and the
code would run more slowly.

  It is better to test for _NULL_ only at the "source:" when a pointer
that may be _NULL_ is received, for example, from ‘malloc()’ or from a
function that may raise an exception.

  The macros *note Py_INCREF(): 299b. and *note Py_DECREF(): 29a1. do
not check for _NULL_ pointers — however, their variants *note
Py_XINCREF(): 29b0. and *note Py_XDECREF(): 29a0. do.

  The macros for checking for a particular object type
(‘Pytype_Check()’) don’t check for _NULL_ pointers — again, there is
much code that calls several of these in a row to test an object against
various different expected types, and this would generate redundant
tests.  There are no variants with _NULL_ checking.

  The C function calling mechanism guarantees that the argument list
passed to C functions (‘args’ in the examples) is never _NULL_ — in fact
it guarantees that it is always a tuple.  (1)

  It is a severe error to ever let a _NULL_ pointer "escape" to the
Python user.

   ---------- Footnotes ----------

   (1) These guarantees don’t hold when you use the "old" style calling
convention — this is still found in much existing code.


File: python.info,  Node: Writing Extensions in C++,  Next: Providing a C API for an Extension Module,  Prev: Reference Counts,  Up: Extending Python with C or C++

6.1.11 Writing Extensions in C++
--------------------------------

It is possible to write extension modules in C++.  Some restrictions
apply.  If the main program (the Python interpreter) is compiled and
linked by the C compiler, global or static objects with constructors
cannot be used.  This is not a problem if the main program is linked by
the C++ compiler.  Functions that will be called by the Python
interpreter (in particular, module initialization functions) have to be
declared using ‘extern "C"’.  It is unnecessary to enclose the Python
header files in ‘extern "C" {...}’ — they use this form already if the
symbol ‘__cplusplus’ is defined (all recent C++ compilers define this
symbol).


File: python.info,  Node: Providing a C API for an Extension Module,  Prev: Writing Extensions in C++,  Up: Extending Python with C or C++

6.1.12 Providing a C API for an Extension Module
------------------------------------------------

Many extension modules just provide new functions and types to be used
from Python, but sometimes the code in an extension module can be useful
for other extension modules.  For example, an extension module could
implement a type "collection" which works like lists without order.
Just like the standard Python list type has a C API which permits
extension modules to create and manipulate lists, this new collection
type should have a set of C functions for direct manipulation from other
extension modules.

  At first sight this seems easy: just write the functions (without
declaring them ‘static’, of course), provide an appropriate header file,
and document the C API. And in fact this would work if all extension
modules were always linked statically with the Python interpreter.  When
modules are used as shared libraries, however, the symbols defined in
one module may not be visible to another module.  The details of
visibility depend on the operating system; some systems use one global
namespace for the Python interpreter and all extension modules (Windows,
for example), whereas others require an explicit list of imported
symbols at module link time (AIX is one example), or offer a choice of
different strategies (most Unices).  And even if symbols are globally
visible, the module whose functions one wishes to call might not have
been loaded yet!

  Portability therefore requires not to make any assumptions about
symbol visibility.  This means that all symbols in extension modules
should be declared ‘static’, except for the module’s initialization
function, in order to avoid name clashes with other extension modules
(as discussed in section *note The Module’s Method Table and
Initialization Function: 29a6.).  And it means that symbols that
_should_ be accessible from other extension modules must be exported in
a different way.

  Python provides a special mechanism to pass C-level information
(pointers) from one extension module to another one: Capsules.  A
Capsule is a Python data type which stores a pointer (‘void *’).
Capsules can only be created and accessed via their C API, but they can
be passed around like any other Python object.  In particular, they can
be assigned to a name in an extension module’s namespace.  Other
extension modules can then import this module, retrieve the value of
this name, and then retrieve the pointer from the Capsule.

  There are many ways in which Capsules can be used to export the C API
of an extension module.  Each function could get its own Capsule, or all
C API pointers could be stored in an array whose address is published in
a Capsule.  And the various tasks of storing and retrieving the pointers
can be distributed in different ways between the module providing the
code and the client modules.

  Whichever method you choose, it’s important to name your Capsules
properly.  The function *note PyCapsule_New(): 29d1. takes a name
parameter (‘const char *’); you’re permitted to pass in a _NULL_ name,
but we strongly encourage you to specify a name.  Properly named
Capsules provide a degree of runtime type-safety; there is no feasible
way to tell one unnamed Capsule from another.

  In particular, Capsules used to expose C APIs should be given a name
following this convention:

     modulename.attributename

  The convenience function *note PyCapsule_Import(): 29d2. makes it easy
to load a C API provided via a Capsule, but only if the Capsule’s name
matches this convention.  This behavior gives C API users a high degree
of certainty that the Capsule they load contains the correct C API.

  The following example demonstrates an approach that puts most of the
burden on the writer of the exporting module, which is appropriate for
commonly used library modules.  It stores all C API pointers (just one
in the example!)  in an array of ‘void’ pointers which becomes the value
of a Capsule.  The header file corresponding to the module provides a
macro that takes care of importing the module and retrieving its C API
pointers; client modules only have to call this macro before accessing
the C API.

  The exporting module is a modification of the ‘spam’ module from
section *note A Simple Example: 2994.  The function ‘spam.system()’ does
not call the C library function ‘system()’ directly, but a function
‘PySpam_System()’, which would of course do something more complicated
in reality (such as adding "spam" to every command).  This function
‘PySpam_System()’ is also exported to other extension modules.

  The function ‘PySpam_System()’ is a plain C function, declared
‘static’ like everything else:

     static int
     PySpam_System(const char *command)
     {
         return system(command);
     }

  The function ‘spam_system()’ is modified in a trivial way:

     static PyObject *
     spam_system(PyObject *self, PyObject *args)
     {
         const char *command;
         int sts;

         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;
         sts = PySpam_System(command);
         return Py_BuildValue("i", sts);
     }

  In the beginning of the module, right after the line

     #include "Python.h"

  two more lines must be added:

     #define SPAM_MODULE
     #include "spammodule.h"

  The ‘#define’ is used to tell the header file that it is being
included in the exporting module, not a client module.  Finally, the
module’s initialization function must take care of initializing the C
API pointer array:

     PyMODINIT_FUNC
     initspam(void)
     {
         PyObject *m;
         static void *PySpam_API[PySpam_API_pointers];
         PyObject *c_api_object;

         m = Py_InitModule("spam", SpamMethods);
         if (m == NULL)
             return;

         /* Initialize the C API pointer array */
         PySpam_API[PySpam_System_NUM] = (void *)PySpam_System;

         /* Create a Capsule containing the API pointer array's address */
         c_api_object = PyCapsule_New((void *)PySpam_API, "spam._C_API", NULL);

         if (c_api_object != NULL)
             PyModule_AddObject(m, "_C_API", c_api_object);
     }

  Note that ‘PySpam_API’ is declared ‘static’; otherwise the pointer
array would disappear when ‘initspam()’ terminates!

  The bulk of the work is in the header file ‘spammodule.h’, which looks
like this:

     #ifndef Py_SPAMMODULE_H
     #define Py_SPAMMODULE_H
     #ifdef __cplusplus
     extern "C" {
     #endif

     /* Header file for spammodule */

     /* C API functions */
     #define PySpam_System_NUM 0
     #define PySpam_System_RETURN int
     #define PySpam_System_PROTO (const char *command)

     /* Total number of C API pointers */
     #define PySpam_API_pointers 1


     #ifdef SPAM_MODULE
     /* This section is used when compiling spammodule.c */

     static PySpam_System_RETURN PySpam_System PySpam_System_PROTO;

     #else
     /* This section is used in modules that use spammodule's API */

     static void **PySpam_API;

     #define PySpam_System \
      (*(PySpam_System_RETURN (*)PySpam_System_PROTO) PySpam_API[PySpam_System_NUM])

     /* Return -1 on error, 0 on success.
      * PyCapsule_Import will set an exception if there's an error.
      */
     static int
     import_spam(void)
     {
         PySpam_API = (void **)PyCapsule_Import("spam._C_API", 0);
         return (PySpam_API != NULL) ? 0 : -1;
     }

     #endif

     #ifdef __cplusplus
     }
     #endif

     #endif /* !defined(Py_SPAMMODULE_H) */

  All that a client module must do in order to have access to the
function ‘PySpam_System()’ is to call the function (or rather macro)
‘import_spam()’ in its initialization function:

     PyMODINIT_FUNC
     initclient(void)
     {
         PyObject *m;

         m = Py_InitModule("client", ClientMethods);
         if (m == NULL)
             return;
         if (import_spam() < 0)
             return;
         /* additional initialization can happen here */
     }

  The main disadvantage of this approach is that the file ‘spammodule.h’
is rather complicated.  However, the basic structure is the same for
each function that is exported, so it has to be learned only once.

  Finally it should be mentioned that Capsules offer additional
functionality, which is especially useful for memory allocation and
deallocation of the pointer stored in a Capsule.  The details are
described in the Python/C API Reference Manual in the section *note
Capsules: 29d3. and in the implementation of Capsules (files
‘Include/pycapsule.h’ and ‘Objects/pycapsule.c’ in the Python source
code distribution).


File: python.info,  Node: Defining New Types,  Next: Building C and C++ Extensions with distutils,  Prev: Extending Python with C or C++,  Up: Extending and Embedding the Python Interpreter

6.2 Defining New Types
======================

As mentioned in the last chapter, Python allows the writer of an
extension module to define new types that can be manipulated from Python
code, much like strings and lists in core Python.

  This is not hard; the code for all extension types follows a pattern,
but there are some details that you need to understand before you can
get started.

     Note: The way new types are defined changed dramatically (and for
     the better) in Python 2.2.  This document documents how to define
     new types for Python 2.2 and later.  If you need to support older
     versions of Python, you will need to refer to older versions of
     this documentation(1).

* Menu:

* The Basics:: 
* Type Methods:: 

The Basics

* Adding data and methods to the Basic example:: 
* Providing finer control over data attributes:: 
* Supporting cyclic garbage collection:: 
* Subclassing other types:: 

Type Methods

* Finalization and De-allocation:: 
* Object Presentation:: 
* Attribute Management:: 
* Object Comparison:: 
* Abstract Protocol Support:: 
* Weak Reference Support:: 
* More Suggestions:: 

Attribute Management

* Generic Attribute Management:: 
* Type-specific Attribute Management:: 

   ---------- Footnotes ----------

   (1) http://www.python.org/doc/versions/


File: python.info,  Node: The Basics,  Next: Type Methods,  Up: Defining New Types

6.2.1 The Basics
----------------

The Python runtime sees all Python objects as variables of type *note
PyObject*: 3a6.  A *note PyObject: 3a6. is not a very magnificent object
- it just contains the refcount and a pointer to the object’s "type
object".  This is where the action is; the type object determines which
(C) functions get called when, for instance, an attribute gets looked up
on an object or it is multiplied by another object.  These C functions
are called "type methods".

  So, if you want to define a new object type, you need to create a new
type object.

  This sort of thing can only be explained by example, so here’s a
minimal, but complete, module that defines a new type:

     #include <Python.h>

     typedef struct {
         PyObject_HEAD
         /* Type-specific fields go here. */
     } noddy_NoddyObject;

     static PyTypeObject noddy_NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(noddy_NoddyObject), /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         0,                         /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT,        /*tp_flags*/
         "Noddy objects",           /* tp_doc */
     };

     static PyMethodDef noddy_methods[] = {
         {NULL}  /* Sentinel */
     };

     #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
     #define PyMODINIT_FUNC void
     #endif
     PyMODINIT_FUNC
     initnoddy(void)
     {
         PyObject* m;

         noddy_NoddyType.tp_new = PyType_GenericNew;
         if (PyType_Ready(&noddy_NoddyType) < 0)
             return;

         m = Py_InitModule3("noddy", noddy_methods,
                            "Example module that creates an extension type.");

         Py_INCREF(&noddy_NoddyType);
         PyModule_AddObject(m, "Noddy", (PyObject *)&noddy_NoddyType);
     }


  Now that’s quite a bit to take in at once, but hopefully bits will
seem familiar from the last chapter.

  The first bit that will be new is:

     typedef struct {
         PyObject_HEAD
     } noddy_NoddyObject;

  This is what a Noddy object will contain—in this case, nothing more
than every Python object contains, namely a refcount and a pointer to a
type object.  These are the fields the ‘PyObject_HEAD’ macro brings in.
The reason for the macro is to standardize the layout and to enable
special debugging fields in debug builds.  Note that there is no
semicolon after the ‘PyObject_HEAD’ macro; one is included in the macro
definition.  Be wary of adding one by accident; it’s easy to do from
habit, and your compiler might not complain, but someone else’s probably
will!  (On Windows, MSVC is known to call this an error and refuse to
compile the code.)

  For contrast, let’s take a look at the corresponding definition for
standard Python integers:

     typedef struct {
         PyObject_HEAD
         long ob_ival;
     } PyIntObject;

  Moving on, we come to the crunch — the type object.

     static PyTypeObject noddy_NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(noddy_NoddyObject), /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         0,                         /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT,        /*tp_flags*/
         "Noddy objects",           /* tp_doc */
     };

  Now if you go and look up the definition of *note PyTypeObject: 29d9.
in ‘object.h’ you’ll see that it has many more fields that the
definition above.  The remaining fields will be filled with zeros by the
C compiler, and it’s common practice to not specify them explicitly
unless you need them.

  This is so important that we’re going to pick the top of it apart
still further:

     PyObject_HEAD_INIT(NULL)

  This line is a bit of a wart; what we’d like to write is:

     PyObject_HEAD_INIT(&PyType_Type)

  as the type of a type object is "type", but this isn’t strictly
conforming C and some compilers complain.  Fortunately, this member will
be filled in for us by *note PyType_Ready(): 29da.

     0,                          /* ob_size */

  The ‘ob_size’ field of the header is not used; its presence in the
type structure is a historical artifact that is maintained for binary
compatibility with extension modules compiled for older versions of
Python.  Always set this field to zero.

     "noddy.Noddy",              /* tp_name */

  The name of our type.  This will appear in the default textual
representation of our objects and in some error messages, for example:

     >>> "" + noddy.new_noddy()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: cannot add type "noddy.Noddy" to string

  Note that the name is a dotted name that includes both the module name
and the name of the type within the module.  The module in this case is
‘noddy’ and the type is ‘Noddy’, so we set the type name to
‘noddy.Noddy’.

     sizeof(noddy_NoddyObject),  /* tp_basicsize */

  This is so that Python knows how much memory to allocate when you call
*note PyObject_New(): 46b.

     Note: If you want your type to be subclassable from Python, and
     your type has the same *note tp_basicsize: 29db. as its base type,
     you may have problems with multiple inheritance.  A Python subclass
     of your type will have to list your type first in its *note
     __bases__: 6fc, or else it will not be able to call your type’s
     *note __new__(): 6f9. method without getting an error.  You can
     avoid this problem by ensuring that your type has a larger value
     for *note tp_basicsize: 29db. than its base type does.  Most of the
     time, this will be true anyway, because either your base type will
     be *note object: 1f1, or else you will be adding data members to
     your base type, and therefore increasing its size.

     0,                          /* tp_itemsize */

  This has to do with variable length objects like lists and strings.
Ignore this for now.

  Skipping a number of type methods that we don’t provide, we set the
class flags to *note Py_TPFLAGS_DEFAULT: 29dc.

     Py_TPFLAGS_DEFAULT,        /*tp_flags*/

  All types should include this constant in their flags.  It enables all
of the members defined by the current version of Python.

  We provide a doc string for the type in *note tp_doc: 29dd.

     "Noddy objects",           /* tp_doc */

  Now we get into the type methods, the things that make your objects
different from the others.  We aren’t going to implement any of these in
this version of the module.  We’ll expand this example later to have
more interesting behavior.

  For now, all we want to be able to do is to create new ‘Noddy’
objects.  To enable object creation, we have to provide a *note tp_new:
29de. implementation.  In this case, we can just use the default
implementation provided by the API function *note PyType_GenericNew():
29df.  We’d like to just assign this to the *note tp_new: 29de. slot,
but we can’t, for portability sake, On some platforms or compilers, we
can’t statically initialize a structure member with a function defined
in another C module, so, instead, we’ll assign the *note tp_new: 29de.
slot in the module initialization function just before calling *note
PyType_Ready(): 29da.:

     noddy_NoddyType.tp_new = PyType_GenericNew;
     if (PyType_Ready(&noddy_NoddyType) < 0)
         return;

  All the other type methods are _NULL_, so we’ll go over them later —
that’s for a later section!

  Everything else in the file should be familiar, except for some code
in ‘initnoddy()’:

     if (PyType_Ready(&noddy_NoddyType) < 0)
         return;

  This initializes the ‘Noddy’ type, filing in a number of members,
including ‘ob_type’ that we initially set to _NULL_.

     PyModule_AddObject(m, "Noddy", (PyObject *)&noddy_NoddyType);

  This adds the type to the module dictionary.  This allows us to create
‘Noddy’ instances by calling the ‘Noddy’ class:

     >>> import noddy
     >>> mynoddy = noddy.Noddy()

  That’s it!  All that remains is to build it; put the above code in a
file called ‘noddy.c’ and

     from distutils.core import setup, Extension
     setup(name="noddy", version="1.0",
           ext_modules=[Extension("noddy", ["noddy.c"])])

  in a file called ‘setup.py’; then typing

     $ python setup.py build

  at a shell should produce a file ‘noddy.so’ in a subdirectory; move to
that directory and fire up Python — you should be able to ‘import noddy’
and play around with Noddy objects.

  That wasn’t so hard, was it?

  Of course, the current Noddy type is pretty uninteresting.  It has no
data and doesn’t do anything.  It can’t even be subclassed.

* Menu:

* Adding data and methods to the Basic example:: 
* Providing finer control over data attributes:: 
* Supporting cyclic garbage collection:: 
* Subclassing other types:: 


File: python.info,  Node: Adding data and methods to the Basic example,  Next: Providing finer control over data attributes,  Up: The Basics

6.2.1.1 Adding data and methods to the Basic example
....................................................

Let’s expend the basic example to add some data and methods.  Let’s also
make the type usable as a base class.  We’ll create a new module,
‘noddy2’ that adds these capabilities:

     #include <Python.h>
     #include "structmember.h"

     typedef struct {
         PyObject_HEAD
         PyObject *first; /* first name */
         PyObject *last;  /* last name */
         int number;
     } Noddy;

     static void
     Noddy_dealloc(Noddy* self)
     {
         Py_XDECREF(self->first);
         Py_XDECREF(self->last);
         self->ob_type->tp_free((PyObject*)self);
     }

     static PyObject *
     Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     {
         Noddy *self;

         self = (Noddy *)type->tp_alloc(type, 0);
         if (self != NULL) {
             self->first = PyString_FromString("");
             if (self->first == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->last = PyString_FromString("");
             if (self->last == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->number = 0;
         }

         return (PyObject *)self;
     }

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL, *tmp;

         static char *kwlist[] = {"first", "last", "number", NULL};

         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;

         if (first) {
             tmp = self->first;
             Py_INCREF(first);
             self->first = first;
             Py_XDECREF(tmp);
         }

         if (last) {
             tmp = self->last;
             Py_INCREF(last);
             self->last = last;
             Py_XDECREF(tmp);
         }

         return 0;
     }


     static PyMemberDef Noddy_members[] = {
         {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
          "first name"},
         {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
          "last name"},
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

     static PyObject *
     Noddy_name(Noddy* self)
     {
         static PyObject *format = NULL;
         PyObject *args, *result;

         if (format == NULL) {
             format = PyString_FromString("%s %s");
             if (format == NULL)
                 return NULL;
         }

         if (self->first == NULL) {
             PyErr_SetString(PyExc_AttributeError, "first");
             return NULL;
         }

         if (self->last == NULL) {
             PyErr_SetString(PyExc_AttributeError, "last");
             return NULL;
         }

         args = Py_BuildValue("OO", self->first, self->last);
         if (args == NULL)
             return NULL;

         result = PyString_Format(format, args);
         Py_DECREF(args);

         return result;
     }

     static PyMethodDef Noddy_methods[] = {
         {"name", (PyCFunction)Noddy_name, METH_NOARGS,
          "Return the name, combining the first and last name"
         },
         {NULL}  /* Sentinel */
     };

     static PyTypeObject NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(Noddy),             /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         (destructor)Noddy_dealloc, /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
         "Noddy objects",           /* tp_doc */
         0,		               /* tp_traverse */
         0,		               /* tp_clear */
         0,		               /* tp_richcompare */
         0,		               /* tp_weaklistoffset */
         0,		               /* tp_iter */
         0,		               /* tp_iternext */
         Noddy_methods,             /* tp_methods */
         Noddy_members,             /* tp_members */
         0,                         /* tp_getset */
         0,                         /* tp_base */
         0,                         /* tp_dict */
         0,                         /* tp_descr_get */
         0,                         /* tp_descr_set */
         0,                         /* tp_dictoffset */
         (initproc)Noddy_init,      /* tp_init */
         0,                         /* tp_alloc */
         Noddy_new,                 /* tp_new */
     };

     static PyMethodDef module_methods[] = {
         {NULL}  /* Sentinel */
     };

     #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
     #define PyMODINIT_FUNC void
     #endif
     PyMODINIT_FUNC
     initnoddy2(void)
     {
         PyObject* m;

         if (PyType_Ready(&NoddyType) < 0)
             return;

         m = Py_InitModule3("noddy2", module_methods,
                            "Example module that creates an extension type.");

         if (m == NULL)
           return;

         Py_INCREF(&NoddyType);
         PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
     }


  This version of the module has a number of changes.

  We’ve added an extra include:

     #include <structmember.h>

  This include provides declarations that we use to handle attributes,
as described a bit later.

  The name of the ‘Noddy’ object structure has been shortened to
‘Noddy’.  The type object name has been shortened to ‘NoddyType’.

  The ‘Noddy’ type now has three data attributes, _first_, _last_, and
_number_.  The _first_ and _last_ variables are Python strings
containing first and last names.  The _number_ attribute is an integer.

  The object structure is updated accordingly:

     typedef struct {
         PyObject_HEAD
         PyObject *first;
         PyObject *last;
         int number;
     } Noddy;

  Because we now have data to manage, we have to be more careful about
object allocation and deallocation.  At a minimum, we need a
deallocation method:

     static void
     Noddy_dealloc(Noddy* self)
     {
         Py_XDECREF(self->first);
         Py_XDECREF(self->last);
         self->ob_type->tp_free((PyObject*)self);
     }

  which is assigned to the *note tp_dealloc: 29e1. member:

     (destructor)Noddy_dealloc, /*tp_dealloc*/

  This method decrements the reference counts of the two Python
attributes.  We use *note Py_XDECREF(): 29a0. here because the ‘first’
and ‘last’ members could be _NULL_. It then calls the *note tp_free:
29e2. member of the object’s type to free the object’s memory.  Note
that the object’s type might not be ‘NoddyType’, because the object may
be an instance of a subclass.

  We want to make sure that the first and last names are initialized to
empty strings, so we provide a new method:

     static PyObject *
     Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     {
         Noddy *self;

         self = (Noddy *)type->tp_alloc(type, 0);
         if (self != NULL) {
             self->first = PyString_FromString("");
             if (self->first == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->last = PyString_FromString("");
             if (self->last == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->number = 0;
         }

         return (PyObject *)self;
     }

  and install it in the *note tp_new: 29de. member:

     Noddy_new,                 /* tp_new */

  The new member is responsible for creating (as opposed to
initializing) objects of the type.  It is exposed in Python as the *note
__new__(): 6f9. method.  See the paper titled "Unifying types and
classes in Python" for a detailed discussion of the *note __new__():
6f9. method.  One reason to implement a new method is to assure the
initial values of instance variables.  In this case, we use the new
method to make sure that the initial values of the members ‘first’ and
‘last’ are not _NULL_. If we didn’t care whether the initial values were
_NULL_, we could have used *note PyType_GenericNew(): 29df. as our new
method, as we did before.  *note PyType_GenericNew(): 29df. initializes
all of the instance variable members to _NULL_.

  The new method is a static method that is passed the type being
instantiated and any arguments passed when the type was called, and that
returns the new object created.  New methods always accept positional
and keyword arguments, but they often ignore the arguments, leaving the
argument handling to initializer methods.  Note that if the type
supports subclassing, the type passed may not be the type being defined.
The new method calls the tp_alloc slot to allocate memory.  We don’t
fill the *note tp_alloc: 29e3. slot ourselves.  Rather *note
PyType_Ready(): 29da. fills it for us by inheriting it from our base
class, which is *note object: 1f1. by default.  Most types use the
default allocation.

     Note: If you are creating a co-operative *note tp_new: 29de. (one
     that calls a base type’s *note tp_new: 29de. or *note __new__():
     6f9.), you must _not_ try to determine what method to call using
     method resolution order at runtime.  Always statically determine
     what type you are going to call, and call its *note tp_new: 29de.
     directly, or via ‘type->tp_base->tp_new’.  If you do not do this,
     Python subclasses of your type that also inherit from other
     Python-defined classes may not work correctly.  (Specifically, you
     may not be able to create instances of such subclasses without
     getting a *note TypeError: 218.)

  We provide an initialization function:

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL, *tmp;

         static char *kwlist[] = {"first", "last", "number", NULL};

         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;

         if (first) {
             tmp = self->first;
             Py_INCREF(first);
             self->first = first;
             Py_XDECREF(tmp);
         }

         if (last) {
             tmp = self->last;
             Py_INCREF(last);
             self->last = last;
             Py_XDECREF(tmp);
         }

         return 0;
     }

  by filling the *note tp_init: 29e4. slot.

     (initproc)Noddy_init,         /* tp_init */

  The *note tp_init: 29e4. slot is exposed in Python as the *note
__init__(): 37c. method.  It is used to initialize an object after it’s
created.  Unlike the new method, we can’t guarantee that the initializer
is called.  The initializer isn’t called when unpickling objects and it
can be overridden.  Our initializer accepts arguments to provide initial
values for our instance.  Initializers always accept positional and
keyword arguments.

  Initializers can be called multiple times.  Anyone can call the *note
__init__(): 37c. method on our objects.  For this reason, we have to be
extra careful when assigning the new values.  We might be tempted, for
example to assign the ‘first’ member like this:

     if (first) {
         Py_XDECREF(self->first);
         Py_INCREF(first);
         self->first = first;
     }

  But this would be risky.  Our type doesn’t restrict the type of the
‘first’ member, so it could be any kind of object.  It could have a
destructor that causes code to be executed that tries to access the
‘first’ member.  To be paranoid and protect ourselves against this
possibility, we almost always reassign members before decrementing their
reference counts.  When don’t we have to do this?

   * when we absolutely know that the reference count is greater than 1

   * when we know that deallocation of the object (1) will not cause any
     calls back into our type’s code

   * when decrementing a reference count in a *note tp_dealloc: 29e1.
     handler when garbage-collections is not supported (2)

  We want to expose our instance variables as attributes.  There are a
number of ways to do that.  The simplest way is to define member
definitions:

     static PyMemberDef Noddy_members[] = {
         {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
          "first name"},
         {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
          "last name"},
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

  and put the definitions in the *note tp_members: 29e5. slot:

     Noddy_members,             /* tp_members */

  Each member definition has a member name, type, offset, access flags
and documentation string.  See the *note Generic Attribute Management:
29e6. section below for details.

  A disadvantage of this approach is that it doesn’t provide a way to
restrict the types of objects that can be assigned to the Python
attributes.  We expect the first and last names to be strings, but any
Python objects can be assigned.  Further, the attributes can be deleted,
setting the C pointers to _NULL_. Even though we can make sure the
members are initialized to non-_NULL_ values, the members can be set to
_NULL_ if the attributes are deleted.

  We define a single method, ‘name()’, that outputs the objects name as
the concatenation of the first and last names.

     static PyObject *
     Noddy_name(Noddy* self)
     {
         static PyObject *format = NULL;
         PyObject *args, *result;

         if (format == NULL) {
             format = PyString_FromString("%s %s");
             if (format == NULL)
                 return NULL;
         }

         if (self->first == NULL) {
             PyErr_SetString(PyExc_AttributeError, "first");
             return NULL;
         }

         if (self->last == NULL) {
             PyErr_SetString(PyExc_AttributeError, "last");
             return NULL;
         }

         args = Py_BuildValue("OO", self->first, self->last);
         if (args == NULL)
             return NULL;

         result = PyString_Format(format, args);
         Py_DECREF(args);

         return result;
     }

  The method is implemented as a C function that takes a ‘Noddy’ (or
‘Noddy’ subclass) instance as the first argument.  Methods always take
an instance as the first argument.  Methods often take positional and
keyword arguments as well, but in this cased we don’t take any and don’t
need to accept a positional argument tuple or keyword argument
dictionary.  This method is equivalent to the Python method:

     def name(self):
        return "%s %s" % (self.first, self.last)

  Note that we have to check for the possibility that our ‘first’ and
‘last’ members are _NULL_. This is because they can be deleted, in which
case they are set to _NULL_. It would be better to prevent deletion of
these attributes and to restrict the attribute values to be strings.
We’ll see how to do that in the next section.

  Now that we’ve defined the method, we need to create an array of
method definitions:

     static PyMethodDef Noddy_methods[] = {
         {"name", (PyCFunction)Noddy_name, METH_NOARGS,
          "Return the name, combining the first and last name"
         },
         {NULL}  /* Sentinel */
     };

  and assign them to the *note tp_methods: 29e7. slot:

     Noddy_methods,             /* tp_methods */

  Note that we used the *note METH_NOARGS: 46f. flag to indicate that
the method is passed no arguments.

  Finally, we’ll make our type usable as a base class.  We’ve written
our methods carefully so far so that they don’t make any assumptions
about the type of the object being created or used, so all we need to do
is to add the *note Py_TPFLAGS_BASETYPE: 29e8. to our class flag
definition:

     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/

  We rename ‘initnoddy()’ to ‘initnoddy2()’ and update the module name
passed to *note Py_InitModule3(): 29e9.

  Finally, we update our ‘setup.py’ file to build the new module:

     from distutils.core import setup, Extension
     setup(name="noddy", version="1.0",
           ext_modules=[
              Extension("noddy", ["noddy.c"]),
              Extension("noddy2", ["noddy2.c"]),
              ])

   ---------- Footnotes ----------

   (1) This is true when we know that the object is a basic type, like a
string or a float.

   (2) We relied on this in the *note tp_dealloc: 29e1. handler in this
example, because our type doesn’t support garbage collection.  Even if a
type supports garbage collection, there are calls that can be made to
"untrack" the object from garbage collection, however, these calls are
advanced and not covered here.


File: python.info,  Node: Providing finer control over data attributes,  Next: Supporting cyclic garbage collection,  Prev: Adding data and methods to the Basic example,  Up: The Basics

6.2.1.2 Providing finer control over data attributes
....................................................

In this section, we’ll provide finer control over how the ‘first’ and
‘last’ attributes are set in the ‘Noddy’ example.  In the previous
version of our module, the instance variables ‘first’ and ‘last’ could
be set to non-string values or even deleted.  We want to make sure that
these attributes always contain strings.

     #include <Python.h>
     #include "structmember.h"

     typedef struct {
         PyObject_HEAD
         PyObject *first;
         PyObject *last;
         int number;
     } Noddy;

     static void
     Noddy_dealloc(Noddy* self)
     {
         Py_XDECREF(self->first);
         Py_XDECREF(self->last);
         self->ob_type->tp_free((PyObject*)self);
     }

     static PyObject *
     Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     {
         Noddy *self;

         self = (Noddy *)type->tp_alloc(type, 0);
         if (self != NULL) {
             self->first = PyString_FromString("");
             if (self->first == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->last = PyString_FromString("");
             if (self->last == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->number = 0;
         }

         return (PyObject *)self;
     }

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL, *tmp;

         static char *kwlist[] = {"first", "last", "number", NULL};

         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;

         if (first) {
             tmp = self->first;
             Py_INCREF(first);
             self->first = first;
             Py_DECREF(tmp);
         }

         if (last) {
             tmp = self->last;
             Py_INCREF(last);
             self->last = last;
             Py_DECREF(tmp);
         }

         return 0;
     }

     static PyMemberDef Noddy_members[] = {
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

     static PyObject *
     Noddy_getfirst(Noddy *self, void *closure)
     {
         Py_INCREF(self->first);
         return self->first;
     }

     static int
     Noddy_setfirst(Noddy *self, PyObject *value, void *closure)
     {
       if (value == NULL) {
         PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
         return -1;
       }

       if (! PyString_Check(value)) {
         PyErr_SetString(PyExc_TypeError,
                         "The first attribute value must be a string");
         return -1;
       }

       Py_DECREF(self->first);
       Py_INCREF(value);
       self->first = value;

       return 0;
     }

     static PyObject *
     Noddy_getlast(Noddy *self, void *closure)
     {
         Py_INCREF(self->last);
         return self->last;
     }

     static int
     Noddy_setlast(Noddy *self, PyObject *value, void *closure)
     {
       if (value == NULL) {
         PyErr_SetString(PyExc_TypeError, "Cannot delete the last attribute");
         return -1;
       }

       if (! PyString_Check(value)) {
         PyErr_SetString(PyExc_TypeError,
                         "The last attribute value must be a string");
         return -1;
       }

       Py_DECREF(self->last);
       Py_INCREF(value);
       self->last = value;

       return 0;
     }

     static PyGetSetDef Noddy_getseters[] = {
         {"first",
          (getter)Noddy_getfirst, (setter)Noddy_setfirst,
          "first name",
          NULL},
         {"last",
          (getter)Noddy_getlast, (setter)Noddy_setlast,
          "last name",
          NULL},
         {NULL}  /* Sentinel */
     };

     static PyObject *
     Noddy_name(Noddy* self)
     {
         static PyObject *format = NULL;
         PyObject *args, *result;

         if (format == NULL) {
             format = PyString_FromString("%s %s");
             if (format == NULL)
                 return NULL;
         }

         args = Py_BuildValue("OO", self->first, self->last);
         if (args == NULL)
             return NULL;

         result = PyString_Format(format, args);
         Py_DECREF(args);

         return result;
     }

     static PyMethodDef Noddy_methods[] = {
         {"name", (PyCFunction)Noddy_name, METH_NOARGS,
          "Return the name, combining the first and last name"
         },
         {NULL}  /* Sentinel */
     };

     static PyTypeObject NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(Noddy),             /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         (destructor)Noddy_dealloc, /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
         "Noddy objects",           /* tp_doc */
         0,		               /* tp_traverse */
         0,		               /* tp_clear */
         0,		               /* tp_richcompare */
         0,		               /* tp_weaklistoffset */
         0,		               /* tp_iter */
         0,		               /* tp_iternext */
         Noddy_methods,             /* tp_methods */
         Noddy_members,             /* tp_members */
         Noddy_getseters,           /* tp_getset */
         0,                         /* tp_base */
         0,                         /* tp_dict */
         0,                         /* tp_descr_get */
         0,                         /* tp_descr_set */
         0,                         /* tp_dictoffset */
         (initproc)Noddy_init,      /* tp_init */
         0,                         /* tp_alloc */
         Noddy_new,                 /* tp_new */
     };

     static PyMethodDef module_methods[] = {
         {NULL}  /* Sentinel */
     };

     #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
     #define PyMODINIT_FUNC void
     #endif
     PyMODINIT_FUNC
     initnoddy3(void)
     {
         PyObject* m;

         if (PyType_Ready(&NoddyType) < 0)
             return;

         m = Py_InitModule3("noddy3", module_methods,
                            "Example module that creates an extension type.");

         if (m == NULL)
           return;

         Py_INCREF(&NoddyType);
         PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
     }


  To provide greater control, over the ‘first’ and ‘last’ attributes,
we’ll use custom getter and setter functions.  Here are the functions
for getting and setting the ‘first’ attribute:

     Noddy_getfirst(Noddy *self, void *closure)
     {
         Py_INCREF(self->first);
         return self->first;
     }

     static int
     Noddy_setfirst(Noddy *self, PyObject *value, void *closure)
     {
       if (value == NULL) {
         PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
         return -1;
       }

       if (! PyString_Check(value)) {
         PyErr_SetString(PyExc_TypeError,
                         "The first attribute value must be a string");
         return -1;
       }

       Py_DECREF(self->first);
       Py_INCREF(value);
       self->first = value;

       return 0;
     }

  The getter function is passed a ‘Noddy’ object and a "closure", which
is void pointer.  In this case, the closure is ignored.  (The closure
supports an advanced usage in which definition data is passed to the
getter and setter.  This could, for example, be used to allow a single
set of getter and setter functions that decide the attribute to get or
set based on data in the closure.)

  The setter function is passed the ‘Noddy’ object, the new value, and
the closure.  The new value may be _NULL_, in which case the attribute
is being deleted.  In our setter, we raise an error if the attribute is
deleted or if the attribute value is not a string.

  We create an array of ‘PyGetSetDef’ structures:

     static PyGetSetDef Noddy_getseters[] = {
         {"first",
          (getter)Noddy_getfirst, (setter)Noddy_setfirst,
          "first name",
          NULL},
         {"last",
          (getter)Noddy_getlast, (setter)Noddy_setlast,
          "last name",
          NULL},
         {NULL}  /* Sentinel */
     };

  and register it in the *note tp_getset: 29eb. slot:

     Noddy_getseters,           /* tp_getset */

  to register our attribute getters and setters.

  The last item in a ‘PyGetSetDef’ structure is the closure mentioned
above.  In this case, we aren’t using the closure, so we just pass
_NULL_.

  We also remove the member definitions for these attributes:

     static PyMemberDef Noddy_members[] = {
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

  We also need to update the *note tp_init: 29e4. handler to only allow
strings (1) to be passed:

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL, *tmp;

         static char *kwlist[] = {"first", "last", "number", NULL};

         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|SSi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;

         if (first) {
             tmp = self->first;
             Py_INCREF(first);
             self->first = first;
             Py_DECREF(tmp);
         }

         if (last) {
             tmp = self->last;
             Py_INCREF(last);
             self->last = last;
             Py_DECREF(tmp);
         }

         return 0;
     }

  With these changes, we can assure that the ‘first’ and ‘last’ members
are never _NULL_ so we can remove checks for _NULL_ values in almost all
cases.  This means that most of the *note Py_XDECREF(): 29a0. calls can
be converted to *note Py_DECREF(): 29a1. calls.  The only place we can’t
change these calls is in the deallocator, where there is the possibility
that the initialization of these members failed in the constructor.

  We also rename the module initialization function and module name in
the initialization function, as we did before, and we add an extra
definition to the ‘setup.py’ file.

   ---------- Footnotes ----------

   (1) We now know that the first and last members are strings, so
perhaps we could be less careful about decrementing their reference
counts, however, we accept instances of string subclasses.  Even though
deallocating normal strings won’t call back into our objects, we can’t
guarantee that deallocating an instance of a string subclass won’t call
back into our objects.


File: python.info,  Node: Supporting cyclic garbage collection,  Next: Subclassing other types,  Prev: Providing finer control over data attributes,  Up: The Basics

6.2.1.3 Supporting cyclic garbage collection
............................................

Python has a cyclic-garbage collector that can identify unneeded objects
even when their reference counts are not zero.  This can happen when
objects are involved in cycles.  For example, consider:

     >>> l = []
     >>> l.append(l)
     >>> del l

  In this example, we create a list that contains itself.  When we
delete it, it still has a reference from itself.  Its reference count
doesn’t drop to zero.  Fortunately, Python’s cyclic-garbage collector
will eventually figure out that the list is garbage and free it.

  In the second version of the ‘Noddy’ example, we allowed any kind of
object to be stored in the ‘first’ or ‘last’ attributes.  (1) This means
that ‘Noddy’ objects can participate in cycles:

     >>> import noddy2
     >>> n = noddy2.Noddy()
     >>> l = [n]
     >>> n.first = l

  This is pretty silly, but it gives us an excuse to add support for the
cyclic-garbage collector to the ‘Noddy’ example.  To support cyclic
garbage collection, types need to fill two slots and set a class flag
that enables these slots:

     #include <Python.h>
     #include "structmember.h"

     typedef struct {
         PyObject_HEAD
         PyObject *first;
         PyObject *last;
         int number;
     } Noddy;

     static int
     Noddy_traverse(Noddy *self, visitproc visit, void *arg)
     {
         int vret;

         if (self->first) {
             vret = visit(self->first, arg);
             if (vret != 0)
                 return vret;
         }
         if (self->last) {
             vret = visit(self->last, arg);
             if (vret != 0)
                 return vret;
         }

         return 0;
     }

     static int
     Noddy_clear(Noddy *self)
     {
         PyObject *tmp;

         tmp = self->first;
         self->first = NULL;
         Py_XDECREF(tmp);

         tmp = self->last;
         self->last = NULL;
         Py_XDECREF(tmp);

         return 0;
     }

     static void
     Noddy_dealloc(Noddy* self)
     {
         Noddy_clear(self);
         self->ob_type->tp_free((PyObject*)self);
     }

     static PyObject *
     Noddy_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
     {
         Noddy *self;

         self = (Noddy *)type->tp_alloc(type, 0);
         if (self != NULL) {
             self->first = PyString_FromString("");
             if (self->first == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->last = PyString_FromString("");
             if (self->last == NULL)
               {
                 Py_DECREF(self);
                 return NULL;
               }

             self->number = 0;
         }

         return (PyObject *)self;
     }

     static int
     Noddy_init(Noddy *self, PyObject *args, PyObject *kwds)
     {
         PyObject *first=NULL, *last=NULL, *tmp;

         static char *kwlist[] = {"first", "last", "number", NULL};

         if (! PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                           &first, &last,
                                           &self->number))
             return -1;

         if (first) {
             tmp = self->first;
             Py_INCREF(first);
             self->first = first;
             Py_XDECREF(tmp);
         }

         if (last) {
             tmp = self->last;
             Py_INCREF(last);
             self->last = last;
             Py_XDECREF(tmp);
         }

         return 0;
     }


     static PyMemberDef Noddy_members[] = {
         {"first", T_OBJECT_EX, offsetof(Noddy, first), 0,
          "first name"},
         {"last", T_OBJECT_EX, offsetof(Noddy, last), 0,
          "last name"},
         {"number", T_INT, offsetof(Noddy, number), 0,
          "noddy number"},
         {NULL}  /* Sentinel */
     };

     static PyObject *
     Noddy_name(Noddy* self)
     {
         static PyObject *format = NULL;
         PyObject *args, *result;

         if (format == NULL) {
             format = PyString_FromString("%s %s");
             if (format == NULL)
                 return NULL;
         }

         if (self->first == NULL) {
             PyErr_SetString(PyExc_AttributeError, "first");
             return NULL;
         }

         if (self->last == NULL) {
             PyErr_SetString(PyExc_AttributeError, "last");
             return NULL;
         }

         args = Py_BuildValue("OO", self->first, self->last);
         if (args == NULL)
             return NULL;

         result = PyString_Format(format, args);
         Py_DECREF(args);

         return result;
     }

     static PyMethodDef Noddy_methods[] = {
         {"name", (PyCFunction)Noddy_name, METH_NOARGS,
          "Return the name, combining the first and last name"
         },
         {NULL}  /* Sentinel */
     };

     static PyTypeObject NoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                         /*ob_size*/
         "noddy.Noddy",             /*tp_name*/
         sizeof(Noddy),             /*tp_basicsize*/
         0,                         /*tp_itemsize*/
         (destructor)Noddy_dealloc, /*tp_dealloc*/
         0,                         /*tp_print*/
         0,                         /*tp_getattr*/
         0,                         /*tp_setattr*/
         0,                         /*tp_compare*/
         0,                         /*tp_repr*/
         0,                         /*tp_as_number*/
         0,                         /*tp_as_sequence*/
         0,                         /*tp_as_mapping*/
         0,                         /*tp_hash */
         0,                         /*tp_call*/
         0,                         /*tp_str*/
         0,                         /*tp_getattro*/
         0,                         /*tp_setattro*/
         0,                         /*tp_as_buffer*/
         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /*tp_flags*/
         "Noddy objects",           /* tp_doc */
         (traverseproc)Noddy_traverse,   /* tp_traverse */
         (inquiry)Noddy_clear,           /* tp_clear */
         0,		               /* tp_richcompare */
         0,		               /* tp_weaklistoffset */
         0,		               /* tp_iter */
         0,		               /* tp_iternext */
         Noddy_methods,             /* tp_methods */
         Noddy_members,             /* tp_members */
         0,                         /* tp_getset */
         0,                         /* tp_base */
         0,                         /* tp_dict */
         0,                         /* tp_descr_get */
         0,                         /* tp_descr_set */
         0,                         /* tp_dictoffset */
         (initproc)Noddy_init,      /* tp_init */
         0,                         /* tp_alloc */
         Noddy_new,                 /* tp_new */
     };

     static PyMethodDef module_methods[] = {
         {NULL}  /* Sentinel */
     };

     #ifndef PyMODINIT_FUNC	/* declarations for DLL import/export */
     #define PyMODINIT_FUNC void
     #endif
     PyMODINIT_FUNC
     initnoddy4(void)
     {
         PyObject* m;

         if (PyType_Ready(&NoddyType) < 0)
             return;

         m = Py_InitModule3("noddy4", module_methods,
                            "Example module that creates an extension type.");

         if (m == NULL)
           return;

         Py_INCREF(&NoddyType);
         PyModule_AddObject(m, "Noddy", (PyObject *)&NoddyType);
     }


  The traversal method provides access to subobjects that could
participate in cycles:

     static int
     Noddy_traverse(Noddy *self, visitproc visit, void *arg)
     {
         int vret;

         if (self->first) {
             vret = visit(self->first, arg);
             if (vret != 0)
                 return vret;
         }
         if (self->last) {
             vret = visit(self->last, arg);
             if (vret != 0)
                 return vret;
         }

         return 0;
     }

  For each subobject that can participate in cycles, we need to call the
‘visit()’ function, which is passed to the traversal method.  The
‘visit()’ function takes as arguments the subobject and the extra
argument _arg_ passed to the traversal method.  It returns an integer
value that must be returned if it is non-zero.

  Python 2.4 and higher provide a *note Py_VISIT(): 29ed. macro that
automates calling visit functions.  With *note Py_VISIT(): 29ed,
‘Noddy_traverse()’ can be simplified:

     static int
     Noddy_traverse(Noddy *self, visitproc visit, void *arg)
     {
         Py_VISIT(self->first);
         Py_VISIT(self->last);
         return 0;
     }

     Note: Note that the *note tp_traverse: 242a. implementation must
     name its arguments exactly _visit_ and _arg_ in order to use *note
     Py_VISIT(): 29ed.  This is to encourage uniformity across these
     boring implementations.

  We also need to provide a method for clearing any subobjects that can
participate in cycles.  We implement the method and reimplement the
deallocator to use it:

     static int
     Noddy_clear(Noddy *self)
     {
         PyObject *tmp;

         tmp = self->first;
         self->first = NULL;
         Py_XDECREF(tmp);

         tmp = self->last;
         self->last = NULL;
         Py_XDECREF(tmp);

         return 0;
     }

     static void
     Noddy_dealloc(Noddy* self)
     {
         Noddy_clear(self);
         self->ob_type->tp_free((PyObject*)self);
     }

  Notice the use of a temporary variable in ‘Noddy_clear()’.  We use the
temporary variable so that we can set each member to _NULL_ before
decrementing its reference count.  We do this because, as was discussed
earlier, if the reference count drops to zero, we might cause code to
run that calls back into the object.  In addition, because we now
support garbage collection, we also have to worry about code being run
that triggers garbage collection.  If garbage collection is run, our
*note tp_traverse: 242a. handler could get called.  We can’t take a
chance of having ‘Noddy_traverse()’ called when a member’s reference
count has dropped to zero and its value hasn’t been set to _NULL_.

  Python 2.4 and higher provide a *note Py_CLEAR(): 29ee. that automates
the careful decrementing of reference counts.  With *note Py_CLEAR():
29ee, the ‘Noddy_clear()’ function can be simplified:

     static int
     Noddy_clear(Noddy *self)
     {
         Py_CLEAR(self->first);
         Py_CLEAR(self->last);
         return 0;
     }

  Finally, we add the *note Py_TPFLAGS_HAVE_GC: 29ef. flag to the class
flags:

     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, /*tp_flags*/

  That’s pretty much it.  If we had written custom *note tp_alloc: 29e3.
or *note tp_free: 29e2. slots, we’d need to modify them for
cyclic-garbage collection.  Most extensions will use the versions
automatically provided.

   ---------- Footnotes ----------

   (1) Even in the third version, we aren’t guaranteed to avoid cycles.
Instances of string subclasses are allowed and string subclasses could
allow cycles even if normal strings don’t.


File: python.info,  Node: Subclassing other types,  Prev: Supporting cyclic garbage collection,  Up: The Basics

6.2.1.4 Subclassing other types
...............................

It is possible to create new extension types that are derived from
existing types.  It is easiest to inherit from the built in types, since
an extension can easily use the ‘PyTypeObject’ it needs.  It can be
difficult to share these ‘PyTypeObject’ structures between extension
modules.

  In this example we will create a ‘Shoddy’ type that inherits from the
built-in *note list: 3bc. type.  The new type will be completely
compatible with regular lists, but will have an additional ‘increment()’
method that increases an internal counter.

     >>> import shoddy
     >>> s = shoddy.Shoddy(range(3))
     >>> s.extend(s)
     >>> print len(s)
     6
     >>> print s.increment()
     1
     >>> print s.increment()
     2

     #include <Python.h>

     typedef struct {
         PyListObject list;
         int state;
     } Shoddy;


     static PyObject *
     Shoddy_increment(Shoddy *self, PyObject *unused)
     {
         self->state++;
         return PyInt_FromLong(self->state);
     }


     static PyMethodDef Shoddy_methods[] = {
         {"increment", (PyCFunction)Shoddy_increment, METH_NOARGS,
          PyDoc_STR("increment state counter")},
         {NULL,	NULL},
     };

     static int
     Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds)
     {
         if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)
             return -1;
         self->state = 0;
         return 0;
     }


     static PyTypeObject ShoddyType = {
         PyObject_HEAD_INIT(NULL)
         0,                       /* ob_size */
         "shoddy.Shoddy",         /* tp_name */
         sizeof(Shoddy),          /* tp_basicsize */
         0,                       /* tp_itemsize */
         0,                       /* tp_dealloc */
         0,                       /* tp_print */
         0,                       /* tp_getattr */
         0,                       /* tp_setattr */
         0,                       /* tp_compare */
         0,                       /* tp_repr */
         0,                       /* tp_as_number */
         0,                       /* tp_as_sequence */
         0,                       /* tp_as_mapping */
         0,                       /* tp_hash */
         0,                       /* tp_call */
         0,                       /* tp_str */
         0,                       /* tp_getattro */
         0,                       /* tp_setattro */
         0,                       /* tp_as_buffer */
         Py_TPFLAGS_DEFAULT |
           Py_TPFLAGS_BASETYPE,   /* tp_flags */
         0,                       /* tp_doc */
         0,                       /* tp_traverse */
         0,                       /* tp_clear */
         0,                       /* tp_richcompare */
         0,                       /* tp_weaklistoffset */
         0,                       /* tp_iter */
         0,                       /* tp_iternext */
         Shoddy_methods,          /* tp_methods */
         0,                       /* tp_members */
         0,                       /* tp_getset */
         0,                       /* tp_base */
         0,                       /* tp_dict */
         0,                       /* tp_descr_get */
         0,                       /* tp_descr_set */
         0,                       /* tp_dictoffset */
         (initproc)Shoddy_init,   /* tp_init */
         0,                       /* tp_alloc */
         0,                       /* tp_new */
     };

     PyMODINIT_FUNC
     initshoddy(void)
     {
         PyObject *m;

         ShoddyType.tp_base = &PyList_Type;
         if (PyType_Ready(&ShoddyType) < 0)
             return;

         m = Py_InitModule3("shoddy", NULL, "Shoddy module");
         if (m == NULL)
             return;

         Py_INCREF(&ShoddyType);
         PyModule_AddObject(m, "Shoddy", (PyObject *) &ShoddyType);
     }


  As you can see, the source code closely resembles the ‘Noddy’ examples
in previous sections.  We will break down the main differences between
them.

     typedef struct {
         PyListObject list;
         int state;
     } Shoddy;

  The primary difference for derived type objects is that the base
type’s object structure must be the first value.  The base type will
already include the *note PyObject_HEAD(): 29f1. at the beginning of its
structure.

  When a Python object is a ‘Shoddy’ instance, its _PyObject*_ pointer
can be safely cast to both _PyListObject*_ and _Shoddy*_.

     static int
     Shoddy_init(Shoddy *self, PyObject *args, PyObject *kwds)
     {
         if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)
            return -1;
         self->state = 0;
         return 0;
     }

  In the ‘__init__’ method for our type, we can see how to call through
to the ‘__init__’ method of the base type.

  This pattern is important when writing a type with custom *note new:
122. and ‘dealloc’ methods.  The *note new: 122. method should not
actually create the memory for the object with *note tp_alloc: 29e3,
that will be handled by the base class when calling its *note tp_new:
29de.

  When filling out the *note PyTypeObject(): 29d9. for the ‘Shoddy’
type, you see a slot for ‘tp_base()’.  Due to cross platform compiler
issues, you can’t fill that field directly with the *note PyList_Type():
29f2.; it can be done later in the module’s ‘init()’ function.

     PyMODINIT_FUNC
     initshoddy(void)
     {
         PyObject *m;

         ShoddyType.tp_base = &PyList_Type;
         if (PyType_Ready(&ShoddyType) < 0)
             return;

         m = Py_InitModule3("shoddy", NULL, "Shoddy module");
         if (m == NULL)
             return;

         Py_INCREF(&ShoddyType);
         PyModule_AddObject(m, "Shoddy", (PyObject *) &ShoddyType);
     }

  Before calling *note PyType_Ready(): 29da, the type structure must
have the *note tp_base: 29f3. slot filled in.  When we are deriving a
new type, it is not necessary to fill out the *note tp_alloc: 29e3. slot
with *note PyType_GenericNew(): 29df. – the allocate function from the
base type will be inherited.

  After that, calling *note PyType_Ready(): 29da. and adding the type
object to the module is the same as with the basic ‘Noddy’ examples.


File: python.info,  Node: Type Methods,  Prev: The Basics,  Up: Defining New Types

6.2.2 Type Methods
------------------

This section aims to give a quick fly-by on the various type methods you
can implement and what they do.

  Here is the definition of *note PyTypeObject: 29d9, with some fields
only used in debug builds omitted:

     typedef struct _typeobject {
         PyObject_VAR_HEAD
         char *tp_name; /* For printing, in format "<module>.<name>" */
         int tp_basicsize, tp_itemsize; /* For allocation */

         /* Methods to implement standard operations */

         destructor tp_dealloc;
         printfunc tp_print;
         getattrfunc tp_getattr;
         setattrfunc tp_setattr;
         cmpfunc tp_compare;
         reprfunc tp_repr;

         /* Method suites for standard classes */

         PyNumberMethods *tp_as_number;
         PySequenceMethods *tp_as_sequence;
         PyMappingMethods *tp_as_mapping;

         /* More standard operations (here for binary compatibility) */

         hashfunc tp_hash;
         ternaryfunc tp_call;
         reprfunc tp_str;
         getattrofunc tp_getattro;
         setattrofunc tp_setattro;

         /* Functions to access object as input/output buffer */
         PyBufferProcs *tp_as_buffer;

         /* Flags to define presence of optional/expanded features */
         long tp_flags;

         char *tp_doc; /* Documentation string */

         /* Assigned meaning in release 2.0 */
         /* call function for all accessible objects */
         traverseproc tp_traverse;

         /* delete references to contained objects */
         inquiry tp_clear;

         /* Assigned meaning in release 2.1 */
         /* rich comparisons */
         richcmpfunc tp_richcompare;

         /* weak reference enabler */
         long tp_weaklistoffset;

         /* Added in release 2.2 */
         /* Iterators */
         getiterfunc tp_iter;
         iternextfunc tp_iternext;

         /* Attribute descriptor and subclassing stuff */
         struct PyMethodDef *tp_methods;
         struct PyMemberDef *tp_members;
         struct PyGetSetDef *tp_getset;
         struct _typeobject *tp_base;
         PyObject *tp_dict;
         descrgetfunc tp_descr_get;
         descrsetfunc tp_descr_set;
         long tp_dictoffset;
         initproc tp_init;
         allocfunc tp_alloc;
         newfunc tp_new;
         freefunc tp_free; /* Low-level free-memory routine */
         inquiry tp_is_gc; /* For PyObject_IS_GC */
         PyObject *tp_bases;
         PyObject *tp_mro; /* method resolution order */
         PyObject *tp_cache;
         PyObject *tp_subclasses;
         PyObject *tp_weaklist;

     } PyTypeObject;


  Now that’s a _lot_ of methods.  Don’t worry too much though - if you
have a type you want to define, the chances are very good that you will
only implement a handful of these.

  As you probably expect by now, we’re going to go over this and give
more information about the various handlers.  We won’t go in the order
they are defined in the structure, because there is a lot of historical
baggage that impacts the ordering of the fields; be sure your type
initialization keeps the fields in the right order!  It’s often easiest
to find an example that includes all the fields you need (even if
they’re initialized to ‘0’) and then change the values to suit your new
type.

     char *tp_name; /* For printing */

  The name of the type - as mentioned in the last section, this will
appear in various places, almost entirely for diagnostic purposes.  Try
to choose something that will be helpful in such a situation!

     int tp_basicsize, tp_itemsize; /* For allocation */

  These fields tell the runtime how much memory to allocate when new
objects of this type are created.  Python has some built-in support for
variable length structures (think: strings, lists) which is where the
*note tp_itemsize: 29f6. field comes in.  This will be dealt with later.

     char *tp_doc;

  Here you can put a string (or its address) that you want returned when
the Python script references ‘obj.__doc__’ to retrieve the doc string.

  Now we come to the basic type methods—the ones most extension types
will implement.

* Menu:

* Finalization and De-allocation:: 
* Object Presentation:: 
* Attribute Management:: 
* Object Comparison:: 
* Abstract Protocol Support:: 
* Weak Reference Support:: 
* More Suggestions:: 


File: python.info,  Node: Finalization and De-allocation,  Next: Object Presentation,  Up: Type Methods

6.2.2.1 Finalization and De-allocation
......................................

     destructor tp_dealloc;

  This function is called when the reference count of the instance of
your type is reduced to zero and the Python interpreter wants to reclaim
it.  If your type has memory to free or other clean-up to perform, put
it here.  The object itself needs to be freed here as well.  Here is an
example of this function:

     static void
     newdatatype_dealloc(newdatatypeobject * obj)
     {
         free(obj->obj_UnderlyingDatatypePtr);
         obj->ob_type->tp_free(obj);
     }

  One important requirement of the deallocator function is that it
leaves any pending exceptions alone.  This is important since
deallocators are frequently called as the interpreter unwinds the Python
stack; when the stack is unwound due to an exception (rather than normal
returns), nothing is done to protect the deallocators from seeing that
an exception has already been set.  Any actions which a deallocator
performs which may cause additional Python code to be executed may
detect that an exception has been set.  This can lead to misleading
errors from the interpreter.  The proper way to protect against this is
to save a pending exception before performing the unsafe action, and
restoring it when done.  This can be done using the *note PyErr_Fetch():
29f8. and *note PyErr_Restore(): 29f9. functions:

     static void
     my_dealloc(PyObject *obj)
     {
         MyObject *self = (MyObject *) obj;
         PyObject *cbresult;

         if (self->my_callback != NULL) {
             PyObject *err_type, *err_value, *err_traceback;
             int have_error = PyErr_Occurred() ? 1 : 0;

             if (have_error)
                 PyErr_Fetch(&err_type, &err_value, &err_traceback);

             cbresult = PyObject_CallObject(self->my_callback, NULL);
             if (cbresult == NULL)
                 PyErr_WriteUnraisable(self->my_callback);
             else
                 Py_DECREF(cbresult);

             if (have_error)
                 PyErr_Restore(err_type, err_value, err_traceback);

             Py_DECREF(self->my_callback);
         }
         obj->ob_type->tp_free((PyObject*)self);
     }


File: python.info,  Node: Object Presentation,  Next: Attribute Management,  Prev: Finalization and De-allocation,  Up: Type Methods

6.2.2.2 Object Presentation
...........................

In Python, there are three ways to generate a textual representation of
an object: the *note repr(): 145. function (or equivalent back-tick
syntax), the *note str(): 1ea. function, and the *note print: 4e0.
statement.  For most objects, the *note print: 4e0. statement is
equivalent to the *note str(): 1ea. function, but it is possible to
special-case printing to a ‘FILE*’ if necessary; this should only be
done if efficiency is identified as a problem and profiling suggests
that creating a temporary string object to be written to a file is too
expensive.

  These handlers are all optional, and most types at most need to
implement the *note tp_str: 29fb. and *note tp_repr: 29fc. handlers.

     reprfunc tp_repr;
     reprfunc tp_str;
     printfunc tp_print;

  The *note tp_repr: 29fc. handler should return a string object
containing a representation of the instance for which it is called.
Here is a simple example:

     static PyObject *
     newdatatype_repr(newdatatypeobject * obj)
     {
         return PyString_FromFormat("Repr-ified_newdatatype{{size:\%d}}",
                                    obj->obj_UnderlyingDatatypePtr->size);
     }

  If no *note tp_repr: 29fc. handler is specified, the interpreter will
supply a representation that uses the type’s *note tp_name: 29fd. and a
uniquely-identifying value for the object.

  The *note tp_str: 29fb. handler is to *note str(): 1ea. what the *note
tp_repr: 29fc. handler described above is to *note repr(): 145.; that
is, it is called when Python code calls *note str(): 1ea. on an instance
of your object.  Its implementation is very similar to the *note
tp_repr: 29fc. function, but the resulting string is intended for human
consumption.  If *note tp_str: 29fb. is not specified, the *note
tp_repr: 29fc. handler is used instead.

  Here is a simple example:

     static PyObject *
     newdatatype_str(newdatatypeobject * obj)
     {
         return PyString_FromFormat("Stringified_newdatatype{{size:\%d}}",
                                    obj->obj_UnderlyingDatatypePtr->size);
     }

  The print function will be called whenever Python needs to "print" an
instance of the type.  For example, if ’node’ is an instance of type
TreeNode, then the print function is called when Python code calls:

     print node

  There is a flags argument and one flag, ‘Py_PRINT_RAW’, and it
suggests that you print without string quotes and possibly without
interpreting escape sequences.

  The print function receives a file object as an argument.  You will
likely want to write to that file object.

  Here is a sample print function:

     static int
     newdatatype_print(newdatatypeobject *obj, FILE *fp, int flags)
     {
         if (flags & Py_PRINT_RAW) {
             fprintf(fp, "<{newdatatype object--size: %d}>",
                     obj->obj_UnderlyingDatatypePtr->size);
         }
         else {
             fprintf(fp, "\"<{newdatatype object--size: %d}>\"",
                     obj->obj_UnderlyingDatatypePtr->size);
         }
         return 0;
     }


File: python.info,  Node: Attribute Management,  Next: Object Comparison,  Prev: Object Presentation,  Up: Type Methods

6.2.2.3 Attribute Management
............................

For every object which can support attributes, the corresponding type
must provide the functions that control how the attributes are resolved.
There needs to be a function which can retrieve attributes (if any are
defined), and another to set attributes (if setting attributes is
allowed).  Removing an attribute is a special case, for which the new
value passed to the handler is _NULL_.

  Python supports two pairs of attribute handlers; a type that supports
attributes only needs to implement the functions for one pair.  The
difference is that one pair takes the name of the attribute as a
‘char*’, while the other accepts a *note PyObject*: 3a6.  Each type can
use whichever pair makes more sense for the implementation’s
convenience.

     getattrfunc  tp_getattr;        /* char * version */
     setattrfunc  tp_setattr;
     /* ... */
     getattrofunc tp_getattrofunc;   /* PyObject * version */
     setattrofunc tp_setattrofunc;

  If accessing attributes of an object is always a simple operation
(this will be explained shortly), there are generic implementations
which can be used to provide the *note PyObject*: 3a6. version of the
attribute management functions.  The actual need for type-specific
attribute handlers almost completely disappeared starting with Python
2.2, though there are many examples which have not been updated to use
some of the new generic mechanism that is available.

* Menu:

* Generic Attribute Management:: 
* Type-specific Attribute Management:: 


File: python.info,  Node: Generic Attribute Management,  Next: Type-specific Attribute Management,  Up: Attribute Management

6.2.2.4 Generic Attribute Management
....................................

New in version 2.2.

  Most extension types only use _simple_ attributes.  So, what makes the
attributes simple?  There are only a couple of conditions that must be
met:

  1. The name of the attributes must be known when *note PyType_Ready():
     29da. is called.

  2. No special processing is needed to record that an attribute was
     looked up or set, nor do actions need to be taken based on the
     value.

  Note that this list does not place any restrictions on the values of
the attributes, when the values are computed, or how relevant data is
stored.

  When *note PyType_Ready(): 29da. is called, it uses three tables
referenced by the type object to create *note descriptor: 1529.s which
are placed in the dictionary of the type object.  Each descriptor
controls access to one attribute of the instance object.  Each of the
tables is optional; if all three are _NULL_, instances of the type will
only have attributes that are inherited from their base type, and should
leave the *note tp_getattro: 2a00. and *note tp_setattro: 2a01. fields
_NULL_ as well, allowing the base type to handle attributes.

  The tables are declared as three fields of the type object:

     struct PyMethodDef *tp_methods;
     struct PyMemberDef *tp_members;
     struct PyGetSetDef *tp_getset;

  If *note tp_methods: 29e7. is not _NULL_, it must refer to an array of
*note PyMethodDef: 472. structures.  Each entry in the table is an
instance of this structure:

     typedef struct PyMethodDef {
         char        *ml_name;       /* method name */
         PyCFunction  ml_meth;       /* implementation function */
         int          ml_flags;      /* flags */
         char        *ml_doc;        /* docstring */
     } PyMethodDef;

  One entry should be defined for each method provided by the type; no
entries are needed for methods inherited from a base type.  One
additional entry is needed at the end; it is a sentinel that marks the
end of the array.  The ‘ml_name’ field of the sentinel must be _NULL_.

  XXX Need to refer to some unified discussion of the structure fields,
shared with the next section.

  The second table is used to define attributes which map directly to
data stored in the instance.  A variety of primitive C types are
supported, and access may be read-only or read-write.  The structures in
the table are defined as:

     typedef struct PyMemberDef {
         char *name;
         int   type;
         int   offset;
         int   flags;
         char *doc;
     } PyMemberDef;

  For each entry in the table, a *note descriptor: 1529. will be
constructed and added to the type which will be able to extract a value
from the instance structure.  The *note type: 490. field should contain
one of the type codes defined in the ‘structmember.h’ header; the value
will be used to determine how to convert Python values to and from C
values.  The ‘flags’ field is used to store flags which control how the
attribute can be accessed.

  XXX Need to move some of this to a shared section!

  The following flag constants are defined in ‘structmember.h’; they may
be combined using bitwise-OR.

Constant                        Meaning
                                
-----------------------------------------------------------------------------------
                                
‘READONLY’                      Never writable.
                                
                                
‘RO’                            Shorthand for ‘READONLY’.
                                
                                
‘READ_RESTRICTED’               Not readable in restricted mode.
                                
                                
‘WRITE_RESTRICTED’              Not writable in restricted mode.
                                
                                
‘RESTRICTED’                    Not readable or writable in restricted mode.
                                

  An interesting advantage of using the *note tp_members: 29e5. table to
build descriptors that are used at runtime is that any attribute defined
this way can have an associated doc string simply by providing the text
in the table.  An application can use the introspection API to retrieve
the descriptor from the class object, and get the doc string using its
‘__doc__’ attribute.

  As with the *note tp_methods: 29e7. table, a sentinel entry with a
‘name’ value of _NULL_ is required.


File: python.info,  Node: Type-specific Attribute Management,  Prev: Generic Attribute Management,  Up: Attribute Management

6.2.2.5 Type-specific Attribute Management
..........................................

For simplicity, only the ‘char*’ version will be demonstrated here; the
type of the name parameter is the only difference between the ‘char*’
and *note PyObject*: 3a6. flavors of the interface.  This example
effectively does the same thing as the generic example above, but does
not use the generic support added in Python 2.2.  The value in showing
this is two-fold: it demonstrates how basic attribute management can be
done in a way that is portable to older versions of Python, and explains
how the handler functions are called, so that if you do need to extend
their functionality, you’ll understand what needs to be done.

  The *note tp_getattr: 2a03. handler is called when the object requires
an attribute look-up.  It is called in the same situations where the
*note __getattr__(): 331. method of a class would be called.

  A likely way to handle this is (1) to implement a set of functions
(such as ‘newdatatype_getSize()’ and ‘newdatatype_setSize()’ in the
example below), (2) provide a method table listing these functions, and
(3) provide a getattr function that returns the result of a lookup in
that table.  The method table uses the same structure as the *note
tp_methods: 29e7. field of the type object.

  Here is an example:

     static PyMethodDef newdatatype_methods[] = {
         {"getSize", (PyCFunction)newdatatype_getSize, METH_VARARGS,
          "Return the current size."},
         {"setSize", (PyCFunction)newdatatype_setSize, METH_VARARGS,
          "Set the size."},
         {NULL, NULL, 0, NULL}           /* sentinel */
     };

     static PyObject *
     newdatatype_getattr(newdatatypeobject *obj, char *name)
     {
         return Py_FindMethod(newdatatype_methods, (PyObject *)obj, name);
     }

  The *note tp_setattr: 2a04. handler is called when the *note
__setattr__(): 488. or *note __delattr__(): 6fd. method of a class
instance would be called.  When an attribute should be deleted, the
third parameter will be _NULL_. Here is an example that simply raises an
exception; if this were really all you wanted, the *note tp_setattr:
2a04. handler should be set to _NULL_.

     static int
     newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)
     {
         (void)PyErr_Format(PyExc_RuntimeError, "Read-only attribute: \%s", name);
         return -1;
     }

