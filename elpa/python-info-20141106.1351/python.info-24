This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: Distributing Python Modules,  Next: Installing Python Modules,  Prev: Python/C API Reference Manual,  Up: Top

8 Distributing Python Modules
*****************************

     Authors: Greg Ward, Anthony Baxter

     Email: <distutils-sig@python.org>

  This document describes the Python Distribution Utilities
("Distutils") from the module developer’s point of view, describing how
to use the Distutils to make Python modules and extensions easily
available to a wider audience with very little overhead for
build/release/install mechanics.

     Note: This guide only covers the basic tools for building and
     distributing extensions that are provided as part of this version
     of Python.  Third party tools offer easier to use and more secure
     alternatives.  Refer to the quick recommendations section(1) in the
     Python Packaging User Guide for more information.

* Menu:

* An Introduction to Distutils:: 
* Writing the Setup Script:: 
* Writing the Setup Configuration File:: 
* Creating a Source Distribution:: 
* Creating Built Distributions:: 
* The Python Package Index (PyPI): The Python Package Index PyPI. 
* Examples: Examples<24>. 
* Extending Distutils:: 
* Command Reference:: 
* API Reference:: 

An Introduction to Distutils

* Concepts & Terminology:: 
* A Simple Example: A Simple Example<2>. 
* General Python terminology:: 
* Distutils-specific terminology:: 

Writing the Setup Script

* Listing whole packages:: 
* Listing individual modules:: 
* Describing extension modules:: 
* Relationships between Distributions and Packages:: 
* Installing Scripts:: 
* Installing Package Data:: 
* Installing Additional Files:: 
* Additional meta-data:: 
* Debugging the setup script:: 

Describing extension modules

* Extension names and packages:: 
* Extension source files:: 
* Preprocessor options:: 
* Library options:: 
* Other options:: 

Creating a Source Distribution

* Specifying the files to distribute:: 
* Manifest-related options:: 
* The MANIFEST.in template: The MANIFEST in template. 

The MANIFEST.in template

* Principle:: 
* Commands:: 

Creating Built Distributions

* Creating dumb built distributions:: 
* Creating RPM packages:: 
* Creating Windows Installers:: 
* Cross-compiling on Windows:: 
* Vista User Access Control (UAC): Vista User Access Control UAC. 

Cross-compiling on Windows

* The Postinstallation script:: 

The Python Package Index (PyPI)

* Registering Packages:: 
* Uploading Packages:: 
* The .pypirc file: The pypirc file. 
* PyPI package display:: 

Examples

* Pure Python distribution (by module): Pure Python distribution by module. 
* Pure Python distribution (by package): Pure Python distribution by package. 
* Single extension module:: 

Extending Distutils

* Integrating new commands:: 
* Adding new distribution types:: 

Command Reference

* Installing modules; the install command family: Installing modules the install command family. 

Installing modules: the install command family

* install_data:: 
* install_scripts:: 

API Reference

* distutils.core: distutils core --- Core Distutils functionality. Core Distutils functionality
* distutils.ccompiler: distutils ccompiler --- CCompiler base class. CCompiler base class
* distutils.unixccompiler: distutils unixccompiler --- Unix C Compiler. Unix C Compiler
* distutils.msvccompiler: distutils msvccompiler --- Microsoft Compiler. Microsoft Compiler
* distutils.bcppcompiler: distutils bcppcompiler --- Borland Compiler. Borland Compiler
* distutils.cygwincompiler: distutils cygwincompiler --- Cygwin Compiler. Cygwin Compiler
* distutils.emxccompiler: distutils emxccompiler --- OS/2 EMX Compiler. OS/2 EMX Compiler
* distutils.archive_util: distutils archive_util --- Archiving utilities. Archiving utilities
* distutils.dep_util: distutils dep_util --- Dependency checking. Dependency checking
* distutils.dir_util: distutils dir_util --- Directory tree operations. Directory tree operations
* distutils.file_util: distutils file_util --- Single file operations. Single file operations
* distutils.util: distutils util --- Miscellaneous other utility functions. Miscellaneous other utility functions
* distutils.dist: distutils dist --- The Distribution class. The Distribution class
* distutils.extension: distutils extension --- The Extension class. The Extension class
* distutils.debug: distutils debug --- Distutils debug mode. Distutils debug mode
* distutils.errors: distutils errors --- Distutils exceptions. Distutils exceptions
* distutils.fancy_getopt: distutils fancy_getopt --- Wrapper around the standard getopt module. Wrapper around the standard getopt module
* distutils.filelist: distutils filelist --- The FileList class. The FileList class
* distutils.log: distutils log --- Simple PEP 282-style logging. Simple PEP 282-style logging
* distutils.spawn: distutils spawn --- Spawn a sub-process. Spawn a sub-process
* distutils.sysconfig: distutils sysconfig --- System configuration information. System configuration information
* distutils.text_file: distutils text_file --- The TextFile class. The TextFile class
* distutils.version: distutils version --- Version number classes. Version number classes
* distutils.cmd: distutils cmd --- Abstract base class for Distutils commands. Abstract base class for Distutils commands
* Creating a new Distutils command:: 
* distutils.command: distutils command --- Individual Distutils commands. Individual Distutils commands
* distutils.command.bdist: distutils command bdist --- Build a binary installer. Build a binary installer
* distutils.command.bdist_packager: distutils command bdist_packager --- Abstract base class for packagers. Abstract base class for packagers
* distutils.command.bdist_dumb: distutils command bdist_dumb --- Build a "dumb" installer. Build a "dumb" installer
* distutils.command.bdist_msi: distutils command bdist_msi --- Build a Microsoft Installer binary package. Build a Microsoft Installer binary package
* distutils.command.bdist_rpm: distutils command bdist_rpm --- Build a binary distribution as a Redhat RPM and SRPM. Build a binary distribution as a Redhat RPM and
                               SRPM
* distutils.command.bdist_wininst: distutils command bdist_wininst --- Build a Windows installer. Build a Windows installer
* distutils.command.sdist: distutils command sdist --- Build a source distribution. Build a source distribution
* distutils.command.build: distutils command build --- Build all files of a package. Build all files of a package
* distutils.command.build_clib: distutils command build_clib --- Build any C libraries in a package. Build any C libraries in a package
* distutils.command.build_ext: distutils command build_ext --- Build any extensions in a package. Build any extensions in a package
* distutils.command.build_py: distutils command build_py --- Build the py/ pyc files of a package. Build the .py/.pyc files of a package
* distutils.command.build_scripts: distutils command build_scripts --- Build the scripts of a package. Build the scripts of a package
* distutils.command.clean: distutils command clean --- Clean a package build area. Clean a package build area
* distutils.command.config: distutils command config --- Perform package configuration. Perform package configuration
* distutils.command.install: distutils command install --- Install a package. Install a package
* distutils.command.install_data: distutils command install_data --- Install data files from a package. Install data files from a package
* distutils.command.install_headers: distutils command install_headers --- Install C/C++ header files from a package. Install C/C++ header files from a package
* distutils.command.install_lib: distutils command install_lib --- Install library files from a package. Install library files from a package
* distutils.command.install_scripts: distutils command install_scripts --- Install script files from a package. Install script files from a package
* distutils.command.register: distutils command register --- Register a module with the Python Package Index. Register a module with the Python Package Index
* distutils.command.check: distutils command check --- Check the meta-data of a package. Check the meta-data of a package

   ---------- Footnotes ----------

   (1) 
https://python-packaging-user-guide.readthedocs.org/en/latest/current.html


File: python.info,  Node: An Introduction to Distutils,  Next: Writing the Setup Script,  Up: Distributing Python Modules

8.1 An Introduction to Distutils
================================

This document covers using the Distutils to distribute your Python
modules, concentrating on the role of developer/distributor: if you’re
looking for information on installing Python modules, you should refer
to the *note Installing Python Modules: 617. chapter.

* Menu:

* Concepts & Terminology:: 
* A Simple Example: A Simple Example<2>. 
* General Python terminology:: 
* Distutils-specific terminology:: 


File: python.info,  Node: Concepts & Terminology,  Next: A Simple Example<2>,  Up: An Introduction to Distutils

8.1.1 Concepts & Terminology
----------------------------

Using the Distutils is quite simple, both for module developers and for
users/administrators installing third-party modules.  As a developer,
your responsibilities (apart from writing solid, well-documented and
well-tested code, of course!)  are:

   * write a setup script (‘setup.py’ by convention)

   * (optional) write a setup configuration file

   * create a source distribution

   * (optional) create one or more built (binary) distributions

  Each of these tasks is covered in this document.

  Not all module developers have access to a multitude of platforms, so
it’s not always feasible to expect them to create a multitude of built
distributions.  It is hoped that a class of intermediaries, called
_packagers_, will arise to address this need.  Packagers will take
source distributions released by module developers, build them on one or
more platforms, and release the resulting built distributions.  Thus,
users on the most popular platforms will be able to install most popular
Python module distributions in the most natural way for their platform,
without having to run a single setup script or compile a line of code.


File: python.info,  Node: A Simple Example<2>,  Next: General Python terminology,  Prev: Concepts & Terminology,  Up: An Introduction to Distutils

8.1.2 A Simple Example
----------------------

The setup script is usually quite simple, although since it’s written in
Python, there are no arbitrary limits to what you can do with it, though
you should be careful about putting arbitrarily expensive operations in
your setup script.  Unlike, say, Autoconf-style configure scripts, the
setup script may be run multiple times in the course of building and
installing your module distribution.

  If all you want to do is distribute a module called ‘foo’, contained
in a file ‘foo.py’, then your setup script can be as simple as this:

     from distutils.core import setup
     setup(name='foo',
           version='1.0',
           py_modules=['foo'],
           )

  Some observations:

   * most information that you supply to the Distutils is supplied as
     keyword arguments to the ‘setup()’ function

   * those keyword arguments fall into two categories: package metadata
     (name, version number) and information about what’s in the package
     (a list of pure Python modules, in this case)

   * modules are specified by module name, not filename (the same will
     hold true for packages and extensions)

   * it’s recommended that you supply a little more metadata, in
     particular your name, email address and a URL for the project (see
     section *note Writing the Setup Script: 2e7c. for an example)

  To create a source distribution for this module, you would create a
setup script, ‘setup.py’, containing the above code, and run this
command from a terminal:

     python setup.py sdist

  For Windows, open a command prompt windows (_Start ‣ Accessories_) and
change the command to:

     setup.py sdist

  *sdist* will create an archive file (e.g., tarball on Unix, ZIP file
on Windows) containing your setup script ‘setup.py’, and your module
‘foo.py’.  The archive file will be named ‘foo-1.0.tar.gz’ (or ‘.zip’),
and will unpack into a directory ‘foo-1.0’.

  If an end-user wishes to install your ‘foo’ module, all she has to do
is download ‘foo-1.0.tar.gz’ (or ‘.zip’), unpack it, and—from the
‘foo-1.0’ directory—run

     python setup.py install

  which will ultimately copy ‘foo.py’ to the appropriate directory for
third-party modules in their Python installation.

  This simple example demonstrates some fundamental concepts of the
Distutils.  First, both developers and installers have the same basic
user interface, i.e.  the setup script.  The difference is which
Distutils _commands_ they use: the *sdist* command is almost exclusively
for module developers, while *install* is more often for installers
(although most developers will want to install their own code
occasionally).

  If you want to make things really easy for your users, you can create
one or more built distributions for them.  For instance, if you are
running on a Windows machine, and want to make things easy for other
Windows users, you can create an executable installer (the most
appropriate type of built distribution for this platform) with the
*bdist_wininst* command.  For example:

     python setup.py bdist_wininst

  will create an executable installer, ‘foo-1.0.win32.exe’, in the
current directory.

  Other useful built distribution formats are RPM, implemented by the
*bdist_rpm* command, Solaris *pkgtool* (*bdist_pkgtool*), and HP-UX
*swinstall* (*bdist_sdux*).  For example, the following command will
create an RPM file called ‘foo-1.0.noarch.rpm’:

     python setup.py bdist_rpm

  (The *bdist_rpm* command uses the *rpm* executable, therefore this has
to be run on an RPM-based system such as Red Hat Linux, SuSE Linux, or
Mandrake Linux.)

  You can find out what distribution formats are available at any time
by running

     python setup.py bdist --help-formats


File: python.info,  Node: General Python terminology,  Next: Distutils-specific terminology,  Prev: A Simple Example<2>,  Up: An Introduction to Distutils

8.1.3 General Python terminology
--------------------------------

If you’re reading this document, you probably have a good idea of what
modules, extensions, and so forth are.  Nevertheless, just to be sure
that everyone is operating from a common starting point, we offer the
following glossary of common Python terms:

module

     the basic unit of code reusability in Python: a block of code
     imported by some other code.  Three types of modules concern us
     here: pure Python modules, extension modules, and packages.

pure Python module

     a module written in Python and contained in a single ‘.py’ file
     (and possibly associated ‘.pyc’ and/or ‘.pyo’ files).  Sometimes
     referred to as a "pure module."

extension module

     a module written in the low-level language of the Python
     implementation: C/C++ for Python, Java for Jython.  Typically
     contained in a single dynamically loadable pre-compiled file, e.g.
     a shared object (‘.so’) file for Python extensions on Unix, a DLL
     (given the ‘.pyd’ extension) for Python extensions on Windows, or a
     Java class file for Jython extensions.  (Note that currently, the
     Distutils only handles C/C++ extensions for Python.)

package

     a module that contains other modules; typically contained in a
     directory in the filesystem and distinguished from other
     directories by the presence of a file ‘__init__.py’.

root package

     the root of the hierarchy of packages.  (This isn’t really a
     package, since it doesn’t have an ‘__init__.py’ file.  But we have
     to call it something.)  The vast majority of the standard library
     is in the root package, as are many small, standalone third-party
     modules that don’t belong to a larger module collection.  Unlike
     regular packages, modules in the root package can be found in many
     directories: in fact, every directory listed in ‘sys.path’
     contributes modules to the root package.


File: python.info,  Node: Distutils-specific terminology,  Prev: General Python terminology,  Up: An Introduction to Distutils

8.1.4 Distutils-specific terminology
------------------------------------

The following terms apply more specifically to the domain of
distributing Python modules using the Distutils:

module distribution

     a collection of Python modules distributed together as a single
     downloadable resource and meant to be installed _en masse_.
     Examples of some well-known module distributions are Numeric
     Python, PyXML, PIL (the Python Imaging Library), or mxBase.  (This
     would be called a _package_, except that term is already taken in
     the Python context: a single module distribution may contain zero,
     one, or many Python packages.)

pure module distribution

     a module distribution that contains only pure Python modules and
     packages.  Sometimes referred to as a "pure distribution."

non-pure module distribution

     a module distribution that contains at least one extension module.
     Sometimes referred to as a "non-pure distribution."

distribution root

     the top-level directory of your source tree (or source
     distribution); the directory where ‘setup.py’ exists.  Generally
     ‘setup.py’ will be run from this directory.


File: python.info,  Node: Writing the Setup Script,  Next: Writing the Setup Configuration File,  Prev: An Introduction to Distutils,  Up: Distributing Python Modules

8.2 Writing the Setup Script
============================

The setup script is the centre of all activity in building,
distributing, and installing modules using the Distutils.  The main
purpose of the setup script is to describe your module distribution to
the Distutils, so that the various commands that operate on your modules
do the right thing.  As we saw in section *note A Simple Example: 2e7a.
above, the setup script consists mainly of a call to ‘setup()’, and most
information supplied to the Distutils by the module developer is
supplied as keyword arguments to ‘setup()’.

  Here’s a slightly more involved example, which we’ll follow for the
next couple of sections: the Distutils’ own setup script.  (Keep in mind
that although the Distutils are included with Python 1.6 and later, they
also have an independent existence so that Python 1.5.2 users can use
them to install other module distributions.  The Distutils’ own setup
script, shown here, is used to install the package into Python 1.5.2.)

     #!/usr/bin/env python

     from distutils.core import setup

     setup(name='Distutils',
           version='1.0',
           description='Python Distribution Utilities',
           author='Greg Ward',
           author_email='gward@python.net',
           url='http://www.python.org/sigs/distutils-sig/',
           packages=['distutils', 'distutils.command'],
          )

  There are only two differences between this and the trivial one-file
distribution presented in section *note A Simple Example: 2e7a.: more
metadata, and the specification of pure Python modules by package,
rather than by module.  This is important since the Distutils consist of
a couple of dozen modules split into (so far) two packages; an explicit
list of every module would be tedious to generate and difficult to
maintain.  For more information on the additional meta-data, see section
*note Additional meta-data: 2e83.

  Note that any pathnames (files or directories) supplied in the setup
script should be written using the Unix convention, i.e.
slash-separated.  The Distutils will take care of converting this
platform-neutral representation into whatever is appropriate on your
current platform before actually using the pathname.  This makes your
setup script portable across operating systems, which of course is one
of the major goals of the Distutils.  In this spirit, all pathnames in
this document are slash-separated.

  This, of course, only applies to pathnames given to Distutils
functions.  If you, for example, use standard Python functions such as
*note glob.glob(): 348. or *note os.listdir(): 2d2. to specify files,
you should be careful to write portable code instead of hardcoding path
separators:

     glob.glob(os.path.join('mydir', 'subdir', '*.html'))
     os.listdir(os.path.join('mydir', 'subdir'))

* Menu:

* Listing whole packages:: 
* Listing individual modules:: 
* Describing extension modules:: 
* Relationships between Distributions and Packages:: 
* Installing Scripts:: 
* Installing Package Data:: 
* Installing Additional Files:: 
* Additional meta-data:: 
* Debugging the setup script:: 


File: python.info,  Node: Listing whole packages,  Next: Listing individual modules,  Up: Writing the Setup Script

8.2.1 Listing whole packages
----------------------------

The ‘packages’ option tells the Distutils to process (build, distribute,
install, etc.)  all pure Python modules found in each package mentioned
in the ‘packages’ list.  In order to do this, of course, there has to be
a correspondence between package names and directories in the
filesystem.  The default correspondence is the most obvious one, i.e.
package *note distutils: 85. is found in the directory ‘distutils’
relative to the distribution root.  Thus, when you say ‘packages =
['foo']’ in your setup script, you are promising that the Distutils will
find a file ‘foo/__init__.py’ (which might be spelled differently on
your system, but you get the idea) relative to the directory where your
setup script lives.  If you break this promise, the Distutils will issue
a warning but still process the broken package anyway.

  If you use a different convention to lay out your source directory,
that’s no problem: you just have to supply the ‘package_dir’ option to
tell the Distutils about your convention.  For example, say you keep all
Python source under ‘lib’, so that modules in the "root package" (i.e.,
not in any package at all) are in ‘lib’, modules in the ‘foo’ package
are in ‘lib/foo’, and so forth.  Then you would put

     package_dir = {'': 'lib'}

  in your setup script.  The keys to this dictionary are package names,
and an empty package name stands for the root package.  The values are
directory names relative to your distribution root.  In this case, when
you say ‘packages = ['foo']’, you are promising that the file
‘lib/foo/__init__.py’ exists.

  Another possible convention is to put the ‘foo’ package right in
‘lib’, the ‘foo.bar’ package in ‘lib/bar’, etc.  This would be written
in the setup script as

     package_dir = {'foo': 'lib'}

  A ‘package: dir’ entry in the ‘package_dir’ dictionary implicitly
applies to all packages below _package_, so the ‘foo.bar’ case is
automatically handled here.  In this example, having ‘packages = ['foo',
'foo.bar']’ tells the Distutils to look for ‘lib/__init__.py’ and
‘lib/bar/__init__.py’.  (Keep in mind that although ‘package_dir’
applies recursively, you must explicitly list all packages in
‘packages’: the Distutils will _not_ recursively scan your source tree
looking for any directory with an ‘__init__.py’ file.)


File: python.info,  Node: Listing individual modules,  Next: Describing extension modules,  Prev: Listing whole packages,  Up: Writing the Setup Script

8.2.2 Listing individual modules
--------------------------------

For a small module distribution, you might prefer to list all modules
rather than listing packages—especially the case of a single module that
goes in the "root package" (i.e., no package at all).  This simplest
case was shown in section *note A Simple Example: 2e7a.; here is a
slightly more involved example:

     py_modules = ['mod1', 'pkg.mod2']

  This describes two modules, one of them in the "root" package, the
other in the ‘pkg’ package.  Again, the default package/directory layout
implies that these two modules can be found in ‘mod1.py’ and
‘pkg/mod2.py’, and that ‘pkg/__init__.py’ exists as well.  And again,
you can override the package/directory correspondence using the
‘package_dir’ option.


File: python.info,  Node: Describing extension modules,  Next: Relationships between Distributions and Packages,  Prev: Listing individual modules,  Up: Writing the Setup Script

8.2.3 Describing extension modules
----------------------------------

Just as writing Python extension modules is a bit more complicated than
writing pure Python modules, describing them to the Distutils is a bit
more complicated.  Unlike pure modules, it’s not enough just to list
modules or packages and expect the Distutils to go out and find the
right files; you have to specify the extension name, source file(s), and
any compile/link requirements (include directories, libraries to link
with, etc.).

  All of this is done through another keyword argument to ‘setup()’, the
‘ext_modules’ option.  ‘ext_modules’ is just a list of *note Extension:
2e8a. instances, each of which describes a single extension module.
Suppose your distribution includes a single extension, called ‘foo’ and
implemented by ‘foo.c’.  If no additional instructions to the
compiler/linker are needed, describing this extension is quite simple:

     Extension('foo', ['foo.c'])

  The ‘Extension’ class can be imported from *note distutils.core: a0.
along with ‘setup()’.  Thus, the setup script for a module distribution
that contains only this one extension and nothing else might be:

     from distutils.core import setup, Extension
     setup(name='foo',
           version='1.0',
           ext_modules=[Extension('foo', ['foo.c'])],
           )

  The ‘Extension’ class (actually, the underlying extension-building
machinery implemented by the *build_ext* command) supports a great deal
of flexibility in describing Python extensions, which is explained in
the following sections.

* Menu:

* Extension names and packages:: 
* Extension source files:: 
* Preprocessor options:: 
* Library options:: 
* Other options:: 


File: python.info,  Node: Extension names and packages,  Next: Extension source files,  Up: Describing extension modules

8.2.3.1 Extension names and packages
....................................

The first argument to the *note Extension: 2e8a. constructor is always
the name of the extension, including any package names.  For example,

     Extension('foo', ['src/foo1.c', 'src/foo2.c'])

  describes an extension that lives in the root package, while

     Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c'])

  describes the same extension in the ‘pkg’ package.  The source files
and resulting object code are identical in both cases; the only
difference is where in the filesystem (and therefore where in Python’s
namespace hierarchy) the resulting extension lives.

  If you have a number of extensions all in the same package (or all
under the same base package), use the ‘ext_package’ keyword argument to
‘setup()’.  For example,

     setup(...,
           ext_package='pkg',
           ext_modules=[Extension('foo', ['foo.c']),
                        Extension('subpkg.bar', ['bar.c'])],
          )

  will compile ‘foo.c’ to the extension ‘pkg.foo’, and ‘bar.c’ to
‘pkg.subpkg.bar’.


File: python.info,  Node: Extension source files,  Next: Preprocessor options,  Prev: Extension names and packages,  Up: Describing extension modules

8.2.3.2 Extension source files
..............................

The second argument to the *note Extension: 2e8a. constructor is a list
of source files.  Since the Distutils currently only support C, C++, and
Objective-C extensions, these are normally C/C++/Objective-C source
files.  (Be sure to use appropriate extensions to distinguish C++source
files: ‘.cc’ and ‘.cpp’ seem to be recognized by both Unix and Windows
compilers.)

  However, you can also include SWIG interface (‘.i’) files in the list;
the *build_ext* command knows how to deal with SWIG extensions: it will
run SWIG on the interface file and compile the resulting C/C++ file into
your extension.

  This warning notwithstanding, options to SWIG can be currently passed
like this:

     setup(...,
           ext_modules=[Extension('_foo', ['foo.i'],
                                  swig_opts=['-modern', '-I../include'])],
           py_modules=['foo'],
          )

  Or on the commandline like this:

     > python setup.py build_ext --swig-opts="-modern -I../include"

  On some platforms, you can include non-source files that are processed
by the compiler and included in your extension.  Currently, this just
means Windows message text (‘.mc’) files and resource definition (‘.rc’)
files for Visual C++.  These will be compiled to binary resource
(‘.res’) files and linked into the executable.


File: python.info,  Node: Preprocessor options,  Next: Library options,  Prev: Extension source files,  Up: Describing extension modules

8.2.3.3 Preprocessor options
............................

Three optional arguments to *note Extension: 2e8a. will help if you need
to specify include directories to search or preprocessor macros to
define/undefine: ‘include_dirs’, ‘define_macros’, and ‘undef_macros’.

  For example, if your extension requires header files in the ‘include’
directory under your distribution root, use the ‘include_dirs’ option:

     Extension('foo', ['foo.c'], include_dirs=['include'])

  You can specify absolute directories there; if you know that your
extension will only be built on Unix systems with X11R6 installed to
‘/usr’, you can get away with

     Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11'])

  You should avoid this sort of non-portable usage if you plan to
distribute your code: it’s probably better to write C code like

     #include <X11/Xlib.h>

  If you need to include header files from some other Python extension,
you can take advantage of the fact that header files are installed in a
consistent way by the Distutils *install_headers* command.  For example,
the Numerical Python header files are installed (on a standard Unix
installation) to ‘/usr/local/include/python1.5/Numerical’.  (The exact
location will differ according to your platform and Python
installation.)  Since the Python include
directory—‘/usr/local/include/python1.5’ in this case—is always included
in the search path when building Python extensions, the best approach is
to write C code like

     #include <Numerical/arrayobject.h>

  If you must put the ‘Numerical’ include directory right into your
header search path, though, you can find that directory using the
Distutils *note distutils.sysconfig: af. module:

     from distutils.sysconfig import get_python_inc
     incdir = os.path.join(get_python_inc(plat_specific=1), 'Numerical')
     setup(...,
           Extension(..., include_dirs=[incdir]),
           )

  Even though this is quite portable—it will work on any Python
installation, regardless of platform—it’s probably easier to just write
your C code in the sensible way.

  You can define and undefine pre-processor macros with the
‘define_macros’ and ‘undef_macros’ options.  ‘define_macros’ takes a
list of ‘(name, value)’ tuples, where ‘name’ is the name of the macro to
define (a string) and ‘value’ is its value: either a string or ‘None’.
(Defining a macro ‘FOO’ to ‘None’ is the equivalent of a bare ‘#define
FOO’ in your C source: with most compilers, this sets ‘FOO’ to the
string ‘1’.)  ‘undef_macros’ is just a list of macros to undefine.

  For example:

     Extension(...,
               define_macros=[('NDEBUG', '1'),
                              ('HAVE_STRFTIME', None)],
               undef_macros=['HAVE_FOO', 'HAVE_BAR'])

  is the equivalent of having this at the top of every C source file:

     #define NDEBUG 1
     #define HAVE_STRFTIME
     #undef HAVE_FOO
     #undef HAVE_BAR


File: python.info,  Node: Library options,  Next: Other options,  Prev: Preprocessor options,  Up: Describing extension modules

8.2.3.4 Library options
.......................

You can also specify the libraries to link against when building your
extension, and the directories to search for those libraries.  The
‘libraries’ option is a list of libraries to link against,
‘library_dirs’ is a list of directories to search for libraries at
link-time, and ‘runtime_library_dirs’ is a list of directories to search
for shared (dynamically loaded) libraries at run-time.

  For example, if you need to link against libraries known to be in the
standard library search path on target systems

     Extension(...,
               libraries=['gdbm', 'readline'])

  If you need to link with libraries in a non-standard location, you’ll
have to include the location in ‘library_dirs’:

     Extension(...,
               library_dirs=['/usr/X11R6/lib'],
               libraries=['X11', 'Xt'])

  (Again, this sort of non-portable construct should be avoided if you
intend to distribute your code.)


File: python.info,  Node: Other options,  Prev: Library options,  Up: Describing extension modules

8.2.3.5 Other options
.....................

There are still some other options which can be used to handle special
cases.

  The ‘extra_objects’ option is a list of object files to be passed to
the linker.  These files must not have extensions, as the default
extension for the compiler is used.

  ‘extra_compile_args’ and ‘extra_link_args’ can be used to specify
additional command line options for the respective compiler and linker
command lines.

  ‘export_symbols’ is only useful on Windows.  It can contain a list of
symbols (functions or variables) to be exported.  This option is not
needed when building compiled extensions: Distutils will automatically
add ‘initmodule’ to the list of exported symbols.

  The ‘depends’ option is a list of files that the extension depends on
(for example header files).  The build command will call the compiler on
the sources to rebuild extension if any on this files has been modified
since the previous build.


File: python.info,  Node: Relationships between Distributions and Packages,  Next: Installing Scripts,  Prev: Describing extension modules,  Up: Writing the Setup Script

8.2.4 Relationships between Distributions and Packages
------------------------------------------------------

A distribution may relate to packages in three specific ways:

  1. It can require packages or modules.

  2. It can provide packages or modules.

  3. It can obsolete packages or modules.

  These relationships can be specified using keyword arguments to the
*note distutils.core.setup(): 2e91. function.

  Dependencies on other Python modules and packages can be specified by
supplying the _requires_ keyword argument to ‘setup()’.  The value must
be a list of strings.  Each string specifies a package that is required,
and optionally what versions are sufficient.

  To specify that any version of a module or package is required, the
string should consist entirely of the module or package name.  Examples
include ‘'mymodule'’ and ‘'xml.parsers.expat'’.

  If specific versions are required, a sequence of qualifiers can be
supplied in parentheses.  Each qualifier may consist of a comparison
operator and a version number.  The accepted comparison operators are:

     <    >    ==
     <=   >=   !=

  These can be combined by using multiple qualifiers separated by commas
(and optional whitespace).  In this case, all of the qualifiers must be
matched; a logical AND is used to combine the evaluations.

  Let’s look at a bunch of examples:

Requires Expression           Explanation
                              
---------------------------------------------------------------------------------
                              
‘==1.0’                       Only version ‘1.0’ is compatible
                              
                              
‘>1.0, !=1.5.1, <2.0’         Any version after ‘1.0’ and before ‘2.0’ is
                              compatible, except ‘1.5.1’
                              

  Now that we can specify dependencies, we also need to be able to
specify what we provide that other distributions can require.  This is
done using the _provides_ keyword argument to ‘setup()’.  The value for
this keyword is a list of strings, each of which names a Python module
or package, and optionally identifies the version.  If the version is
not specified, it is assumed to match that of the distribution.

  Some examples:

Provides Expression       Explanation
                          
-----------------------------------------------------------------------------
                          
‘mypkg’                   Provide ‘mypkg’, using the distribution version
                          
                          
‘mypkg (1.1)’             Provide ‘mypkg’ version 1.1, regardless of the
                          distribution version
                          

  A package can declare that it obsoletes other packages using the
_obsoletes_ keyword argument.  The value for this is similar to that of
the _requires_ keyword: a list of strings giving module or package
specifiers.  Each specifier consists of a module or package name
optionally followed by one or more version qualifiers.  Version
qualifiers are given in parentheses after the module or package name.

  The versions identified by the qualifiers are those that are obsoleted
by the distribution being described.  If no qualifiers are given, all
versions of the named module or package are understood to be obsoleted.


File: python.info,  Node: Installing Scripts,  Next: Installing Package Data,  Prev: Relationships between Distributions and Packages,  Up: Writing the Setup Script

8.2.5 Installing Scripts
------------------------

So far we have been dealing with pure and non-pure Python modules, which
are usually not run by themselves but imported by scripts.

  Scripts are files containing Python source code, intended to be
started from the command line.  Scripts don’t require Distutils to do
anything very complicated.  The only clever feature is that if the first
line of the script starts with ‘#!’ and contains the word "python", the
Distutils will adjust the first line to refer to the current interpreter
location.  By default, it is replaced with the current interpreter
location.  The ‘--executable’ (or ‘-e’) option will allow the
interpreter path to be explicitly overridden.

  The ‘scripts’ option simply is a list of files to be handled in this
way.  From the PyXML setup script:

     setup(...,
           scripts=['scripts/xmlproc_parse', 'scripts/xmlproc_val']
           )

  Changed in version 2.7: All the scripts will also be added to the
‘MANIFEST’ file if no template is provided.  See *note Specifying the
files to distribute: 2e94.


File: python.info,  Node: Installing Package Data,  Next: Installing Additional Files,  Prev: Installing Scripts,  Up: Writing the Setup Script

8.2.6 Installing Package Data
-----------------------------

Often, additional files need to be installed into a package.  These
files are often data that’s closely related to the package’s
implementation, or text files containing documentation that might be of
interest to programmers using the package.  These files are called
_package data_.

  Package data can be added to packages using the ‘package_data’ keyword
argument to the ‘setup()’ function.  The value must be a mapping from
package name to a list of relative path names that should be copied into
the package.  The paths are interpreted as relative to the directory
containing the package (information from the ‘package_dir’ mapping is
used if appropriate); that is, the files are expected to be part of the
package in the source directories.  They may contain glob patterns as
well.

  The path names may contain directory portions; any necessary
directories will be created in the installation.

  For example, if a package should contain a subdirectory with several
data files, the files can be arranged like this in the source tree:

     setup.py
     src/
         mypkg/
             __init__.py
             module.py
             data/
                 tables.dat
                 spoons.dat
                 forks.dat

  The corresponding call to ‘setup()’ might be:

     setup(...,
           packages=['mypkg'],
           package_dir={'mypkg': 'src/mypkg'},
           package_data={'mypkg': ['data/*.dat']},
           )

  New in version 2.4.

  Changed in version 2.7: All the files that match ‘package_data’ will
be added to the ‘MANIFEST’ file if no template is provided.  See *note
Specifying the files to distribute: 2e94.


File: python.info,  Node: Installing Additional Files,  Next: Additional meta-data,  Prev: Installing Package Data,  Up: Writing the Setup Script

8.2.7 Installing Additional Files
---------------------------------

The ‘data_files’ option can be used to specify additional files needed
by the module distribution: configuration files, message catalogs, data
files, anything which doesn’t fit in the previous categories.

  ‘data_files’ specifies a sequence of (_directory_, _files_) pairs in
the following way:

     setup(...,
           data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),
                       ('config', ['cfg/data.cfg']),
                       ('/etc/init.d', ['init-script'])]
          )

  Note that you can specify the directory names where the data files
will be installed, but you cannot rename the data files themselves.

  Each (_directory_, _files_) pair in the sequence specifies the
installation directory and the files to install there.  If _directory_
is a relative path, it is interpreted relative to the installation
prefix (Python’s ‘sys.prefix’ for pure-Python packages,
‘sys.exec_prefix’ for packages that contain extension modules).  Each
file name in _files_ is interpreted relative to the ‘setup.py’ script at
the top of the package source distribution.  No directory information
from _files_ is used to determine the final location of the installed
file; only the name of the file is used.

  You can specify the ‘data_files’ options as a simple sequence of files
without specifying a target directory, but this is not recommended, and
the *install* command will print a warning in this case.  To install
data files directly in the target directory, an empty string should be
given as the directory.

  Changed in version 2.7: All the files that match ‘data_files’ will be
added to the ‘MANIFEST’ file if no template is provided.  See *note
Specifying the files to distribute: 2e94.


File: python.info,  Node: Additional meta-data,  Next: Debugging the setup script,  Prev: Installing Additional Files,  Up: Writing the Setup Script

8.2.8 Additional meta-data
--------------------------

The setup script may include additional meta-data beyond the name and
version.  This information includes:

Meta-Data                  Description                     Value                 Notes
                                                                                 
----------------------------------------------------------------------------------------------
                                                                                 
‘name’                     name of the package             short string          (1)
                                                                                 
                                                                                 
‘version’                  version of this release         short string          (1)(2)
                                                                                 
                                                                                 
‘author’                   package author’s name           short string          (3)
                                                                                 
                                                                                 
‘author_email’             email address of the package    email address         (3)
                           author                                                
                           
                                                                                 
‘maintainer’               package maintainer’s name       short string          (3)
                                                                                 
                                                                                 
‘maintainer_email’         email address of the package    email address         (3)
                           maintainer                                            
                           
                                                                                 
‘url’                      home page for the package       URL                   (1)
                                                                                 
                                                                                 
‘description’              short, summary description of   short string
                           the package                     
                           
                                                                                 
‘long_description’         longer description of the       long string           (5)
                           package                                               
                           
                                                                                 
‘download_url’             location where the package      URL                   (4)
                           may be downloaded                                     
                           
                                                                                 
‘classifiers’              a list of classifiers           list of strings       (4)
                                                                                 
                                                                                 
‘platforms’                a list of platforms             list of strings
                                                           
                                                                                 
‘license’                  license for the package         short string          (6)
                                                                                 

  Notes:

  1. These fields are required.

  2. It is recommended that versions take the form
     _major.minor[.patch[.sub]]_.

  3. Either the author or the maintainer must be identified.  If
     maintainer is provided, distutils lists it as the author in
     ‘PKG-INFO’.

  4. These fields should not be used if your package is to be compatible
     with Python versions prior to 2.2.3 or 2.3.  The list is available
     from the PyPI website(1).

  5. The ‘long_description’ field is used by PyPI when you are *note
     registering: 2e9a. a package, to *note build its home page: 2e9b.

  6. The ‘license’ field is a text indicating the license covering the
     package where the license is not a selection from the "License"
     Trove classifiers.  See the ‘Classifier’ field.  Notice that
     there’s a ‘licence’ distribution option which is deprecated but
     still acts as an alias for ‘license’.

’short string’

     A single line of text, not more than 200 characters.

’long string’

     Multiple lines of plain text in reStructuredText format (see
     ‘http://docutils.sf.net/’).

’list of strings’

     See below.

  None of the string values may be Unicode.

  Encoding the version information is an art in itself.  Python packages
generally adhere to the version format _major.minor[.patch][sub]_.  The
major number is 0 for initial, experimental releases of software.  It is
incremented for releases that represent major milestones in a package.
The minor number is incremented when important new features are added to
the package.  The patch number increments when bug-fix releases are
made.  Additional trailing version information is sometimes used to
indicate sub-releases.  These are "a1,a2,...,aN" (for alpha releases,
where functionality and API may change), "b1,b2,...,bN" (for beta
releases, which only fix bugs) and "pr1,pr2,...,prN" (for final
pre-release release testing).  Some examples:

0.1.0

     the first, experimental release of a package

1.0.1a2

     the second alpha release of the first patch version of 1.0

  ‘classifiers’ are specified in a Python list:

     setup(...,
           classifiers=[
               'Development Status :: 4 - Beta',
               'Environment :: Console',
               'Environment :: Web Environment',
               'Intended Audience :: End Users/Desktop',
               'Intended Audience :: Developers',
               'Intended Audience :: System Administrators',
               'License :: OSI Approved :: Python Software Foundation License',
               'Operating System :: MacOS :: MacOS X',
               'Operating System :: Microsoft :: Windows',
               'Operating System :: POSIX',
               'Programming Language :: Python',
               'Topic :: Communications :: Email',
               'Topic :: Office/Business',
               'Topic :: Software Development :: Bug Tracking',
               ],
           )

  If you wish to include classifiers in your ‘setup.py’ file and also
wish to remain backwards-compatible with Python releases prior to 2.2.3,
then you can include the following code fragment in your ‘setup.py’
before the ‘setup()’ call.

     # patch distutils if it can't cope with the "classifiers" or
     # "download_url" keywords
     from sys import version
     if version < '2.2.3':
         from distutils.dist import DistributionMetadata
         DistributionMetadata.classifiers = None
         DistributionMetadata.download_url = None

   ---------- Footnotes ----------

   (1) http://pypi.python.org/pypi


File: python.info,  Node: Debugging the setup script,  Prev: Additional meta-data,  Up: Writing the Setup Script

8.2.9 Debugging the setup script
--------------------------------

Sometimes things go wrong, and the setup script doesn’t do what the
developer wants.

  Distutils catches any exceptions when running the setup script, and
print a simple error message before the script is terminated.  The
motivation for this behaviour is to not confuse administrators who don’t
know much about Python and are trying to install a package.  If they get
a big long traceback from deep inside the guts of Distutils, they may
think the package or the Python installation is broken because they
don’t read all the way down to the bottom and see that it’s a permission
problem.

  On the other hand, this doesn’t help the developer to find the cause
of the failure.  For this purpose, the ‘DISTUTILS_DEBUG’ environment
variable can be set to anything except an empty string, and distutils
will now print detailed information about what it is doing, dump the
full traceback when an exception occurs, and print the whole command
line when an external program (like a C compiler) fails.


File: python.info,  Node: Writing the Setup Configuration File,  Next: Creating a Source Distribution,  Prev: Writing the Setup Script,  Up: Distributing Python Modules

8.3 Writing the Setup Configuration File
========================================

Often, it’s not possible to write down everything needed to build a
distribution _a priori_: you may need to get some information from the
user, or from the user’s system, in order to proceed.  As long as that
information is fairly simple—a list of directories to search for C
header files or libraries, for example—then providing a configuration
file, ‘setup.cfg’, for users to edit is a cheap and easy way to solicit
it.  Configuration files also let you provide default values for any
command option, which the installer can then override either on the
command-line or by editing the config file.

  The setup configuration file is a useful middle-ground between the
setup script —which, ideally, would be opaque to installers (1)—and the
command-line to the setup script, which is outside of your control and
entirely up to the installer.  In fact, ‘setup.cfg’ (and any other
Distutils configuration files present on the target system) are
processed after the contents of the setup script, but before the
command-line.  This has several useful consequences:

   * installers can override some of what you put in ‘setup.py’ by
     editing ‘setup.cfg’

   * you can provide non-standard defaults for options that are not
     easily set in ‘setup.py’

   * installers can override anything in ‘setup.cfg’ using the
     command-line options to ‘setup.py’

  The basic syntax of the configuration file is simple:

     [command]
     option=value
     ...

  where _command_ is one of the Distutils commands (e.g.  *build_py*,
*install*), and _option_ is one of the options that command supports.
Any number of options can be supplied for each command, and any number
of command sections can be included in the file.  Blank lines are
ignored, as are comments, which run from a ‘'#'’ character until the end
of the line.  Long option values can be split across multiple lines
simply by indenting the continuation lines.

  You can find out the list of options supported by a particular command
with the universal *note –help: 1d5. option, e.g.

     > python setup.py --help build_ext
     [...]
     Options for 'build_ext' command:
       --build-lib (-b)     directory for compiled extension modules
       --build-temp (-t)    directory for temporary files (build by-products)
       --inplace (-i)       ignore build-lib and put compiled extensions into the
                            source directory alongside your pure Python modules
       --include-dirs (-I)  list of directories to search for header files
       --define (-D)        C preprocessor macros to define
       --undef (-U)         C preprocessor macros to undefine
       --swig-opts          list of SWIG command line options
     [...]

  Note that an option spelled ‘--foo-bar’ on the command-line is spelled
‘foo_bar’ in configuration files.  For example, say you want your
extensions to be built "in-place"—that is, you have an extension
‘pkg.ext’, and you want the compiled extension file (‘ext.so’ on Unix,
say) to be put in the same source directory as your pure Python modules
‘pkg.mod1’ and ‘pkg.mod2’.  You can always use the ‘--inplace’ option on
the command-line to ensure this:

     python setup.py build_ext --inplace

  But this requires that you always specify the *build_ext* command
explicitly, and remember to provide ‘--inplace’.  An easier way is to
"set and forget" this option, by encoding it in ‘setup.cfg’, the
configuration file for this distribution:

     [build_ext]
     inplace=1

  This will affect all builds of this module distribution, whether or
not you explicitly specify *build_ext*.  If you include ‘setup.cfg’ in
your source distribution, it will also affect end-user builds—which is
probably a bad idea for this option, since always building extensions
in-place would break installation of the module distribution.  In
certain peculiar cases, though, modules are built right in their
installation directory, so this is conceivably a useful ability.
(Distributing extensions that expect to be built in their installation
directory is almost always a bad idea, though.)

  Another example: certain commands take a lot of options that don’t
change from run to run; for example, *bdist_rpm* needs to know
everything required to generate a "spec" file for creating an RPM
distribution.  Some of this information comes from the setup script, and
some is automatically generated by the Distutils (such as the list of
files installed).  But some of it has to be supplied as options to
*bdist_rpm*, which would be very tedious to do on the command-line for
every run.  Hence, here is a snippet from the Distutils’ own
‘setup.cfg’:

     [bdist_rpm]
     release = 1
     packager = Greg Ward <gward@python.net>
     doc_files = CHANGES.txt
                 README.txt
                 USAGE.txt
                 doc/
                 examples/

  Note that the ‘doc_files’ option is simply a whitespace-separated
string split across multiple lines for readability.

See also
........

*note Syntax of config files: 2ea2. in "Installing Python Modules"

     More information on the configuration files is available in the
     manual for system administrators.

   ---------- Footnotes ----------

   (1) This ideal probably won’t be achieved until auto-configuration is
fully supported by the Distutils.


File: python.info,  Node: Creating a Source Distribution,  Next: Creating Built Distributions,  Prev: Writing the Setup Configuration File,  Up: Distributing Python Modules

8.4 Creating a Source Distribution
==================================

As shown in section *note A Simple Example: 2e7a, you use the *sdist*
command to create a source distribution.  In the simplest case,

     python setup.py sdist

  (assuming you haven’t specified any *sdist* options in the setup
script or config file), *sdist* creates the archive of the default
format for the current platform.  The default format is a gzip’ed tar
file (‘.tar.gz’) on Unix, and ZIP file on Windows.

  You can specify as many formats as you like using the ‘--formats’
option, for example:

     python setup.py sdist --formats=gztar,zip

  to create a gzipped tarball and a zip file.  The available formats
are:

Format          Description                   Notes
                                              
------------------------------------------------------------
                                              
‘zip’           zip file (‘.zip’)             (1),(3)
                                              
                                              
‘gztar’         gzip’ed tar file              (2)
                (‘.tar.gz’)                   
                
                                              
‘bztar’         bzip2’ed tar file
                (‘.tar.bz2’)
                
                                              
‘ztar’          compressed tar file           (4)
                (‘.tar.Z’)                    
                
                                              
‘tar’           tar file (‘.tar’)
                

  Notes:

  1. default on Windows

  2. default on Unix

  3. requires either external *zip* utility or *note zipfile: 1ab.
     module (part of the standard Python library since Python 1.6)

  4. requires the *compress* program.

  When using any ‘tar’ format (‘gztar’, ‘bztar’, ‘ztar’ or ‘tar’) under
Unix, you can specify the ‘owner’ and ‘group’ names that will be set for
each member of the archive.

  For example, if you want all files of the archive to be owned by root:

     python setup.py sdist --owner=root --group=root

* Menu:

* Specifying the files to distribute:: 
* Manifest-related options:: 
* The MANIFEST.in template: The MANIFEST in template. 


File: python.info,  Node: Specifying the files to distribute,  Next: Manifest-related options,  Up: Creating a Source Distribution

8.4.1 Specifying the files to distribute
----------------------------------------

If you don’t supply an explicit list of files (or instructions on how to
generate one), the *sdist* command puts a minimal default set into the
source distribution:

   * all Python source files implied by the ‘py_modules’ and ‘packages’
     options

   * all C source files mentioned in the ‘ext_modules’ or ‘libraries’
     options

   * scripts identified by the ‘scripts’ option See *note Installing
     Scripts: 2e93.

   * anything that looks like a test script: ‘test/test*.py’ (currently,
     the Distutils don’t do anything with test scripts except include
     them in source distributions, but in the future there will be a
     standard for testing Python module distributions)

   * ‘README.txt’ (or ‘README’), ‘setup.py’ (or whatever you called your
     setup script), and ‘setup.cfg’

   * all files that matches the ‘package_data’ metadata.  See *note
     Installing Package Data: 2e96.

   * all files that matches the ‘data_files’ metadata.  See *note
     Installing Additional Files: 2e98.

  Sometimes this is enough, but usually you will want to specify
additional files to distribute.  The typical way to do this is to write
a _manifest template_, called ‘MANIFEST.in’ by default.  The manifest
template is just a list of instructions for how to generate your
manifest file, ‘MANIFEST’, which is the exact list of files to include
in your source distribution.  The *sdist* command processes this
template and generates a manifest based on its instructions and what it
finds in the filesystem.

  If you prefer to roll your own manifest file, the format is simple:
one filename per line, regular files (or symlinks to them) only.  If you
do supply your own ‘MANIFEST’, you must specify everything: the default
set of files described above does not apply in this case.

  Changed in version 2.7: An existing generated ‘MANIFEST’ will be
regenerated without *sdist* comparing its modification time to the one
of ‘MANIFEST.in’ or ‘setup.py’.

  Changed in version 2.7.1: ‘MANIFEST’ files start with a comment
indicating they are generated.  Files without this comment are not
overwritten or removed.

  Changed in version 2.7.3: *sdist* will read a ‘MANIFEST’ file if no
‘MANIFEST.in’ exists, like it did before 2.7.

  See *note The MANIFEST.in template: 2ea7. section for a syntax
reference.


File: python.info,  Node: Manifest-related options,  Next: The MANIFEST in template,  Prev: Specifying the files to distribute,  Up: Creating a Source Distribution

8.4.2 Manifest-related options
------------------------------

The normal course of operations for the *sdist* command is as follows:

   * if the manifest file (‘MANIFEST’ by default) exists and the first
     line does not have a comment indicating it is generated from
     ‘MANIFEST.in’, then it is used as is, unaltered

   * if the manifest file doesn’t exist or has been previously
     automatically generated, read ‘MANIFEST.in’ and create the manifest

   * if neither ‘MANIFEST’ nor ‘MANIFEST.in’ exist, create a manifest
     with just the default file set

   * use the list of files now in ‘MANIFEST’ (either just generated or
     read in) to create the source distribution archive(s)

  There are a couple of options that modify this behaviour.  First, use
the ‘--no-defaults’ and ‘--no-prune’ to disable the standard "include"
and "exclude" sets.

  Second, you might just want to (re)generate the manifest, but not
create a source distribution:

     python setup.py sdist --manifest-only

  ‘-o’ is a shortcut for ‘--manifest-only’.


File: python.info,  Node: The MANIFEST in template,  Prev: Manifest-related options,  Up: Creating a Source Distribution

8.4.3 The MANIFEST.in template
------------------------------

A ‘MANIFEST.in’ file can be added in a project to define the list of
files to include in the distribution built by the *sdist* command.

  When *sdist* is run, it will look for the ‘MANIFEST.in’ file and
interpret it to generate the ‘MANIFEST’ file that contains the list of
files that will be included in the package.

  This mechanism can be used when the default list of files is not
enough.  (See *note Specifying the files to distribute: 2e94.).

* Menu:

* Principle:: 
* Commands:: 


File: python.info,  Node: Principle,  Next: Commands,  Up: The MANIFEST in template

8.4.3.1 Principle
.................

The manifest template has one command per line, where each command
specifies a set of files to include or exclude from the source
distribution.  For an example, let’s look at the Distutils’ own manifest
template:

     include *.txt
     recursive-include examples *.txt *.py
     prune examples/sample?/build

  The meanings should be fairly clear: include all files in the
distribution root matching ‘*.txt’, all files anywhere under the
‘examples’ directory matching ‘*.txt’ or ‘*.py’, and exclude all
directories matching ‘examples/sample?/build’.  All of this is done
_after_ the standard include set, so you can exclude files from the
standard set with explicit instructions in the manifest template.  (Or,
you can use the ‘--no-defaults’ option to disable the standard set
entirely.)

  The order of commands in the manifest template matters: initially, we
have the list of default files as described above, and each command in
the template adds to or removes from that list of files.  Once we have
fully processed the manifest template, we remove files that should not
be included in the source distribution:

   * all files in the Distutils "build" tree (default ‘build/’)

   * all files in directories named ‘RCS’, ‘CVS’, ‘.svn’, ‘.hg’, ‘.git’,
     ‘.bzr’ or ‘_darcs’

  Now we have our complete list of files, which is written to the
manifest for future reference, and then used to build the source
distribution archive(s).

  You can disable the default set of included files with the
‘--no-defaults’ option, and you can disable the standard exclude set
with ‘--no-prune’.

  Following the Distutils’ own manifest template, let’s trace how the
*sdist* command builds the list of files to include in the Distutils
source distribution:

  1. include all Python source files in the ‘distutils’ and
     ‘distutils/command’ subdirectories (because packages corresponding
     to those two directories were mentioned in the ‘packages’ option in
     the setup script—see section *note Writing the Setup Script: 2e7c.)

  2. include ‘README.txt’, ‘setup.py’, and ‘setup.cfg’ (standard files)

  3. include ‘test/test*.py’ (standard files)

  4. include ‘*.txt’ in the distribution root (this will find
     ‘README.txt’ a second time, but such redundancies are weeded out
     later)

  5. include anything matching ‘*.txt’ or ‘*.py’ in the sub-tree under
     ‘examples’,

  6. exclude all files in the sub-trees starting at directories matching
     ‘examples/sample?/build’—this may exclude files included by the
     previous two steps, so it’s important that the ‘prune’ command in
     the manifest template comes after the ‘recursive-include’ command

  7. exclude the entire ‘build’ tree, and any ‘RCS’, ‘CVS’, ‘.svn’,
     ‘.hg’, ‘.git’, ‘.bzr’ and ‘_darcs’ directories

  Just like in the setup script, file and directory names in the
manifest template should always be slash-separated; the Distutils will
take care of converting them to the standard representation on your
platform.  That way, the manifest template is portable across operating
systems.


File: python.info,  Node: Commands,  Prev: Principle,  Up: The MANIFEST in template

8.4.3.2 Commands
................

The manifest template commands are:

Command                                         Description
                                                
----------------------------------------------------------------------------------------------------
                                                
*include pat1 pat2 ...*                         include all files matching any of the listed
                                                patterns
                                                
                                                
*exclude pat1 pat2 ...*                         exclude all files matching any of the listed
                                                patterns
                                                
                                                
*recursive-include dir pat1 pat2 ...*           include all files under _dir_ matching any of the
                                                listed patterns
                                                
                                                
*recursive-exclude dir pat1 pat2 ...*           exclude all files under _dir_ matching any of the
                                                listed patterns
                                                
                                                
*global-include pat1 pat2 ...*                  include all files anywhere in the source tree
                                                matching — & any of the listed patterns
                                                
                                                
*global-exclude pat1 pat2 ...*                  exclude all files anywhere in the source tree
                                                matching — & any of the listed patterns
                                                
                                                
*prune dir*                                     exclude all files under _dir_
                                                
                                                
*graft dir*                                     include all files under _dir_
                                                

  The patterns here are Unix-style "glob" patterns: ‘*’ matches any
sequence of regular filename characters, ‘?’ matches any single regular
filename character, and ‘[range]’ matches any of the characters in
_range_ (e.g., ‘a-z’, ‘a-zA-Z’, ‘a-f0-9_.’).  The definition of "regular
filename character" is platform-specific: on Unix it is anything except
slash; on Windows anything except backslash or colon.


File: python.info,  Node: Creating Built Distributions,  Next: The Python Package Index PyPI,  Prev: Creating a Source Distribution,  Up: Distributing Python Modules

8.5 Creating Built Distributions
================================

A "built distribution" is what you’re probably used to thinking of
either as a "binary package" or an "installer" (depending on your
background).  It’s not necessarily binary, though, because it might
contain only Python source code and/or byte-code; and we don’t call it a
package, because that word is already spoken for in Python.  (And
"installer" is a term specific to the world of mainstream desktop
systems.)

  A built distribution is how you make life as easy as possible for
installers of your module distribution: for users of RPM-based Linux
systems, it’s a binary RPM; for Windows users, it’s an executable
installer; for Debian-based Linux users, it’s a Debian package; and so
forth.  Obviously, no one person will be able to create built
distributions for every platform under the sun, so the Distutils are
designed to enable module developers to concentrate on their
specialty—writing code and creating source distributions—while an
intermediary species called _packagers_ springs up to turn source
distributions into built distributions for as many platforms as there
are packagers.

  Of course, the module developer could be his own packager; or the
packager could be a volunteer "out there" somewhere who has access to a
platform which the original developer does not; or it could be software
periodically grabbing new source distributions and turning them into
built distributions for as many platforms as the software has access to.
Regardless of who they are, a packager uses the setup script and the
*bdist* command family to generate built distributions.

  As a simple example, if I run the following command in the Distutils
source tree:

     python setup.py bdist

  then the Distutils builds my module distribution (the Distutils itself
in this case), does a "fake" installation (also in the ‘build’
directory), and creates the default type of built distribution for my
platform.  The default format for built distributions is a "dumb" tar
file on Unix, and a simple executable installer on Windows.  (That tar
file is considered "dumb" because it has to be unpacked in a specific
location to work.)

  Thus, the above command on a Unix system creates
‘Distutils-1.0._plat_.tar.gz’; unpacking this tarball from the right
place installs the Distutils just as though you had downloaded the
source distribution and run ‘python setup.py install’.  (The "right
place" is either the root of the filesystem or Python’s ‘_prefix_’
directory, depending on the options given to the *bdist_dumb* command;
the default is to make dumb distributions relative to ‘_prefix_’.)

  Obviously, for pure Python distributions, this isn’t any simpler than
just running ‘python setup.py install’—but for non-pure distributions,
which include extensions that would need to be compiled, it can mean the
difference between someone being able to use your extensions or not.
And creating "smart" built distributions, such as an RPM package or an
executable installer for Windows, is far more convenient for users even
if your distribution doesn’t include any extensions.

  The *bdist* command has a ‘--formats’ option, similar to the *sdist*
command, which you can use to select the types of built distribution to
generate: for example,

     python setup.py bdist --format=zip

  would, when run on a Unix system, create
‘Distutils-1.0._plat_.zip’—again, this archive would be unpacked from
the root directory to install the Distutils.

  The available formats for built distributions are:

Format            Description                        Notes
                                                     
-------------------------------------------------------------------
                                                     
‘gztar’           gzipped tar file (‘.tar.gz’)       (1),(3)
                                                     
                                                     
‘ztar’            compressed tar file (‘.tar.Z’)     (3)
                                                     
                                                     
‘tar’             tar file (‘.tar’)                  (3)
                                                     
                                                     
‘zip’             zip file (‘.zip’)                  (2),(4)
                                                     
                                                     
‘rpm’             RPM                                (5)
                                                     
                                                     
‘pkgtool’         Solaris *pkgtool*
                  
                                                     
‘sdux’            HP-UX *swinstall*
                  
                                                     
‘wininst’         self-extracting ZIP file for       (4)
                  Windows                            
                  
                                                     
‘msi’             Microsoft Installer.
                  

  Notes:

  1. default on Unix

  2. default on Windows

  3. requires external utilities: *tar* and possibly one of *gzip*,
     *bzip2*, or *compress*

  4. requires either external *zip* utility or *note zipfile: 1ab.
     module (part of the standard Python library since Python 1.6)

  5. requires external *rpm* utility, version 3.0.4 or better (use ‘rpm
     --version’ to find out which version you have)

  You don’t have to use the *bdist* command with the ‘--formats’ option;
you can also use the command that directly implements the format you’re
interested in.  Some of these *bdist* "sub-commands" actually generate
several similar formats; for instance, the *bdist_dumb* command
generates all the "dumb" archive formats (‘tar’, ‘ztar’, ‘gztar’, and
‘zip’), and *bdist_rpm* generates both binary and source RPMs.  The
*bdist* sub-commands, and the formats generated by each, are:

Command                        Formats
                               
-----------------------------------------------------------
                               
*bdist_dumb*                   tar, ztar, gztar, zip
                               
                               
*bdist_rpm*                    rpm, srpm
                               
                               
*bdist_wininst*                wininst
                               
                               
*bdist_msi*                    msi
                               

  The following sections give details on the individual *bdist_**
commands.

* Menu:

* Creating dumb built distributions:: 
* Creating RPM packages:: 
* Creating Windows Installers:: 
* Cross-compiling on Windows:: 
* Vista User Access Control (UAC): Vista User Access Control UAC. 


File: python.info,  Node: Creating dumb built distributions,  Next: Creating RPM packages,  Up: Creating Built Distributions

8.5.1 Creating dumb built distributions
---------------------------------------


File: python.info,  Node: Creating RPM packages,  Next: Creating Windows Installers,  Prev: Creating dumb built distributions,  Up: Creating Built Distributions

8.5.2 Creating RPM packages
---------------------------

The RPM format is used by many popular Linux distributions, including
Red Hat, SuSE, and Mandrake.  If one of these (or any of the other
RPM-based Linux distributions) is your usual environment, creating RPM
packages for other users of that same distribution is trivial.
Depending on the complexity of your module distribution and differences
between Linux distributions, you may also be able to create RPMs that
work on different RPM-based distributions.

  The usual way to create an RPM of your module distribution is to run
the *bdist_rpm* command:

     python setup.py bdist_rpm

  or the *bdist* command with the ‘--format’ option:

     python setup.py bdist --formats=rpm

  The former allows you to specify RPM-specific options; the latter
allows you to easily specify multiple formats in one run.  If you need
to do both, you can explicitly specify multiple *bdist_** commands and
their options:

     python setup.py bdist_rpm --packager="John Doe <jdoe@example.org>" \
                     bdist_wininst --target-version="2.0"

  Creating RPM packages is driven by a ‘.spec’ file, much as using the
Distutils is driven by the setup script.  To make your life easier, the
*bdist_rpm* command normally creates a ‘.spec’ file based on the
information you supply in the setup script, on the command line, and in
any Distutils configuration files.  Various options and sections in the
‘.spec’ file are derived from options in the setup script as follows:

RPM ‘.spec’ file option or section             Distutils setup script option
                                               
--------------------------------------------------------------------------------------------------
                                               
Name                                           ‘name’
                                               
                                               
Summary (in preamble)                          ‘description’
                                               
                                               
Version                                        ‘version’
                                               
                                               
Vendor                                         ‘author’ and ‘author_email’, or — & ‘maintainer’
                                               and ‘maintainer_email’
                                               
                                               
Copyright                                      ‘license’
                                               
                                               
Url                                            ‘url’
                                               
                                               
%description (section)                         ‘long_description’
                                               

  Additionally, there are many options in ‘.spec’ files that don’t have
corresponding options in the setup script.  Most of these are handled
through options to the *bdist_rpm* command as follows:

RPM ‘.spec’ file option or          *bdist_rpm* option                default value
section                                                               

----------------------------------------------------------------------------------------------------
                                                                      
Release                             ‘release’                         "1"
                                                                      
                                                                      
Group                               ‘group’                           "Development/Libraries"
                                                                      
                                                                      
Vendor                              ‘vendor’                          (see above)
                                                                      
                                                                      
Packager                            ‘packager’                        (none)
                                                                      
                                                                      
Provides                            ‘provides’                        (none)
                                                                      
                                                                      
Requires                            ‘requires’                        (none)
                                                                      
                                                                      
Conflicts                           ‘conflicts’                       (none)
                                                                      
                                                                      
Obsoletes                           ‘obsoletes’                       (none)
                                                                      
                                                                      
Distribution                        ‘distribution_name’               (none)
                                                                      
                                                                      
BuildRequires                       ‘build_requires’                  (none)
                                                                      
                                                                      
Icon                                ‘icon’                            (none)
                                                                      

  Obviously, supplying even a few of these options on the command-line
would be tedious and error-prone, so it’s usually best to put them in
the setup configuration file, ‘setup.cfg’—see section *note Writing the
Setup Configuration File: 2ea0.  If you distribute or package many
Python module distributions, you might want to put options that apply to
all of them in your personal Distutils configuration file
(‘~/.pydistutils.cfg’).  If you want to temporarily disable this file,
you can pass the –no-user-cfg option to setup.py.

  There are three steps to building a binary RPM package, all of which
are handled automatically by the Distutils:

  1. create a ‘.spec’ file, which describes the package (analogous to
     the Distutils setup script; in fact, much of the information in the
     setup script winds up in the ‘.spec’ file)

  2. create the source RPM

  3. create the "binary" RPM (which may or may not contain binary code,
     depending on whether your module distribution contains Python
     extensions)

  Normally, RPM bundles the last two steps together; when you use the
Distutils, all three steps are typically bundled together.

  If you wish, you can separate these three steps.  You can use the
‘--spec-only’ option to make *bdist_rpm* just create the ‘.spec’ file
and exit; in this case, the ‘.spec’ file will be written to the
"distribution directory"—normally ‘dist/’, but customizable with the
‘--dist-dir’ option.  (Normally, the ‘.spec’ file winds up deep in the
"build tree," in a temporary directory created by *bdist_rpm*.)


File: python.info,  Node: Creating Windows Installers,  Next: Cross-compiling on Windows,  Prev: Creating RPM packages,  Up: Creating Built Distributions

8.5.3 Creating Windows Installers
---------------------------------

Executable installers are the natural format for binary distributions on
Windows.  They display a nice graphical user interface, display some
information about the module distribution to be installed taken from the
metadata in the setup script, let the user select a few options, and
start or cancel the installation.

  Since the metadata is taken from the setup script, creating Windows
installers is usually as easy as running:

     python setup.py bdist_wininst

  or the *bdist* command with the ‘--formats’ option:

     python setup.py bdist --formats=wininst

  If you have a pure module distribution (only containing pure Python
modules and packages), the resulting installer will be version
independent and have a name like ‘foo-1.0.win32.exe’.  These installers
can even be created on Unix platforms or Mac OS X.

  If you have a non-pure distribution, the extensions can only be
created on a Windows platform, and will be Python version dependent.
The installer filename will reflect this and now has the form
‘foo-1.0.win32-py2.0.exe’.  You have to create a separate installer for
every Python version you want to support.

  The installer will try to compile pure modules into *note bytecode:
583. after installation on the target system in normal and optimizing
mode.  If you don’t want this to happen for some reason, you can run the
*bdist_wininst* command with the ‘--no-target-compile’ and/or the
‘--no-target-optimize’ option.

  By default the installer will display the cool "Python Powered" logo
when it is run, but you can also supply your own 152x261 bitmap which
must be a Windows ‘.bmp’ file with the ‘--bitmap’ option.

  The installer will also display a large title on the desktop
background window when it is run, which is constructed from the name of
your distribution and the version number.  This can be changed to
another text by using the ‘--title’ option.

  The installer file will be written to the "distribution directory" —
normally ‘dist/’, but customizable with the ‘--dist-dir’ option.


File: python.info,  Node: Cross-compiling on Windows,  Next: Vista User Access Control UAC,  Prev: Creating Windows Installers,  Up: Creating Built Distributions

8.5.4 Cross-compiling on Windows
--------------------------------

Starting with Python 2.6, distutils is capable of cross-compiling
between Windows platforms.  In practice, this means that with the
correct tools installed, you can use a 32bit version of Windows to
create 64bit extensions and vice-versa.

  To build for an alternate platform, specify the ‘--plat-name’ option
to the build command.  Valid values are currently ’win32’, ’win-amd64’
and ’win-ia64’.  For example, on a 32bit version of Windows, you could
execute:

     python setup.py build --plat-name=win-amd64

  to build a 64bit version of your extension.  The Windows Installers
also support this option, so the command:

     python setup.py build --plat-name=win-amd64 bdist_wininst

  would create a 64bit installation executable on your 32bit version of
Windows.

  To cross-compile, you must download the Python source code and
cross-compile Python itself for the platform you are targetting - it is
not possible from a binary installation of Python (as the .lib etc file
for other platforms are not included.)  In practice, this means the user
of a 32 bit operating system will need to use Visual Studio 2008 to open
the ‘PCBuild/PCbuild.sln’ solution in the Python source tree and build
the "x64" configuration of the ’pythoncore’ project before
cross-compiling extensions is possible.

  Note that by default, Visual Studio 2008 does not install 64bit
compilers or tools.  You may need to reexecute the Visual Studio setup
process and select these tools (using Control Panel->[Add/Remove]
Programs is a convenient way to check or modify your existing install.)

* Menu:

* The Postinstallation script:: 


File: python.info,  Node: The Postinstallation script,  Up: Cross-compiling on Windows

8.5.4.1 The Postinstallation script
...................................

Starting with Python 2.3, a postinstallation script can be specified
with the ‘--install-script’ option.  The basename of the script must be
specified, and the script filename must also be listed in the scripts
argument to the setup function.

  This script will be run at installation time on the target system
after all the files have been copied, with ‘argv[1]’ set to ‘-install’,
and again at uninstallation time before the files are removed with
‘argv[1]’ set to ‘-remove’.

  The installation script runs embedded in the windows installer, every
output (‘sys.stdout’, ‘sys.stderr’) is redirected into a buffer and will
be displayed in the GUI after the script has finished.

  Some functions especially useful in this context are available as
additional built-in functions in the installation script.

 -- Function: directory_created (path)
 -- Function: file_created (path)

     These functions should be called when a directory or file is
     created by the postinstall script at installation time.  It will
     register _path_ with the uninstaller, so that it will be removed
     when the distribution is uninstalled.  To be safe, directories are
     only removed if they are empty.

 -- Function: get_special_folder_path (csidl_string)

     This function can be used to retrieve special folder locations on
     Windows like the Start Menu or the Desktop.  It returns the full
     path to the folder.  _csidl_string_ must be one of the following
     strings:

          "CSIDL_APPDATA"

          "CSIDL_COMMON_STARTMENU"
          "CSIDL_STARTMENU"

          "CSIDL_COMMON_DESKTOPDIRECTORY"
          "CSIDL_DESKTOPDIRECTORY"

          "CSIDL_COMMON_STARTUP"
          "CSIDL_STARTUP"

          "CSIDL_COMMON_PROGRAMS"
          "CSIDL_PROGRAMS"

          "CSIDL_FONTS"

     If the folder cannot be retrieved, *note OSError: 231. is raised.

     Which folders are available depends on the exact Windows version,
     and probably also the configuration.  For details refer to
     Microsoft’s documentation of the ‘SHGetSpecialFolderPath()’
     function.

 -- Function: create_shortcut (target, description, filename[,
          arguments[, workdir[, iconpath[, iconindex]]]])

     This function creates a shortcut.  _target_ is the path to the
     program to be started by the shortcut.  _description_ is the
     description of the shortcut.  _filename_ is the title of the
     shortcut that the user will see.  _arguments_ specifies the command
     line arguments, if any.  _workdir_ is the working directory for the
     program.  _iconpath_ is the file containing the icon for the
     shortcut, and _iconindex_ is the index of the icon in the file
     _iconpath_.  Again, for details consult the Microsoft documentation
     for the ‘IShellLink’ interface.


File: python.info,  Node: Vista User Access Control UAC,  Prev: Cross-compiling on Windows,  Up: Creating Built Distributions

8.5.5 Vista User Access Control (UAC)
-------------------------------------

Starting with Python 2.6, bdist_wininst supports a
‘--user-access-control’ option.  The default is ’none’ (meaning no UAC
handling is done), and other valid values are ’auto’ (meaning prompt for
UAC elevation if Python was installed for all users) and ’force’
(meaning always prompt for elevation).


File: python.info,  Node: The Python Package Index PyPI,  Next: Examples<24>,  Prev: Creating Built Distributions,  Up: Distributing Python Modules

8.6 The Python Package Index (PyPI)
===================================

The Python Package Index (PyPI)(1) holds *note meta-data: 2e83.
describing distributions packaged with distutils, as well as package
data like distribution files if the package author wishes.

  Distutils exposes two commands for submitting package data to PyPI:
the *note register: 2e9a. command for submitting meta-data to PyPI and
the *note upload: 2ec2. command for submitting distribution files.  Both
commands read configuration data from a special file called the *note
.pypirc file: 2ec3.  PyPI *note displays a home page: 2e9b. for each
package created from the ‘long_description’ submitted by the *register*
command.

* Menu:

* Registering Packages:: 
* Uploading Packages:: 
* The .pypirc file: The pypirc file. 
* PyPI package display:: 

   ---------- Footnotes ----------

   (1) http://pypi.python.org/


File: python.info,  Node: Registering Packages,  Next: Uploading Packages,  Up: The Python Package Index PyPI

8.6.1 Registering Packages
--------------------------

The distutils command *register* is used to submit your distribution’s
meta-data to the index.  It is invoked as follows:

     python setup.py register

  Distutils will respond with the following prompt:

     running register
     We need to know who you are, so please choose either:
         1. use your existing login,
         2. register as a new user,
         3. have the server generate a new password for you (and email it to you), or
         4. quit
     Your selection [default 1]:

  Note: if your username and password are saved locally, you will not
see this menu.

  If you have not registered with PyPI, then you will need to do so now.
You should choose option 2, and enter your details as required.  Soon
after submitting your details, you will receive an email which will be
used to confirm your registration.

  Once you are registered, you may choose option 1 from the menu.  You
will be prompted for your PyPI username and password, and *register*
will then submit your meta-data to the index.

  You may submit any number of versions of your distribution to the
index.  If you alter the meta-data for a particular version, you may
submit it again and the index will be updated.

  PyPI holds a record for each (name, version) combination submitted.
The first user to submit information for a given name is designated the
Owner of that name.  They may submit changes through the *register*
command or through the web interface.  They may also designate other
users as Owners or Maintainers.  Maintainers may edit the package
information, but not designate other Owners or Maintainers.

  By default PyPI displays only the newest version of a given package.
The web interface lets one change this default behavior and manually
select which versions to display and hide.


File: python.info,  Node: Uploading Packages,  Next: The pypirc file,  Prev: Registering Packages,  Up: The Python Package Index PyPI

8.6.2 Uploading Packages
------------------------

New in version 2.5.

  The distutils command *upload* pushes the distribution files to PyPI.

  The command is invoked immediately after building one or more
distribution files.  For example, the command

     python setup.py sdist bdist_wininst upload

  will cause the source distribution and the Windows installer to be
uploaded to PyPI. Note that these will be uploaded even if they are
built using an earlier invocation of ‘setup.py’, but that only
distributions named on the command line for the invocation including the
*upload* command are uploaded.

  The *upload* command uses the username, password, and repository URL
from the ‘$HOME/.pypirc’ file (see section *note The .pypirc file: 2ec3.
for more on this file).  If a *register* command was previously called
in the same command, and if the password was entered in the prompt,
*upload* will reuse the entered password.  This is useful if you do not
want to store a clear text password in the ‘$HOME/.pypirc’ file.

  You can specify another PyPI server with the ‘--repository=url’
option:

     python setup.py sdist bdist_wininst upload -r http://example.com/pypi

  See section *note The .pypirc file: 2ec3. for more on defining several
servers.

  You can use the ‘--sign’ option to tell *upload* to sign each uploaded
file using GPG (GNU Privacy Guard).  The *gpg* program must be available
for execution on the system ‘PATH’.  You can also specify which key to
use for signing using the ‘--identity=name’ option.

  Other *upload* options include ‘--repository=url’ or
‘--repository=section’ where _url_ is the url of the server and
_section_ the name of the section in ‘$HOME/.pypirc’, and
‘--show-response’ (which displays the full response text from the PyPI
server for help in debugging upload problems).


File: python.info,  Node: The pypirc file,  Next: PyPI package display,  Prev: Uploading Packages,  Up: The Python Package Index PyPI

8.6.3 The .pypirc file
----------------------

The format of the ‘.pypirc’ file is as follows:

     [distutils]
     index-servers =
         pypi

     [pypi]
     repository: <repository-url>
     username: <username>
     password: <password>

  The _distutils_ section defines a _index-servers_ variable that lists
the name of all sections describing a repository.

  Each section describing a repository defines three variables:

   - 
     _repository_, that defines the url of the PyPI server. Defaults to

          ‘http://www.python.org/pypi’.

   - _username_, which is the registered username on the PyPI server.

   - 
     _password_, that will be used to authenticate. If omitted the user

          will be prompt to type it when needed.

  If you want to define another server a new section can be created and
listed in the _index-servers_ variable:

     [distutils]
     index-servers =
         pypi
         other

     [pypi]
     repository: <repository-url>
     username: <username>
     password: <password>

     [other]
     repository: http://example.com/pypi
     username: <username>
     password: <password>

  *register* can then be called with the -r option to point the
repository to work with:

     python setup.py register -r http://example.com/pypi

  For convenience, the name of the section that describes the repository
may also be used:

     python setup.py register -r other


File: python.info,  Node: PyPI package display,  Prev: The pypirc file,  Up: The Python Package Index PyPI

8.6.4 PyPI package display
--------------------------

The ‘long_description’ field plays a special role at PyPI. It is used by
the server to display a home page for the registered package.

  If you use the reStructuredText(1) syntax for this field, PyPI will
parse it and display an HTML output for the package home page.

  The ‘long_description’ field can be attached to a text file located in
the package:

     from distutils.core import setup

     with open('README.txt') as file:
         long_description = file.read()

     setup(name='Distutils',
           long_description=long_description)

  In that case, ‘README.txt’ is a regular reStructuredText text file
located in the root of the package besides ‘setup.py’.

  To prevent registering broken reStructuredText content, you can use
the *rst2html* program that is provided by the ‘docutils’ package and
check the ‘long_description’ from the command line:

     $ python setup.py --long-description | rst2html.py > output.html

  ‘docutils’ will display a warning if there’s something wrong with your
syntax.  Because PyPI applies additional checks (e.g.  by passing
‘--no-raw’ to ‘rst2html.py’ in the command above), being able to run the
command above without warnings does not guarantee that PyPI will convert
the content successfully.

   ---------- Footnotes ----------

   (1) http://docutils.sourceforge.net/rst.html


File: python.info,  Node: Examples<24>,  Next: Extending Distutils,  Prev: The Python Package Index PyPI,  Up: Distributing Python Modules

8.7 Examples
============

This chapter provides a number of basic examples to help get started
with distutils.  Additional information about using distutils can be
found in the Distutils Cookbook.

See also
........

Distutils Cookbook(1)

     Collection of recipes showing how to achieve more control over
     distutils.

* Menu:

* Pure Python distribution (by module): Pure Python distribution by module. 
* Pure Python distribution (by package): Pure Python distribution by package. 
* Single extension module:: 

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/Distutils/Cookbook


File: python.info,  Node: Pure Python distribution by module,  Next: Pure Python distribution by package,  Up: Examples<24>

8.7.1 Pure Python distribution (by module)
------------------------------------------

If you’re just distributing a couple of modules, especially if they
don’t live in a particular package, you can specify them individually
using the ‘py_modules’ option in the setup script.

  In the simplest case, you’ll have two files to worry about: a setup
script and the single module you’re distributing, ‘foo.py’ in this
example:

     <root>/
             setup.py
             foo.py

  (In all diagrams in this section, _<root>_ will refer to the
distribution root directory.)  A minimal setup script to describe this
situation would be:

     from distutils.core import setup
     setup(name='foo',
           version='1.0',
           py_modules=['foo'],
           )

  Note that the name of the distribution is specified independently with
the ‘name’ option, and there’s no rule that says it has to be the same
as the name of the sole module in the distribution (although that’s
probably a good convention to follow).  However, the distribution name
is used to generate filenames, so you should stick to letters, digits,
underscores, and hyphens.

  Since ‘py_modules’ is a list, you can of course specify multiple
modules, eg.  if you’re distributing modules ‘foo’ and ‘bar’, your setup
might look like this:

     <root>/
             setup.py
             foo.py
             bar.py

  and the setup script might be

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           py_modules=['foo', 'bar'],
           )

  You can put module source files into another directory, but if you
have enough modules to do that, it’s probably easier to specify modules
by package rather than listing them individually.


File: python.info,  Node: Pure Python distribution by package,  Next: Single extension module,  Prev: Pure Python distribution by module,  Up: Examples<24>

8.7.2 Pure Python distribution (by package)
-------------------------------------------

If you have more than a couple of modules to distribute, especially if
they are in multiple packages, it’s probably easier to specify whole
packages rather than individual modules.  This works even if your
modules are not in a package; you can just tell the Distutils to process
modules from the root package, and that works the same as any other
package (except that you don’t have to have an ‘__init__.py’ file).

  The setup script from the last example could also be written as

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=[''],
           )

  (The empty string stands for the root package.)

  If those two files are moved into a subdirectory, but remain in the
root package, e.g.:

     <root>/
             setup.py
             src/      foo.py
                       bar.py

  then you would still specify the root package, but you have to tell
the Distutils where source files in the root package live:

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'': 'src'},
           packages=[''],
           )

  More typically, though, you will want to distribute multiple modules
in the same package (or in sub-packages).  For example, if the ‘foo’ and
‘bar’ modules belong in package ‘foobar’, one way to layout your source
tree is

     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py

  This is in fact the default layout expected by the Distutils, and the
one that requires the least work to describe in your setup script:

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=['foobar'],
           )

  If you want to put modules in directories not named for their package,
then you need to use the ‘package_dir’ option again.  For example, if
the ‘src’ directory holds modules in the ‘foobar’ package:

     <root>/
             setup.py
             src/
                      __init__.py
                      foo.py
                      bar.py

  an appropriate setup script would be

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'foobar': 'src'},
           packages=['foobar'],
           )

  Or, you might put modules from your main package right in the
distribution root:

     <root>/
             setup.py
             __init__.py
             foo.py
             bar.py

  in which case your setup script would be

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'foobar': ''},
           packages=['foobar'],
           )

  (The empty string also stands for the current directory.)

  If you have sub-packages, they must be explicitly listed in
‘packages’, but any entries in ‘package_dir’ automatically extend to
sub-packages.  (In other words, the Distutils does _not_ scan your
source tree, trying to figure out which directories correspond to Python
packages by looking for ‘__init__.py’ files.)  Thus, if the default
layout grows a sub-package:

     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py
                      subfoo/
                                __init__.py
                                blah.py

  then the corresponding setup script would be

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=['foobar', 'foobar.subfoo'],
           )


File: python.info,  Node: Single extension module,  Prev: Pure Python distribution by package,  Up: Examples<24>

8.7.3 Single extension module
-----------------------------

Extension modules are specified using the ‘ext_modules’ option.
‘package_dir’ has no effect on where extension source files are found;
it only affects the source for pure Python modules.  The simplest case,
a single extension module in a single C source file, is:

     <root>/
             setup.py
             foo.c

  If the ‘foo’ extension belongs in the root package, the setup script
for this could be

     from distutils.core import setup
     from distutils.extension import Extension
     setup(name='foobar',
           version='1.0',
           ext_modules=[Extension('foo', ['foo.c'])],
           )

  If the extension actually belongs in a package, say ‘foopkg’, then

  With exactly the same source tree layout, this extension can be put in
the ‘foopkg’ package simply by changing the name of the extension:

     from distutils.core import setup
     from distutils.extension import Extension
     setup(name='foobar',
           version='1.0',
           ext_modules=[Extension('foopkg.foo', ['foo.c'])],
           )


File: python.info,  Node: Extending Distutils,  Next: Command Reference,  Prev: Examples<24>,  Up: Distributing Python Modules

8.8 Extending Distutils
=======================

Distutils can be extended in various ways.  Most extensions take the
form of new commands or replacements for existing commands.  New
commands may be written to support new types of platform-specific
packaging, for example, while replacements for existing commands may be
made to modify details of how the command operates on a package.

  Most extensions of the distutils are made within ‘setup.py’ scripts
that want to modify existing commands; many simply add a few file
extensions that should be copied into packages in addition to ‘.py’
files as a convenience.

  Most distutils command implementations are subclasses of the *note
distutils.cmd.Command: 2ed4. class.  New commands may directly inherit
from ‘Command’, while replacements often derive from ‘Command’
indirectly, directly subclassing the command they are replacing.
Commands are required to derive from ‘Command’.

* Menu:

* Integrating new commands:: 
* Adding new distribution types:: 


File: python.info,  Node: Integrating new commands,  Next: Adding new distribution types,  Up: Extending Distutils

8.8.1 Integrating new commands
------------------------------

There are different ways to integrate new command implementations into
distutils.  The most difficult is to lobby for the inclusion of the new
features in distutils itself, and wait for (and require) a version of
Python that provides that support.  This is really hard for many
reasons.

  The most common, and possibly the most reasonable for most needs, is
to include the new implementations with your ‘setup.py’ script, and
cause the *note distutils.core.setup(): 2e91. function use them:

     from distutils.command.build_py import build_py as _build_py
     from distutils.core import setup

     class build_py(_build_py):
         """Specialized Python source builder."""

         # implement whatever needs to be different...

     setup(cmdclass={'build_py': build_py},
           ...)

  This approach is most valuable if the new implementations must be used
to use a particular package, as everyone interested in the package will
need to have the new command implementation.

  Beginning with Python 2.4, a third option is available, intended to
allow new commands to be added which can support existing ‘setup.py’
scripts without requiring modifications to the Python installation.
This is expected to allow third-party extensions to provide support for
additional packaging systems, but the commands can be used for anything
distutils commands can be used for.  A new configuration option,
‘command_packages’ (command-line option ‘--command-packages’), can be
used to specify additional packages to be searched for modules
implementing commands.  Like all distutils options, this can be
specified on the command line or in a configuration file.  This option
can only be set in the ‘[global]’ section of a configuration file, or
before any commands on the command line.  If set in a configuration
file, it can be overridden from the command line; setting it to an empty
string on the command line causes the default to be used.  This should
never be set in a configuration file provided with a package.

  This new option can be used to add any number of packages to the list
of packages searched for command implementations; multiple package names
should be separated by commas.  When not specified, the search is only
performed in the *note distutils.command: 8a. package.  When ‘setup.py’
is run with the option ‘--command-packages’ ‘distcmds,buildcmds’,
however, the packages *note distutils.command: 8a, ‘distcmds’, and
‘buildcmds’ will be searched in that order.  New commands are expected
to be implemented in modules of the same name as the command by classes
sharing the same name.  Given the example command line option above, the
command *bdist_openpkg* could be implemented by the class
‘distcmds.bdist_openpkg.bdist_openpkg’ or
‘buildcmds.bdist_openpkg.bdist_openpkg’.


File: python.info,  Node: Adding new distribution types,  Prev: Integrating new commands,  Up: Extending Distutils

8.8.2 Adding new distribution types
-----------------------------------

Commands that create distributions (files in the ‘dist/’ directory) need
to add ‘(command, filename)’ pairs to ‘self.distribution.dist_files’ so
that *upload* can upload it to PyPI. The _filename_ in the pair contains
no path information, only the name of the file itself.  In dry-run mode,
pairs should still be added to represent what would have been created.


File: python.info,  Node: Command Reference,  Next: API Reference,  Prev: Extending Distutils,  Up: Distributing Python Modules

8.9 Command Reference
=====================

* Menu:

* Installing modules; the install command family: Installing modules the install command family. 

Installing modules: the install command family

* install_data:: 
* install_scripts:: 


File: python.info,  Node: Installing modules the install command family,  Up: Command Reference

8.9.1 Installing modules: the *install* command family
------------------------------------------------------

The install command ensures that the build commands have been run and
then runs the subcommands *install_lib*, *install_data* and
*install_scripts*.

* Menu:

* install_data:: 
* install_scripts:: 


File: python.info,  Node: install_data,  Next: install_scripts,  Up: Installing modules the install command family

8.9.1.1 *install_data*
......................

This command installs all data files provided with the distribution.


File: python.info,  Node: install_scripts,  Prev: install_data,  Up: Installing modules the install command family

8.9.1.2 *install_scripts*
.........................

This command installs all (Python) scripts in the distribution.


File: python.info,  Node: API Reference,  Prev: Command Reference,  Up: Distributing Python Modules

8.10 API Reference
==================

* Menu:

* distutils.core: distutils core --- Core Distutils functionality. Core Distutils functionality
* distutils.ccompiler: distutils ccompiler --- CCompiler base class. CCompiler base class
* distutils.unixccompiler: distutils unixccompiler --- Unix C Compiler. Unix C Compiler
* distutils.msvccompiler: distutils msvccompiler --- Microsoft Compiler. Microsoft Compiler
* distutils.bcppcompiler: distutils bcppcompiler --- Borland Compiler. Borland Compiler
* distutils.cygwincompiler: distutils cygwincompiler --- Cygwin Compiler. Cygwin Compiler
* distutils.emxccompiler: distutils emxccompiler --- OS/2 EMX Compiler. OS/2 EMX Compiler
* distutils.archive_util: distutils archive_util --- Archiving utilities. Archiving utilities
* distutils.dep_util: distutils dep_util --- Dependency checking. Dependency checking
* distutils.dir_util: distutils dir_util --- Directory tree operations. Directory tree operations
* distutils.file_util: distutils file_util --- Single file operations. Single file operations
* distutils.util: distutils util --- Miscellaneous other utility functions. Miscellaneous other utility functions
* distutils.dist: distutils dist --- The Distribution class. The Distribution class
* distutils.extension: distutils extension --- The Extension class. The Extension class
* distutils.debug: distutils debug --- Distutils debug mode. Distutils debug mode
* distutils.errors: distutils errors --- Distutils exceptions. Distutils exceptions
* distutils.fancy_getopt: distutils fancy_getopt --- Wrapper around the standard getopt module. Wrapper around the standard getopt module
* distutils.filelist: distutils filelist --- The FileList class. The FileList class
* distutils.log: distutils log --- Simple PEP 282-style logging. Simple PEP 282-style logging
* distutils.spawn: distutils spawn --- Spawn a sub-process. Spawn a sub-process
* distutils.sysconfig: distutils sysconfig --- System configuration information. System configuration information
* distutils.text_file: distutils text_file --- The TextFile class. The TextFile class
* distutils.version: distutils version --- Version number classes. Version number classes
* distutils.cmd: distutils cmd --- Abstract base class for Distutils commands. Abstract base class for Distutils commands
* Creating a new Distutils command:: 
* distutils.command: distutils command --- Individual Distutils commands. Individual Distutils commands
* distutils.command.bdist: distutils command bdist --- Build a binary installer. Build a binary installer
* distutils.command.bdist_packager: distutils command bdist_packager --- Abstract base class for packagers. Abstract base class for packagers
* distutils.command.bdist_dumb: distutils command bdist_dumb --- Build a "dumb" installer. Build a "dumb" installer
* distutils.command.bdist_msi: distutils command bdist_msi --- Build a Microsoft Installer binary package. Build a Microsoft Installer binary package
* distutils.command.bdist_rpm: distutils command bdist_rpm --- Build a binary distribution as a Redhat RPM and SRPM. Build a binary distribution as a Redhat RPM and
                               SRPM
* distutils.command.bdist_wininst: distutils command bdist_wininst --- Build a Windows installer. Build a Windows installer
* distutils.command.sdist: distutils command sdist --- Build a source distribution. Build a source distribution
* distutils.command.build: distutils command build --- Build all files of a package. Build all files of a package
* distutils.command.build_clib: distutils command build_clib --- Build any C libraries in a package. Build any C libraries in a package
* distutils.command.build_ext: distutils command build_ext --- Build any extensions in a package. Build any extensions in a package
* distutils.command.build_py: distutils command build_py --- Build the py/ pyc files of a package. Build the .py/.pyc files of a package
* distutils.command.build_scripts: distutils command build_scripts --- Build the scripts of a package. Build the scripts of a package
* distutils.command.clean: distutils command clean --- Clean a package build area. Clean a package build area
* distutils.command.config: distutils command config --- Perform package configuration. Perform package configuration
* distutils.command.install: distutils command install --- Install a package. Install a package
* distutils.command.install_data: distutils command install_data --- Install data files from a package. Install data files from a package
* distutils.command.install_headers: distutils command install_headers --- Install C/C++ header files from a package. Install C/C++ header files from a package
* distutils.command.install_lib: distutils command install_lib --- Install library files from a package. Install library files from a package
* distutils.command.install_scripts: distutils command install_scripts --- Install script files from a package. Install script files from a package
* distutils.command.register: distutils command register --- Register a module with the Python Package Index. Register a module with the Python Package Index
* distutils.command.check: distutils command check --- Check the meta-data of a package. Check the meta-data of a package


File: python.info,  Node: distutils core --- Core Distutils functionality,  Next: distutils ccompiler --- CCompiler base class,  Up: API Reference

8.10.1 ‘distutils.core’ — Core Distutils functionality
------------------------------------------------------

The *note distutils.core: a0. module is the only module that needs to be
installed to use the Distutils.  It provides the *note setup(): 2e91.
(which is called from the setup script).  Indirectly provides the
‘distutils.dist.Distribution’ and *note distutils.cmd.Command: 2ed4.
class.

 -- Function: distutils.core.setup (arguments)

     The basic do-everything function that does most everything you
     could ever ask for from a Distutils method.

     The setup function takes a large number of arguments.  These are
     laid out in the following table.

     argument name            value                                type
                                                                   
     --------------------------------------------------------------------------------------------------------------------------------
                                                                   
     _name_                   The name of the package              a string
                                                                   
                                                                   
     _version_                The version number of the package;   a string
                              see *note distutils.version: b3.     
                              
                                                                   
     _description_            A single line describing the         a string
                              package                              
                              
                                                                   
     _long_description_       Longer description of the package    a string
                                                                   
                                                                   
     _author_                 The name of the package author       a string
                                                                   
                                                                   
     _author_email_           The email address of the package     a string
                              author                               
                              
                                                                   
     _maintainer_             The name of the current              a string
                              maintainer, if different from the    
                              author.  Note that if the
                              maintainer is provided, distutils
                              will use it as the author in
                              ‘PKG-INFO’
                              
                                                                   
     _maintainer_email_       The email address of the current     a string
                              maintainer, if different from the    
                              author
                              
                                                                   
     _url_                    A URL for the package (homepage)     a string
                                                                   
                                                                   
     _download_url_           A URL to download the package        a string
                                                                   
                                                                   
     _packages_               A list of Python packages that       a list of strings
                              distutils will manipulate            
                              
                                                                   
     _py_modules_             A list of Python modules that        a list of strings
                              distutils will manipulate            
                              
                                                                   
     _scripts_                A list of standalone script files    a list of strings
                              to be built and installed            
                              
                                                                   
     _ext_modules_            A list of Python extensions to be    a list of instances of *note distutils.core.Extension: 2e8a.
                              built                                
                              
                                                                   
     _classifiers_            A list of categories for the         a list of strings; valid classifiers are listed on PyPI(1).
                              package                              
                              
                                                                   
     _distclass_              the *note Distribution: 2ee4.        a subclass of *note distutils.core.Distribution: 2ee4.
                              class to use                         
                              
                                                                   
     _script_name_            The name of the setup.py script -    a string
                              defaults to ‘sys.argv[0]’            
                              
                                                                   
     _script_args_            Arguments to supply to the setup     a list of strings
                              script                               
                              
                                                                   
     _options_                default options for the setup        a dictionary
                              script                               
                              
                                                                   
     _license_                The license for the package          a string
                                                                   
                                                                   
     _keywords_               Descriptive meta-data, see PEP       a list of strings or a comma-separated string
                              314(2)                               
                              
                                                                   
     _platforms_                                                   a list of strings or a comma-separated string
                                                                   
                                                                   
     _cmdclass_               A mapping of command names to        a dictionary
                              *note Command: 2ee5. subclasses      
                              
                                                                   
     _data_files_             A list of data files to install      a list
                                                                   
                                                                   
     _package_dir_            A mapping of package to directory    a dictionary
                              names                                
                              

 -- Function: distutils.core.run_setup (script_name[, script_args=None,
          stop_after='run'])

     Run a setup script in a somewhat controlled environment, and return
     the ‘distutils.dist.Distribution’ instance that drives things.
     This is useful if you need to find out the distribution meta-data
     (passed as keyword args from _script_ to *note setup(): 2e91.), or
     the contents of the config files or command-line.

     _script_name_ is a file that will be run with *note execfile():
     436. ‘sys.argv[0]’ will be replaced with _script_ for the duration
     of the call.  _script_args_ is a list of strings; if supplied,
     ‘sys.argv[1:]’ will be replaced by _script_args_ for the duration
     of the call.

     _stop_after_ tells *note setup(): 2e91. when to stop processing;
     possible values:

     value               description
                         
     ----------------------------------------------------------------------
                         
     _init_              Stop after the *note Distribution: 2ee4.
                         instance has been created and populated with
                         the keyword arguments to *note setup(): 2e91.
                         
                         
     _config_            Stop after config files have been parsed (and
                         their data stored in the *note Distribution:
                         2ee4. instance)
                         
                         
     _commandline_       Stop after the command-line (‘sys.argv[1:]’ or
                         _script_args_) have been parsed (and the data
                         stored in the *note Distribution: 2ee4.
                         instance.)
                         
                         
     _run_               Stop after all commands have been run (the same
                         as if *note setup(): 2e91. had been called in
                         the usual way).  This is the default value.
                         

  In addition, the *note distutils.core: a0. module exposed a number of
classes that live elsewhere.

   * ‘Extension’ from *note distutils.extension: a8.

   * *note Command: 2ed4. from *note distutils.cmd: 89.

   * ‘Distribution’ from *note distutils.dist: a5.

  A short description of each of these follows, but see the relevant
module for the full reference.

 -- Class: distutils.core.Extension

     The Extension class describes a single C or C++extension module in
     a setup script.  It accepts the following keyword arguments in its
     constructor

     argument name                value                                type
                                                                       
     --------------------------------------------------------------------------------------------------
                                                                       
     _name_                       the full name of the extension,      a string
                                  including any packages — ie.         
                                  _not_ a filename or pathname, but
                                  Python dotted name
                                  
                                                                       
     _sources_                    list of source filenames, relative   a list of strings
                                  to the distribution root (where      
                                  the setup script lives), in Unix
                                  form (slash- separated) for
                                  portability.  Source files may be
                                  C, C++, SWIG (.i),
                                  platform-specific resource files,
                                  or whatever else is recognized by
                                  the *build_ext* command as source
                                  for a Python extension.
                                  
                                                                       
     _include_dirs_               list of directories to search for    a list of strings
                                  C/C++ header files (in Unix form     
                                  for portability)
                                  
                                                                       
     _define_macros_              list of macros to define; each       a list of tuples
                                  macro is defined using a 2-tuple     
                                  ‘(name, value)’, where _value_ is
                                  either the string to define it to
                                  or ‘None’ to define it without a
                                  particular value (equivalent of
                                  ‘#define FOO’ in source or ‘-DFOO’
                                  on Unix C compiler command line)
                                  
                                                                       
     _undef_macros_               list of macros to undefine           a list of strings
                                  explicitly                           
                                  
                                                                       
     _library_dirs_               list of directories to search for    a list of strings
                                  C/C++ libraries at link time         
                                  
                                                                       
     _libraries_                  list of library names (not           a list of strings
                                  filenames or paths) to link          
                                  against
                                  
                                                                       
     _runtime_library_dirs_       list of directories to search for    a list of strings
                                  C/C++ libraries at run time (for     
                                  shared extensions, this is when
                                  the extension is loaded)
                                  
                                                                       
     _extra_objects_              list of extra files to link with     a list of strings
                                  (eg.  object files not implied by    
                                  ’sources’, static library that
                                  must be explicitly specified,
                                  binary resource files, etc.)
                                  
                                                                       
     _extra_compile_args_         any extra platform- and              a list of strings
                                  compiler-specific information to     
                                  use when compiling the source
                                  files in ’sources’.  For platforms
                                  and compilers where a command line
                                  makes sense, this is typically a
                                  list of command-line arguments,
                                  but for other platforms it could
                                  be anything.
                                  
                                                                       
     _extra_link_args_            any extra platform- and              a list of strings
                                  compiler-specific information to     
                                  use when linking object files
                                  together to create the extension
                                  (or to create a new static Python
                                  interpreter).  Similar
                                  interpretation as for
                                  ’extra_compile_args’.
                                  
                                                                       
     _export_symbols_             list of symbols to be exported       a list of strings
                                  from a shared extension.  Not used   
                                  on all platforms, and not
                                  generally necessary for Python
                                  extensions, which typically export
                                  exactly one symbol: ‘init’ +
                                  extension_name.
                                  
                                                                       
     _depends_                    list of files that the extension     a list of strings
                                  depends on                           
                                  
                                                                       
     _language_                   extension language (i.e.  ‘'c'’,     a string
                                  ‘'c++'’, ‘'objc'’).  Will be         
                                  detected from the source
                                  extensions if not provided.
                                  

 -- Class: distutils.core.Distribution

     A *note Distribution: 2ee4. describes how to build, install and
     package up a Python software package.

     See the *note setup(): 2e91. function for a list of keyword
     arguments accepted by the Distribution constructor.  *note setup():
     2e91. creates a Distribution instance.

 -- Class: distutils.core.Command

     A *note Command: 2ee5. class (or rather, an instance of one of its
     subclasses) implement a single distutils command.

   ---------- Footnotes ----------

   (1) http://pypi.python.org/pypi?:action=list_classifiers

   (2) http://www.python.org/dev/peps/pep-0314


File: python.info,  Node: distutils ccompiler --- CCompiler base class,  Next: distutils unixccompiler --- Unix C Compiler,  Prev: distutils core --- Core Distutils functionality,  Up: API Reference

8.10.2 ‘distutils.ccompiler’ — CCompiler base class
---------------------------------------------------

This module provides the abstract base class for the *note CCompiler:
2ee8. classes.  A *note CCompiler: 2ee8. instance can be used for all
the compile and link steps needed to build a single project.  Methods
are provided to set options for the compiler — macro definitions,
include directories, link path, libraries and the like.

  This module provides the following functions.

 -- Function: distutils.ccompiler.gen_lib_options (compiler,
          library_dirs, runtime_library_dirs, libraries)

     Generate linker options for searching library directories and
     linking with specific libraries.  _libraries_ and _library_dirs_
     are, respectively, lists of library names (not filenames!)  and
     search directories.  Returns a list of command-line options
     suitable for use with some compiler (depending on the two format
     strings passed in).

 -- Function: distutils.ccompiler.gen_preprocess_options (macros,
          include_dirs)

     Generate C pre-processor options (‘-D’, *note -U: 64a, ‘-I’) as
     used by at least two types of compilers: the typical Unix compiler
     and Visual C++.  _macros_ is the usual thing, a list of 1- or
     2-tuples, where ‘(name,)’ means undefine (*note -U: 64a.) macro
     _name_, and ‘(name, value)’ means define (‘-D’) macro _name_ to
     _value_.  _include_dirs_ is just a list of directory names to be
     added to the header file search path (‘-I’).  Returns a list of
     command-line options suitable for either Unix compilers or Visual
     C++.

 -- Function: distutils.ccompiler.get_default_compiler (osname,
          platform)

     Determine the default compiler to use for the given platform.

     _osname_ should be one of the standard Python OS names (i.e.  the
     ones returned by ‘os.name’) and _platform_ the common value
     returned by ‘sys.platform’ for the platform in question.

     The default values are ‘os.name’ and ‘sys.platform’ in case the
     parameters are not given.

 -- Function: distutils.ccompiler.new_compiler (plat=None,
          compiler=None, verbose=0, dry_run=0, force=0)

     Factory function to generate an instance of some CCompiler subclass
     for the supplied platform/compiler combination.  _plat_ defaults to
     ‘os.name’ (eg.  ‘'posix'’, ‘'nt'’), and _compiler_ defaults to the
     default compiler for that platform.  Currently only ‘'posix'’ and
     ‘'nt'’ are supported, and the default compilers are "traditional
     Unix interface" (‘UnixCCompiler’ class) and Visual C++
     (‘MSVCCompiler’ class).  Note that it’s perfectly possible to ask
     for a Unix compiler object under Windows, and a Microsoft compiler
     object under Unix—if you supply a value for _compiler_, _plat_ is
     ignored.

 -- Function: distutils.ccompiler.show_compilers ()

     Print list of available compilers (used by the ‘--help-compiler’
     options to *build*, *build_ext*, *build_clib*).

 -- Class: distutils.ccompiler.CCompiler ([verbose=0, dry_run=0,
          force=0])

     The abstract base class *note CCompiler: 2ee8. defines the
     interface that must be implemented by real compiler classes.  The
     class also has some utility methods used by several compiler
     classes.

     The basic idea behind a compiler abstraction class is that each
     instance can be used for all the compile/link steps in building a
     single project.  Thus, attributes common to all of those compile
     and link steps — include directories, macros to define, libraries
     to link against, etc.  — are attributes of the compiler instance.
     To allow for variability in how individual files are treated, most
     of those attributes may be varied on a per-compilation or per-link
     basis.

     The constructor for each subclass creates an instance of the
     Compiler object.  Flags are _verbose_ (show verbose output),
     _dry_run_ (don’t actually execute the steps) and _force_ (rebuild
     everything, regardless of dependencies).  All of these flags
     default to ‘0’ (off).  Note that you probably don’t want to
     instantiate *note CCompiler: 2ee8. or one of its subclasses
     directly - use the ‘distutils.CCompiler.new_compiler()’ factory
     function instead.

     The following methods allow you to manually alter compiler options
     for the instance of the Compiler class.

      -- Method: add_include_dir (dir)

          Add _dir_ to the list of directories that will be searched for
          header files.  The compiler is instructed to search
          directories in the order in which they are supplied by
          successive calls to *note add_include_dir(): 2eee.

      -- Method: set_include_dirs (dirs)

          Set the list of directories that will be searched to _dirs_ (a
          list of strings).  Overrides any preceding calls to *note
          add_include_dir(): 2eee.; subsequent calls to *note
          add_include_dir(): 2eee. add to the list passed to *note
          set_include_dirs(): 2eef.  This does not affect any list of
          standard include directories that the compiler may search by
          default.

      -- Method: add_library (libname)

          Add _libname_ to the list of libraries that will be included
          in all links driven by this compiler object.  Note that
          _libname_ should *not* be the name of a file containing a
          library, but the name of the library itself: the actual
          filename will be inferred by the linker, the compiler, or the
          compiler class (depending on the platform).

          The linker will be instructed to link against libraries in the
          order they were supplied to *note add_library(): 2ef0. and/or
          *note set_libraries(): 2ef1.  It is perfectly valid to
          duplicate library names; the linker will be instructed to link
          against libraries as many times as they are mentioned.

      -- Method: set_libraries (libnames)

          Set the list of libraries to be included in all links driven
          by this compiler object to _libnames_ (a list of strings).
          This does not affect any standard system libraries that the
          linker may include by default.

      -- Method: add_library_dir (dir)

          Add _dir_ to the list of directories that will be searched for
          libraries specified to *note add_library(): 2ef0. and *note
          set_libraries(): 2ef1.  The linker will be instructed to
          search for libraries in the order they are supplied to *note
          add_library_dir(): 2ef2. and/or *note set_library_dirs():
          2ef3.

      -- Method: set_library_dirs (dirs)

          Set the list of library search directories to _dirs_ (a list
          of strings).  This does not affect any standard library search
          path that the linker may search by default.

      -- Method: add_runtime_library_dir (dir)

          Add _dir_ to the list of directories that will be searched for
          shared libraries at runtime.

      -- Method: set_runtime_library_dirs (dirs)

          Set the list of directories to search for shared libraries at
          runtime to _dirs_ (a list of strings).  This does not affect
          any standard search path that the runtime linker may search by
          default.

      -- Method: define_macro (name[, value=None])

          Define a preprocessor macro for all compilations driven by
          this compiler object.  The optional parameter _value_ should
          be a string; if it is not supplied, then the macro will be
          defined without an explicit value and the exact outcome
          depends on the compiler used.

      -- Method: undefine_macro (name)

          Undefine a preprocessor macro for all compilations driven by
          this compiler object.  If the same macro is defined by *note
          define_macro(): 2ef6. and undefined by *note undefine_macro():
          2ef7. the last call takes precedence (including multiple
          redefinitions or undefinitions).  If the macro is
          redefined/undefined on a per-compilation basis (ie.  in the
          call to *note compile(): 1fb.), then that takes precedence.

      -- Method: add_link_object (object)

          Add _object_ to the list of object files (or analogues, such
          as explicitly named library files or the output of "resource
          compilers") to be included in every link driven by this
          compiler object.

      -- Method: set_link_objects (objects)

          Set the list of object files (or analogues) to be included in
          every link to _objects_.  This does not affect any standard
          object files that the linker may include by default (such as
          system libraries).

     The following methods implement methods for autodetection of
     compiler options, providing some functionality similar to GNU
     *autoconf*.

      -- Method: detect_language (sources)

          Detect the language of a given file, or list of files.  Uses
          the instance attributes ‘language_map’ (a dictionary), and
          ‘language_order’ (a list) to do the job.

      -- Method: find_library_file (dirs, lib[, debug=0])

          Search the specified list of directories for a static or
          shared library file _lib_ and return the full path to that
          file.  If _debug_ is true, look for a debugging version (if
          that makes sense on the current platform).  Return ‘None’ if
          _lib_ wasn’t found in any of the specified directories.

      -- Method: has_function (funcname[, includes=None,
               include_dirs=None, libraries=None, library_dirs=None])

          Return a boolean indicating whether _funcname_ is supported on
          the current platform.  The optional arguments can be used to
          augment the compilation environment by providing additional
          include files and paths and libraries and paths.

      -- Method: library_dir_option (dir)

          Return the compiler option to add _dir_ to the list of
          directories searched for libraries.

      -- Method: library_option (lib)

          Return the compiler option to add _dir_ to the list of
          libraries linked into the shared library or executable.

      -- Method: runtime_library_dir_option (dir)

          Return the compiler option to add _dir_ to the list of
          directories searched for runtime libraries.

      -- Method: set_executables (**args)

          Define the executables (and options for them) that will be run
          to perform the various stages of compilation.  The exact set
          of executables that may be specified here depends on the
          compiler class (via the ’executables’ class attribute), but
          most will have:

          attribute          description
                             
          ------------------------------------------------------------------
                             
          _compiler_         the C/C++ compiler
                             
                             
          _linker_so_        linker used to create shared objects and
                             libraries
                             
                             
          _linker_exe_       linker used to create binary executables
                             
                             
          _archiver_         static library creator
                             

          On platforms with a command-line (Unix, DOS/Windows), each of
          these is a string that will be split into executable name and
          (optional) list of arguments.  (Splitting the string is done
          similarly to how Unix shells operate: words are delimited by
          spaces, but quotes and backslashes can override this.  See
          *note distutils.util.split_quoted(): 2f01.)

     The following methods invoke stages in the build process.

      -- Method: compile (sources[, output_dir=None, macros=None,
               include_dirs=None, debug=0, extra_preargs=None,
               extra_postargs=None, depends=None])

          Compile one or more source files.  Generates object files
          (e.g.  transforms a ‘.c’ file to a ‘.o’ file.)

          _sources_ must be a list of filenames, most likely C/C++
          files, but in reality anything that can be handled by a
          particular compiler and compiler class (eg.  ‘MSVCCompiler’
          can handle resource files in _sources_).  Return a list of
          object filenames, one per source filename in _sources_.
          Depending on the implementation, not all source files will
          necessarily be compiled, but all corresponding object
          filenames will be returned.

          If _output_dir_ is given, object files will be put under it,
          while retaining their original path component.  That is,
          ‘foo/bar.c’ normally compiles to ‘foo/bar.o’ (for a Unix
          implementation); if _output_dir_ is _build_, then it would
          compile to ‘build/foo/bar.o’.

          _macros_, if given, must be a list of macro definitions.  A
          macro definition is either a ‘(name, value)’ 2-tuple or a
          ‘(name,)’ 1-tuple.  The former defines a macro; if the value
          is ‘None’, the macro is defined without an explicit value.
          The 1-tuple case undefines a macro.  Later
          definitions/redefinitions/undefinitions take precedence.

          _include_dirs_, if given, must be a list of strings, the
          directories to add to the default include file search path for
          this compilation only.

          _debug_ is a boolean; if true, the compiler will be instructed
          to output debug symbols in (or alongside) the object file(s).

          _extra_preargs_ and _extra_postargs_ are
          implementation-dependent.  On platforms that have the notion
          of a command-line (e.g.  Unix, DOS/Windows), they are most
          likely lists of strings: extra command-line arguments to
          prepend/append to the compiler command line.  On other
          platforms, consult the implementation class documentation.  In
          any event, they are intended as an escape hatch for those
          occasions when the abstract compiler framework doesn’t cut the
          mustard.

          _depends_, if given, is a list of filenames that all targets
          depend on.  If a source file is older than any file in
          depends, then the source file will be recompiled.  This
          supports dependency tracking, but only at a coarse
          granularity.

          Raises ‘CompileError’ on failure.

      -- Method: create_static_lib (objects, output_libname[,
               output_dir=None, debug=0, target_lang=None])

          Link a bunch of stuff together to create a static library
          file.  The "bunch of stuff" consists of the list of object
          files supplied as _objects_, the extra object files supplied
          to *note add_link_object(): 2ef8. and/or *note
          set_link_objects(): 2ef9, the libraries supplied to *note
          add_library(): 2ef0. and/or *note set_libraries(): 2ef1, and
          the libraries supplied as _libraries_ (if any).

          _output_libname_ should be a library name, not a filename; the
          filename will be inferred from the library name.  _output_dir_
          is the directory where the library file will be put.

          _debug_ is a boolean; if true, debugging information will be
          included in the library (note that on most platforms, it is
          the compile step where this matters: the _debug_ flag is
          included here just for consistency).

          _target_lang_ is the target language for which the given
          objects are being compiled.  This allows specific linkage time
          treatment of certain languages.

          Raises ‘LibError’ on failure.

      -- Method: link (target_desc, objects, output_filename[,
               output_dir=None, libraries=None, library_dirs=None,
               runtime_library_dirs=None, export_symbols=None, debug=0,
               extra_preargs=None, extra_postargs=None, build_temp=None,
               target_lang=None])

          Link a bunch of stuff together to create an executable or
          shared library file.

          The "bunch of stuff" consists of the list of object files
          supplied as _objects_.  _output_filename_ should be a
          filename.  If _output_dir_ is supplied, _output_filename_ is
          relative to it (i.e.  _output_filename_ can provide directory
          components if needed).

          _libraries_ is a list of libraries to link against.  These are
          library names, not filenames, since they’re translated into
          filenames in a platform-specific way (eg.  _foo_ becomes
          ‘libfoo.a’ on Unix and ‘foo.lib’ on DOS/Windows).  However,
          they can include a directory component, which means the linker
          will look in that specific directory rather than searching all
          the normal locations.

          _library_dirs_, if supplied, should be a list of directories
          to search for libraries that were specified as bare library
          names (ie.  no directory component).  These are on top of the
          system default and those supplied to *note add_library_dir():
          2ef2. and/or *note set_library_dirs(): 2ef3.
          _runtime_library_dirs_ is a list of directories that will be
          embedded into the shared library and used to search for other
          shared libraries that *it* depends on at run-time.  (This may
          only be relevant on Unix.)

          _export_symbols_ is a list of symbols that the shared library
          will export.  (This appears to be relevant only on Windows.)

          _debug_ is as for *note compile(): 1fb. and *note
          create_static_lib(): 2f03, with the slight distinction that it
          actually matters on most platforms (as opposed to *note
          create_static_lib(): 2f03, which includes a _debug_ flag
          mostly for form’s sake).

          _extra_preargs_ and _extra_postargs_ are as for *note
          compile(): 1fb. (except of course that they supply
          command-line arguments for the particular linker being used).

          _target_lang_ is the target language for which the given
          objects are being compiled.  This allows specific linkage time
          treatment of certain languages.

          Raises ‘LinkError’ on failure.

      -- Method: link_executable (objects, output_progname[,
               output_dir=None, libraries=None, library_dirs=None,
               runtime_library_dirs=None, debug=0, extra_preargs=None,
               extra_postargs=None, target_lang=None])

          Link an executable.  _output_progname_ is the name of the file
          executable, while _objects_ are a list of object filenames to
          link in.  Other arguments are as for the *note link(): 2f04.
          method.

      -- Method: link_shared_lib (objects, output_libname[,
               output_dir=None, libraries=None, library_dirs=None,
               runtime_library_dirs=None, export_symbols=None, debug=0,
               extra_preargs=None, extra_postargs=None, build_temp=None,
               target_lang=None])

          Link a shared library.  _output_libname_ is the name of the
          output library, while _objects_ is a list of object filenames
          to link in.  Other arguments are as for the *note link():
          2f04. method.

      -- Method: link_shared_object (objects, output_filename[,
               output_dir=None, libraries=None, library_dirs=None,
               runtime_library_dirs=None, export_symbols=None, debug=0,
               extra_preargs=None, extra_postargs=None, build_temp=None,
               target_lang=None])

          Link a shared object.  _output_filename_ is the name of the
          shared object that will be created, while _objects_ is a list
          of object filenames to link in.  Other arguments are as for
          the *note link(): 2f04. method.

      -- Method: preprocess (source[, output_file=None, macros=None,
               include_dirs=None, extra_preargs=None,
               extra_postargs=None])

          Preprocess a single C/C++ source file, named in _source_.
          Output will be written to file named _output_file_, or
          _stdout_ if _output_file_ not supplied.  _macros_ is a list of
          macro definitions as for *note compile(): 1fb, which will
          augment the macros set with *note define_macro(): 2ef6. and
          *note undefine_macro(): 2ef7.  _include_dirs_ is a list of
          directory names that will be added to the default list, in the
          same way as *note add_include_dir(): 2eee.

          Raises ‘PreprocessError’ on failure.

     The following utility methods are defined by the *note CCompiler:
     2ee8. class, for use by the various concrete subclasses.

      -- Method: executable_filename (basename[, strip_dir=0,
               output_dir=''])

          Returns the filename of the executable for the given
          _basename_.  Typically for non-Windows platforms this is the
          same as the basename, while Windows will get a ‘.exe’ added.

      -- Method: library_filename (libname[, lib_type='static',
               strip_dir=0, output_dir=''])

          Returns the filename for the given library name on the current
          platform.  On Unix a library with _lib_type_ of ‘'static'’
          will typically be of the form ‘liblibname.a’, while a
          _lib_type_ of ‘'dynamic'’ will be of the form ‘liblibname.so’.

      -- Method: object_filenames (source_filenames[, strip_dir=0,
               output_dir=''])

          Returns the name of the object files for the given source
          files.  _source_filenames_ should be a list of filenames.

      -- Method: shared_object_filename (basename[, strip_dir=0,
               output_dir=''])

          Returns the name of a shared object file for the given file
          name _basename_.

      -- Method: execute (func, args[, msg=None, level=1])

          Invokes *note distutils.util.execute(): 2f0e.  This method
          invokes a Python function _func_ with the given arguments
          _args_, after logging and taking into account the _dry_run_
          flag.

      -- Method: spawn (cmd)

          Invokes ‘distutils.util.spawn()’.  This invokes an external
          process to run the given command.

      -- Method: mkpath (name[, mode=511])

          Invokes *note distutils.dir_util.mkpath(): 2f11.  This creates
          a directory and any missing ancestor directories.

      -- Method: move_file (src, dst)

          Invokes *note distutils.file_util.move_file(): 2f13.  Renames
          _src_ to _dst_.

      -- Method: announce (msg[, level=1])

          Write a message using ‘distutils.log.debug()’.

      -- Method: warn (msg)

          Write a warning message _msg_ to standard error.

      -- Method: debug_print (msg)

          If the _debug_ flag is set on this *note CCompiler: 2ee8.
          instance, print _msg_ to standard output, otherwise do
          nothing.


File: python.info,  Node: distutils unixccompiler --- Unix C Compiler,  Next: distutils msvccompiler --- Microsoft Compiler,  Prev: distutils ccompiler --- CCompiler base class,  Up: API Reference

8.10.3 ‘distutils.unixccompiler’ — Unix C Compiler
--------------------------------------------------

This module provides the ‘UnixCCompiler’ class, a subclass of
‘CCompiler’ that handles the typical Unix-style command-line C compiler:

   * macros defined with ‘-Dname[=value]’

   * macros undefined with ‘-Uname’

   * include search directories specified with ‘-Idir’

   * libraries specified with ‘-llib’

   * library search directories specified with ‘-Ldir’

   * compile handled by *cc* (or similar) executable with *note -c: 27b.
     option: compiles ‘.c’ to ‘.o’

   * link static library handled by *ar* command (possibly with
     *ranlib*)

   * link shared library handled by *cc* ‘-shared’


File: python.info,  Node: distutils msvccompiler --- Microsoft Compiler,  Next: distutils bcppcompiler --- Borland Compiler,  Prev: distutils unixccompiler --- Unix C Compiler,  Up: API Reference

8.10.4 ‘distutils.msvccompiler’ — Microsoft Compiler
----------------------------------------------------

This module provides ‘MSVCCompiler’, an implementation of the abstract
‘CCompiler’ class for Microsoft Visual Studio.  Typically, extension
modules need to be compiled with the same compiler that was used to
compile Python.  For Python 2.3 and earlier, the compiler was Visual
Studio 6.  For Python 2.4 and 2.5, the compiler is Visual Studio .NET
2003.  The AMD64 and Itanium binaries are created using the Platform
SDK.

  ‘MSVCCompiler’ will normally choose the right compiler, linker etc.
on its own.  To override this choice, the environment variables
_DISTUTILS_USE_SDK_ and _MSSdk_ must be both set.  _MSSdk_ indicates
that the current environment has been setup by the SDK’s ‘SetEnv.Cmd’
script, or that the environment variables had been registered when the
SDK was installed; _DISTUTILS_USE_SDK_ indicates that the distutils user
has made an explicit choice to override the compiler selection by
‘MSVCCompiler’.


File: python.info,  Node: distutils bcppcompiler --- Borland Compiler,  Next: distutils cygwincompiler --- Cygwin Compiler,  Prev: distutils msvccompiler --- Microsoft Compiler,  Up: API Reference

8.10.5 ‘distutils.bcppcompiler’ — Borland Compiler
--------------------------------------------------

This module provides ‘BorlandCCompiler’, an subclass of the abstract
‘CCompiler’ class for the Borland C++ compiler.


File: python.info,  Node: distutils cygwincompiler --- Cygwin Compiler,  Next: distutils emxccompiler --- OS/2 EMX Compiler,  Prev: distutils bcppcompiler --- Borland Compiler,  Up: API Reference

8.10.6 ‘distutils.cygwincompiler’ — Cygwin Compiler
---------------------------------------------------

This module provides the ‘CygwinCCompiler’ class, a subclass of
‘UnixCCompiler’ that handles the Cygwin port of the GNU C compiler to
Windows.  It also contains the Mingw32CCompiler class which handles the
mingw32 port of GCC (same as cygwin in no-cygwin mode).


File: python.info,  Node: distutils emxccompiler --- OS/2 EMX Compiler,  Next: distutils archive_util --- Archiving utilities,  Prev: distutils cygwincompiler --- Cygwin Compiler,  Up: API Reference

8.10.7 ‘distutils.emxccompiler’ — OS/2 EMX Compiler
---------------------------------------------------

This module provides the EMXCCompiler class, a subclass of
‘UnixCCompiler’ that handles the EMX port of the GNU C compiler to OS/2.


File: python.info,  Node: distutils archive_util --- Archiving utilities,  Next: distutils dep_util --- Dependency checking,  Prev: distutils emxccompiler --- OS/2 EMX Compiler,  Up: API Reference

8.10.8 ‘distutils.archive_util’ — Archiving utilities
-----------------------------------------------------

This module provides a few functions for creating archive files, such as
tarballs or zipfiles.

 -- Function: distutils.archive_util.make_archive (base_name, format[,
          root_dir=None, base_dir=None, verbose=0, dry_run=0])

     Create an archive file (eg.  ‘zip’ or ‘tar’).  _base_name_ is the
     name of the file to create, minus any format-specific extension;
     _format_ is the archive format: one of ‘zip’, ‘tar’, ‘ztar’, or
     ‘gztar’.  _root_dir_ is a directory that will be the root directory
     of the archive; ie.  we typically ‘chdir’ into _root_dir_ before
     creating the archive.  _base_dir_ is the directory where we start
     archiving from; ie.  _base_dir_ will be the common prefix of all
     files and directories in the archive.  _root_dir_ and _base_dir_
     both default to the current directory.  Returns the name of the
     archive file.

 -- Function: distutils.archive_util.make_tarball (base_name, base_dir[,
          compress='gzip', verbose=0, dry_run=0])

     ’Create an (optional compressed) archive as a tar file from all
     files in and under _base_dir_.  _compress_ must be ‘'gzip'’ (the
     default), ‘'compress'’, ‘'bzip2'’, or ‘None’.  Both *tar* and the
     compression utility named by _compress_ must be on the default
     program search path, so this is probably Unix-specific.  The output
     tar file will be named ‘base_dir.tar’, possibly plus the
     appropriate compression extension (‘.gz’, ‘.bz2’ or ‘.Z’).  Return
     the output filename.

 -- Function: distutils.archive_util.make_zipfile (base_name, base_dir[,
          verbose=0, dry_run=0])

     Create a zip file from all files in and under _base_dir_.  The
     output zip file will be named _base_name_ + ‘.zip’.  Uses either
     the *note zipfile: 1ab. Python module (if available) or the InfoZIP
     ‘zip’ utility (if installed and found on the default search path).
     If neither tool is available, raises ‘DistutilsExecError’.  Returns
     the name of the output zip file.


File: python.info,  Node: distutils dep_util --- Dependency checking,  Next: distutils dir_util --- Directory tree operations,  Prev: distutils archive_util --- Archiving utilities,  Up: API Reference

8.10.9 ‘distutils.dep_util’ — Dependency checking
-------------------------------------------------

This module provides functions for performing simple, timestamp-based
dependency of files and groups of files; also, functions based entirely
on such timestamp dependency analysis.

 -- Function: distutils.dep_util.newer (source, target)

     Return true if _source_ exists and is more recently modified than
     _target_, or if _source_ exists and _target_ doesn’t.  Return false
     if both exist and _target_ is the same age or newer than _source_.
     Raise ‘DistutilsFileError’ if _source_ does not exist.

 -- Function: distutils.dep_util.newer_pairwise (sources, targets)

     Walk two filename lists in parallel, testing if each source is
     newer than its corresponding target.  Return a pair of lists
     (_sources_, _targets_) where source is newer than target, according
     to the semantics of *note newer(): 2f21.

 -- Function: distutils.dep_util.newer_group (sources, target[,
          missing='error'])

     Return true if _target_ is out-of-date with respect to any file
     listed in _sources_ In other words, if _target_ exists and is newer
     than every file in _sources_, return false; otherwise return true.
     _missing_ controls what we do when a source file is missing; the
     default (‘'error'’) is to blow up with an *note OSError: 231. from
     inside *note os.stat(): 3c4.; if it is ‘'ignore'’, we silently drop
     any missing source files; if it is ‘'newer'’, any missing source
     files make us assume that _target_ is out-of-date (this is handy in
     "dry-run" mode: it’ll make you pretend to carry out commands that
     wouldn’t work because inputs are missing, but that doesn’t matter
     because you’re not actually going to run the commands).


File: python.info,  Node: distutils dir_util --- Directory tree operations,  Next: distutils file_util --- Single file operations,  Prev: distutils dep_util --- Dependency checking,  Up: API Reference

8.10.10 ‘distutils.dir_util’ — Directory tree operations
--------------------------------------------------------

This module provides functions for operating on directories and trees of
directories.

 -- Function: distutils.dir_util.mkpath (name[, mode=0777, verbose=0,
          dry_run=0])

     Create a directory and any missing ancestor directories.  If the
     directory already exists (or if _name_ is the empty string, which
     means the current directory, which of course exists), then do
     nothing.  Raise ‘DistutilsFileError’ if unable to create some
     directory along the way (eg.  some sub-path exists, but is a file
     rather than a directory).  If _verbose_ is true, print a one-line
     summary of each mkdir to stdout.  Return the list of directories
     actually created.

 -- Function: distutils.dir_util.create_tree (base_dir, files[,
          mode=0777, verbose=0, dry_run=0])

     Create all the empty directories under _base_dir_ needed to put
     _files_ there.  _base_dir_ is just the a name of a directory which
     doesn’t necessarily exist yet; _files_ is a list of filenames to be
     interpreted relative to _base_dir_.  _base_dir_ + the directory
     portion of every file in _files_ will be created if it doesn’t
     already exist.  _mode_, _verbose_ and _dry_run_ flags are as for
     *note mkpath(): 2f11.

 -- Function: distutils.dir_util.copy_tree (src, dst[, preserve_mode=1,
          preserve_times=1, preserve_symlinks=0, update=0, verbose=0,
          dry_run=0])

     Copy an entire directory tree _src_ to a new location _dst_.  Both
     _src_ and _dst_ must be directory names.  If _src_ is not a
     directory, raise ‘DistutilsFileError’.  If _dst_ does not exist, it
     is created with *note mkpath(): 2f11.  The end result of the copy
     is that every file in _src_ is copied to _dst_, and directories
     under _src_ are recursively copied to _dst_.  Return the list of
     files that were copied or might have been copied, using their
     output name.  The return value is unaffected by _update_ or
     _dry_run_: it is simply the list of all files under _src_, with the
     names changed to be under _dst_.

     _preserve_mode_ and _preserve_times_ are the same as for *note
     distutils.file_util.copy_file(): 2f27.; note that they only apply
     to regular files, not to directories.  If _preserve_symlinks_ is
     true, symlinks will be copied as symlinks (on platforms that
     support them!); otherwise (the default), the destination of the
     symlink will be copied.  _update_ and _verbose_ are the same as for
     ‘copy_file()’.

     Files in _src_ that begin with ‘.nfs’ are skipped (more information
     on these files is available in answer D2 of the NFS FAQ page(1).

     Changed in version 2.7.4: NFS files are ignored.

 -- Function: distutils.dir_util.remove_tree (directory[, verbose=0,
          dry_run=0])

     Recursively remove _directory_ and all files and directories
     underneath it.  Any errors are ignored (apart from being reported
     to ‘sys.stdout’ if _verbose_ is true).

   ---------- Footnotes ----------

   (1) http://nfs.sourceforge.net/#section_d


File: python.info,  Node: distutils file_util --- Single file operations,  Next: distutils util --- Miscellaneous other utility functions,  Prev: distutils dir_util --- Directory tree operations,  Up: API Reference

8.10.11 ‘distutils.file_util’ — Single file operations
------------------------------------------------------

This module contains some utility functions for operating on individual
files.

 -- Function: distutils.file_util.copy_file (src, dst[, preserve_mode=1,
          preserve_times=1, update=0, link=None, verbose=0, dry_run=0])

     Copy file _src_ to _dst_.  If _dst_ is a directory, then _src_ is
     copied there with the same name; otherwise, it must be a filename.
     (If the file exists, it will be ruthlessly clobbered.)  If
     _preserve_mode_ is true (the default), the file’s mode (type and
     permission bits, or whatever is analogous on the current platform)
     is copied.  If _preserve_times_ is true (the default), the
     last-modified and last-access times are copied as well.  If
     _update_ is true, _src_ will only be copied if _dst_ does not
     exist, or if _dst_ does exist but is older than _src_.

     _link_ allows you to make hard links (using *note os.link(): 1148.)
     or symbolic links (using *note os.symlink(): 1157.) instead of
     copying: set it to ‘'hard'’ or ‘'sym'’; if it is ‘None’ (the
     default), files are copied.  Don’t set _link_ on systems that don’t
     support it: *note copy_file(): 2f27. doesn’t check if hard or
     symbolic linking is available.  It uses ‘_copy_file_contents()’ to
     copy file contents.

     Return a tuple ‘(dest_name, copied)’: _dest_name_ is the actual
     name of the output file, and _copied_ is true if the file was
     copied (or would have been copied, if _dry_run_ true).

 -- Function: distutils.file_util.move_file (src, dst[, verbose,
          dry_run])

     Move file _src_ to _dst_.  If _dst_ is a directory, the file will
     be moved into it with the same name; otherwise, _src_ is just
     renamed to _dst_.  Returns the new full name of the file.

          Warning: Handles cross-device moves on Unix using *note
          copy_file(): 2f27.  What about other systems?

 -- Function: distutils.file_util.write_file (filename, contents)

     Create a file called _filename_ and write _contents_ (a sequence of
     strings without line terminators) to it.


File: python.info,  Node: distutils util --- Miscellaneous other utility functions,  Next: distutils dist --- The Distribution class,  Prev: distutils file_util --- Single file operations,  Up: API Reference

8.10.12 ‘distutils.util’ — Miscellaneous other utility functions
----------------------------------------------------------------

This module contains other assorted bits and pieces that don’t fit into
any other utility module.

 -- Function: distutils.util.get_platform ()

     Return a string that identifies the current platform.  This is used
     mainly to distinguish platform-specific build directories and
     platform-specific built distributions.  Typically includes the OS
     name and version and the architecture (as supplied by
     ’os.uname()’), although the exact information included depends on
     the OS; eg.  for IRIX the architecture isn’t particularly important
     (IRIX only runs on SGI hardware), but for Linux the kernel version
     isn’t particularly important.

     Examples of returned values:

        * ‘linux-i586’

        * ‘linux-alpha’

        * ‘solaris-2.6-sun4u’

        * ‘irix-5.3’

        * ‘irix64-6.2’

     For non-POSIX platforms, currently just returns ‘sys.platform’.

     For Mac OS X systems the OS version reflects the minimal version on
     which binaries will run (that is, the value of
     ‘MACOSX_DEPLOYMENT_TARGET’ during the build of Python), not the OS
     version of the current system.

     For universal binary builds on Mac OS X the architecture value
     reflects the univeral binary status instead of the architecture of
     the current processor.  For 32-bit universal binaries the
     architecture is ‘fat’, for 64-bit universal binaries the
     architecture is ‘fat64’, and for 4-way universal binaries the
     architecture is ‘universal’.  Starting from Python 2.7 and Python
     3.2 the architecture ‘fat3’ is used for a 3-way universal build
     (ppc, i386, x86_64) and ‘intel’ is used for a univeral build with
     the i386 and x86_64 architectures

     Examples of returned values on Mac OS X:

        * ‘macosx-10.3-ppc’

        * ‘macosx-10.3-fat’

        * ‘macosx-10.5-universal’

        * ‘macosx-10.6-intel’

 -- Function: distutils.util.convert_path (pathname)

     Return ’pathname’ as a name that will work on the native
     filesystem, i.e.  split it on ’/’ and put it back together again
     using the current directory separator.  Needed because filenames in
     the setup script are always supplied in Unix style, and have to be
     converted to the local convention before we can actually use them
     in the filesystem.  Raises *note ValueError: 236. on non-Unix-ish
     systems if _pathname_ either starts or ends with a slash.

 -- Function: distutils.util.change_root (new_root, pathname)

     Return _pathname_ with _new_root_ prepended.  If _pathname_ is
     relative, this is equivalent to ‘os.path.join(new_root,pathname)’
     Otherwise, it requires making _pathname_ relative and then joining
     the two, which is tricky on DOS/Windows.

 -- Function: distutils.util.check_environ ()

     Ensure that ’os.environ’ has all the environment variables we
     guarantee that users can use in config files, command-line options,
     etc.  Currently this includes:

        * ‘HOME’ - user’s home directory (Unix only)

        * ‘PLAT’ - description of the current platform, including
          hardware and OS (see *note get_platform(): 2f2c.)

 -- Function: distutils.util.subst_vars (s, local_vars)

     Perform shell/Perl-style variable substitution on _s_.  Every
     occurrence of ‘$’ followed by a name is considered a variable, and
     variable is substituted by the value found in the _local_vars_
     dictionary, or in ‘os.environ’ if it’s not in _local_vars_.
     _os.environ_ is first checked/augmented to guarantee that it
     contains certain values: see *note check_environ(): 2f2f.  Raise
     *note ValueError: 236. for any variables not found in either
     _local_vars_ or ‘os.environ’.

     Note that this is not a fully-fledged string interpolation
     function.  A valid ‘$variable’ can consist only of upper and lower
     case letters, numbers and an underscore.  No { } or ( ) style
     quoting is available.

 -- Function: distutils.util.split_quoted (s)

     Split a string up according to Unix shell-like rules for quotes and
     backslashes.  In short: words are delimited by spaces, as long as
     those spaces are not escaped by a backslash, or inside a quoted
     string.  Single and double quotes are equivalent, and the quote
     characters can be backslash-escaped.  The backslash is stripped
     from any two-character escape sequence, leaving only the escaped
     character.  The quote characters are stripped from any quoted
     string.  Returns a list of words.

 -- Function: distutils.util.execute (func, args[, msg=None, verbose=0,
          dry_run=0])

     Perform some action that affects the outside world (for instance,
     writing to the filesystem).  Such actions are special because they
     are disabled by the _dry_run_ flag.  This method takes care of all
     that bureaucracy for you; all you have to do is supply the function
     to call and an argument tuple for it (to embody the "external
     action" being performed), and an optional message to print.

 -- Function: distutils.util.strtobool (val)

     Convert a string representation of truth to true (1) or false (0).

     True values are ‘y’, ‘yes’, ‘t’, ‘true’, ‘on’ and ‘1’; false values
     are ‘n’, ‘no’, ‘f’, ‘false’, ‘off’ and ‘0’.  Raises *note
     ValueError: 236. if _val_ is anything else.

 -- Function: distutils.util.byte_compile (py_files[, optimize=0,
          force=0, prefix=None, base_dir=None, verbose=1, dry_run=0,
          direct=None])

     Byte-compile a collection of Python source files to either ‘.pyc’
     or ‘.pyo’ files in the same directory.  _py_files_ is a list of
     files to compile; any files that don’t end in ‘.py’ are silently
     skipped.  _optimize_ must be one of the following:

        * ‘0’ - don’t optimize (generate ‘.pyc’)

        * ‘1’ - normal optimization (like ‘python -O’)

        * ‘2’ - extra optimization (like ‘python -OO’)

     If _force_ is true, all files are recompiled regardless of
     timestamps.

     The source filename encoded in each *note bytecode: 583. file
     defaults to the filenames listed in _py_files_; you can modify
     these with _prefix_ and _basedir_.  _prefix_ is a string that will
     be stripped off of each source filename, and _base_dir_ is a
     directory name that will be prepended (after _prefix_ is stripped).
     You can supply either or both (or neither) of _prefix_ and
     _base_dir_, as you wish.

     If _dry_run_ is true, doesn’t actually do anything that would
     affect the filesystem.

     Byte-compilation is either done directly in this interpreter
     process with the standard *note py_compile: 13d. module, or
     indirectly by writing a temporary script and executing it.
     Normally, you should let *note byte_compile(): 2f32. figure out to
     use direct compilation or not (see the source for details).  The
     _direct_ flag is used by the script generated in indirect mode;
     unless you know what you’re doing, leave it set to ‘None’.

 -- Function: distutils.util.rfc822_escape (header)

     Return a version of _header_ escaped for inclusion in an RFC 822(1)
     header, by ensuring there are 8 spaces space after each newline.
     Note that it does no other modification of the string.

   ---------- Footnotes ----------

   (1) http://tools.ietf.org/html/rfc822.html


File: python.info,  Node: distutils dist --- The Distribution class,  Next: distutils extension --- The Extension class,  Prev: distutils util --- Miscellaneous other utility functions,  Up: API Reference

8.10.13 ‘distutils.dist’ — The Distribution class
-------------------------------------------------

This module provides the *note Distribution: 2ee4. class, which
represents the module distribution being built/installed/distributed.


File: python.info,  Node: distutils extension --- The Extension class,  Next: distutils debug --- Distutils debug mode,  Prev: distutils dist --- The Distribution class,  Up: API Reference

8.10.14 ‘distutils.extension’ — The Extension class
---------------------------------------------------

This module provides the ‘Extension’ class, used to describe C/C++
extension modules in setup scripts.


File: python.info,  Node: distutils debug --- Distutils debug mode,  Next: distutils errors --- Distutils exceptions,  Prev: distutils extension --- The Extension class,  Up: API Reference

8.10.15 ‘distutils.debug’ — Distutils debug mode
------------------------------------------------

This module provides the DEBUG flag.


File: python.info,  Node: distutils errors --- Distutils exceptions,  Next: distutils fancy_getopt --- Wrapper around the standard getopt module,  Prev: distutils debug --- Distutils debug mode,  Up: API Reference

8.10.16 ‘distutils.errors’ — Distutils exceptions
-------------------------------------------------

Provides exceptions used by the Distutils modules.  Note that Distutils
modules may raise standard exceptions; in particular, SystemExit is
usually raised for errors that are obviously the end-user’s fault (eg.
bad command-line arguments).

  This module is safe to use in ‘from ... import *’ mode; it only
exports symbols whose names start with ‘Distutils’ and end with ‘Error’.


File: python.info,  Node: distutils fancy_getopt --- Wrapper around the standard getopt module,  Next: distutils filelist --- The FileList class,  Prev: distutils errors --- Distutils exceptions,  Up: API Reference

8.10.17 ‘distutils.fancy_getopt’ — Wrapper around the standard getopt module
----------------------------------------------------------------------------

This module provides a wrapper around the standard *note getopt: de.
module that provides the following additional features:

   * short and long options are tied together

   * options have help strings, so *note fancy_getopt(): 2f39. could
     potentially create a complete usage summary

   * options set attributes of a passed-in object

   * boolean options can have "negative aliases" — eg.  if ‘--quiet’ is
     the "negative alias" of ‘--verbose’, then ‘--quiet’ on the command
     line sets _verbose_ to false.

 -- Function: distutils.fancy_getopt.fancy_getopt (options,
          negative_opt, object, args)

     Wrapper function.  _options_ is a list of ‘(long_option,
     short_option, help_string)’ 3-tuples as described in the
     constructor for *note FancyGetopt: 2f3a.  _negative_opt_ should be
     a dictionary mapping option names to option names, both the key and
     value should be in the _options_ list.  _object_ is an object which
     will be used to store values (see the *note getopt(): de. method of
     the *note FancyGetopt: 2f3a. class).  _args_ is the argument list.
     Will use ‘sys.argv[1:]’ if you pass ‘None’ as _args_.

 -- Function: distutils.fancy_getopt.wrap_text (text, width)

     Wraps _text_ to less than _width_ wide.

 -- Class: distutils.fancy_getopt.FancyGetopt ([option_table=None])

     The option_table is a list of 3-tuples: ‘(long_option,
     short_option, help_string)’

     If an option takes an argument, its _long_option_ should have ‘'='’
     appended; _short_option_ should just be a single character, no
     ‘':'’ in any case.  _short_option_ should be ‘None’ if a
     _long_option_ doesn’t have a corresponding _short_option_.  All
     option tuples must have long options.

  The *note FancyGetopt: 2f3a. class provides the following methods:

 -- Method: FancyGetopt.getopt ([args=None, object=None])

     Parse command-line options in args.  Store as attributes on
     _object_.

     If _args_ is ‘None’ or not supplied, uses ‘sys.argv[1:]’.  If
     _object_ is ‘None’ or not supplied, creates a new ‘OptionDummy’
     instance, stores option values there, and returns a tuple ‘(args,
     object)’.  If _object_ is supplied, it is modified in place and
     *note getopt(): de. just returns _args_; in both cases, the
     returned _args_ is a modified copy of the passed-in _args_ list,
     which is left untouched.

 -- Method: FancyGetopt.get_option_order ()

     Returns the list of ‘(option, value)’ tuples processed by the
     previous run of *note getopt(): de. Raises *note RuntimeError: 39b.
     if *note getopt(): de. hasn’t been called yet.

 -- Method: FancyGetopt.generate_help ([header=None])

     Generate help text (a list of strings, one per suggested line of
     output) from the option table for this *note FancyGetopt: 2f3a.
     object.

     If supplied, prints the supplied _header_ at the top of the help.


File: python.info,  Node: distutils filelist --- The FileList class,  Next: distutils log --- Simple PEP 282-style logging,  Prev: distutils fancy_getopt --- Wrapper around the standard getopt module,  Up: API Reference

8.10.18 ‘distutils.filelist’ — The FileList class
-------------------------------------------------

This module provides the ‘FileList’ class, used for poking about the
filesystem and building lists of files.


File: python.info,  Node: distutils log --- Simple PEP 282-style logging,  Next: distutils spawn --- Spawn a sub-process,  Prev: distutils filelist --- The FileList class,  Up: API Reference

8.10.19 ‘distutils.log’ — Simple PEP 282-style logging
------------------------------------------------------


File: python.info,  Node: distutils spawn --- Spawn a sub-process,  Next: distutils sysconfig --- System configuration information,  Prev: distutils log --- Simple PEP 282-style logging,  Up: API Reference

8.10.20 ‘distutils.spawn’ — Spawn a sub-process
-----------------------------------------------

This module provides the ‘spawn()’ function, a front-end to various
platform-specific functions for launching another program in a
sub-process.  Also provides ‘find_executable()’ to search the path for a
given executable name.


File: python.info,  Node: distutils sysconfig --- System configuration information,  Next: distutils text_file --- The TextFile class,  Prev: distutils spawn --- Spawn a sub-process,  Up: API Reference

8.10.21 ‘distutils.sysconfig’ — System configuration information
----------------------------------------------------------------

The *note distutils.sysconfig: af. module provides access to Python’s
low-level configuration information.  The specific configuration
variables available depend heavily on the platform and configuration.
The specific variables depend on the build process for the specific
version of Python being run; the variables are those found in the
‘Makefile’ and configuration header that are installed with Python on
Unix systems.  The configuration header is called ‘pyconfig.h’ for
Python versions starting with 2.2, and ‘config.h’ for earlier versions
of Python.

  Some additional functions are provided which perform some useful
manipulations for other parts of the *note distutils: 85. package.

 -- Data: distutils.sysconfig.PREFIX

     The result of ‘os.path.normpath(sys.prefix)’.

 -- Data: distutils.sysconfig.EXEC_PREFIX

     The result of ‘os.path.normpath(sys.exec_prefix)’.

 -- Function: distutils.sysconfig.get_config_var (name)

     Return the value of a single variable.  This is equivalent to
     ‘get_config_vars().get(name)’.

 -- Function: distutils.sysconfig.get_config_vars (...)

     Return a set of variable definitions.  If there are no arguments,
     this returns a dictionary mapping names of configuration variables
     to values.  If arguments are provided, they should be strings, and
     the return value will be a sequence giving the associated values.
     If a given name does not have a corresponding value, ‘None’ will be
     included for that variable.

 -- Function: distutils.sysconfig.get_config_h_filename ()

     Return the full path name of the configuration header.  For Unix,
     this will be the header generated by the *configure* script; for
     other platforms the header will have been supplied directly by the
     Python source distribution.  The file is a platform-specific text
     file.

 -- Function: distutils.sysconfig.get_makefile_filename ()

     Return the full path name of the ‘Makefile’ used to build Python.
     For Unix, this will be a file generated by the *configure* script;
     the meaning for other platforms will vary.  The file is a
     platform-specific text file, if it exists.  This function is only
     useful on POSIX platforms.

 -- Function: distutils.sysconfig.get_python_inc ([plat_specific[,
          prefix]])

     Return the directory for either the general or platform-dependent C
     include files.  If _plat_specific_ is true, the platform-dependent
     include directory is returned; if false or omitted, the
     platform-independent directory is returned.  If _prefix_ is given,
     it is used as either the prefix instead of *note PREFIX: 2f43, or
     as the exec-prefix instead of *note EXEC_PREFIX: 2f44. if
     _plat_specific_ is true.

 -- Function: distutils.sysconfig.get_python_lib ([plat_specific[,
          standard_lib[, prefix]]])

     Return the directory for either the general or platform-dependent
     library installation.  If _plat_specific_ is true, the
     platform-dependent include directory is returned; if false or
     omitted, the platform-independent directory is returned.  If
     _prefix_ is given, it is used as either the prefix instead of *note
     PREFIX: 2f43, or as the exec-prefix instead of *note EXEC_PREFIX:
     2f44. if _plat_specific_ is true.  If _standard_lib_ is true, the
     directory for the standard library is returned rather than the
     directory for the installation of third-party extensions.

  The following function is only intended for use within the *note
distutils: 85. package.

 -- Function: distutils.sysconfig.customize_compiler (compiler)

     Do any platform-specific customization of a *note
     distutils.ccompiler.CCompiler: 2ee8. instance.

     This function is only needed on Unix at this time, but should be
     called consistently to support forward-compatibility.  It inserts
     the information that varies across Unix flavors and is stored in
     Python’s ‘Makefile’.  This information includes the selected
     compiler, compiler and linker options, and the extension used by
     the linker for shared objects.

  This function is even more special-purpose, and should only be used
from Python’s own build procedures.

 -- Function: distutils.sysconfig.set_python_build ()

     Inform the *note distutils.sysconfig: af. module that it is being
     used as part of the build process for Python.  This changes a lot
     of relative locations for files, allowing them to be located in the
     build area rather than in an installed Python.


File: python.info,  Node: distutils text_file --- The TextFile class,  Next: distutils version --- Version number classes,  Prev: distutils sysconfig --- System configuration information,  Up: API Reference

8.10.22 ‘distutils.text_file’ — The TextFile class
--------------------------------------------------

This module provides the *note TextFile: 2f4e. class, which gives an
interface to text files that (optionally) takes care of stripping
comments, ignoring blank lines, and joining lines with backslashes.

 -- Class: distutils.text_file.TextFile ([filename=None, file=None,
          **options])

     This class provides a file-like object that takes care of all the
     things you commonly want to do when processing a text file that has
     some line-by-line syntax: strip comments (as long as ‘#’ is your
     comment character), skip blank lines, join adjacent lines by
     escaping the newline (ie.  backslash at end of line), strip leading
     and/or trailing whitespace.  All of these are optional and
     independently controllable.

     The class provides a *note warn(): 2f4f. method so you can generate
     warning messages that report physical line number, even if the
     logical line in question spans multiple physical lines.  Also
     provides *note unreadline(): 2f50. for implementing line-at-a-time
     lookahead.

     *note TextFile: 2f4e. instances are create with either _filename_,
     _file_, or both.  *note RuntimeError: 39b. is raised if both are
     ‘None’.  _filename_ should be a string, and _file_ a file object
     (or something that provides *note readline(): 144. and *note
     close(): 2f51. methods).  It is recommended that you supply at
     least _filename_, so that *note TextFile: 2f4e. can include it in
     warning messages.  If _file_ is not supplied, *note TextFile: 2f4e.
     creates its own using the *note open(): 2d6. built-in function.

     The options are all boolean, and affect the values returned by
     *note readline(): 144.

     option name            description                          default
                                                                 
     --------------------------------------------------------------------------
                                                                 
     _strip_comments_       strip from ‘'#'’ to end-of- line,    true
                            as well as any whitespace leading    
                            up to the ‘'#'’—unless it is
                            escaped by a backslash
                            
                                                                 
     _lstrip_ws_            strip leading whitespace from each   false
                            line before returning it             
                            
                                                                 
     _rstrip_ws_            strip trailing whitespace            true
                            (including line terminator!)  from   
                            each line before returning it.
                            
                                                                 
     _skip_blanks_          skip lines that are empty *after*    true
                            stripping comments and whitespace.   
                            (If both lstrip_ws and rstrip_ws
                            are false, then some lines may
                            consist of solely whitespace:
                            these will *not* be skipped, even
                            if _skip_blanks_ is true.)
                            
                                                                 
     _join_lines_           if a backslash is the last           false
                            non-newline character on a line      
                            after stripping comments and
                            whitespace, join the following
                            line to it to form one logical
                            line; if N consecutive lines end
                            with a backslash, then N+1
                            physical lines will be joined to
                            form one logical line.
                            
                                                                 
     _collapse_join_        strip leading whitespace from        false
                            lines that are joined to their       
                            predecessor; only matters if
                            ‘(join_lines and not lstrip_ws)’
                            

     Note that since _rstrip_ws_ can strip the trailing newline, the
     semantics of *note readline(): 144. must differ from those of the
     built-in file object’s *note readline(): 144. method!  In
     particular, *note readline(): 144. returns ‘None’ for end-of-file:
     an empty string might just be a blank line (or an all-whitespace
     line), if _rstrip_ws_ is true but _skip_blanks_ is not.

      -- Method: open (filename)

          Open a new file _filename_.  This overrides any _file_ or
          _filename_ constructor arguments.

      -- Method: close ()

          Close the current file and forget everything we know about it
          (including the filename and the current line number).

      -- Method: warn (msg[, line=None])

          Print (to stderr) a warning message tied to the current
          logical line in the current file.  If the current logical line
          in the file spans multiple physical lines, the warning refers
          to the whole range, such as ‘"lines 3-5"’.  If _line_ is
          supplied, it overrides the current line number; it may be a
          list or tuple to indicate a range of physical lines, or an
          integer for a single physical line.

      -- Method: readline ()

          Read and return a single logical line from the current file
          (or from an internal buffer if lines have previously been
          "unread" with *note unreadline(): 2f50.).  If the _join_lines_
          option is true, this may involve reading multiple physical
          lines concatenated into a single string.  Updates the current
          line number, so calling *note warn(): 2f4f. after *note
          readline(): 144. emits a warning about the physical line(s)
          just read.  Returns ‘None’ on end-of-file, since the empty
          string can occur if _rstrip_ws_ is true but _strip_blanks_ is
          not.

      -- Method: readlines ()

          Read and return the list of all logical lines remaining in the
          current file.  This updates the current line number to the
          last line of the file.

      -- Method: unreadline (line)

          Push _line_ (a string) onto an internal buffer that will be
          checked by future *note readline(): 144. calls.  Handy for
          implementing a parser with line-at-a-time lookahead.  Note
          that lines that are "unread" with *note unreadline(): 2f50.
          are not subsequently re-cleansed (whitespace stripped, or
          whatever) when read with *note readline(): 144.  If multiple
          calls are made to *note unreadline(): 2f50. before a call to
          *note readline(): 144, the lines will be returned most in most
          recent first order.


File: python.info,  Node: distutils version --- Version number classes,  Next: distutils cmd --- Abstract base class for Distutils commands,  Prev: distutils text_file --- The TextFile class,  Up: API Reference

8.10.23 ‘distutils.version’ — Version number classes
----------------------------------------------------


File: python.info,  Node: distutils cmd --- Abstract base class for Distutils commands,  Next: Creating a new Distutils command,  Prev: distutils version --- Version number classes,  Up: API Reference

8.10.24 ‘distutils.cmd’ — Abstract base class for Distutils commands
--------------------------------------------------------------------

This module supplies the abstract base class *note Command: 2ed4.

 -- Class: distutils.cmd.Command (dist)

     Abstract base class for defining command classes, the "worker bees"
     of the Distutils.  A useful analogy for command classes is to think
     of them as subroutines with local variables called _options_.  The
     options are declared in *note initialize_options(): 2f57. and
     defined (given their final values) in *note finalize_options():
     2f58, both of which must be defined by every command class.  The
     distinction between the two is necessary because option values
     might come from the outside world (command line, config file, ...),
     and any options dependent on other options must be computed after
     these outside influences have been processed — hence *note
     finalize_options(): 2f58.  The body of the subroutine, where it
     does all its work based on the values of its options, is the *note
     run(): 2f59. method, which must also be implemented by every
     command class.

     The class constructor takes a single argument _dist_, a *note
     Distribution: 2ee4. instance.


File: python.info,  Node: Creating a new Distutils command,  Next: distutils command --- Individual Distutils commands,  Prev: distutils cmd --- Abstract base class for Distutils commands,  Up: API Reference

8.10.25 Creating a new Distutils command
----------------------------------------

This section outlines the steps to create a new Distutils command.

  A new command lives in a module in the *note distutils.command: 8a.
package.  There is a sample template in that directory called
‘command_template’.  Copy this file to a new module with the same name
as the new command you’re implementing.  This module should implement a
class with the same name as the module (and the command).  So, for
instance, to create the command ‘peel_banana’ (so that users can run
‘setup.py peel_banana’), you’d copy ‘command_template’ to
‘distutils/command/peel_banana.py’, then edit it so that it’s
implementing the class ‘peel_banana’, a subclass of *note
distutils.cmd.Command: 2ed4.

  Subclasses of *note Command: 2ed4. must define the following methods.

 -- Method: Command.initialize_options ()

     Set default values for all the options that this command supports.
     Note that these defaults may be overridden by other commands, by
     the setup script, by config files, or by the command-line.  Thus,
     this is not the place to code dependencies between options;
     generally, *note initialize_options(): 2f57. implementations are
     just a bunch of ‘self.foo = None’ assignments.

 -- Method: Command.finalize_options ()

     Set final values for all the options that this command supports.
     This is always called as late as possible, ie.  after any option
     assignments from the command-line or from other commands have been
     done.  Thus, this is the place to code option dependencies: if
     _foo_ depends on _bar_, then it is safe to set _foo_ from _bar_ as
     long as _foo_ still has the same value it was assigned in *note
     initialize_options(): 2f57.

 -- Method: Command.run ()

     A command’s raison d’etre: carry out the action it exists to
     perform, controlled by the options initialized in *note
     initialize_options(): 2f57, customized by other commands, the setup
     script, the command-line, and config files, and finalized in *note
     finalize_options(): 2f58.  All terminal output and filesystem
     interaction should be done by *note run(): 2f59.

 -- Attribute: Command.sub_commands

     _sub_commands_ formalizes the notion of a "family" of commands,
     e.g.  ‘install’ as the parent with sub-commands ‘install_lib’,
     ‘install_headers’, etc.  The parent of a family of commands defines
     _sub_commands_ as a class attribute; it’s a list of 2-tuples
     ‘(command_name, predicate)’, with _command_name_ a string and
     _predicate_ a function, a string or ‘None’.  _predicate_ is a
     method of the parent command that determines whether the
     corresponding command is applicable in the current situation.
     (E.g.  ‘install_headers’ is only applicable if we have any C header
     files to install.)  If _predicate_ is ‘None’, that command is
     always applicable.

     _sub_commands_ is usually defined at the _end_ of a class, because
     predicates can be methods of the class, so they must already have
     been defined.  The canonical example is the *install* command.


File: python.info,  Node: distutils command --- Individual Distutils commands,  Next: distutils command bdist --- Build a binary installer,  Prev: Creating a new Distutils command,  Up: API Reference

8.10.26 ‘distutils.command’ — Individual Distutils commands
-----------------------------------------------------------


File: python.info,  Node: distutils command bdist --- Build a binary installer,  Next: distutils command bdist_packager --- Abstract base class for packagers,  Prev: distutils command --- Individual Distutils commands,  Up: API Reference

8.10.27 ‘distutils.command.bdist’ — Build a binary installer
------------------------------------------------------------


File: python.info,  Node: distutils command bdist_packager --- Abstract base class for packagers,  Next: distutils command bdist_dumb --- Build a "dumb" installer,  Prev: distutils command bdist --- Build a binary installer,  Up: API Reference

8.10.28 ‘distutils.command.bdist_packager’ — Abstract base class for packagers
------------------------------------------------------------------------------


File: python.info,  Node: distutils command bdist_dumb --- Build a "dumb" installer,  Next: distutils command bdist_msi --- Build a Microsoft Installer binary package,  Prev: distutils command bdist_packager --- Abstract base class for packagers,  Up: API Reference

8.10.29 ‘distutils.command.bdist_dumb’ — Build a "dumb" installer
-----------------------------------------------------------------


File: python.info,  Node: distutils command bdist_msi --- Build a Microsoft Installer binary package,  Next: distutils command bdist_rpm --- Build a binary distribution as a Redhat RPM and SRPM,  Prev: distutils command bdist_dumb --- Build a "dumb" installer,  Up: API Reference

8.10.30 ‘distutils.command.bdist_msi’ — Build a Microsoft Installer binary package
----------------------------------------------------------------------------------

 -- Class: distutils.command.bdist_msi.bdist_msi

     Builds a Windows Installer(1) (.msi) binary package.

     In most cases, the ‘bdist_msi’ installer is a better choice than
     the ‘bdist_wininst’ installer, because it provides better support
     for Win64 platforms, allows administrators to perform
     non-interactive installations, and allows installation through
     group policies.

   ---------- Footnotes ----------

   (1) http://msdn.microsoft.com/en-us/library/cc185688(VS.85).aspx


File: python.info,  Node: distutils command bdist_rpm --- Build a binary distribution as a Redhat RPM and SRPM,  Next: distutils command bdist_wininst --- Build a Windows installer,  Prev: distutils command bdist_msi --- Build a Microsoft Installer binary package,  Up: API Reference

8.10.31 ‘distutils.command.bdist_rpm’ — Build a binary distribution as a Redhat RPM and SRPM
--------------------------------------------------------------------------------------------


File: python.info,  Node: distutils command bdist_wininst --- Build a Windows installer,  Next: distutils command sdist --- Build a source distribution,  Prev: distutils command bdist_rpm --- Build a binary distribution as a Redhat RPM and SRPM,  Up: API Reference

8.10.32 ‘distutils.command.bdist_wininst’ — Build a Windows installer
---------------------------------------------------------------------


File: python.info,  Node: distutils command sdist --- Build a source distribution,  Next: distutils command build --- Build all files of a package,  Prev: distutils command bdist_wininst --- Build a Windows installer,  Up: API Reference

8.10.33 ‘distutils.command.sdist’ — Build a source distribution
---------------------------------------------------------------


File: python.info,  Node: distutils command build --- Build all files of a package,  Next: distutils command build_clib --- Build any C libraries in a package,  Prev: distutils command sdist --- Build a source distribution,  Up: API Reference

8.10.34 ‘distutils.command.build’ — Build all files of a package
----------------------------------------------------------------


File: python.info,  Node: distutils command build_clib --- Build any C libraries in a package,  Next: distutils command build_ext --- Build any extensions in a package,  Prev: distutils command build --- Build all files of a package,  Up: API Reference

8.10.35 ‘distutils.command.build_clib’ — Build any C libraries in a package
---------------------------------------------------------------------------


File: python.info,  Node: distutils command build_ext --- Build any extensions in a package,  Next: distutils command build_py --- Build the py/ pyc files of a package,  Prev: distutils command build_clib --- Build any C libraries in a package,  Up: API Reference

8.10.36 ‘distutils.command.build_ext’ — Build any extensions in a package
-------------------------------------------------------------------------


File: python.info,  Node: distutils command build_py --- Build the py/ pyc files of a package,  Next: distutils command build_scripts --- Build the scripts of a package,  Prev: distutils command build_ext --- Build any extensions in a package,  Up: API Reference

8.10.37 ‘distutils.command.build_py’ — Build the .py/.pyc files of a package
----------------------------------------------------------------------------


File: python.info,  Node: distutils command build_scripts --- Build the scripts of a package,  Next: distutils command clean --- Clean a package build area,  Prev: distutils command build_py --- Build the py/ pyc files of a package,  Up: API Reference

8.10.38 ‘distutils.command.build_scripts’ — Build the scripts of a package
--------------------------------------------------------------------------


File: python.info,  Node: distutils command clean --- Clean a package build area,  Next: distutils command config --- Perform package configuration,  Prev: distutils command build_scripts --- Build the scripts of a package,  Up: API Reference

8.10.39 ‘distutils.command.clean’ — Clean a package build area
--------------------------------------------------------------

This command removes the temporary files created by *build* and its
subcommands, like intermediary compiled object files.  With the ‘--all’
option, the complete build directory will be removed.

  Extension modules built *note in place: 2ea1. will not be cleaned, as
they are not in the build directory.


File: python.info,  Node: distutils command config --- Perform package configuration,  Next: distutils command install --- Install a package,  Prev: distutils command clean --- Clean a package build area,  Up: API Reference

8.10.40 ‘distutils.command.config’ — Perform package configuration
------------------------------------------------------------------


File: python.info,  Node: distutils command install --- Install a package,  Next: distutils command install_data --- Install data files from a package,  Prev: distutils command config --- Perform package configuration,  Up: API Reference

8.10.41 ‘distutils.command.install’ — Install a package
-------------------------------------------------------


File: python.info,  Node: distutils command install_data --- Install data files from a package,  Next: distutils command install_headers --- Install C/C++ header files from a package,  Prev: distutils command install --- Install a package,  Up: API Reference

8.10.42 ‘distutils.command.install_data’ — Install data files from a package
----------------------------------------------------------------------------


File: python.info,  Node: distutils command install_headers --- Install C/C++ header files from a package,  Next: distutils command install_lib --- Install library files from a package,  Prev: distutils command install_data --- Install data files from a package,  Up: API Reference

8.10.43 ‘distutils.command.install_headers’ — Install C/C++ header files from a package
---------------------------------------------------------------------------------------


File: python.info,  Node: distutils command install_lib --- Install library files from a package,  Next: distutils command install_scripts --- Install script files from a package,  Prev: distutils command install_headers --- Install C/C++ header files from a package,  Up: API Reference

8.10.44 ‘distutils.command.install_lib’ — Install library files from a package
------------------------------------------------------------------------------


File: python.info,  Node: distutils command install_scripts --- Install script files from a package,  Next: distutils command register --- Register a module with the Python Package Index,  Prev: distutils command install_lib --- Install library files from a package,  Up: API Reference

8.10.45 ‘distutils.command.install_scripts’ — Install script files from a package
---------------------------------------------------------------------------------


File: python.info,  Node: distutils command register --- Register a module with the Python Package Index,  Next: distutils command check --- Check the meta-data of a package,  Prev: distutils command install_scripts --- Install script files from a package,  Up: API Reference

8.10.46 ‘distutils.command.register’ — Register a module with the Python Package Index
--------------------------------------------------------------------------------------

The ‘register’ command registers the package with the Python Package
Index.  This is described in more detail in PEP 301(1).

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0301


File: python.info,  Node: distutils command check --- Check the meta-data of a package,  Prev: distutils command register --- Register a module with the Python Package Index,  Up: API Reference

8.10.47 ‘distutils.command.check’ — Check the meta-data of a package
--------------------------------------------------------------------

The ‘check’ command performs some tests on the meta-data of a package.
For example, it verifies that all required meta-data are provided as the
arguments passed to the ‘setup()’ function.


File: python.info,  Node: Installing Python Modules,  Next: Python HOWTOs,  Prev: Distributing Python Modules,  Up: Top

9 Installing Python Modules
***************************

     Author: Greg Ward

  This document describes the Python Distribution Utilities
("Distutils") from the end-user’s point-of-view, describing how to
extend the capabilities of a standard Python installation by building
and installing third-party Python modules and extensions.

     Note: This guide only covers the basic tools for installing
     extensions that are provided as part of this version of Python.
     Third party tools offer easier to use and more secure alternatives.
     Refer to the quick recommendations section(1) in the Python
     Packaging User Guide for more information.

* Menu:

* Introduction: Introduction<11>. 
* Standard Build and Install:: 
* Alternate Installation:: 
* Custom Installation:: 
* Distutils Configuration Files:: 
* Building Extensions; Tips and Tricks: Building Extensions Tips and Tricks. 

Introduction

* Best case; trivial installation: Best case trivial installation. 
* The new standard; Distutils: The new standard Distutils. 

Standard Build and Install

* Platform variations:: 
* Splitting the job up:: 
* How building works:: 
* How installation works:: 

Alternate Installation

* Alternate installation; the user scheme: Alternate installation the user scheme. 
* Alternate installation; the home scheme: Alternate installation the home scheme. 
* Alternate installation; Unix (the prefix scheme): Alternate installation Unix the prefix scheme. 
* Alternate installation; Windows (the prefix scheme): Alternate installation Windows the prefix scheme. 

Custom Installation

* Modifying Python's Search Path:: 

Distutils Configuration Files

* Location and names of config files:: 
* Syntax of config files:: 

Building Extensions: Tips and Tricks

* Tweaking compiler/linker flags:: 
* Using non-Microsoft compilers on Windows:: 

Using non-Microsoft compilers on Windows

* Borland/CodeGear C++:: 
* GNU C / Cygwin / MinGW:: 

GNU C / Cygwin / MinGW

* Older Versions of Python and MinGW:: 

   ---------- Footnotes ----------

   (1) 
https://python-packaging-user-guide.readthedocs.org/en/latest/current.html


File: python.info,  Node: Introduction<11>,  Next: Standard Build and Install,  Up: Installing Python Modules

9.1 Introduction
================

Although Python’s extensive standard library covers many programming
needs, there often comes a time when you need to add some new
functionality to your Python installation in the form of third-party
modules.  This might be necessary to support your own programming, or to
support an application that you want to use and that happens to be
written in Python.

  In the past, there has been little support for adding third-party
modules to an existing Python installation.  With the introduction of
the Python Distribution Utilities (Distutils for short) in Python 2.0,
this changed.

  This document is aimed primarily at the people who need to install
third-party Python modules: end-users and system administrators who just
need to get some Python application running, and existing Python
programmers who want to add some new goodies to their toolbox.  You
don’t need to know Python to read this document; there will be some
brief forays into using Python’s interactive mode to explore your
installation, but that’s it.  If you’re looking for information on how
to distribute your own Python modules so that others may use them, see
the *note Distributing Python Modules: 2479. manual.  *note Debugging
the setup script: 2e9d. may also be of interest.

* Menu:

* Best case; trivial installation: Best case trivial installation. 
* The new standard; Distutils: The new standard Distutils. 


File: python.info,  Node: Best case trivial installation,  Next: The new standard Distutils,  Up: Introduction<11>

9.1.1 Best case: trivial installation
-------------------------------------

In the best case, someone will have prepared a special version of the
module distribution you want to install that is targeted specifically at
your platform and is installed just like any other software on your
platform.  For example, the module developer might make an executable
installer available for Windows users, an RPM package for users of
RPM-based Linux systems (Red Hat, SuSE, Mandrake, and many others), a
Debian package for users of Debian-based Linux systems, and so forth.

  In that case, you would download the installer appropriate to your
platform and do the obvious thing with it: run it if it’s an executable
installer, ‘rpm --install’ it if it’s an RPM, etc.  You don’t need to
run Python or a setup script, you don’t need to compile anything—you
might not even need to read any instructions (although it’s always a
good idea to do so anyway).

  Of course, things will not always be that easy.  You might be
interested in a module distribution that doesn’t have an easy-to-use
installer for your platform.  In that case, you’ll have to start with
the source distribution released by the module’s author/maintainer.
Installing from a source distribution is not too hard, as long as the
modules are packaged in the standard way.  The bulk of this document is
about building and installing modules from standard source
distributions.


File: python.info,  Node: The new standard Distutils,  Prev: Best case trivial installation,  Up: Introduction<11>

9.1.2 The new standard: Distutils
---------------------------------

If you download a module source distribution, you can tell pretty
quickly if it was packaged and distributed in the standard way, i.e.
using the Distutils.  First, the distribution’s name and version number
will be featured prominently in the name of the downloaded archive, e.g.
‘foo-1.0.tar.gz’ or ‘widget-0.9.7.zip’.  Next, the archive will unpack
into a similarly-named directory: ‘foo-1.0’ or ‘widget-0.9.7’.
Additionally, the distribution will contain a setup script ‘setup.py’,
and a file named ‘README.txt’ or possibly just ‘README’, which should
explain that building and installing the module distribution is a simple
matter of running one command from a terminal:

     python setup.py install

  For Windows, this command should be run from a command prompt window
(_Start ‣ Accessories_):

     setup.py install

  If all these things are true, then you already know how to build and
install the modules you’ve just downloaded: Run the command above.
Unless you need to install things in a non-standard way or customize the
build process, you don’t really need this manual.  Or rather, the above
command is everything you need to get out of this manual.


File: python.info,  Node: Standard Build and Install,  Next: Alternate Installation,  Prev: Introduction<11>,  Up: Installing Python Modules

9.2 Standard Build and Install
==============================

As described in section *note The new standard; Distutils: 2f7a,
building and installing a module distribution using the Distutils is
usually one simple command to run from a terminal:

     python setup.py install

* Menu:

* Platform variations:: 
* Splitting the job up:: 
* How building works:: 
* How installation works:: 


File: python.info,  Node: Platform variations,  Next: Splitting the job up,  Up: Standard Build and Install

9.2.1 Platform variations
-------------------------

You should always run the setup command from the distribution root
directory, i.e.  the top-level subdirectory that the module source
distribution unpacks into.  For example, if you’ve just downloaded a
module source distribution ‘foo-1.0.tar.gz’ onto a Unix system, the
normal thing to do is:

     gunzip -c foo-1.0.tar.gz | tar xf -    # unpacks into directory foo-1.0
     cd foo-1.0
     python setup.py install

  On Windows, you’d probably download ‘foo-1.0.zip’.  If you downloaded
the archive file to ‘C:\Temp’, then it would unpack into
‘C:\Temp\foo-1.0’; you can use either a archive manipulator with a
graphical user interface (such as WinZip) or a command-line tool (such
as *unzip* or *pkunzip*) to unpack the archive.  Then, open a command
prompt window and run:

     cd c:\Temp\foo-1.0
     python setup.py install


File: python.info,  Node: Splitting the job up,  Next: How building works,  Prev: Platform variations,  Up: Standard Build and Install

9.2.2 Splitting the job up
--------------------------

Running ‘setup.py install’ builds and installs all modules in one run.
If you prefer to work incrementally—especially useful if you want to
customize the build process, or if things are going wrong—you can use
the setup script to do one thing at a time.  This is particularly
helpful when the build and install will be done by different users—for
example, you might want to build a module distribution and hand it off
to a system administrator for installation (or do it yourself, with
super-user privileges).

  For example, you can build everything in one step, and then install
everything in a second step, by invoking the setup script twice:

     python setup.py build
     python setup.py install

  If you do this, you will notice that running the *install* command
first runs the *build* command, which—in this case—quickly notices that
it has nothing to do, since everything in the ‘build’ directory is
up-to-date.

  You may not need this ability to break things down often if all you do
is install modules downloaded off the ’net, but it’s very handy for more
advanced tasks.  If you get into distributing your own Python modules
and extensions, you’ll run lots of individual Distutils commands on
their own.


File: python.info,  Node: How building works,  Next: How installation works,  Prev: Splitting the job up,  Up: Standard Build and Install

9.2.3 How building works
------------------------

As implied above, the *build* command is responsible for putting the
files to install into a _build directory_.  By default, this is ‘build’
under the distribution root; if you’re excessively concerned with speed,
or want to keep the source tree pristine, you can change the build
directory with the ‘--build-base’ option.  For example:

     python setup.py build --build-base=/path/to/pybuild/foo-1.0

  (Or you could do this permanently with a directive in your system or
personal Distutils configuration file; see section *note Distutils
Configuration Files: 2f83.)  Normally, this isn’t necessary.

  The default layout for the build tree is as follows:

     --- build/ --- lib/
     or
     --- build/ --- lib.<plat>/
                    temp.<plat>/

  where ‘<plat>’ expands to a brief description of the current
OS/hardware platform and Python version.  The first form, with just a
‘lib’ directory, is used for "pure module distributions"—that is, module
distributions that include only pure Python modules.  If a module
distribution contains any extensions (modules written in C/C++), then
the second form, with two ‘<plat>’ directories, is used.  In that case,
the ‘temp._plat_’ directory holds temporary files generated by the
compile/link process that don’t actually get installed.  In either case,
the ‘lib’ (or ‘lib._plat_’) directory contains all Python modules (pure
Python and extensions) that will be installed.

  In the future, more directories will be added to handle Python
scripts, documentation, binary executables, and whatever else is needed
to handle the job of installing Python modules and applications.


File: python.info,  Node: How installation works,  Prev: How building works,  Up: Standard Build and Install

9.2.4 How installation works
----------------------------

After the *build* command runs (whether you run it explicitly, or the
*install* command does it for you), the work of the *install* command is
relatively simple: all it has to do is copy everything under ‘build/lib’
(or ‘build/lib._plat_’) to your chosen installation directory.

  If you don’t choose an installation directory—i.e., if you just run
‘setup.py install’—then the *install* command installs to the standard
location for third-party Python modules.  This location varies by
platform and by how you built/installed Python itself.  On Unix (and Mac
OS X, which is also Unix-based), it also depends on whether the module
distribution being installed is pure Python or contains extensions
("non-pure"):

Platform              Standard installation location                            Default value                                          Notes
                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------
                                                                                                                                       
Unix (pure)           ‘_prefix_/lib/python_X.Y_/site-packages’                  ‘/usr/local/lib/python_X.Y_/site-packages’             (1)
                                                                                                                                       
                                                                                                                                       
Unix (non-pure)       ‘_exec-prefix_/lib/python_X.Y_/site-packages’             ‘/usr/local/lib/python_X.Y_/site-packages’             (1)
                                                                                                                                       
                                                                                                                                       
Windows               ‘_prefix_\Lib\site-packages’                              ‘C:\Python_XY_\Lib\site-packages’                      (2)
                                                                                                                                       

  Notes:

  1. Most Linux distributions include Python as a standard part of the
     system, so ‘_prefix_’ and ‘_exec-prefix_’ are usually both ‘/usr’
     on Linux.  If you build Python yourself on Linux (or any Unix-like
     system), the default ‘_prefix_’ and ‘_exec-prefix_’ are
     ‘/usr/local’.

  2. The default installation directory on Windows was ‘C:\Program
     Files\Python’ under Python 1.6a1, 1.5.2, and earlier.

  ‘_prefix_’ and ‘_exec-prefix_’ stand for the directories that Python
is installed to, and where it finds its libraries at run-time.  They are
always the same under Windows, and very often the same under Unix and
Mac OS X. You can find out what your Python installation uses for
‘_prefix_’ and ‘_exec-prefix_’ by running Python in interactive mode and
typing a few simple commands.  Under Unix, just type ‘python’ at the
shell prompt.  Under Windows, choose _Start ‣ Programs ‣ Python X.Y ‣
Python (command line)_.  Once the interpreter is started, you type
Python code at the prompt.  For example, on my Linux system, I type the
three Python statements shown below, and get the output as shown, to
find out my ‘_prefix_’ and ‘_exec-prefix_’:

     Python 2.4 (#26, Aug  7 2004, 17:19:02)
     Type "help", "copyright", "credits" or "license" for more information.
     >>> import sys
     >>> sys.prefix
     '/usr'
     >>> sys.exec_prefix
     '/usr'

  A few other placeholders are used in this document: ‘_X.Y_’ stands for
the version of Python, for example ‘2.7’; ‘_distname_’ will be replaced
by the name of the module distribution being installed.  Dots and
capitalization are important in the paths; for example, a value that
uses ‘python2.7’ on UNIX will typically use ‘Python27’ on Windows.

  If you don’t want to install modules to the standard location, or if
you don’t have permission to write there, then you need to read about
alternate installations in section *note Alternate Installation: 2f86.
If you want to customize your installation directories more heavily, see
section *note Custom Installation: 2f87. on custom installations.


File: python.info,  Node: Alternate Installation,  Next: Custom Installation,  Prev: Standard Build and Install,  Up: Installing Python Modules

9.3 Alternate Installation
==========================

Often, it is necessary or desirable to install modules to a location
other than the standard location for third-party Python modules.  For
example, on a Unix system you might not have permission to write to the
standard third-party module directory.  Or you might wish to try out a
module before making it a standard part of your local Python
installation.  This is especially true when upgrading a distribution
already present: you want to make sure your existing base of scripts
still works with the new version before actually upgrading.

  The Distutils *install* command is designed to make installing module
distributions to an alternate location simple and painless.  The basic
idea is that you supply a base directory for the installation, and the
*install* command picks a set of directories (called an _installation
scheme_) under this base directory in which to install files.  The
details differ across platforms, so read whichever of the following
sections applies to you.

  Note that the various alternate installation schemes are mutually
exclusive: you can pass ‘--user’, or ‘--home’, or ‘--prefix’ and
‘--exec-prefix’, or ‘--install-base’ and ‘--install-platbase’, but you
can’t mix from these groups.

* Menu:

* Alternate installation; the user scheme: Alternate installation the user scheme. 
* Alternate installation; the home scheme: Alternate installation the home scheme. 
* Alternate installation; Unix (the prefix scheme): Alternate installation Unix the prefix scheme. 
* Alternate installation; Windows (the prefix scheme): Alternate installation Windows the prefix scheme. 


File: python.info,  Node: Alternate installation the user scheme,  Next: Alternate installation the home scheme,  Up: Alternate Installation

9.3.1 Alternate installation: the user scheme
---------------------------------------------

This scheme is designed to be the most convenient solution for users
that don’t have write permission to the global site-packages directory
or don’t want to install into it.  It is enabled with a simple option:

     python setup.py install --user

  Files will be installed into subdirectories of *note site.USER_BASE:
653. (written as ‘_userbase_’ hereafter).  This scheme installs pure
Python modules and extension modules in the same location (also known as
*note site.USER_SITE: 640.).  Here are the values for UNIX, including
Mac OS X:

Type of file        Installation directory
                    
------------------------------------------------------------------------------------
                    
modules             ‘_userbase_/lib/python_X.Y_/site-packages’
                    
                    
scripts             ‘_userbase_/bin’
                    
                    
data                ‘_userbase_’
                    
                    
C headers           ‘_userbase_/include/python_X.Y_/_distname_’
                    

  And here are the values used on Windows:

Type of file        Installation directory
                    
------------------------------------------------------------------------------------
                    
modules             ‘_userbase_\Python_XY_\site-packages’
                    
                    
scripts             ‘_userbase_\Scripts’
                    
                    
data                ‘_userbase_’
                    
                    
C headers           ‘_userbase_\Python_XY_\Include\_distname_’
                    

  The advantage of using this scheme compared to the other ones
described below is that the user site-packages directory is under normal
conditions always included in *note sys.path: 57f. (see *note site: 158.
for more information), which means that there is no additional step to
perform after running the ‘setup.py’ script to finalize the
installation.

  The *build_ext* command also has a ‘--user’ option to add
‘_userbase_/include’ to the compiler search path for header files and
‘_userbase_/lib’ to the compiler search path for libraries as well as to
the runtime search path for shared C libraries (rpath).


File: python.info,  Node: Alternate installation the home scheme,  Next: Alternate installation Unix the prefix scheme,  Prev: Alternate installation the user scheme,  Up: Alternate Installation

9.3.2 Alternate installation: the home scheme
---------------------------------------------

The idea behind the "home scheme" is that you build and maintain a
personal stash of Python modules.  This scheme’s name is derived from
the idea of a "home" directory on Unix, since it’s not unusual for a
Unix user to make their home directory have a layout similar to ‘/usr/’
or ‘/usr/local/’.  This scheme can be used by anyone, regardless of the
operating system they are installing for.

  Installing a new module distribution is as simple as

     python setup.py install --home=<dir>

  where you can supply any directory you like for the ‘--home’ option.
On Unix, lazy typists can just type a tilde (‘~’); the *install* command
will expand this to your home directory:

     python setup.py install --home=~

  To make Python find the distributions installed with this scheme, you
may have to *note modify Python’s search path: 2f8c. or edit
‘sitecustomize’ (see *note site: 158.) to call *note site.addsitedir():
2469. or edit *note sys.path: 57f.

  The ‘--home’ option defines the installation base directory.  Files
are installed to the following directories under the installation base
as follows:

Type of file        Installation directory
                    
------------------------------------------------------------------------------------
                    
modules             ‘_home_/lib/python’
                    
                    
scripts             ‘_home_/bin’
                    
                    
data                ‘_home_’
                    
                    
C headers           ‘_home_/include/python/_distname_’
                    

  (Mentally replace slashes with backslashes if you’re on Windows.)

  Changed in version 2.4: The ‘--home’ option used to be supported only
on Unix.


File: python.info,  Node: Alternate installation Unix the prefix scheme,  Next: Alternate installation Windows the prefix scheme,  Prev: Alternate installation the home scheme,  Up: Alternate Installation

9.3.3 Alternate installation: Unix (the prefix scheme)
------------------------------------------------------

The "prefix scheme" is useful when you wish to use one Python
installation to perform the build/install (i.e., to run the setup
script), but install modules into the third-party module directory of a
different Python installation (or something that looks like a different
Python installation).  If this sounds a trifle unusual, it is—that’s why
the user and home schemes come before.  However, there are at least two
known cases where the prefix scheme will be useful.

  First, consider that many Linux distributions put Python in ‘/usr’,
rather than the more traditional ‘/usr/local’.  This is entirely
appropriate, since in those cases Python is part of "the system" rather
than a local add-on.  However, if you are installing Python modules from
source, you probably want them to go in ‘/usr/local/lib/python2._X_’
rather than ‘/usr/lib/python2._X_’.  This can be done with

     /usr/bin/python setup.py install --prefix=/usr/local

  Another possibility is a network filesystem where the name used to
write to a remote directory is different from the name used to read it:
for example, the Python interpreter accessed as ‘/usr/local/bin/python’
might search for modules in ‘/usr/local/lib/python2._X_’, but those
modules would have to be installed to, say,
‘/mnt/_@server_/export/lib/python2._X_’.  This could be done with

     /usr/local/bin/python setup.py install --prefix=/mnt/@server/export

  In either case, the ‘--prefix’ option defines the installation base,
and the ‘--exec-prefix’ option defines the platform-specific
installation base, which is used for platform-specific files.
(Currently, this just means non-pure module distributions, but could be
expanded to C libraries, binary executables, etc.)  If ‘--exec-prefix’
is not supplied, it defaults to ‘--prefix’.  Files are installed as
follows:

Type of file          Installation directory
                      
-------------------------------------------------------------------------------------
                      
Python modules        ‘_prefix_/lib/python_X.Y_/site-packages’
                      
                      
extension modules     ‘_exec-prefix_/lib/python_X.Y_/site-packages’
                      
                      
scripts               ‘_prefix_/bin’
                      
                      
data                  ‘_prefix_’
                      
                      
C headers             ‘_prefix_/include/python_X.Y_/_distname_’
                      

  There is no requirement that ‘--prefix’ or ‘--exec-prefix’ actually
point to an alternate Python installation; if the directories listed
above do not already exist, they are created at installation time.

  Incidentally, the real reason the prefix scheme is important is simply
that a standard Unix installation uses the prefix scheme, but with
‘--prefix’ and ‘--exec-prefix’ supplied by Python itself as ‘sys.prefix’
and ‘sys.exec_prefix’.  Thus, you might think you’ll never use the
prefix scheme, but every time you run ‘python setup.py install’ without
any other options, you’re using it.

  Note that installing extensions to an alternate Python installation
has no effect on how those extensions are built: in particular, the
Python header files (‘Python.h’ and friends) installed with the Python
interpreter used to run the setup script will be used in compiling
extensions.  It is your responsibility to ensure that the interpreter
used to run extensions installed in this way is compatible with the
interpreter used to build them.  The best way to do this is to ensure
that the two interpreters are the same version of Python (possibly
different builds, or possibly copies of the same build).  (Of course, if
your ‘--prefix’ and ‘--exec-prefix’ don’t even point to an alternate
Python installation, this is immaterial.)


File: python.info,  Node: Alternate installation Windows the prefix scheme,  Prev: Alternate installation Unix the prefix scheme,  Up: Alternate Installation

9.3.4 Alternate installation: Windows (the prefix scheme)
---------------------------------------------------------

Windows has no concept of a user’s home directory, and since the
standard Python installation under Windows is simpler than under Unix,
the ‘--prefix’ option has traditionally been used to install additional
packages in separate locations on Windows.

     python setup.py install --prefix="\Temp\Python"

  to install modules to the ‘\Temp\Python’ directory on the current
drive.

  The installation base is defined by the ‘--prefix’ option; the
‘--exec-prefix’ option is not supported under Windows, which means that
pure Python modules and extension modules are installed into the same
location.  Files are installed as follows:

Type of file        Installation directory
                    
-----------------------------------------------------------------------------------
                    
modules             ‘_prefix_\Lib\site-packages’
                    
                    
scripts             ‘_prefix_\Scripts’
                    
                    
data                ‘_prefix_’
                    
                    
C headers           ‘_prefix_\Include\_distname_’
                    


File: python.info,  Node: Custom Installation,  Next: Distutils Configuration Files,  Prev: Alternate Installation,  Up: Installing Python Modules

9.4 Custom Installation
=======================

Sometimes, the alternate installation schemes described in section *note
Alternate Installation: 2f86. just don’t do what you want.  You might
want to tweak just one or two directories while keeping everything under
the same base directory, or you might want to completely redefine the
installation scheme.  In either case, you’re creating a _custom
installation scheme_.

  To create a custom installation scheme, you start with one of the
alternate schemes and override some of the installation directories used
for the various types of files, using these options:

Type of file               Override option
                           
-------------------------------------------------------
                           
Python modules             ‘--install-purelib’
                           
                           
extension modules          ‘--install-platlib’
                           
                           
all modules                ‘--install-lib’
                           
                           
scripts                    ‘--install-scripts’
                           
                           
data                       ‘--install-data’
                           
                           
C headers                  ‘--install-headers’
                           

  These override options can be relative, absolute, or explicitly
defined in terms of one of the installation base directories.  (There
are two installation base directories, and they are normally the same—
they only differ when you use the Unix "prefix scheme" and supply
different ‘--prefix’ and ‘--exec-prefix’ options; using ‘--install-lib’
will override values computed or given for ‘--install-purelib’ and
‘--install-platlib’, and is recommended for schemes that don’t make a
difference between Python and extension modules.)

  For example, say you’re installing a module distribution to your home
directory under Unix—but you want scripts to go in ‘~/scripts’ rather
than ‘~/bin’.  As you might expect, you can override this directory with
the ‘--install-scripts’ option; in this case, it makes most sense to
supply a relative path, which will be interpreted relative to the
installation base directory (your home directory, in this case):

     python setup.py install --home=~ --install-scripts=scripts

  Another Unix example: suppose your Python installation was built and
installed with a prefix of ‘/usr/local/python’, so under a standard
installation scripts will wind up in ‘/usr/local/python/bin’.  If you
want them in ‘/usr/local/bin’ instead, you would supply this absolute
directory for the ‘--install-scripts’ option:

     python setup.py install --install-scripts=/usr/local/bin

  (This performs an installation using the "prefix scheme," where the
prefix is whatever your Python interpreter was installed with—
‘/usr/local/python’ in this case.)

  If you maintain Python on Windows, you might want third-party modules
to live in a subdirectory of ‘_prefix_’, rather than right in ‘_prefix_’
itself.  This is almost as easy as customizing the script installation
directory —you just have to remember that there are two types of modules
to worry about, Python and extension modules, which can conveniently be
both controlled by one option:

     python setup.py install --install-lib=Site

  The specified installation directory is relative to ‘_prefix_’.  Of
course, you also have to ensure that this directory is in Python’s
module search path, such as by putting a ‘.pth’ file in a site directory
(see *note site: 158.).  See section *note Modifying Python’s Search
Path: 2f8c. to find out how to modify Python’s search path.

  If you want to define an entire installation scheme, you just have to
supply all of the installation directory options.  The recommended way
to do this is to supply relative paths; for example, if you want to
maintain all Python module-related files under ‘python’ in your home
directory, and you want a separate directory for each platform that you
use your home directory from, you might define the following
installation scheme:

     python setup.py install --home=~ \
                             --install-purelib=python/lib \
                             --install-platlib=python/lib.$PLAT \
                             --install-scripts=python/scripts
                             --install-data=python/data

  or, equivalently,

     python setup.py install --home=~/python \
                             --install-purelib=lib \
                             --install-platlib='lib.$PLAT' \
                             --install-scripts=scripts
                             --install-data=data

  ‘$PLAT’ is not (necessarily) an environment variable—it will be
expanded by the Distutils as it parses your command line options, just
as it does when parsing your configuration file(s).

  Obviously, specifying the entire installation scheme every time you
install a new module distribution would be very tedious.  Thus, you can
put these options into your Distutils config file (see section *note
Distutils Configuration Files: 2f83.):

     [install]
     install-base=$HOME
     install-purelib=python/lib
     install-platlib=python/lib.$PLAT
     install-scripts=python/scripts
     install-data=python/data

  or, equivalently,

     [install]
     install-base=$HOME/python
     install-purelib=lib
     install-platlib=lib.$PLAT
     install-scripts=scripts
     install-data=data

  Note that these two are _not_ equivalent if you supply a different
installation base directory when you run the setup script.  For example,

     python setup.py install --install-base=/tmp

  would install pure modules to ‘/tmp/python/lib’ in the first case, and
to ‘/tmp/lib’ in the second case.  (For the second case, you probably
want to supply an installation base of ‘/tmp/python’.)

  You probably noticed the use of ‘$HOME’ and ‘$PLAT’ in the sample
configuration file input.  These are Distutils configuration variables,
which bear a strong resemblance to environment variables.  In fact, you
can use environment variables in config files on platforms that have
such a notion but the Distutils additionally define a few extra
variables that may not be in your environment, such as ‘$PLAT’.  (And of
course, on systems that don’t have environment variables, such as Mac OS
9, the configuration variables supplied by the Distutils are the only
ones you can use.)  See section *note Distutils Configuration Files:
2f83. for details.

* Menu:

* Modifying Python's Search Path:: 


File: python.info,  Node: Modifying Python's Search Path,  Up: Custom Installation

9.4.1 Modifying Python’s Search Path
------------------------------------

When the Python interpreter executes an *note import: 1f4. statement, it
searches for both Python code and extension modules along a search path.
A default value for the path is configured into the Python binary when
the interpreter is built.  You can determine the path by importing the
*note sys: 16d. module and printing the value of ‘sys.path’.

     $ python
     Python 2.2 (#11, Oct  3 2002, 13:31:27)
     [GCC 2.96 20000731 (Red Hat Linux 7.3 2.96-112)] on linux2
     Type "help", "copyright", "credits" or "license" for more information.
     >>> import sys
     >>> sys.path
     ['', '/usr/local/lib/python2.3', '/usr/local/lib/python2.3/plat-linux2',
      '/usr/local/lib/python2.3/lib-tk', '/usr/local/lib/python2.3/lib-dynload',
      '/usr/local/lib/python2.3/site-packages']
     >>>

  The null string in ‘sys.path’ represents the current working
directory.

  The expected convention for locally installed packages is to put them
in the ‘_..._/site-packages/’ directory, but you may want to install
Python modules into some arbitrary directory.  For example, your site
may have a convention of keeping all software related to the web server
under ‘/www’.  Add-on Python modules might then belong in ‘/www/python’,
and in order to import them, this directory must be added to ‘sys.path’.
There are several different ways to add the directory.

  The most convenient way is to add a path configuration file to a
directory that’s already on Python’s path, usually to the
‘.../site-packages/’ directory.  Path configuration files have an
extension of ‘.pth’, and each line must contain a single path that will
be appended to ‘sys.path’.  (Because the new paths are appended to
‘sys.path’, modules in the added directories will not override standard
modules.  This means you can’t use this mechanism for installing fixed
versions of standard modules.)

  Paths can be absolute or relative, in which case they’re relative to
the directory containing the ‘.pth’ file.  See the documentation of the
*note site: 158. module for more information.

  A slightly less convenient way is to edit the ‘site.py’ file in
Python’s standard library, and modify ‘sys.path’.  ‘site.py’ is
automatically imported when the Python interpreter is executed, unless
the *note -S: 641. switch is supplied to suppress this behaviour.  So
you could simply edit ‘site.py’ and add two lines to it:

     import sys
     sys.path.append('/www/python/')

  However, if you reinstall the same major version of Python (perhaps
when upgrading from 2.2 to 2.2.2, for example) ‘site.py’ will be
overwritten by the stock version.  You’d have to remember that it was
modified and save a copy before doing the installation.

  There are two environment variables that can modify ‘sys.path’.  *note
PYTHONHOME: 63d. sets an alternate value for the prefix of the Python
installation.  For example, if *note PYTHONHOME: 63d. is set to
‘/www/python’, the search path will be set to ‘['',
'/www/python/lib/pythonX.Y/', '/www/python/lib/pythonX.Y/plat-linux2',
...]’.

  The *note PYTHONPATH: 580. variable can be set to a list of paths that
will be added to the beginning of ‘sys.path’.  For example, if *note
PYTHONPATH: 580. is set to ‘/www/python:/opt/py’, the search path will
begin with ‘['/www/python', '/opt/py']’.  (Note that directories must
exist in order to be added to ‘sys.path’; the *note site: 158. module
removes paths that don’t exist.)

  Finally, ‘sys.path’ is just a regular Python list, so any Python
application can modify it by adding or removing entries.


File: python.info,  Node: Distutils Configuration Files,  Next: Building Extensions Tips and Tricks,  Prev: Custom Installation,  Up: Installing Python Modules

9.5 Distutils Configuration Files
=================================

As mentioned above, you can use Distutils configuration files to record
personal or site preferences for any Distutils options.  That is, any
option to any command can be stored in one of two or three (depending on
your platform) configuration files, which will be consulted before the
command-line is parsed.  This means that configuration files will
override default values, and the command-line will in turn override
configuration files.  Furthermore, if multiple configuration files
apply, values from "earlier" files are overridden by "later" files.

* Menu:

* Location and names of config files:: 
* Syntax of config files:: 


File: python.info,  Node: Location and names of config files,  Next: Syntax of config files,  Up: Distutils Configuration Files

9.5.1 Location and names of config files
----------------------------------------

The names and locations of the configuration files vary slightly across
platforms.  On Unix and Mac OS X, the three configuration files (in the
order they are processed) are:

Type of file       Location and filename                                          Notes
                                                                                  
----------------------------------------------------------------------------------------------
                                                                                  
system             ‘_prefix_/lib/python_ver_/distutils/distutils.cfg’             (1)
                                                                                  
                                                                                  
personal           ‘$HOME/.pydistutils.cfg’                                       (2)
                                                                                  
                                                                                  
local              ‘setup.cfg’                                                    (3)
                                                                                  

  And on Windows, the configuration files are:

Type of file       Location and filename                                 Notes
                                                                         
-------------------------------------------------------------------------------------
                                                                         
system             ‘_prefix_\Lib\distutils\distutils.cfg’                (4)
                                                                         
                                                                         
personal           ‘%HOME%\pydistutils.cfg’                              (5)
                                                                         
                                                                         
local              ‘setup.cfg’                                           (3)
                                                                         

  On all platforms, the "personal" file can be temporarily disabled by
passing the ‘–no-user-cfg’ option.

  Notes:

  1. Strictly speaking, the system-wide configuration file lives in the
     directory where the Distutils are installed; under Python 1.6 and
     later on Unix, this is as shown.  For Python 1.5.2, the Distutils
     will normally be installed to
     ‘_prefix_/lib/python1.5/site-packages/distutils’, so the system
     configuration file should be put there under Python 1.5.2.

  2. On Unix, if the ‘HOME’ environment variable is not defined, the
     user’s home directory will be determined with the ‘getpwuid()’
     function from the standard *note pwd: 13c. module.  This is done by
     the *note os.path.expanduser(): df9. function used by Distutils.

  3. I.e., in the current directory (usually the location of the setup
     script).

  4. (See also note (1).)  Under Python 1.6 and later, Python’s default
     "installation prefix" is ‘C:\Python’, so the system configuration
     file is normally ‘C:\Python\Lib\distutils\distutils.cfg’.  Under
     Python 1.5.2, the default prefix was ‘C:\Program Files\Python’, and
     the Distutils were not part of the standard library—so the system
     configuration file would be ‘C:\Program
     Files\Python\distutils\distutils.cfg’ in a standard Python 1.5.2
     installation under Windows.

  5. On Windows, if the ‘HOME’ environment variable is not defined,
     ‘USERPROFILE’ then ‘HOMEDRIVE’ and ‘HOMEPATH’ will be tried.  This
     is done by the *note os.path.expanduser(): df9. function used by
     Distutils.


File: python.info,  Node: Syntax of config files,  Prev: Location and names of config files,  Up: Distutils Configuration Files

9.5.2 Syntax of config files
----------------------------

The Distutils configuration files all have the same syntax.  The config
files are grouped into sections.  There is one section for each
Distutils command, plus a ‘global’ section for global options that
affect every command.  Each section consists of one option per line,
specified as ‘option=value’.

  For example, the following is a complete config file that just forces
all commands to run quietly by default:

     [global]
     verbose=0

  If this is installed as the system config file, it will affect all
processing of any Python module distribution by any user on the current
system.  If it is installed as your personal config file (on systems
that support them), it will affect only module distributions processed
by you.  And if it is used as the ‘setup.cfg’ for a particular module
distribution, it affects only that distribution.

  You could override the default "build base" directory and make the
*build** commands always forcibly rebuild all files with the following:

     [build]
     build-base=blib
     force=1

  which corresponds to the command-line arguments

     python setup.py build --build-base=blib --force

  except that including the *build* command on the command-line means
that command will be run.  Including a particular command in config
files has no such implication; it only means that if the command is run,
the options in the config file will apply.  (Or if other commands that
derive values from it are run, they will use the values in the config
file.)

  You can find out the complete list of options for any command using
the *note –help: 1d5. option, e.g.:

     python setup.py build --help

  and you can find out the complete list of global options by using
*note –help: 1d5. without a command:

     python setup.py --help

  See also the "Reference" section of the "Distributing Python Modules"
manual.


File: python.info,  Node: Building Extensions Tips and Tricks,  Prev: Distutils Configuration Files,  Up: Installing Python Modules

9.6 Building Extensions: Tips and Tricks
========================================

Whenever possible, the Distutils try to use the configuration
information made available by the Python interpreter used to run the
‘setup.py’ script.  For example, the same compiler and linker flags used
to compile Python will also be used for compiling extensions.  Usually
this will work well, but in complicated situations this might be
inappropriate.  This section discusses how to override the usual
Distutils behaviour.

* Menu:

* Tweaking compiler/linker flags:: 
* Using non-Microsoft compilers on Windows:: 


File: python.info,  Node: Tweaking compiler/linker flags,  Next: Using non-Microsoft compilers on Windows,  Up: Building Extensions Tips and Tricks

9.6.1 Tweaking compiler/linker flags
------------------------------------

Compiling a Python extension written in C or C++ will sometimes require
specifying custom flags for the compiler and linker in order to use a
particular library or produce a special kind of object code.  This is
especially true if the extension hasn’t been tested on your platform, or
if you’re trying to cross-compile Python.

  In the most general case, the extension author might have foreseen
that compiling the extensions would be complicated, and provided a
‘Setup’ file for you to edit.  This will likely only be done if the
module distribution contains many separate extension modules, or if they
often require elaborate sets of compiler flags in order to work.

  A ‘Setup’ file, if present, is parsed in order to get a list of
extensions to build.  Each line in a ‘Setup’ describes a single module.
Lines have the following structure:

     module ... [sourcefile ...] [cpparg ...] [library ...]

  Let’s examine each of the fields in turn.

   * _module_ is the name of the extension module to be built, and
     should be a valid Python identifier.  You can’t just change this in
     order to rename a module (edits to the source code would also be
     needed), so this should be left alone.

   * _sourcefile_ is anything that’s likely to be a source code file, at
     least judging by the filename.  Filenames ending in ‘.c’ are
     assumed to be written in C, filenames ending in ‘.C’, ‘.cc’, and
     ‘.c++’ are assumed to be C++, and filenames ending in ‘.m’ or ‘.mm’
     are assumed to be in Objective C.

   * _cpparg_ is an argument for the C preprocessor, and is anything
     starting with ‘-I’, ‘-D’, *note -U: 64a. or ‘-C’.

   * _library_ is anything ending in ‘.a’ or beginning with ‘-l’ or
     ‘-L’.

  If a particular platform requires a special library on your platform,
you can add it by editing the ‘Setup’ file and running ‘python setup.py
build’.  For example, if the module defined by the line

     foo foomodule.c

  must be linked with the math library ‘libm.a’ on your platform, simply
add ‘-lm’ to the line:

     foo foomodule.c -lm

  Arbitrary switches intended for the compiler or the linker can be
supplied with the ‘-Xcompiler’ _arg_ and ‘-Xlinker’ _arg_ options:

     foo foomodule.c -Xcompiler -o32 -Xlinker -shared -lm

  The next option after ‘-Xcompiler’ and ‘-Xlinker’ will be appended to
the proper command line, so in the above example the compiler will be
passed the ‘-o32’ option, and the linker will be passed ‘-shared’.  If a
compiler option requires an argument, you’ll have to supply multiple
‘-Xcompiler’ options; for example, to pass ‘-x c++’ the ‘Setup’ file
would have to contain ‘-Xcompiler -x -Xcompiler c++’.

  Compiler flags can also be supplied through setting the ‘CFLAGS’
environment variable.  If set, the contents of ‘CFLAGS’ will be added to
the compiler flags specified in the ‘Setup’ file.


File: python.info,  Node: Using non-Microsoft compilers on Windows,  Prev: Tweaking compiler/linker flags,  Up: Building Extensions Tips and Tricks

9.6.2 Using non-Microsoft compilers on Windows
----------------------------------------------

* Menu:

* Borland/CodeGear C++:: 
* GNU C / Cygwin / MinGW:: 


File: python.info,  Node: Borland/CodeGear C++,  Next: GNU C / Cygwin / MinGW,  Up: Using non-Microsoft compilers on Windows

9.6.2.1 Borland/CodeGear C++
............................

This subsection describes the necessary steps to use Distutils with the
Borland C++ compiler version 5.5.  First you have to know that Borland’s
object file format (OMF) is different from the format used by the Python
version you can download from the Python or ActiveState Web site.
(Python is built with Microsoft Visual C++, which uses COFF as the
object file format.)  For this reason you have to convert Python’s
library ‘python25.lib’ into the Borland format.  You can do this as
follows:

     coff2omf python25.lib python25_bcpp.lib

  The ‘coff2omf’ program comes with the Borland compiler.  The file
‘python25.lib’ is in the ‘Libs’ directory of your Python installation.
If your extension uses other libraries (zlib, ...)  you have to convert
them too.

  The converted files have to reside in the same directories as the
normal libraries.

  How does Distutils manage to use these libraries with their changed
names?  If the extension needs a library (eg.  ‘foo’) Distutils checks
first if it finds a library with suffix ‘_bcpp’ (eg.  ‘foo_bcpp.lib’)
and then uses this library.  In the case it doesn’t find such a special
library it uses the default name (‘foo.lib’.)  (1)

  To let Distutils compile your extension with Borland C++ you now have
to type:

     python setup.py build --compiler=bcpp

  If you want to use the Borland C++ compiler as the default, you could
specify this in your personal or system-wide configuration file for
Distutils (see section *note Distutils Configuration Files: 2f83.)

See also
........

C++Builder Compiler(2)

     Information about the free C++ compiler from Borland, including
     links to the download pages.

Creating Python Extensions Using Borland’s Free Compiler(3)

     Document describing how to use Borland’s free command-line C++
     compiler to build Python.

   ---------- Footnotes ----------

   (1) This also means you could replace all existing COFF-libraries
with OMF-libraries of the same name.

   (2) http://www.codegear.com/downloads/free/cppbuilder

   (3) http://www.cyberus.ca/~g_will/pyExtenDL.shtml


File: python.info,  Node: GNU C / Cygwin / MinGW,  Prev: Borland/CodeGear C++,  Up: Using non-Microsoft compilers on Windows

9.6.2.2 GNU C / Cygwin / MinGW
..............................

This section describes the necessary steps to use Distutils with the GNU
C/C++ compilers in their Cygwin and MinGW distributions.  (1) For a
Python interpreter that was built with Cygwin, everything should work
without any of these following steps.

  Not all extensions can be built with MinGW or Cygwin, but many can.
Extensions most likely to not work are those that use C++ or depend on
Microsoft Visual C extensions.

  To let Distutils compile your extension with Cygwin you have to type:

     python setup.py build --compiler=cygwin

  and for Cygwin in no-cygwin mode (2) or for MinGW type:

     python setup.py build --compiler=mingw32

  If you want to use any of these options/compilers as default, you
should consider writing it in your personal or system-wide configuration
file for Distutils (see section *note Distutils Configuration Files:
2f83.)

* Menu:

* Older Versions of Python and MinGW:: 

   ---------- Footnotes ----------

   (1) Check ‘http://sources.redhat.com/cygwin/’ and
‘http://www.mingw.org/’ for more information

   (2) Then you have no POSIX emulation available, but you also don’t
need ‘cygwin1.dll’.


File: python.info,  Node: Older Versions of Python and MinGW,  Up: GNU C / Cygwin / MinGW

9.6.2.3 Older Versions of Python and MinGW
..........................................

The following instructions only apply if you’re using a version of
Python inferior to 2.4.1 with a MinGW inferior to 3.0.0 (with
binutils-2.13.90-20030111-1).

  These compilers require some special libraries.  This task is more
complex than for Borland’s C++, because there is no program to convert
the library.  First you have to create a list of symbols which the
Python DLL exports.  (You can find a good program for this task at
‘http://sourceforge.net/projects/mingw/files/MinGW/Extension/pexports/’).

     pexports python25.dll >python25.def

  The location of an installed ‘python25.dll’ will depend on the
installation options and the version and language of Windows.  In a
"just for me" installation, it will appear in the root of the
installation directory.  In a shared installation, it will be located in
the system directory.

  Then you can create from these information an import library for gcc.

     /cygwin/bin/dlltool --dllname python25.dll --def python25.def --output-lib libpython25.a

  The resulting library has to be placed in the same directory as
‘python25.lib’.  (Should be the ‘libs’ directory under your Python
installation directory.)

  If your extension uses other libraries (zlib,...)  you might have to
convert them too.  The converted files have to reside in the same
directories as the normal libraries do.

See also
........

Building Python modules on MS Windows platform with MinGW(1)

     Information about building the required libraries for the MinGW
     environment.

   ---------- Footnotes ----------

   (1) http://www.zope.org/Members/als/tips/win32_mingw_modules


File: python.info,  Node: Python HOWTOs,  Next: Python Frequently Asked Questions,  Prev: Installing Python Modules,  Up: Top

10 Python HOWTOs
****************

Python HOWTOs are documents that cover a single, specific topic, and
attempt to cover it fairly completely.  Modelled on the Linux
Documentation Project’s HOWTO collection, this collection is an effort
to foster documentation that’s more detailed than the Python Library
Reference.

  Currently, the HOWTOs are:

* Menu:

* Porting Python 2 Code to Python 3:: 
* Porting Extension Modules to Python 3:: 
* Curses Programming with Python:: 
* Descriptor HowTo Guide:: 
* Idioms and Anti-Idioms in Python:: 
* Functional Programming HOWTO:: 
* Logging HOWTO:: 
* Logging Cookbook:: 
* Regular Expression HOWTO:: 
* Socket Programming HOWTO:: 
* Sorting HOW TO:: 
* Unicode HOWTO:: 
* HOWTO Fetch Internet Resources Using urllib2:: 
* HOWTO Use Python in the web:: 
* Argparse Tutorial:: 

Porting Python 2 Code to Python 3

* The Short Version:: 
* Before You Begin:: 
* Writing Source-Compatible Python 2/3 Code:: 
* Alternative Approaches:: 
* Other Resources: Other Resources<2>. 

Writing Source-Compatible Python 2/3 Code

* Projects to Consider:: 
* Tips & Tricks:: 
* Eliminate -3 Warnings:: 

Tips & Tricks

* Support Python 2.7: Support Python 2 7. 
* Try to Support Python 2.6 and Newer Only: Try to Support Python 2 6 and Newer Only. 
* Supporting Python 2.5 and Newer Only: Supporting Python 2 5 and Newer Only. 
* Handle Common "Gotchas":: 

Try to Support Python 2.6 and Newer Only

* from __future__ import print_function:: 
* from __future__ import unicode_literals:: 
* Bytes/string literals:: 
* from __future__ import absolute_import:: 

Supporting Python 2.5 and Newer Only

* from __future__ import absolute_import: from __future__ import absolute_import<2>. 
* Mark all Unicode strings with a u prefix:: 
* Capturing the Currently Raised Exception:: 

Handle Common "Gotchas"

* from __future__ import division:: 
* Specify when opening a file as binary:: 
* Text files:: 
* Subclass object:: 
* Deal With the Bytes/String Dichotomy:: 
* Indexing bytes objects:: 
* __str__()/__unicode__(): __str__ /__unicode__. 
* Don't Index on Exceptions:: 
* Don't use __getslice__ & Friends:: 
* Updating doctests:: 
* Update map for imbalanced input sequences:: 

Deal With the Bytes/String Dichotomy

* Mark Up Python 2 String Literals:: 
* Decide what APIs Will Accept:: 
* Bytes / Unicode Comparison:: 

Alternative Approaches

* Supporting Only Python 3 Going Forward From Python 2 Code:: 
* Backporting Python 3 code to Python 2:: 

Porting Extension Modules to Python 3

* Conditional compilation:: 
* Changes to Object APIs:: 
* Module initialization and state:: 
* CObject replaced with Capsule:: 
* Other options: Other options<2>. 

Changes to Object APIs

* str/unicode Unification:: 
* long/int Unification:: 

Curses Programming with Python

* What is curses?:: 
* Starting and ending a curses application:: 
* Windows and Pads:: 
* Displaying Text:: 
* User Input:: 
* For More Information:: 

What is curses?

* The Python curses module:: 

Displaying Text

* Attributes and Color:: 

Descriptor HowTo Guide

* Abstract:: 
* Definition and Introduction:: 
* Descriptor Protocol:: 
* Invoking Descriptors: Invoking Descriptors<2>. 
* Descriptor Example:: 
* Properties:: 
* Functions and Methods:: 
* Static Methods and Class Methods:: 

Idioms and Anti-Idioms in Python

* Language Constructs You Should Not Use:: 
* Exceptions: Exceptions<8>. 
* Using the Batteries:: 
* Using Backslash to Continue Statements:: 

Language Constructs You Should Not Use

* from module import *:: 
* Unadorned exec, execfile() and friends: Unadorned exec execfile and friends. 
* from module import name1, name2: from module import name1 name2. 
* except;: except. 

from module import *

* Inside Function Definitions:: 
* At Module Level:: 
* When It Is Just Fine:: 

Functional Programming HOWTO

* Introduction: Introduction<12>. 
* Iterators: Iterators<2>. 
* Generator expressions and list comprehensions:: 
* Generators: Generators<2>. 
* Built-in functions:: 
* Small functions and the lambda expression:: 
* The itertools module:: 
* The functools module:: 
* Revision History and Acknowledgements:: 
* References:: 

Introduction

* Formal provability:: 
* Modularity:: 
* Ease of debugging and testing:: 
* Composability:: 

Iterators

* Data Types That Support Iterators:: 

Generators

* Passing values into a generator:: 

The itertools module

* Creating new iterators:: 
* Calling functions on elements:: 
* Selecting elements:: 
* Grouping elements:: 

The functools module

* The operator module:: 

References

* General:: 
* Python-specific:: 
* Python documentation:: 

Logging HOWTO

* Basic Logging Tutorial:: 
* Advanced Logging Tutorial:: 
* Logging Levels: Logging Levels<2>. 
* Useful Handlers:: 
* Exceptions raised during logging:: 
* Using arbitrary objects as messages:: 
* Optimization:: 

Basic Logging Tutorial

* When to use logging:: 
* A simple example:: 
* Logging to a file:: 
* Logging from multiple modules:: 
* Logging variable data:: 
* Changing the format of displayed messages:: 
* Displaying the date/time in messages:: 
* Next Steps:: 

Advanced Logging Tutorial

* Logging Flow:: 
* Loggers:: 
* Handlers:: 
* Formatters:: 
* Configuring Logging:: 
* What happens if no configuration is provided:: 
* Configuring Logging for a Library:: 

Logging Levels

* Custom Levels:: 

Logging Cookbook

* Using logging in multiple modules:: 
* Multiple handlers and formatters:: 
* Logging to multiple destinations:: 
* Configuration server example:: 
* Sending and receiving logging events across a network:: 
* Adding contextual information to your logging output:: 
* Logging to a single file from multiple processes:: 
* Using file rotation:: 
* An example dictionary-based configuration:: 
* Inserting a BOM into messages sent to a SysLogHandler:: 
* Implementing structured logging:: 
* Customizing handlers with dictConfig(): Customizing handlers with dictConfig. 
* Configuring filters with dictConfig(): Configuring filters with dictConfig. 

Adding contextual information to your logging output

* Using LoggerAdapters to impart contextual information:: 
* Using Filters to impart contextual information:: 

Using LoggerAdapters to impart contextual information

* Using objects other than dicts to pass contextual information:: 

Regular Expression HOWTO

* Introduction: Introduction<13>. 
* Simple Patterns:: 
* Using Regular Expressions:: 
* More Pattern Power:: 
* Modifying Strings:: 
* Common Problems:: 
* Feedback:: 

Simple Patterns

* Matching Characters:: 
* Repeating Things:: 

Using Regular Expressions

* Compiling Regular Expressions:: 
* The Backslash Plague:: 
* Performing Matches:: 
* Module-Level Functions: Module-Level Functions<2>. 
* Compilation Flags:: 

More Pattern Power

* More Metacharacters:: 
* Grouping:: 
* Non-capturing and Named Groups:: 
* Lookahead Assertions:: 

Modifying Strings

* Splitting Strings:: 
* Search and Replace:: 

Common Problems

* Use String Methods:: 
* match() versus search(): match versus search. 
* Greedy versus Non-Greedy:: 
* Using re.VERBOSE: Using re VERBOSE. 

Socket Programming HOWTO

* Sockets:: 
* Creating a Socket:: 
* Using a Socket:: 
* Disconnecting:: 
* Non-blocking Sockets:: 

Sockets

* History:: 

Creating a Socket

* IPC:: 

Using a Socket

* Binary Data:: 

Disconnecting

* When Sockets Die:: 

Non-blocking Sockets

* Performance: Performance<2>. 

Sorting HOW TO

* Sorting Basics:: 
* Key Functions:: 
* Operator Module Functions:: 
* Ascending and Descending:: 
* Sort Stability and Complex Sorts:: 
* The Old Way Using Decorate-Sort-Undecorate:: 
* The Old Way Using the cmp Parameter:: 
* Odd and Ends:: 

Unicode HOWTO

* Introduction to Unicode:: 
* Python 2.x’s Unicode Support: Python 2 x's Unicode Support. 
* Reading and Writing Unicode Data:: 
* Revision History and Acknowledgements: Revision History and Acknowledgements<2>. 

Introduction to Unicode

* History of Character Codes:: 
* Definitions:: 
* Encodings:: 
* References: References<2>. 

Python 2.x’s Unicode Support

* The Unicode Type:: 
* Unicode Literals in Python Source Code:: 
* Unicode Properties:: 
* References: References<3>. 

Reading and Writing Unicode Data

* Unicode filenames:: 
* Tips for Writing Unicode-aware Programs:: 
* References: References<4>. 

HOWTO Fetch Internet Resources Using urllib2

* Introduction: Introduction<14>. 
* Fetching URLs:: 
* Handling Exceptions: Handling Exceptions<2>. 
* info and geturl:: 
* Openers and Handlers:: 
* Basic Authentication:: 
* Proxies:: 
* Sockets and Layers:: 
* Footnotes:: 

Fetching URLs

* Data:: 
* Headers:: 

Handling Exceptions

* URLError:: 
* HTTPError:: 
* Wrapping it Up:: 

HTTPError

* Error Codes:: 

Wrapping it Up

* Number 1:: 
* Number 2:: 

HOWTO Use Python in the web

* The Low-Level View:: 
* Step back; WSGI: Step back WSGI. 
* Model-View-Controller:: 
* Ingredients for Websites:: 
* Frameworks:: 

The Low-Level View

* Common Gateway Interface:: 
* mod_python:: 
* FastCGI and SCGI:: 
* mod_wsgi:: 

Common Gateway Interface

* Simple script for testing CGI:: 
* Setting up CGI on your own server:: 
* Common problems with CGI scripts:: 

FastCGI and SCGI

* Setting up FastCGI:: 

Step back: WSGI

* WSGI Servers:: 
* Case study; MoinMoin: Case study MoinMoin. 

Ingredients for Websites

* Templates:: 
* Data persistence:: 

Frameworks

* Some notable frameworks:: 

Some notable frameworks

* Django:: 
* TurboGears:: 
* Zope:: 
* Other notable frameworks:: 

Argparse Tutorial

* Concepts:: 
* The basics:: 
* Introducing Positional arguments:: 
* Introducing Optional arguments:: 
* Combining Positional and Optional arguments:: 
* Getting a little more advanced:: 
* Conclusion:: 

Introducing Optional arguments

* Short options:: 

Getting a little more advanced

* Conflicting options:: 


File: python.info,  Node: Porting Python 2 Code to Python 3,  Next: Porting Extension Modules to Python 3,  Up: Python HOWTOs

10.1 Porting Python 2 Code to Python 3
======================================

     author: Brett Cannon

Abstract
........

With Python 3 being the future of Python while Python 2 is still in
active use, it is good to have your project available for both major
releases of Python.  This guide is meant to help you figure out how best
to support both Python 2 & 3 simultaneously.

  If you are looking to port an extension module instead of pure Python
code, please see *note Porting Extension Modules to Python 3: 2fa4.

  If you would like to read one core Python developer’s take on why
Python 3 came into existence, you can read Nick Coghlan’s Python 3 Q &
A(1).

  If you prefer to read a (free) book on porting a project to Python 3,
consider reading Porting to Python 3(2) by Lennart Regebro which should
cover much of what is discussed in this HOWTO.

  For help with porting, you can email the python-porting(3) mailing
list with questions.

* Menu:

* The Short Version:: 
* Before You Begin:: 
* Writing Source-Compatible Python 2/3 Code:: 
* Alternative Approaches:: 
* Other Resources: Other Resources<2>. 

   ---------- Footnotes ----------

   (1) 
http://ncoghlan-devs-python-notes.readthedocs.org/en/latest/python3/questions_and_answers.html

   (2) http://python3porting.com/

   (3) http://mail.python.org/mailman/listinfo/python-porting


File: python.info,  Node: The Short Version,  Next: Before You Begin,  Up: Porting Python 2 Code to Python 3

10.1.1 The Short Version
------------------------

   * Decide what’s the oldest version of Python 2 you want to support
     (if at all)

   * Make sure you have a thorough test suite and use continuous
     integration testing to make sure you stay compatible with the
     versions of Python you care about

   * If you have dependencies, check their Python 3 status using
     caniusepython3 (command-line tool(1), web app(2))

  With that done, your options are:

   * If you are dropping Python 2 support, use 2to3(3) to port to Python
     3

   * If you are keeping Python 2 support, then start writing Python
     2/3-compatible code starting *TODAY*

        + If you have dependencies that have not been ported, reach out
          to them to port their project while working to make your code
          compatible with Python 3 so you’re ready when your
          dependencies are all ported

        + If all your dependencies have been ported (or you have none),
          go ahead and port to Python 3

   * If you are creating a new project that wants to have 2/3
     compatibility, code in Python 3 and then backport to Python 2

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/caniusepython3

   (2) https://caniusepython3.com/

   (3) http://docs.python.org/2/library/2to3.html


File: python.info,  Node: Before You Begin,  Next: Writing Source-Compatible Python 2/3 Code,  Prev: The Short Version,  Up: Porting Python 2 Code to Python 3

10.1.2 Before You Begin
-----------------------

If your project is on the Cheeseshop(1)/PyPI(2), make sure it has the
proper trove classifiers(3) to signify what versions of Python it
*currently* supports.  At minimum you should specify the major
version(s), e.g.  ‘Programming Language :: Python :: 2’ if your project
currently only supports Python 2.  It is preferrable that you be as
specific as possible by listing every major/minor version of Python that
you support, e.g.  if your project supports Python 2.6 and 2.7, then you
want the classifiers of:

     Programming Language :: Python :: 2
     Programming Language :: Python :: 2.6
     Programming Language :: Python :: 2.7

  Once your project supports Python 3 you will want to go back and add
the appropriate classifiers for Python 3 as well.  This is important as
setting the ‘Programming Language :: Python :: 3’ classifier will lead
to your project being listed under the Python 3 Packages(4) section of
PyPI.

  Make sure you have a robust test suite.  You need to make sure
everything continues to work, just like when you support a new
minor/feature release of Python.  This means making sure your test suite
is thorough and is ported properly between Python 2 & 3 (consider using
coverage(5) to measure that you have effective test coverage).  You will
also most likely want to use something like tox(6) to automate testing
between all of your supported versions of Python.  You will also want to
*port your tests first* so that you can make sure that you detect
breakage during the transition.  Tests also tend to be simpler than the
code they are testing so it gives you an idea of how easy it can be to
port code.

  Drop support for older Python versions if possible.  Python 2.5(7)
introduced a lot of useful syntax and libraries which have become
idiomatic in Python 3.  Python 2.6(8) introduced future statements which
makes compatibility much easier if you are going from Python 2 to 3.
Python 2.7(9) continues the trend in the stdlib.  Choose the newest
version of Python which you believe can be your minimum support version
and work from there.

  Target the newest version of Python 3 that you can.  Beyond just the
usual bugfixes, compatibility has continued to improve between Python 2
and 3 as time has passed.  E.g.  Python 3.3 added back the ‘u’ prefix
for strings, making source-compatible Python code easier to write.

   ---------- Footnotes ----------

   (1) http://pypi.python.org/

   (2) http://pypi.python.org/

   (3) https://pypi.python.org/pypi?%3Aaction=list_classifiers

   (4) https://pypi.python.org/pypi?:action=browse&c=533&show=all

   (5) https://pypi.python.org/pypi/coverage

   (6) https://pypi.python.org/pypi/tox

   (7) http://www.python.org/2.5.x

   (8) http://www.python.org/2.6.x

   (9) http://www.python.org/2.7.x


File: python.info,  Node: Writing Source-Compatible Python 2/3 Code,  Next: Alternative Approaches,  Prev: Before You Begin,  Up: Porting Python 2 Code to Python 3

10.1.3 Writing Source-Compatible Python 2/3 Code
------------------------------------------------

Over the years the Python community has discovered that the easiest way
to support both Python 2 and 3 in parallel is to write Python code that
works in either version.  While this might sound counter-intuitive at
first, it actually is not difficult and typically only requires
following some select (non-idiomatic) practices and using some key
projects to help make bridging between Python 2 and 3 easier.

* Menu:

* Projects to Consider:: 
* Tips & Tricks:: 
* Eliminate -3 Warnings:: 


File: python.info,  Node: Projects to Consider,  Next: Tips & Tricks,  Up: Writing Source-Compatible Python 2/3 Code

10.1.3.1 Projects to Consider
.............................

The lowest level library for supporting Python 2 & 3 simultaneously is
six(1).  Reading through its documentation will give you an idea of
where exactly the Python language changed between versions 2 & 3 and
thus what you will want the library to help you continue to support.

  To help automate porting your code over to using six, you can use
modernize(2).  This project will attempt to rewrite your code to be as
modern as possible while using six to smooth out any differences between
Python 2 & 3.

  If you want to write your compatible code to feel more like Python 3
there is the future(3) project.  It tries to provide backports of
objects from Python 3 so that you can use them from Python 2-compatible
code, e.g.  replacing the ‘bytes’ type from Python 2 with the one from
Python 3.  It also provides a translation script like modernize (its
translation code is actually partially based on it) to help start
working with a pre-existing code base.  It is also unique in that its
translation script will also port Python 3 code backwards as well as
Python 2 code forwards.

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/six

   (2) https://github.com/mitsuhiko/python-modernize

   (3) http://python-future.org/


File: python.info,  Node: Tips & Tricks,  Next: Eliminate -3 Warnings,  Prev: Projects to Consider,  Up: Writing Source-Compatible Python 2/3 Code

10.1.3.2 Tips & Tricks
......................

To help with writing source-compatible code using one of the projects
mentioned in *note Projects to Consider: 2fa8, consider following the
below suggestions.  Some of them are handled by the suggested projects,
so if you do use one of them then read their documentation first to see
which suggestions below will taken care of for you.

* Menu:

* Support Python 2.7: Support Python 2 7. 
* Try to Support Python 2.6 and Newer Only: Try to Support Python 2 6 and Newer Only. 
* Supporting Python 2.5 and Newer Only: Supporting Python 2 5 and Newer Only. 
* Handle Common "Gotchas":: 


File: python.info,  Node: Support Python 2 7,  Next: Try to Support Python 2 6 and Newer Only,  Up: Tips & Tricks

10.1.3.3 Support Python 2.7
...........................

As a first step, make sure that your project is compatible with Python
2.7(1).  This is just good to do as Python 2.7 is the last release of
Python 2 and thus will be used for a rather long time.  It also allows
for use of the ‘-3’ flag to Python to help discover places in your code
where compatibility might be an issue (the ‘-3’ flag is in Python 2.6
but Python 2.7 adds more warnings).

   ---------- Footnotes ----------

   (1) http://www.python.org/2.7.x


File: python.info,  Node: Try to Support Python 2 6 and Newer Only,  Next: Supporting Python 2 5 and Newer Only,  Prev: Support Python 2 7,  Up: Tips & Tricks

10.1.3.4 Try to Support Python 2.6 and Newer Only
.................................................

While not possible for all projects, if you can support Python 2.6(1)
and newer *only*, your life will be much easier.  Various future
statements, stdlib additions, etc.  exist only in Python 2.6 and later
which greatly assist in supporting Python 3.  But if you project must
keep support for Python 2.5(2) then it is still possible to
simultaneously support Python 3.

  Below are the benefits you gain if you only have to support Python 2.6
and newer.  Some of these options are personal choice while others are
*strongly* recommended (the ones that are more for personal choice are
labeled as such).  If you continue to support older versions of Python
then you at least need to watch out for situations that these solutions
fix and handle them appropriately (which is where library help from e.g.
six(3) comes in handy).

* Menu:

* from __future__ import print_function:: 
* from __future__ import unicode_literals:: 
* Bytes/string literals:: 
* from __future__ import absolute_import:: 

   ---------- Footnotes ----------

   (1) http://www.python.org/2.6.x

   (2) http://www.python.org/2.5.x

   (3) https://pypi.python.org/pypi/six


File: python.info,  Node: from __future__ import print_function,  Next: from __future__ import unicode_literals,  Up: Try to Support Python 2 6 and Newer Only

10.1.3.5 ‘from __future__ import print_function’
................................................

It will not only get you used to typing ‘print()’ as a function instead
of a statement, but it will also give you the various benefits the
function has over the Python 2 statement (six(1) provides a function if
you support Python 2.5 or older).

   ---------- Footnotes ----------

   (1) https://pypi.python.org/pypi/six

