This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: Common Problems,  Next: Feedback,  Prev: Modifying Strings,  Up: Regular Expression HOWTO

10.9.6 Common Problems
----------------------

Regular expressions are a powerful tool for some applications, but in
some ways their behaviour isn’t intuitive and at times they don’t behave
the way you may expect them to.  This section will point out some of the
most common pitfalls.

* Menu:

* Use String Methods:: 
* match() versus search(): match versus search. 
* Greedy versus Non-Greedy:: 
* Using re.VERBOSE: Using re VERBOSE. 


File: python.info,  Node: Use String Methods,  Next: match versus search,  Up: Common Problems

10.9.6.1 Use String Methods
...........................

Sometimes using the *note re: 143. module is a mistake.  If you’re
matching a fixed string, or a single character class, and you’re not
using any *note re: 143. features such as the ‘IGNORECASE’ flag, then
the full power of regular expressions may not be required.  Strings have
several methods for performing operations with fixed strings and they’re
usually much faster, because the implementation is a single small C loop
that’s been optimized for the purpose, instead of the large, more
generalized regular expression engine.

  One example might be replacing a single fixed string with another one;
for example, you might replace ‘word’ with ‘deed’.  ‘re.sub()’ seems
like the function to use for this, but consider the ‘replace()’ method.
Note that ‘replace()’ will also replace ‘word’ inside words, turning
‘swordfish’ into ‘sdeedfish’, but the naive RE ‘word’ would have done
that, too.  (To avoid performing the substitution on parts of words, the
pattern would have to be ‘\bword\b’, in order to require that ‘word’
have a word boundary on either side.  This takes the job beyond
‘replace()’’s abilities.)

  Another common task is deleting every occurrence of a single character
from a string or replacing it with another single character.  You might
do this with something like ‘re.sub('\n', ' ', S)’, but ‘translate()’ is
capable of doing both tasks and will be faster than any regular
expression operation can be.

  In short, before turning to the *note re: 143. module, consider
whether your problem can be solved with a faster and simpler string
method.


File: python.info,  Node: match versus search,  Next: Greedy versus Non-Greedy,  Prev: Use String Methods,  Up: Common Problems

10.9.6.2 match() versus search()
................................

The ‘match()’ function only checks if the RE matches at the beginning of
the string while ‘search()’ will scan forward through the string for a
match.  It’s important to keep this distinction in mind.  Remember,
‘match()’ will only report a successful match which will start at 0; if
the match wouldn’t start at zero, ‘match()’ will _not_ report it.

     >>> print re.match('super', 'superstition').span()
     (0, 5)
     >>> print re.match('super', 'insuperable')
     None

  On the other hand, ‘search()’ will scan forward through the string,
reporting the first match it finds.

     >>> print re.search('super', 'superstition').span()
     (0, 5)
     >>> print re.search('super', 'insuperable').span()
     (2, 7)

  Sometimes you’ll be tempted to keep using *note re.match(): 9c1, and
just add ‘.*’ to the front of your RE. Resist this temptation and use
*note re.search(): 9c0. instead.  The regular expression compiler does
some analysis of REs in order to speed up the process of looking for a
match.  One such analysis figures out what the first character of a
match must be; for example, a pattern starting with ‘Crow’ must match
starting with a ‘'C'’.  The analysis lets the engine quickly scan
through the string looking for the starting character, only trying the
full match if a ‘'C'’ is found.

  Adding ‘.*’ defeats this optimization, requiring scanning to the end
of the string and then backtracking to find a match for the rest of the
RE. Use *note re.search(): 9c0. instead.


File: python.info,  Node: Greedy versus Non-Greedy,  Next: Using re VERBOSE,  Prev: match versus search,  Up: Common Problems

10.9.6.3 Greedy versus Non-Greedy
.................................

When repeating a regular expression, as in ‘a*’, the resulting action is
to consume as much of the pattern as possible.  This fact often bites
you when you’re trying to match a pair of balanced delimiters, such as
the angle brackets surrounding an HTML tag.  The naive pattern for
matching a single HTML tag doesn’t work because of the greedy nature of
‘.*’.

     >>> s = '<html><head><title>Title</title>'
     >>> len(s)
     32
     >>> print re.match('<.*>', s).span()
     (0, 32)
     >>> print re.match('<.*>', s).group()
     <html><head><title>Title</title>

  The RE matches the ‘'<'’ in ‘<html>’, and the ‘.*’ consumes the rest
of the string.  There’s still more left in the RE, though, and the ‘>’
can’t match at the end of the string, so the regular expression engine
has to backtrack character by character until it finds a match for the
‘>’.  The final match extends from the ‘'<'’ in ‘<html>’ to the ‘'>'’ in
‘</title>’, which isn’t what you want.

  In this case, the solution is to use the non-greedy qualifiers ‘*?’,
‘+?’, ‘??’, or ‘{m,n}?’, which match as _little_ text as possible.  In
the above example, the ‘'>'’ is tried immediately after the first ‘'<'’
matches, and when it fails, the engine advances a character at a time,
retrying the ‘'>'’ at every step.  This produces just the right result:

     >>> print re.match('<.*?>', s).group()
     <html>

  (Note that parsing HTML or XML with regular expressions is painful.
Quick-and-dirty patterns will handle common cases, but HTML and XML have
special cases that will break the obvious regular expression; by the
time you’ve written a regular expression that handles all of the
possible cases, the patterns will be _very_ complicated.  Use an HTML or
XML parser module for such tasks.)


File: python.info,  Node: Using re VERBOSE,  Prev: Greedy versus Non-Greedy,  Up: Common Problems

10.9.6.4 Using re.VERBOSE
.........................

By now you’ve probably noticed that regular expressions are a very
compact notation, but they’re not terribly readable.  REs of moderate
complexity can become lengthy collections of backslashes, parentheses,
and metacharacters, making them difficult to read and understand.

  For such REs, specifying the ‘re.VERBOSE’ flag when compiling the
regular expression can be helpful, because it allows you to format the
regular expression more clearly.

  The ‘re.VERBOSE’ flag has several effects.  Whitespace in the regular
expression that _isn’t_ inside a character class is ignored.  This means
that an expression such as ‘dog | cat’ is equivalent to the less
readable ‘dog|cat’, but ‘[a b]’ will still match the characters ‘'a'’,
‘'b'’, or a space.  In addition, you can also put comments inside a RE;
comments extend from a ‘#’ character to the next newline.  When used
with triple-quoted strings, this enables REs to be formatted more
neatly:

     pat = re.compile(r"""
      \s*                 # Skip leading whitespace
      (?P<header>[^:]+)   # Header name
      \s* :               # Whitespace, and a colon
      (?P<value>.*?)      # The header's value -- *? used to
                          # lose the following trailing whitespace
      \s*$                # Trailing whitespace to end-of-line
     """, re.VERBOSE)

  This is far more readable than:

     pat = re.compile(r"\s*(?P<header>[^:]+)\s*:(?P<value>.*?)\s*$")


File: python.info,  Node: Feedback,  Prev: Common Problems,  Up: Regular Expression HOWTO

10.9.7 Feedback
---------------

Regular expressions are a complicated topic.  Did this document help you
understand them?  Were there parts that were unclear, or Problems you
encountered that weren’t covered here?  If so, please send suggestions
for improvements to the author.

  The most complete book on regular expressions is almost certainly
Jeffrey Friedl’s Mastering Regular Expressions, published by O’Reilly.
Unfortunately, it exclusively concentrates on Perl and Java’s flavours
of regular expressions, and doesn’t contain any Python material at all,
so it won’t be useful as a reference for programming in Python.  (The
first edition covered Python’s now-removed ‘regex’ module, which won’t
help you much.)  Consider checking it out from your library.


File: python.info,  Node: Socket Programming HOWTO,  Next: Sorting HOW TO,  Prev: Regular Expression HOWTO,  Up: Python HOWTOs

10.10 Socket Programming HOWTO
==============================

     Author: Gordon McMillan

Abstract
........

Sockets are used nearly everywhere, but are one of the most severely
misunderstood technologies around.  This is a 10,000 foot overview of
sockets.  It’s not really a tutorial - you’ll still have work to do in
getting things operational.  It doesn’t cover the fine points (and there
are a lot of them), but I hope it will give you enough background to
begin using them decently.

* Menu:

* Sockets:: 
* Creating a Socket:: 
* Using a Socket:: 
* Disconnecting:: 
* Non-blocking Sockets:: 

Sockets

* History:: 

Creating a Socket

* IPC:: 

Using a Socket

* Binary Data:: 

Disconnecting

* When Sockets Die:: 

Non-blocking Sockets

* Performance: Performance<2>. 


File: python.info,  Node: Sockets,  Next: Creating a Socket,  Up: Socket Programming HOWTO

10.10.1 Sockets
---------------

I’m only going to talk about INET sockets, but they account for at least
99% of the sockets in use.  And I’ll only talk about STREAM sockets -
unless you really know what you’re doing (in which case this HOWTO isn’t
for you!), you’ll get better behavior and performance from a STREAM
socket than anything else.  I will try to clear up the mystery of what a
socket is, as well as some hints on how to work with blocking and
non-blocking sockets.  But I’ll start by talking about blocking sockets.
You’ll need to know how they work before dealing with non-blocking
sockets.

  Part of the trouble with understanding these things is that "socket"
can mean a number of subtly different things, depending on context.  So
first, let’s make a distinction between a "client" socket - an endpoint
of a conversation, and a "server" socket, which is more like a
switchboard operator.  The client application (your browser, for
example) uses "client" sockets exclusively; the web server it’s talking
to uses both "server" sockets and "client" sockets.

* Menu:

* History:: 


File: python.info,  Node: History,  Up: Sockets

10.10.1.1 History
.................

Of the various forms of IPC (Inter Process Communication), sockets are
by far the most popular.  On any given platform, there are likely to be
other forms of IPC that are faster, but for cross-platform
communication, sockets are about the only game in town.

  They were invented in Berkeley as part of the BSD flavor of Unix.
They spread like wildfire with the Internet.  With good reason — the
combination of sockets with INET makes talking to arbitrary machines
around the world unbelievably easy (at least compared to other schemes).


File: python.info,  Node: Creating a Socket,  Next: Using a Socket,  Prev: Sockets,  Up: Socket Programming HOWTO

10.10.2 Creating a Socket
-------------------------

Roughly speaking, when you clicked on the link that brought you to this
page, your browser did something like the following:

     #create an INET, STREAMing socket
     s = socket.socket(
         socket.AF_INET, socket.SOCK_STREAM)
     #now connect to the web server on port 80
     # - the normal http port
     s.connect(("www.mcmillan-inc.com", 80))

  When the ‘connect’ completes, the socket ‘s’ can be used to send in a
request for the text of the page.  The same socket will read the reply,
and then be destroyed.  That’s right, destroyed.  Client sockets are
normally only used for one exchange (or a small set of sequential
exchanges).

  What happens in the web server is a bit more complex.  First, the web
server creates a "server socket":

     #create an INET, STREAMing socket
     serversocket = socket.socket(
         socket.AF_INET, socket.SOCK_STREAM)
     #bind the socket to a public host,
     # and a well-known port
     serversocket.bind((socket.gethostname(), 80))
     #become a server socket
     serversocket.listen(5)

  A couple things to notice: we used ‘socket.gethostname()’ so that the
socket would be visible to the outside world.  If we had used
‘s.bind(('localhost', 80))’ or ‘s.bind(('127.0.0.1', 80))’ we would
still have a "server" socket, but one that was only visible within the
same machine.  ‘s.bind(('', 80))’ specifies that the socket is reachable
by any address the machine happens to have.

  A second thing to note: low number ports are usually reserved for
"well known" services (HTTP, SNMP etc).  If you’re playing around, use a
nice high number (4 digits).

  Finally, the argument to ‘listen’ tells the socket library that we
want it to queue up as many as 5 connect requests (the normal max)
before refusing outside connections.  If the rest of the code is written
properly, that should be plenty.

  Now that we have a "server" socket, listening on port 80, we can enter
the mainloop of the web server:

     while 1:
         #accept connections from outside
         (clientsocket, address) = serversocket.accept()
         #now do something with the clientsocket
         #in this case, we'll pretend this is a threaded server
         ct = client_thread(clientsocket)
         ct.run()

  There’s actually 3 general ways in which this loop could work -
dispatching a thread to handle ‘clientsocket’, create a new process to
handle ‘clientsocket’, or restructure this app to use non-blocking
sockets, and mulitplex between our "server" socket and any active
‘clientsocket’s using ‘select’.  More about that later.  The important
thing to understand now is this: this is _all_ a "server" socket does.
It doesn’t send any data.  It doesn’t receive any data.  It just
produces "client" sockets.  Each ‘clientsocket’ is created in response
to some _other_ "client" socket doing a ‘connect()’ to the host and port
we’re bound to.  As soon as we’ve created that ‘clientsocket’, we go
back to listening for more connections.  The two "clients" are free to
chat it up - they are using some dynamically allocated port which will
be recycled when the conversation ends.

* Menu:

* IPC:: 


File: python.info,  Node: IPC,  Up: Creating a Socket

10.10.2.1 IPC
.............

If you need fast IPC between two processes on one machine, you should
look into whatever form of shared memory the platform offers.  A simple
protocol based around shared memory and locks or semaphores is by far
the fastest technique.

  If you do decide to use sockets, bind the "server" socket to
‘'localhost'’.  On most platforms, this will take a shortcut around a
couple of layers of network code and be quite a bit faster.


File: python.info,  Node: Using a Socket,  Next: Disconnecting,  Prev: Creating a Socket,  Up: Socket Programming HOWTO

10.10.3 Using a Socket
----------------------

The first thing to note, is that the web browser’s "client" socket and
the web server’s "client" socket are identical beasts.  That is, this is
a "peer to peer" conversation.  Or to put it another way, _as the
designer, you will have to decide what the rules of etiquette are for a
conversation_.  Normally, the ‘connect’ing socket starts the
conversation, by sending in a request, or perhaps a signon.  But that’s
a design decision - it’s not a rule of sockets.

  Now there are two sets of verbs to use for communication.  You can use
‘send’ and ‘recv’, or you can transform your client socket into a
file-like beast and use ‘read’ and ‘write’.  The latter is the way Java
presents its sockets.  I’m not going to talk about it here, except to
warn you that you need to use ‘flush’ on sockets.  These are buffered
"files", and a common mistake is to ‘write’ something, and then ‘read’
for a reply.  Without a ‘flush’ in there, you may wait forever for the
reply, because the request may still be in your output buffer.

  Now we come to the major stumbling block of sockets - ‘send’ and
‘recv’ operate on the network buffers.  They do not necessarily handle
all the bytes you hand them (or expect from them), because their major
focus is handling the network buffers.  In general, they return when the
associated network buffers have been filled (‘send’) or emptied
(‘recv’).  They then tell you how many bytes they handled.  It is _your_
responsibility to call them again until your message has been completely
dealt with.

  When a ‘recv’ returns 0 bytes, it means the other side has closed (or
is in the process of closing) the connection.  You will not receive any
more data on this connection.  Ever.  You may be able to send data
successfully; I’ll talk more about this later.

  A protocol like HTTP uses a socket for only one transfer.  The client
sends a request, then reads a reply.  That’s it.  The socket is
discarded.  This means that a client can detect the end of the reply by
receiving 0 bytes.

  But if you plan to reuse your socket for further transfers, you need
to realize that _there is no_ EOT (End of Transfer) _on a socket._  I
repeat: if a socket ‘send’ or ‘recv’ returns after handling 0 bytes, the
connection has been broken.  If the connection has _not_ been broken,
you may wait on a ‘recv’ forever, because the socket will _not_ tell you
that there’s nothing more to read (for now).  Now if you think about
that a bit, you’ll come to realize a fundamental truth of sockets:
_messages must either be fixed length_ (yuck), _or be delimited_
(shrug), _or indicate how long they are_ (much better), _or end by
shutting down the connection_.  The choice is entirely yours, (but some
ways are righter than others).

  Assuming you don’t want to end the connection, the simplest solution
is a fixed length message:

     class mysocket:
         '''demonstration class only
           - coded for clarity, not efficiency
         '''

         def __init__(self, sock=None):
             if sock is None:
                 self.sock = socket.socket(
                     socket.AF_INET, socket.SOCK_STREAM)
             else:
                 self.sock = sock

         def connect(self, host, port):
             self.sock.connect((host, port))

         def mysend(self, msg):
             totalsent = 0
             while totalsent < MSGLEN:
                 sent = self.sock.send(msg[totalsent:])
                 if sent == 0:
                     raise RuntimeError("socket connection broken")
                 totalsent = totalsent + sent

         def myreceive(self):
             chunks = []
             bytes_recd = 0
             while bytes_recd < MSGLEN:
                 chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))
                 if chunk == '':
                     raise RuntimeError("socket connection broken")
                 chunks.append(chunk)
                 bytes_recd = bytes_recd + len(chunk)
             return ''.join(chunks)

  The sending code here is usable for almost any messaging scheme - in
Python you send strings, and you can use ‘len()’ to determine its length
(even if it has embedded ‘\0’ characters).  It’s mostly the receiving
code that gets more complex.  (And in C, it’s not much worse, except you
can’t use ‘strlen’ if the message has embedded ‘\0’s.)

  The easiest enhancement is to make the first character of the message
an indicator of message type, and have the type determine the length.
Now you have two ‘recv’s - the first to get (at least) that first
character so you can look up the length, and the second in a loop to get
the rest.  If you decide to go the delimited route, you’ll be receiving
in some arbitrary chunk size, (4096 or 8192 is frequently a good match
for network buffer sizes), and scanning what you’ve received for a
delimiter.

  One complication to be aware of: if your conversational protocol
allows multiple messages to be sent back to back (without some kind of
reply), and you pass ‘recv’ an arbitrary chunk size, you may end up
reading the start of a following message.  You’ll need to put that aside
and hold onto it, until it’s needed.

  Prefixing the message with it’s length (say, as 5 numeric characters)
gets more complex, because (believe it or not), you may not get all 5
characters in one ‘recv’.  In playing around, you’ll get away with it;
but in high network loads, your code will very quickly break unless you
use two ‘recv’ loops - the first to determine the length, the second to
get the data part of the message.  Nasty.  This is also when you’ll
discover that ‘send’ does not always manage to get rid of everything in
one pass.  And despite having read this, you will eventually get bit by
it!

  In the interests of space, building your character, (and preserving my
competitive position), these enhancements are left as an exercise for
the reader.  Lets move on to cleaning up.

* Menu:

* Binary Data:: 


File: python.info,  Node: Binary Data,  Up: Using a Socket

10.10.3.1 Binary Data
.....................

It is perfectly possible to send binary data over a socket.  The major
problem is that not all machines use the same formats for binary data.
For example, a Motorola chip will represent a 16 bit integer with the
value 1 as the two hex bytes 00 01.  Intel and DEC, however, are
byte-reversed - that same 1 is 01 00.  Socket libraries have calls for
converting 16 and 32 bit integers - ‘ntohl, htonl, ntohs, htons’ where
"n" means _network_ and "h" means _host_, "s" means _short_ and "l"
means _long_.  Where network order is host order, these do nothing, but
where the machine is byte-reversed, these swap the bytes around
appropriately.

  In these days of 32 bit machines, the ascii representation of binary
data is frequently smaller than the binary representation.  That’s
because a surprising amount of the time, all those longs have the value
0, or maybe 1.  The string "0" would be two bytes, while binary is four.
Of course, this doesn’t fit well with fixed-length messages.  Decisions,
decisions.


File: python.info,  Node: Disconnecting,  Next: Non-blocking Sockets,  Prev: Using a Socket,  Up: Socket Programming HOWTO

10.10.4 Disconnecting
---------------------

Strictly speaking, you’re supposed to use ‘shutdown’ on a socket before
you ‘close’ it.  The ‘shutdown’ is an advisory to the socket at the
other end.  Depending on the argument you pass it, it can mean "I’m not
going to send anymore, but I’ll still listen", or "I’m not listening,
good riddance!".  Most socket libraries, however, are so used to
programmers neglecting to use this piece of etiquette that normally a
‘close’ is the same as ‘shutdown(); close()’.  So in most situations, an
explicit ‘shutdown’ is not needed.

  One way to use ‘shutdown’ effectively is in an HTTP-like exchange.
The client sends a request and then does a ‘shutdown(1)’.  This tells
the server "This client is done sending, but can still receive."  The
server can detect "EOF" by a receive of 0 bytes.  It can assume it has
the complete request.  The server sends a reply.  If the ‘send’
completes successfully then, indeed, the client was still receiving.

  Python takes the automatic shutdown a step further, and says that when
a socket is garbage collected, it will automatically do a ‘close’ if
it’s needed.  But relying on this is a very bad habit.  If your socket
just disappears without doing a ‘close’, the socket at the other end may
hang indefinitely, thinking you’re just being slow.  _Please_ ‘close’
your sockets when you’re done.

* Menu:

* When Sockets Die:: 


File: python.info,  Node: When Sockets Die,  Up: Disconnecting

10.10.4.1 When Sockets Die
..........................

Probably the worst thing about using blocking sockets is what happens
when the other side comes down hard (without doing a ‘close’).  Your
socket is likely to hang.  SOCKSTREAM is a reliable protocol, and it
will wait a long, long time before giving up on a connection.  If you’re
using threads, the entire thread is essentially dead.  There’s not much
you can do about it.  As long as you aren’t doing something dumb, like
holding a lock while doing a blocking read, the thread isn’t really
consuming much in the way of resources.  Do _not_ try to kill the thread
- part of the reason that threads are more efficient than processes is
that they avoid the overhead associated with the automatic recycling of
resources.  In other words, if you do manage to kill the thread, your
whole process is likely to be screwed up.


File: python.info,  Node: Non-blocking Sockets,  Prev: Disconnecting,  Up: Socket Programming HOWTO

10.10.5 Non-blocking Sockets
----------------------------

If you’ve understood the preceding, you already know most of what you
need to know about the mechanics of using sockets.  You’ll still use the
same calls, in much the same ways.  It’s just that, if you do it right,
your app will be almost inside-out.

  In Python, you use ‘socket.setblocking(0)’ to make it non-blocking.
In C, it’s more complex, (for one thing, you’ll need to choose between
the BSD flavor ‘O_NONBLOCK’ and the almost indistinguishable Posix
flavor ‘O_NDELAY’, which is completely different from ‘TCP_NODELAY’),
but it’s the exact same idea.  You do this after creating the socket,
but before using it.  (Actually, if you’re nuts, you can switch back and
forth.)

  The major mechanical difference is that ‘send’, ‘recv’, ‘connect’ and
‘accept’ can return without having done anything.  You have (of course)
a number of choices.  You can check return code and error codes and
generally drive yourself crazy.  If you don’t believe me, try it
sometime.  Your app will grow large, buggy and suck CPU. So let’s skip
the brain-dead solutions and do it right.

  Use ‘select’.

  In C, coding ‘select’ is fairly complex.  In Python, it’s a piece of
cake, but it’s close enough to the C version that if you understand
‘select’ in Python, you’ll have little trouble with it in C:

     ready_to_read, ready_to_write, in_error = \
                    select.select(
                       potential_readers,
                       potential_writers,
                       potential_errs,
                       timeout)

  You pass ‘select’ three lists: the first contains all sockets that you
might want to try reading; the second all the sockets you might want to
try writing to, and the last (normally left empty) those that you want
to check for errors.  You should note that a socket can go into more
than one list.  The ‘select’ call is blocking, but you can give it a
timeout.  This is generally a sensible thing to do - give it a nice long
timeout (say a minute) unless you have good reason to do otherwise.

  In return, you will get three lists.  They contain the sockets that
are actually readable, writable and in error.  Each of these lists is a
subset (possibly empty) of the corresponding list you passed in.

  If a socket is in the output readable list, you can be
as-close-to-certain-as-we-ever-get-in-this-business that a ‘recv’ on
that socket will return _something_.  Same idea for the writable list.
You’ll be able to send _something_.  Maybe not all you want to, but
_something_ is better than nothing.  (Actually, any reasonably healthy
socket will return as writable - it just means outbound network buffer
space is available.)

  If you have a "server" socket, put it in the potential_readers list.
If it comes out in the readable list, your ‘accept’ will (almost
certainly) work.  If you have created a new socket to ‘connect’ to
someone else, put it in the potential_writers list.  If it shows up in
the writable list, you have a decent chance that it has connected.

  One very nasty problem with ‘select’: if somewhere in those input
lists of sockets is one which has died a nasty death, the ‘select’ will
fail.  You then need to loop through every single damn socket in all
those lists and do a ‘select([sock],[],[],0)’ until you find the bad
one.  That timeout of 0 means it won’t take long, but it’s ugly.

  Actually, ‘select’ can be handy even with blocking sockets.  It’s one
way of determining whether you will block - the socket returns as
readable when there’s something in the buffers.  However, this still
doesn’t help with the problem of determining whether the other end is
done, or just busy with something else.

  *Portability alert*: On Unix, ‘select’ works both with the sockets and
files.  Don’t try this on Windows.  On Windows, ‘select’ works with
sockets only.  Also note that in C, many of the more advanced socket
options are done differently on Windows.  In fact, on Windows I usually
use threads (which work very, very well) with my sockets.  Face it, if
you want any kind of performance, your code will look very different on
Windows than on Unix.

* Menu:

* Performance: Performance<2>. 


File: python.info,  Node: Performance<2>,  Up: Non-blocking Sockets

10.10.5.1 Performance
.....................

There’s no question that the fastest sockets code uses non-blocking
sockets and select to multiplex them.  You can put together something
that will saturate a LAN connection without putting any strain on the
CPU. The trouble is that an app written this way can’t do much of
anything else - it needs to be ready to shuffle bytes around at all
times.

  Assuming that your app is actually supposed to do something more than
that, threading is the optimal solution, (and using non-blocking sockets
will be faster than using blocking sockets).  Unfortunately, threading
support in Unixes varies both in API and quality.  So the normal Unix
solution is to fork a subprocess to deal with each connection.  The
overhead for this is significant (and don’t do this on Windows - the
overhead of process creation is enormous there).  It also means that
unless each subprocess is completely independent, you’ll need to use
another form of IPC, say a pipe, or shared memory and semaphores, to
communicate between the parent and child processes.

  Finally, remember that even though blocking sockets are somewhat
slower than non-blocking, in many cases they are the "right" solution.
After all, if your app is driven by the data it receives over a socket,
there’s not much sense in complicating the logic just so your app can
wait on ‘select’ instead of ‘recv’.


File: python.info,  Node: Sorting HOW TO,  Next: Unicode HOWTO,  Prev: Socket Programming HOWTO,  Up: Python HOWTOs

10.11 Sorting HOW TO
====================

     Author: Andrew Dalke and Raymond Hettinger

     Release: 0.1

  Python lists have a built-in ‘list.sort()’ method that modifies the
list in-place.  There is also a *note sorted(): 223. built-in function
that builds a new sorted list from an iterable.

  In this document, we explore the various techniques for sorting data
using Python.

* Menu:

* Sorting Basics:: 
* Key Functions:: 
* Operator Module Functions:: 
* Ascending and Descending:: 
* Sort Stability and Complex Sorts:: 
* The Old Way Using Decorate-Sort-Undecorate:: 
* The Old Way Using the cmp Parameter:: 
* Odd and Ends:: 


File: python.info,  Node: Sorting Basics,  Next: Key Functions,  Up: Sorting HOW TO

10.11.1 Sorting Basics
----------------------

A simple ascending sort is very easy: just call the *note sorted(): 223.
function.  It returns a new sorted list:

     >>> sorted([5, 2, 3, 1, 4])
     [1, 2, 3, 4, 5]

  You can also use the ‘list.sort()’ method of a list.  It modifies the
list in-place (and returns _None_ to avoid confusion).  Usually it’s
less convenient than *note sorted(): 223. - but if you don’t need the
original list, it’s slightly more efficient.

     >>> a = [5, 2, 3, 1, 4]
     >>> a.sort()
     >>> a
     [1, 2, 3, 4, 5]

  Another difference is that the ‘list.sort()’ method is only defined
for lists.  In contrast, the *note sorted(): 223. function accepts any
iterable.

     >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
     [1, 2, 3, 4, 5]


File: python.info,  Node: Key Functions,  Next: Operator Module Functions,  Prev: Sorting Basics,  Up: Sorting HOW TO

10.11.2 Key Functions
---------------------

Starting with Python 2.4, both ‘list.sort()’ and *note sorted(): 223.
added a _key_ parameter to specify a function to be called on each list
element prior to making comparisons.

  For example, here’s a case-insensitive string comparison:

     >>> sorted("This is a test string from Andrew".split(), key=str.lower)
     ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']

  The value of the _key_ parameter should be a function that takes a
single argument and returns a key to use for sorting purposes.  This
technique is fast because the key function is called exactly once for
each input record.

  A common pattern is to sort complex objects using some of the object’s
indices as keys.  For example:

     >>> student_tuples = [
         ('john', 'A', 15),
         ('jane', 'B', 12),
         ('dave', 'B', 10),
     ]
     >>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

  The same technique works for objects with named attributes.  For
example:

     >>> class Student:
             def __init__(self, name, grade, age):
                 self.name = name
                 self.grade = grade
                 self.age = age
             def __repr__(self):
                 return repr((self.name, self.grade, self.age))

     >>> student_objects = [
         Student('john', 'A', 15),
         Student('jane', 'B', 12),
         Student('dave', 'B', 10),
     ]
     >>> sorted(student_objects, key=lambda student: student.age)   # sort by age
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]


File: python.info,  Node: Operator Module Functions,  Next: Ascending and Descending,  Prev: Key Functions,  Up: Sorting HOW TO

10.11.3 Operator Module Functions
---------------------------------

The key-function patterns shown above are very common, so Python
provides convenience functions to make accessor functions easier and
faster.  The operator module has *note operator.itemgetter(): dee, *note
operator.attrgetter(): ded, and starting in Python 2.5 a *note
operator.methodcaller(): def. function.

  Using those functions, the above examples become simpler and faster:

     >>> from operator import itemgetter, attrgetter

     >>> sorted(student_tuples, key=itemgetter(2))
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

     >>> sorted(student_objects, key=attrgetter('age'))
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

  The operator module functions allow multiple levels of sorting.  For
example, to sort by _grade_ then by _age_:

     >>> sorted(student_tuples, key=itemgetter(1,2))
     [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

     >>> sorted(student_objects, key=attrgetter('grade', 'age'))
     [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

  The *note operator.methodcaller(): def. function makes method calls
with fixed parameters for each object being sorted.  For example, the
*note str.count(): 8bd. method could be used to compute message priority
by counting the number of exclamation marks in a message:

     >>> messages = ['critical!!!', 'hurry!', 'standby', 'immediate!!']
     >>> sorted(messages, key=methodcaller('count', '!'))
     ['standby', 'hurry!', 'immediate!!', 'critical!!!']


File: python.info,  Node: Ascending and Descending,  Next: Sort Stability and Complex Sorts,  Prev: Operator Module Functions,  Up: Sorting HOW TO

10.11.4 Ascending and Descending
--------------------------------

Both ‘list.sort()’ and *note sorted(): 223. accept a _reverse_ parameter
with a boolean value.  This is used to flag descending sorts.  For
example, to get the student data in reverse _age_ order:

     >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
     [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

     >>> sorted(student_objects, key=attrgetter('age'), reverse=True)
     [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]


File: python.info,  Node: Sort Stability and Complex Sorts,  Next: The Old Way Using Decorate-Sort-Undecorate,  Prev: Ascending and Descending,  Up: Sorting HOW TO

10.11.5 Sort Stability and Complex Sorts
----------------------------------------

Starting with Python 2.2, sorts are guaranteed to be stable(1).  That
means that when multiple records have the same key, their original order
is preserved.

     >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
     >>> sorted(data, key=itemgetter(0))
     [('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]

  Notice how the two records for _blue_ retain their original order so
that ‘('blue', 1)’ is guaranteed to precede ‘('blue', 2)’.

  This wonderful property lets you build complex sorts in a series of
sorting steps.  For example, to sort the student data by descending
_grade_ and then ascending _age_, do the _age_ sort first and then sort
again using _grade_:

     >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
     >>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

  The Timsort(2) algorithm used in Python does multiple sorts
efficiently because it can take advantage of any ordering already
present in a dataset.

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Sorting_algorithm#Stability

   (2) http://en.wikipedia.org/wiki/Timsort


File: python.info,  Node: The Old Way Using Decorate-Sort-Undecorate,  Next: The Old Way Using the cmp Parameter,  Prev: Sort Stability and Complex Sorts,  Up: Sorting HOW TO

10.11.6 The Old Way Using Decorate-Sort-Undecorate
--------------------------------------------------

This idiom is called Decorate-Sort-Undecorate after its three steps:

   * First, the initial list is decorated with new values that control
     the sort order.

   * Second, the decorated list is sorted.

   * Finally, the decorations are removed, creating a list that contains
     only the initial values in the new order.

  For example, to sort the student data by _grade_ using the DSU
approach:

     >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
     >>> decorated.sort()
     >>> [student for grade, i, student in decorated]               # undecorate
     [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

  This idiom works because tuples are compared lexicographically; the
first items are compared; if they are the same then the second items are
compared, and so on.

  It is not strictly necessary in all cases to include the index _i_ in
the decorated list, but including it gives two benefits:

   * The sort is stable – if two items have the same key, their order
     will be preserved in the sorted list.

   * The original items do not have to be comparable because the
     ordering of the decorated tuples will be determined by at most the
     first two items.  So for example the original list could contain
     complex numbers which cannot be sorted directly.

  Another name for this idiom is Schwartzian transform(1), after Randal
L. Schwartz, who popularized it among Perl programmers.

  For large lists and lists where the comparison information is
expensive to calculate, and Python versions before 2.4, DSU is likely to
be the fastest way to sort the list.  For 2.4 and later, key functions
provide the same functionality.

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Schwartzian_transform


File: python.info,  Node: The Old Way Using the cmp Parameter,  Next: Odd and Ends,  Prev: The Old Way Using Decorate-Sort-Undecorate,  Up: Sorting HOW TO

10.11.7 The Old Way Using the _cmp_ Parameter
---------------------------------------------

Many constructs given in this HOWTO assume Python 2.4 or later.  Before
that, there was no *note sorted(): 223. builtin and ‘list.sort()’ took
no keyword arguments.  Instead, all of the Py2.x versions supported a
_cmp_ parameter to handle user specified comparison functions.

  In Python 3, the _cmp_ parameter was removed entirely (as part of a
larger effort to simplify and unify the language, eliminating the
conflict between rich comparisons and the *note __cmp__(): 221. magic
method).

  In Python 2, ‘sort()’ allowed an optional function which can be called
for doing the comparisons.  That function should take two arguments to
be compared and then return a negative value for less-than, return zero
if they are equal, or return a positive value for greater-than.  For
example, we can do:

     >>> def numeric_compare(x, y):
             return x - y
     >>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare)
     [1, 2, 3, 4, 5]

  Or you can reverse the order of comparison with:

     >>> def reverse_numeric(x, y):
             return y - x
     >>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric)
     [5, 4, 3, 2, 1]

  When porting code from Python 2.x to 3.x, the situation can arise when
you have the user supplying a comparison function and you need to
convert that to a key function.  The following wrapper makes that easy
to do:

     def cmp_to_key(mycmp):
         'Convert a cmp= function into a key= function'
         class K(object):
             def __init__(self, obj, *args):
                 self.obj = obj
             def __lt__(self, other):
                 return mycmp(self.obj, other.obj) < 0
             def __gt__(self, other):
                 return mycmp(self.obj, other.obj) > 0
             def __eq__(self, other):
                 return mycmp(self.obj, other.obj) == 0
             def __le__(self, other):
                 return mycmp(self.obj, other.obj) <= 0
             def __ge__(self, other):
                 return mycmp(self.obj, other.obj) >= 0
             def __ne__(self, other):
                 return mycmp(self.obj, other.obj) != 0
         return K

  To convert to a key function, just wrap the old comparison function:

     >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
     [5, 4, 3, 2, 1]

  In Python 2.7, the *note functools.cmp_to_key(): 222. function was
added to the functools module.


File: python.info,  Node: Odd and Ends,  Prev: The Old Way Using the cmp Parameter,  Up: Sorting HOW TO

10.11.8 Odd and Ends
--------------------

   * For locale aware sorting, use *note locale.strxfrm(): 2027. for a
     key function or *note locale.strcoll(): 2025. for a comparison
     function.

   * The _reverse_ parameter still maintains sort stability (so that
     records with equal keys retain their original order).
     Interestingly, that effect can be simulated without the parameter
     by using the builtin *note reversed(): 3f8. function twice:

          >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
          >>> assert sorted(data, reverse=True) == list(reversed(sorted(reversed(data))))

   * To create a standard sort order for a class, just add the
     appropriate rich comparison methods:

          >>> Student.__eq__ = lambda self, other: self.age == other.age
          >>> Student.__ne__ = lambda self, other: self.age != other.age
          >>> Student.__lt__ = lambda self, other: self.age < other.age
          >>> Student.__le__ = lambda self, other: self.age <= other.age
          >>> Student.__gt__ = lambda self, other: self.age > other.age
          >>> Student.__ge__ = lambda self, other: self.age >= other.age
          >>> sorted(student_objects)
          [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

     For general purpose comparisons, the recommended approach is to
     define all six rich comparison operators.  The *note
     functools.total_ordering(): 21b. class decorator makes this easy to
     implement.

   * Key functions need not depend directly on the objects being sorted.
     A key function can also access external resources.  For instance,
     if the student grades are stored in a dictionary, they can be used
     to sort a separate list of student names:

          >>> students = ['dave', 'john', 'jane']
          >>> grades = {'john': 'F', 'jane':'A', 'dave': 'C'}
          >>> sorted(students, key=grades.__getitem__)
          ['jane', 'dave', 'john']


File: python.info,  Node: Unicode HOWTO,  Next: HOWTO Fetch Internet Resources Using urllib2,  Prev: Sorting HOW TO,  Up: Python HOWTOs

10.12 Unicode HOWTO
===================

     Release: 1.03

  This HOWTO discusses Python 2.x’s support for Unicode, and explains
various problems that people commonly encounter when trying to work with
Unicode.  For the Python 3 version, see
<‘http://docs.python.org/py3k/howto/unicode.html’>.

* Menu:

* Introduction to Unicode:: 
* Python 2.x’s Unicode Support: Python 2 x's Unicode Support. 
* Reading and Writing Unicode Data:: 
* Revision History and Acknowledgements: Revision History and Acknowledgements<2>. 

Introduction to Unicode

* History of Character Codes:: 
* Definitions:: 
* Encodings:: 
* References: References<2>. 

Python 2.x’s Unicode Support

* The Unicode Type:: 
* Unicode Literals in Python Source Code:: 
* Unicode Properties:: 
* References: References<3>. 

Reading and Writing Unicode Data

* Unicode filenames:: 
* Tips for Writing Unicode-aware Programs:: 
* References: References<4>. 


File: python.info,  Node: Introduction to Unicode,  Next: Python 2 x's Unicode Support,  Up: Unicode HOWTO

10.12.1 Introduction to Unicode
-------------------------------

* Menu:

* History of Character Codes:: 
* Definitions:: 
* Encodings:: 
* References: References<2>. 


File: python.info,  Node: History of Character Codes,  Next: Definitions,  Up: Introduction to Unicode

10.12.1.1 History of Character Codes
....................................

In 1968, the American Standard Code for Information Interchange, better
known by its acronym ASCII, was standardized.  ASCII defined numeric
codes for various characters, with the numeric values running from 0 to
127.  For example, the lowercase letter ’a’ is assigned 97 as its code
value.

  ASCII was an American-developed standard, so it only defined
unaccented characters.  There was an ’e’, but no ’é’ or ’Í’.  This meant
that languages which required accented characters couldn’t be faithfully
represented in ASCII. (Actually the missing accents matter for English,
too, which contains words such as ’naïve’ and ’café’, and some
publications have house styles which require spellings such as
’coöperate’.)

  For a while people just wrote programs that didn’t display accents.  I
remember looking at Apple ][ BASIC programs, published in
French-language publications in the mid-1980s, that had lines like
these:

     PRINT "FICHIER EST COMPLETE."
     PRINT "CARACTERE NON ACCEPTE."

  Those messages should contain accents, and they just look wrong to
someone who can read French.

  In the 1980s, almost all personal computers were 8-bit, meaning that
bytes could hold values ranging from 0 to 255.  ASCII codes only went up
to 127, so some machines assigned values between 128 and 255 to accented
characters.  Different machines had different codes, however, which led
to problems exchanging files.  Eventually various commonly used sets of
values for the 128-255 range emerged.  Some were true standards, defined
by the International Standards Organization, and some were *de facto*
conventions that were invented by one company or another and managed to
catch on.

  255 characters aren’t very many.  For example, you can’t fit both the
accented characters used in Western Europe and the Cyrillic alphabet
used for Russian into the 128-255 range because there are more than 128
such characters.

  You could write files using different codes (all your Russian files in
a coding system called KOI8, all your French files in a different coding
system called Latin1), but what if you wanted to write a French document
that quotes some Russian text?  In the 1980s people began to want to
solve this problem, and the Unicode standardization effort began.

  Unicode started out using 16-bit characters instead of 8-bit
characters.  16 bits means you have 2^16 = 65,536 distinct values
available, making it possible to represent many different characters
from many different alphabets; an initial goal was to have Unicode
contain the alphabets for every single human language.  It turns out
that even 16 bits isn’t enough to meet that goal, and the modern Unicode
specification uses a wider range of codes, 0-1,114,111 (0x10ffff in
base-16).

  There’s a related ISO standard, ISO 10646.  Unicode and ISO 10646 were
originally separate efforts, but the specifications were merged with the
1.1 revision of Unicode.

  (This discussion of Unicode’s history is highly simplified.  I don’t
think the average Python programmer needs to worry about the historical
details; consult the Unicode consortium site listed in the References
for more information.)


File: python.info,  Node: Definitions,  Next: Encodings,  Prev: History of Character Codes,  Up: Introduction to Unicode

10.12.1.2 Definitions
.....................

A *character* is the smallest possible component of a text.  ’A’, ’B’,
’C’, etc., are all different characters.  So are ’È’ and ’Í’.
Characters are abstractions, and vary depending on the language or
context you’re talking about.  For example, the symbol for ohms (Ω) is
usually drawn much like the capital letter omega (Ω) in the Greek
alphabet (they may even be the same in some fonts), but these are two
different characters that have different meanings.

  The Unicode standard describes how characters are represented by *code
points*.  A code point is an integer value, usually denoted in base 16.
In the standard, a code point is written using the notation U+12ca to
mean the character with value 0x12ca (4810 decimal).  The Unicode
standard contains a lot of tables listing characters and their
corresponding code points:

     0061    'a'; LATIN SMALL LETTER A
     0062    'b'; LATIN SMALL LETTER B
     0063    'c'; LATIN SMALL LETTER C
     ...
     007B    '{'; LEFT CURLY BRACKET

  Strictly, these definitions imply that it’s meaningless to say ’this
is character U+12ca’.  U+12ca is a code point, which represents some
particular character; in this case, it represents the character
’ETHIOPIC SYLLABLE WI’.  In informal contexts, this distinction between
code points and characters will sometimes be forgotten.

  A character is represented on a screen or on paper by a set of
graphical elements that’s called a *glyph*.  The glyph for an uppercase
A, for example, is two diagonal strokes and a horizontal stroke, though
the exact details will depend on the font being used.  Most Python code
doesn’t need to worry about glyphs; figuring out the correct glyph to
display is generally the job of a GUI toolkit or a terminal’s font
renderer.


File: python.info,  Node: Encodings,  Next: References<2>,  Prev: Definitions,  Up: Introduction to Unicode

10.12.1.3 Encodings
...................

To summarize the previous section: a Unicode string is a sequence of
code points, which are numbers from 0 to 0x10ffff.  This sequence needs
to be represented as a set of bytes (meaning, values from 0-255) in
memory.  The rules for translating a Unicode string into a sequence of
bytes are called an *encoding*.

  The first encoding you might think of is an array of 32-bit integers.
In this representation, the string "Python" would look like this:

        P           y           t           h           o           n
     0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00
        0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

  This representation is straightforward but using it presents a number
of problems.

  1. It’s not portable; different processors order the bytes
     differently.

  2. It’s very wasteful of space.  In most texts, the majority of the
     code points are less than 127, or less than 255, so a lot of space
     is occupied by zero bytes.  The above string takes 24 bytes
     compared to the 6 bytes needed for an ASCII representation.
     Increased RAM usage doesn’t matter too much (desktop computers have
     megabytes of RAM, and strings aren’t usually that large), but
     expanding our usage of disk and network bandwidth by a factor of 4
     is intolerable.

  3. It’s not compatible with existing C functions such as ‘strlen()’,
     so a new family of wide string functions would need to be used.

  4. Many Internet standards are defined in terms of textual data, and
     can’t handle content with embedded zero bytes.

  Generally people don’t use this encoding, instead choosing other
encodings that are more efficient and convenient.  UTF-8 is probably the
most commonly supported encoding; it will be discussed below.

  Encodings don’t have to handle every possible Unicode character, and
most encodings don’t.  For example, Python’s default encoding is the
’ascii’ encoding.  The rules for converting a Unicode string into the
ASCII encoding are simple; for each code point:

  1. If the code point is < 128, each byte is the same as the value of
     the code point.

  2. If the code point is 128 or greater, the Unicode string can’t be
     represented in this encoding.  (Python raises a *note
     UnicodeEncodeError: 957. exception in this case.)

  Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode
code points 0-255 are identical to the Latin-1 values, so converting to
this encoding simply requires converting code points to byte values; if
a code point larger than 255 is encountered, the string can’t be encoded
into Latin-1.

  Encodings don’t have to be simple one-to-one mappings like Latin-1.
Consider IBM’s EBCDIC, which was used on IBM mainframes.  Letter values
weren’t in one block: ’a’ through ’i’ had values from 129 to 137, but
’j’ through ’r’ were 145 through 153.  If you wanted to use EBCDIC as an
encoding, you’d probably use some sort of lookup table to perform the
conversion, but this is largely an internal detail.

  UTF-8 is one of the most commonly used encodings.  UTF stands for
"Unicode Transformation Format", and the ’8’ means that 8-bit numbers
are used in the encoding.  (There’s also a UTF-16 encoding, but it’s
less frequently used than UTF-8.)  UTF-8 uses the following rules:

  1. If the code point is <128, it’s represented by the corresponding
     byte value.

  2. If the code point is between 128 and 0x7ff, it’s turned into two
     byte values between 128 and 255.

  3. Code points >0x7ff are turned into three- or four-byte sequences,
     where each byte of the sequence is between 128 and 255.

  UTF-8 has several convenient properties:

  1. It can handle any Unicode code point.

  2. A Unicode string is turned into a string of bytes containing no
     embedded zero bytes.  This avoids byte-ordering issues, and means
     UTF-8 strings can be processed by C functions such as ‘strcpy()’
     and sent through protocols that can’t handle zero bytes.

  3. A string of ASCII text is also valid UTF-8 text.

  4. UTF-8 is fairly compact; the majority of code points are turned
     into two bytes, and values less than 128 occupy only a single byte.

  5. If bytes are corrupted or lost, it’s possible to determine the
     start of the next UTF-8-encoded code point and resynchronize.  It’s
     also unlikely that random 8-bit data will look like valid UTF-8.


File: python.info,  Node: References<2>,  Prev: Encodings,  Up: Introduction to Unicode

10.12.1.4 References
....................

The Unicode Consortium site at <‘http://www.unicode.org’> has character
charts, a glossary, and PDF versions of the Unicode specification.  Be
prepared for some difficult reading.
<‘http://www.unicode.org/history/’> is a chronology of the origin and
development of Unicode.

  To help understand the standard, Jukka Korpela has written an
introductory guide to reading the Unicode character tables, available at
<‘http://www.cs.tut.fi/~jkorpela/unicode/guide.html’>.

  Another good introductory article was written by Joel Spolsky
<‘http://www.joelonsoftware.com/articles/Unicode.html’>.  If this
introduction didn’t make things clear to you, you should try reading
this alternate article before continuing.

  Wikipedia entries are often helpful; see the entries for "character
encoding" <‘http://en.wikipedia.org/wiki/Character_encoding’> and UTF-8
<‘http://en.wikipedia.org/wiki/UTF-8’>, for example.


File: python.info,  Node: Python 2 x's Unicode Support,  Next: Reading and Writing Unicode Data,  Prev: Introduction to Unicode,  Up: Unicode HOWTO

10.12.2 Python 2.x’s Unicode Support
------------------------------------

Now that you’ve learned the rudiments of Unicode, we can look at
Python’s Unicode features.

* Menu:

* The Unicode Type:: 
* Unicode Literals in Python Source Code:: 
* Unicode Properties:: 
* References: References<3>. 


File: python.info,  Node: The Unicode Type,  Next: Unicode Literals in Python Source Code,  Up: Python 2 x's Unicode Support

10.12.2.1 The Unicode Type
..........................

Unicode strings are expressed as instances of the *note unicode: 1f5.
type, one of Python’s repertoire of built-in types.  It derives from an
abstract type called *note basestring: 458, which is also an ancestor of
the *note str: 1ea. type; you can therefore check if a value is a string
type with ‘isinstance(value, basestring)’.  Under the hood, Python
represents Unicode strings as either 16- or 32-bit integers, depending
on how the Python interpreter was compiled.

  The *note unicode(): 1f5. constructor has the signature
‘unicode(string[, encoding, errors])’.  All of its arguments should be
8-bit strings.  The first argument is converted to Unicode using the
specified encoding; if you leave off the ‘encoding’ argument, the ASCII
encoding is used for the conversion, so characters greater than 127 will
be treated as errors:

     >>> unicode('abcdef')
     u'abcdef'
     >>> s = unicode('abcdef')
     >>> type(s)
     <type 'unicode'>
     >>> unicode('abcdef' + chr(255))    #doctest: +NORMALIZE_WHITESPACE
     Traceback (most recent call last):
     ...
     UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 6:
     ordinal not in range(128)

  The ‘errors’ argument specifies the response when the input string
can’t be converted according to the encoding’s rules.  Legal values for
this argument are ’strict’ (raise a ‘UnicodeDecodeError’ exception),
’replace’ (add U+FFFD, ’REPLACEMENT CHARACTER’), or ’ignore’ (just leave
the character out of the Unicode result).  The following examples show
the differences:

     >>> unicode('\x80abc', errors='strict')     #doctest: +NORMALIZE_WHITESPACE
     Traceback (most recent call last):
         ...
     UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0:
     ordinal not in range(128)
     >>> unicode('\x80abc', errors='replace')
     u'\ufffdabc'
     >>> unicode('\x80abc', errors='ignore')
     u'abc'

  Encodings are specified as strings containing the encoding’s name.
Python 2.7 comes with roughly 100 different encodings; see the Python
Library Reference at *note Standard Encodings: 8c0. for a list.  Some
encodings have multiple names; for example, ’latin-1’, ’iso_8859_1’ and
’8859’ are all synonyms for the same encoding.

  One-character Unicode strings can also be created with the *note
unichr(): 495. built-in function, which takes integers and returns a
Unicode string of length 1 that contains the corresponding code point.
The reverse operation is the built-in *note ord(): 6f3. function that
takes a one-character Unicode string and returns the code point value:

     >>> unichr(40960)
     u'\ua000'
     >>> ord(u'\ua000')
     40960

  Instances of the *note unicode: 1f5. type have many of the same
methods as the 8-bit string type for operations such as searching and
formatting:

     >>> s = u'Was ever feather so lightly blown to and fro as this multitude?'
     >>> s.count('e')
     5
     >>> s.find('feather')
     9
     >>> s.find('bird')
     -1
     >>> s.replace('feather', 'sand')
     u'Was ever sand so lightly blown to and fro as this multitude?'
     >>> s.upper()
     u'WAS EVER FEATHER SO LIGHTLY BLOWN TO AND FRO AS THIS MULTITUDE?'

  Note that the arguments to these methods can be Unicode strings or
8-bit strings.  8-bit strings will be converted to Unicode before
carrying out the operation; Python’s default ASCII encoding will be
used, so characters greater than 127 will cause an exception:

     >>> s.find('Was\x9f')                   #doctest: +NORMALIZE_WHITESPACE
     Traceback (most recent call last):
         ...
     UnicodeDecodeError: 'ascii' codec can't decode byte 0x9f in position 3:
     ordinal not in range(128)
     >>> s.find(u'Was\x9f')
     -1

  Much Python code that operates on strings will therefore work with
Unicode strings without requiring any changes to the code.  (Input and
output code needs more updating for Unicode; more on this later.)

  Another important method is ‘.encode([encoding], [errors='strict'])’,
which returns an 8-bit string version of the Unicode string, encoded in
the requested encoding.  The ‘errors’ parameter is the same as the
parameter of the ‘unicode()’ constructor, with one additional
possibility; as well as ’strict’, ’ignore’, and ’replace’, you can also
pass ’xmlcharrefreplace’ which uses XML’s character references.  The
following example shows the different results:

     >>> u = unichr(40960) + u'abcd' + unichr(1972)
     >>> u.encode('utf-8')
     '\xea\x80\x80abcd\xde\xb4'
     >>> u.encode('ascii')                       #doctest: +NORMALIZE_WHITESPACE
     Traceback (most recent call last):
         ...
     UnicodeEncodeError: 'ascii' codec can't encode character u'\ua000' in
     position 0: ordinal not in range(128)
     >>> u.encode('ascii', 'ignore')
     'abcd'
     >>> u.encode('ascii', 'replace')
     '?abcd?'
     >>> u.encode('ascii', 'xmlcharrefreplace')
     '&#40960;abcd&#1972;'

  Python’s 8-bit strings have a ‘.decode([encoding], [errors])’ method
that interprets the string using the given encoding:

     >>> u = unichr(40960) + u'abcd' + unichr(1972)   # Assemble a string
     >>> utf8_version = u.encode('utf-8')             # Encode as UTF-8
     >>> type(utf8_version), utf8_version
     (<type 'str'>, '\xea\x80\x80abcd\xde\xb4')
     >>> u2 = utf8_version.decode('utf-8')            # Decode using UTF-8
     >>> u == u2                                      # The two strings match
     True

  The low-level routines for registering and accessing the available
encodings are found in the *note codecs: 63. module.  However, the
encoding and decoding functions returned by this module are usually more
low-level than is comfortable, so I’m not going to describe the *note
codecs: 63. module here.  If you need to implement a completely new
encoding, you’ll need to learn about the *note codecs: 63. module
interfaces, but implementing encodings is a specialized task that also
won’t be covered here.  Consult the Python documentation to learn more
about this module.

  The most commonly used part of the *note codecs: 63. module is the
*note codecs.open(): a5d. function which will be discussed in the
section on input and output.


File: python.info,  Node: Unicode Literals in Python Source Code,  Next: Unicode Properties,  Prev: The Unicode Type,  Up: Python 2 x's Unicode Support

10.12.2.2 Unicode Literals in Python Source Code
................................................

In Python source code, Unicode literals are written as strings prefixed
with the ’u’ or ’U’ character: ‘u'abcdefghijk'’.  Specific code points
can be written using the ‘\u’ escape sequence, which is followed by four
hex digits giving the code point.  The ‘\U’ escape sequence is similar,
but expects 8 hex digits, not 4.

  Unicode literals can also use the same escape sequences as 8-bit
strings, including ‘\x’, but ‘\x’ only takes two hex digits so it can’t
express an arbitrary code point.  Octal escapes can go up to U+01ff,
which is octal 777.

     >>> s = u"a\xac\u1234\u20ac\U00008000"
     ... #      ^^^^ two-digit hex escape
     ... #          ^^^^^^ four-digit Unicode escape
     ... #                      ^^^^^^^^^^ eight-digit Unicode escape
     >>> for c in s:  print ord(c),
     ...
     97 172 4660 8364 32768

  Using escape sequences for code points greater than 127 is fine in
small doses, but becomes an annoyance if you’re using many accented
characters, as you would in a program with messages in French or some
other accent-using language.  You can also assemble strings using the
*note unichr(): 495. built-in function, but this is even more tedious.

  Ideally, you’d want to be able to write literals in your language’s
natural encoding.  You could then edit Python source code with your
favorite editor which would display the accented characters naturally,
and have the right characters used at runtime.

  Python supports writing Unicode literals in any encoding, but you have
to declare the encoding being used.  This is done by including a special
comment as either the first or second line of the source file:

     #!/usr/bin/env python
     # -*- coding: latin-1 -*-

     u = u'abcdé'
     print ord(u[-1])

  The syntax is inspired by Emacs’s notation for specifying variables
local to a file.  Emacs supports many different variables, but Python
only supports ’coding’.  The ‘-*-’ symbols indicate to Emacs that the
comment is special; they have no significance to Python but are a
convention.  Python looks for ‘coding: name’ or ‘coding=name’ in the
comment.

  If you don’t include such a comment, the default encoding used will be
ASCII. Versions of Python before 2.4 were Euro-centric and assumed
Latin-1 as a default encoding for string literals; in Python 2.4,
characters greater than 127 still work but result in a warning.  For
example, the following program has no encoding declaration:

     #!/usr/bin/env python
     u = u'abcdé'
     print ord(u[-1])

  When you run it with Python 2.4, it will output the following warning:

     amk:~$ python2.4 p263.py
     sys:1: DeprecationWarning: Non-ASCII character '\xe9'
          in file p263.py on line 2, but no encoding declared;
          see http://www.python.org/peps/pep-0263.html for details

  Python 2.5 and higher are stricter and will produce a syntax error:

     amk:~$ python2.5 p263.py
     File "/tmp/p263.py", line 2
     SyntaxError: Non-ASCII character '\xc3' in file /tmp/p263.py
       on line 2, but no encoding declared; see
       http://www.python.org/peps/pep-0263.html for details


File: python.info,  Node: Unicode Properties,  Next: References<3>,  Prev: Unicode Literals in Python Source Code,  Up: Python 2 x's Unicode Support

10.12.2.3 Unicode Properties
............................

The Unicode specification includes a database of information about code
points.  For each code point that’s defined, the information includes
the character’s name, its category, the numeric value if applicable
(Unicode has characters representing the Roman numerals and fractions
such as one-third and four-fifths).  There are also properties related
to the code point’s use in bidirectional text and other display-related
properties.

  The following program displays some information about several
characters, and prints the numeric value of one particular character:

     import unicodedata

     u = unichr(233) + unichr(0x0bf2) + unichr(3972) + unichr(6000) + unichr(13231)

     for i, c in enumerate(u):
         print i, '%04x' % ord(c), unicodedata.category(c),
         print unicodedata.name(c)

     # Get numeric value of second character
     print unicodedata.numeric(u[1])

  When run, this prints:

     0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE
     1 0bf2 No TAMIL NUMBER ONE THOUSAND
     2 0f84 Mn TIBETAN MARK HALANTA
     3 1770 Lo TAGBANWA LETTER SA
     4 33af So SQUARE RAD OVER S SQUARED
     1000.0

  The category codes are abbreviations describing the nature of the
character.  These are grouped into categories such as "Letter",
"Number", "Punctuation", or "Symbol", which in turn are broken up into
subcategories.  To take the codes from the above output, ‘'Ll'’ means
’Letter, lowercase’, ‘'No'’ means "Number, other", ‘'Mn'’ is "Mark,
nonspacing", and ‘'So'’ is "Symbol, other".  See
<‘http://www.unicode.org/reports/tr44/#General_Category_Values’> for a
list of category codes.


File: python.info,  Node: References<3>,  Prev: Unicode Properties,  Up: Python 2 x's Unicode Support

10.12.2.4 References
....................

The Unicode and 8-bit string types are described in the Python library
reference at *note Sequence Types — str, unicode, list, tuple,
bytearray, buffer, xrange: 521.

  The documentation for the *note unicodedata: 186. module.

  The documentation for the *note codecs: 63. module.

  Marc-André Lemburg gave a presentation at EuroPython 2002 titled
"Python and Unicode".  A PDF version of his slides is available at
<‘http://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf’>, and is
an excellent overview of the design of Python’s Unicode features.


File: python.info,  Node: Reading and Writing Unicode Data,  Next: Revision History and Acknowledgements<2>,  Prev: Python 2 x's Unicode Support,  Up: Unicode HOWTO

10.12.3 Reading and Writing Unicode Data
----------------------------------------

Once you’ve written some code that works with Unicode data, the next
problem is input/output.  How do you get Unicode strings into your
program, and how do you convert Unicode into a form suitable for storage
or transmission?

  It’s possible that you may not need to do anything depending on your
input sources and output destinations; you should check whether the
libraries used in your application support Unicode natively.  XML
parsers often return Unicode data, for example.  Many relational
databases also support Unicode-valued columns and can return Unicode
values from an SQL query.

  Unicode data is usually converted to a particular encoding before it
gets written to disk or sent over a socket.  It’s possible to do all the
work yourself: open a file, read an 8-bit string from it, and convert
the string with ‘unicode(str, encoding)’.  However, the manual approach
is not recommended.

  One problem is the multi-byte nature of encodings; one Unicode
character can be represented by several bytes.  If you want to read the
file in arbitrary-sized chunks (say, 1K or 4K), you need to write
error-handling code to catch the case where only part of the bytes
encoding a single Unicode character are read at the end of a chunk.  One
solution would be to read the entire file into memory and then perform
the decoding, but that prevents you from working with files that are
extremely large; if you need to read a 2Gb file, you need 2Gb of RAM.
(More, really, since for at least a moment you’d need to have both the
encoded string and its Unicode version in memory.)

  The solution would be to use the low-level decoding interface to catch
the case of partial coding sequences.  The work of implementing this has
already been done for you: the *note codecs: 63. module includes a
version of the *note open(): 2d6. function that returns a file-like
object that assumes the file’s contents are in a specified encoding and
accepts Unicode parameters for methods such as ‘.read()’ and ‘.write()’.

  The function’s parameters are ‘open(filename, mode='rb',
encoding=None, errors='strict', buffering=1)’.  ‘mode’ can be ‘'r'’,
‘'w'’, or ‘'a'’, just like the corresponding parameter to the regular
built-in ‘open()’ function; add a ‘'+'’ to update the file.  ‘buffering’
is similarly parallel to the standard function’s parameter.  ‘encoding’
is a string giving the encoding to use; if it’s left as ‘None’, a
regular Python file object that accepts 8-bit strings is returned.
Otherwise, a wrapper object is returned, and data written to or read
from the wrapper object will be converted as needed.  ‘errors’ specifies
the action for encoding errors and can be one of the usual values of
’strict’, ’ignore’, and ’replace’.

  Reading Unicode from a file is therefore simple:

     import codecs
     f = codecs.open('unicode.rst', encoding='utf-8')
     for line in f:
         print repr(line)

  It’s also possible to open files in update mode, allowing both reading
and writing:

     f = codecs.open('test', encoding='utf-8', mode='w+')
     f.write(u'\u4500 blah blah blah\n')
     f.seek(0)
     print repr(f.readline()[:1])
     f.close()

  Unicode character U+FEFF is used as a byte-order mark (BOM), and is
often written as the first character of a file in order to assist with
autodetection of the file’s byte ordering.  Some encodings, such as
UTF-16, expect a BOM to be present at the start of a file; when such an
encoding is used, the BOM will be automatically written as the first
character and will be silently dropped when the file is read.  There are
variants of these encodings, such as ’utf-16-le’ and ’utf-16-be’ for
little-endian and big-endian encodings, that specify one particular byte
ordering and don’t skip the BOM.

* Menu:

* Unicode filenames:: 
* Tips for Writing Unicode-aware Programs:: 
* References: References<4>. 


File: python.info,  Node: Unicode filenames,  Next: Tips for Writing Unicode-aware Programs,  Up: Reading and Writing Unicode Data

10.12.3.1 Unicode filenames
...........................

Most of the operating systems in common use today support filenames that
contain arbitrary Unicode characters.  Usually this is implemented by
converting the Unicode string into some encoding that varies depending
on the system.  For example, Mac OS X uses UTF-8 while Windows uses a
configurable encoding; on Windows, Python uses the name "mbcs" to refer
to whatever the currently configured encoding is.  On Unix systems,
there will only be a filesystem encoding if you’ve set the ‘LANG’ or
‘LC_CTYPE’ environment variables; if you haven’t, the default encoding
is ASCII.

  The *note sys.getfilesystemencoding(): fe6. function returns the
encoding to use on your current system, in case you want to do the
encoding manually, but there’s not much reason to bother.  When opening
a file for reading or writing, you can usually just provide the Unicode
string as the filename, and it will be automatically converted to the
right encoding for you:

     filename = u'filename\u4500abc'
     f = open(filename, 'w')
     f.write('blah\n')
     f.close()

  Functions in the *note os: 128. module such as *note os.stat(): 3c4.
will also accept Unicode filenames.

  *note os.listdir(): 2d2, which returns filenames, raises an issue:
should it return the Unicode version of filenames, or should it return
8-bit strings containing the encoded versions?  *note os.listdir(): 2d2.
will do both, depending on whether you provided the directory path as an
8-bit string or a Unicode string.  If you pass a Unicode string as the
path, filenames will be decoded using the filesystem’s encoding and a
list of Unicode strings will be returned, while passing an 8-bit path
will return the 8-bit versions of the filenames.  For example, assuming
the default filesystem encoding is UTF-8, running the following program:

     fn = u'filename\u4500abc'
     f = open(fn, 'w')
     f.close()

     import os
     print os.listdir('.')
     print os.listdir(u'.')

  will produce the following output:

     amk:~$ python t.py
     ['.svn', 'filename\xe4\x94\x80abc', ...]
     [u'.svn', u'filename\u4500abc', ...]

  The first list contains UTF-8-encoded filenames, and the second list
contains the Unicode versions.


File: python.info,  Node: Tips for Writing Unicode-aware Programs,  Next: References<4>,  Prev: Unicode filenames,  Up: Reading and Writing Unicode Data

10.12.3.2 Tips for Writing Unicode-aware Programs
.................................................

This section provides some suggestions on writing software that deals
with Unicode.

  The most important tip is:

     Software should only work with Unicode strings internally,
     converting to a particular encoding on output.

  If you attempt to write processing functions that accept both Unicode
and 8-bit strings, you will find your program vulnerable to bugs
wherever you combine the two different kinds of strings.  Python’s
default encoding is ASCII, so whenever a character with an ASCII value >
127 is in the input data, you’ll get a *note UnicodeDecodeError: 958.
because that character can’t be handled by the ASCII encoding.

  It’s easy to miss such problems if you only test your software with
data that doesn’t contain any accents; everything will seem to work, but
there’s actually a bug in your program waiting for the first user who
attempts to use characters > 127.  A second tip, therefore, is:

     Include characters > 127 and, even better, characters > 255 in your
     test data.

  When using data coming from a web browser or some other untrusted
source, a common technique is to check for illegal characters in a
string before using the string in a generated command line or storing it
in a database.  If you’re doing this, be careful to check the string
once it’s in the form that will be used or stored; it’s possible for
encodings to be used to disguise characters.  This is especially true if
the input data also specifies the encoding; many encodings leave the
commonly checked-for characters alone, but Python includes some
encodings such as ‘'base64'’ that modify every single character.

  For example, let’s say you have a content management system that takes
a Unicode filename, and you want to disallow paths with a ’/’ character.
You might write this code:

     def read_file (filename, encoding):
         if '/' in filename:
             raise ValueError("'/' not allowed in filenames")
         unicode_name = filename.decode(encoding)
         f = open(unicode_name, 'r')
         # ... return contents of file ...

  However, if an attacker could specify the ‘'base64'’ encoding, they
could pass ‘'L2V0Yy9wYXNzd2Q='’, which is the base-64 encoded form of
the string ‘'/etc/passwd'’, to read a system file.  The above code looks
for ‘'/'’ characters in the encoded form and misses the dangerous
character in the resulting decoded form.


File: python.info,  Node: References<4>,  Prev: Tips for Writing Unicode-aware Programs,  Up: Reading and Writing Unicode Data

10.12.3.3 References
....................

The PDF slides for Marc-André Lemburg’s presentation "Writing
Unicode-aware Applications in Python" are available at
<‘http://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf’>
and discuss questions of character encodings as well as how to
internationalize and localize an application.


File: python.info,  Node: Revision History and Acknowledgements<2>,  Prev: Reading and Writing Unicode Data,  Up: Unicode HOWTO

10.12.4 Revision History and Acknowledgements
---------------------------------------------

Thanks to the following people who have noted errors or offered
suggestions on this article: Nicholas Bastin, Marius Gedminas, Kent
Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, Chad
Whitacre.

  Version 1.0: posted August 5 2005.

  Version 1.01: posted August 7 2005.  Corrects factual and markup
errors; adds several links.

  Version 1.02: posted August 16 2005.  Corrects factual errors.

  Version 1.03: posted June 20 2010.  Notes that Python 3.x is not
covered, and that the HOWTO only covers 2.x.


File: python.info,  Node: HOWTO Fetch Internet Resources Using urllib2,  Next: HOWTO Use Python in the web,  Prev: Unicode HOWTO,  Up: Python HOWTOs

10.13 HOWTO Fetch Internet Resources Using urllib2
==================================================

     Author: Michael Foord(1)

     Note: There is an French translation of an earlier revision of this
     HOWTO, available at urllib2 - Le Manuel manquant(2).

* Menu:

* Introduction: Introduction<14>. 
* Fetching URLs:: 
* Handling Exceptions: Handling Exceptions<2>. 
* info and geturl:: 
* Openers and Handlers:: 
* Basic Authentication:: 
* Proxies:: 
* Sockets and Layers:: 
* Footnotes:: 

   ---------- Footnotes ----------

   (1) http://www.voidspace.org.uk/python/index.shtml

   (2) 
http://www.voidspace.org.uk/python/articles/urllib2_francais.shtml


File: python.info,  Node: Introduction<14>,  Next: Fetching URLs,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.1 Introduction
--------------------

Related Articles
................

You may also find useful the following article on fetching web resources
with Python:

   * Basic Authentication(1)

          A tutorial on _Basic Authentication_, with examples in Python.

  *urllib2* is a Python(2) module for fetching URLs (Uniform Resource
Locators).  It offers a very simple interface, in the form of the
_urlopen_ function.  This is capable of fetching URLs using a variety of
different protocols.  It also offers a slightly more complex interface
for handling common situations - like basic authentication, cookies,
proxies and so on.  These are provided by objects called handlers and
openers.

  urllib2 supports fetching URLs for many "URL schemes" (identified by
the string before the ":" in URL - for example "ftp" is the URL scheme
of "‘ftp://python.org/’") using their associated network protocols (e.g.
FTP, HTTP). This tutorial focuses on the most common case, HTTP.

  For straightforward situations _urlopen_ is very easy to use.  But as
soon as you encounter errors or non-trivial cases when opening HTTP
URLs, you will need some understanding of the HyperText Transfer
Protocol.  The most comprehensive and authoritative reference to HTTP is
RFC 2616(3).  This is a technical document and not intended to be easy
to read.  This HOWTO aims to illustrate using _urllib2_, with enough
detail about HTTP to help you through.  It is not intended to replace
the *note urllib2: 189. docs, but is supplementary to them.

   ---------- Footnotes ----------

   (1) http://www.voidspace.org.uk/python/articles/authentication.shtml

   (2) http://www.python.org

   (3) http://tools.ietf.org/html/rfc2616.html


File: python.info,  Node: Fetching URLs,  Next: Handling Exceptions<2>,  Prev: Introduction<14>,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.2 Fetching URLs
---------------------

The simplest way to use urllib2 is as follows:

     import urllib2
     response = urllib2.urlopen('http://python.org/')
     html = response.read()

  Many uses of urllib2 will be that simple (note that instead of an
’http:’ URL we could have used an URL starting with ’ftp:’, ’file:’,
etc.).  However, it’s the purpose of this tutorial to explain the more
complicated cases, concentrating on HTTP.

  HTTP is based on requests and responses - the client makes requests
and servers send responses.  urllib2 mirrors this with a ‘Request’
object which represents the HTTP request you are making.  In its
simplest form you create a Request object that specifies the URL you
want to fetch.  Calling ‘urlopen’ with this Request object returns a
response object for the URL requested.  This response is a file-like
object, which means you can for example call ‘.read()’ on the response:

     import urllib2

     req = urllib2.Request('http://www.voidspace.org.uk')
     response = urllib2.urlopen(req)
     the_page = response.read()

  Note that urllib2 makes use of the same Request interface to handle
all URL schemes.  For example, you can make an FTP request like so:

     req = urllib2.Request('ftp://example.com/')

  In the case of HTTP, there are two extra things that Request objects
allow you to do: First, you can pass data to be sent to the server.
Second, you can pass extra information ("metadata") _about_ the data or
the about request itself, to the server - this information is sent as
HTTP "headers".  Let’s look at each of these in turn.

* Menu:

* Data:: 
* Headers:: 


File: python.info,  Node: Data,  Next: Headers,  Up: Fetching URLs

10.13.2.1 Data
..............

Sometimes you want to send data to a URL (often the URL will refer to a
CGI (Common Gateway Interface) script (1) or other web application).
With HTTP, this is often done using what’s known as a *POST* request.
This is often what your browser does when you submit a HTML form that
you filled in on the web.  Not all POSTs have to come from forms: you
can use a POST to transmit arbitrary data to your own application.  In
the common case of HTML forms, the data needs to be encoded in a
standard way, and then passed to the Request object as the ‘data’
argument.  The encoding is done using a function from the ‘urllib’
library _not_ from ‘urllib2’.

     import urllib
     import urllib2

     url = 'http://www.someserver.com/cgi-bin/register.cgi'
     values = {'name' : 'Michael Foord',
               'location' : 'Northampton',
               'language' : 'Python' }

     data = urllib.urlencode(values)
     req = urllib2.Request(url, data)
     response = urllib2.urlopen(req)
     the_page = response.read()

  Note that other encodings are sometimes required (e.g.  for file
upload from HTML forms - see HTML Specification, Form Submission(2) for
more details).

  If you do not pass the ‘data’ argument, urllib2 uses a *GET* request.
One way in which GET and POST requests differ is that POST requests
often have "side-effects": they change the state of the system in some
way (for example by placing an order with the website for a
hundredweight of tinned spam to be delivered to your door).  Though the
HTTP standard makes it clear that POSTs are intended to _always_ cause
side-effects, and GET requests _never_ to cause side-effects, nothing
prevents a GET request from having side-effects, nor a POST requests
from having no side-effects.  Data can also be passed in an HTTP GET
request by encoding it in the URL itself.

  This is done as follows:

     >>> import urllib2
     >>> import urllib
     >>> data = {}
     >>> data['name'] = 'Somebody Here'
     >>> data['location'] = 'Northampton'
     >>> data['language'] = 'Python'
     >>> url_values = urllib.urlencode(data)
     >>> print url_values  # The order may differ. #doctest: +SKIP
     name=Somebody+Here&language=Python&location=Northampton
     >>> url = 'http://www.example.com/example.cgi'
     >>> full_url = url + '?' + url_values
     >>> data = urllib2.urlopen(full_url)

  Notice that the full URL is created by adding a ‘?’ to the URL,
followed by the encoded values.

   ---------- Footnotes ----------

   (1) For an introduction to the CGI protocol see Writing Web
Applications in Python
(http://www.pyzine.com/Issue008/Section_Articles/article_CGIOne.html).

   (2) http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13


File: python.info,  Node: Headers,  Prev: Data,  Up: Fetching URLs

10.13.2.2 Headers
.................

We’ll discuss here one particular HTTP header, to illustrate how to add
headers to your HTTP request.

  Some websites (1) dislike being browsed by programs, or send different
versions to different browsers (2).  By default urllib2 identifies
itself as ‘Python-urllib/x.y’ (where ‘x’ and ‘y’ are the major and minor
version numbers of the Python release, e.g.  ‘Python-urllib/2.5’), which
may confuse the site, or just plain not work.  The way a browser
identifies itself is through the ‘User-Agent’ header (3).  When you
create a Request object you can pass a dictionary of headers in.  The
following example makes the same request as above, but identifies itself
as a version of Internet Explorer (4).

     import urllib
     import urllib2

     url = 'http://www.someserver.com/cgi-bin/register.cgi'
     user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
     values = {'name' : 'Michael Foord',
               'location' : 'Northampton',
               'language' : 'Python' }
     headers = { 'User-Agent' : user_agent }

     data = urllib.urlencode(values)
     req = urllib2.Request(url, data, headers)
     response = urllib2.urlopen(req)
     the_page = response.read()

  The response also has two useful methods.  See the section on *note
info and geturl: 308b. which comes after we have a look at what happens
when things go wrong.

   ---------- Footnotes ----------

   (1) Like Google for example.  The _proper_ way to use google from a
program is to use PyGoogle (http://pygoogle.sourceforge.net) of course.
See Voidspace Google
(http://www.voidspace.org.uk/python/recipebook.shtml#google) for some
examples of using the Google API.

   (2) Browser sniffing is a very bad practise for website design -
building sites using web standards is much more sensible.  Unfortunately
a lot of sites still send different versions to different browsers.

   (3) The user agent for MSIE 6 is _’Mozilla/4.0 (compatible; MSIE 6.0;
Windows NT 5.1; SV1; .NET CLR 1.1.4322)’_

   (4) For details of more HTTP request headers, see Quick Reference to
HTTP Headers (http://www.cs.tut.fi/~jkorpela/http.html).


File: python.info,  Node: Handling Exceptions<2>,  Next: info and geturl,  Prev: Fetching URLs,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.3 Handling Exceptions
---------------------------

_urlopen_ raises ‘URLError’ when it cannot handle a response (though as
usual with Python APIs, built-in exceptions such as *note ValueError:
236, *note TypeError: 218. etc.  may also be raised).

  ‘HTTPError’ is the subclass of ‘URLError’ raised in the specific case
of HTTP URLs.

* Menu:

* URLError:: 
* HTTPError:: 
* Wrapping it Up:: 


File: python.info,  Node: URLError,  Next: HTTPError,  Up: Handling Exceptions<2>

10.13.3.1 URLError
..................

Often, URLError is raised because there is no network connection (no
route to the specified server), or the specified server doesn’t exist.
In this case, the exception raised will have a ’reason’ attribute, which
is a tuple containing an error code and a text error message.

  e.g.

     >>> req = urllib2.Request('http://www.pretend_server.org')
     >>> try: urllib2.urlopen(req)
     ... except URLError as e:
     ...    print e.reason   #doctest: +SKIP
     ...
     (4, 'getaddrinfo failed')


File: python.info,  Node: HTTPError,  Next: Wrapping it Up,  Prev: URLError,  Up: Handling Exceptions<2>

10.13.3.2 HTTPError
...................

Every HTTP response from the server contains a numeric "status code".
Sometimes the status code indicates that the server is unable to fulfil
the request.  The default handlers will handle some of these responses
for you (for example, if the response is a "redirection" that requests
the client fetch the document from a different URL, urllib2 will handle
that for you).  For those it can’t handle, urlopen will raise an
‘HTTPError’.  Typical errors include ’404’ (page not found), ’403’
(request forbidden), and ’401’ (authentication required).

  See section 10 of RFC 2616 for a reference on all the HTTP error
codes.

  The ‘HTTPError’ instance raised will have an integer ’code’ attribute,
which corresponds to the error sent by the server.

* Menu:

* Error Codes:: 


File: python.info,  Node: Error Codes,  Up: HTTPError

10.13.3.3 Error Codes
.....................

Because the default handlers handle redirects (codes in the 300 range),
and codes in the 100-299 range indicate success, you will usually only
see error codes in the 400-599 range.

  ‘BaseHTTPServer.BaseHTTPRequestHandler.responses’ is a useful
dictionary of response codes in that shows all the response codes used
by RFC 2616.  The dictionary is reproduced here for convenience

     # Table mapping response codes to messages; entries have the
     # form {code: (shortmessage, longmessage)}.
     responses = {
         100: ('Continue', 'Request received, please continue'),
         101: ('Switching Protocols',
               'Switching to new protocol; obey Upgrade header'),

         200: ('OK', 'Request fulfilled, document follows'),
         201: ('Created', 'Document created, URL follows'),
         202: ('Accepted',
               'Request accepted, processing continues off-line'),
         203: ('Non-Authoritative Information', 'Request fulfilled from cache'),
         204: ('No Content', 'Request fulfilled, nothing follows'),
         205: ('Reset Content', 'Clear input form for further input.'),
         206: ('Partial Content', 'Partial content follows.'),

         300: ('Multiple Choices',
               'Object has several resources -- see URI list'),
         301: ('Moved Permanently', 'Object moved permanently -- see URI list'),
         302: ('Found', 'Object moved temporarily -- see URI list'),
         303: ('See Other', 'Object moved -- see Method and URL list'),
         304: ('Not Modified',
               'Document has not changed since given time'),
         305: ('Use Proxy',
               'You must use proxy specified in Location to access this '
               'resource.'),
         307: ('Temporary Redirect',
               'Object moved temporarily -- see URI list'),

         400: ('Bad Request',
               'Bad request syntax or unsupported method'),
         401: ('Unauthorized',
               'No permission -- see authorization schemes'),
         402: ('Payment Required',
               'No payment -- see charging schemes'),
         403: ('Forbidden',
               'Request forbidden -- authorization will not help'),
         404: ('Not Found', 'Nothing matches the given URI'),
         405: ('Method Not Allowed',
               'Specified method is invalid for this server.'),
         406: ('Not Acceptable', 'URI not available in preferred format.'),
         407: ('Proxy Authentication Required', 'You must authenticate with '
               'this proxy before proceeding.'),
         408: ('Request Timeout', 'Request timed out; try again later.'),
         409: ('Conflict', 'Request conflict.'),
         410: ('Gone',
               'URI no longer exists and has been permanently removed.'),
         411: ('Length Required', 'Client must specify Content-Length.'),
         412: ('Precondition Failed', 'Precondition in headers is false.'),
         413: ('Request Entity Too Large', 'Entity is too large.'),
         414: ('Request-URI Too Long', 'URI is too long.'),
         415: ('Unsupported Media Type', 'Entity body in unsupported format.'),
         416: ('Requested Range Not Satisfiable',
               'Cannot satisfy request range.'),
         417: ('Expectation Failed',
               'Expect condition could not be satisfied.'),

         500: ('Internal Server Error', 'Server got itself in trouble'),
         501: ('Not Implemented',
               'Server does not support this operation'),
         502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),
         503: ('Service Unavailable',
               'The server cannot process the request due to a high load'),
         504: ('Gateway Timeout',
               'The gateway server did not receive a timely response'),
         505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),
         }

  When an error is raised the server responds by returning an HTTP error
code _and_ an error page.  You can use the ‘HTTPError’ instance as a
response on the page returned.  This means that as well as the code
attribute, it also has read, geturl, and info, methods.

     >>> req = urllib2.Request('http://www.python.org/fish.html')
     >>> try:
     ...     urllib2.urlopen(req)
     ... except urllib2.HTTPError as e:
     ...     print e.code
     ...     print e.read() #doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
     ...
     404
     <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
     ...
     <title>Page Not Found</title>
     ...


File: python.info,  Node: Wrapping it Up,  Prev: HTTPError,  Up: Handling Exceptions<2>

10.13.3.4 Wrapping it Up
........................

So if you want to be prepared for ‘HTTPError’ _or_ ‘URLError’ there are
two basic approaches.  I prefer the second approach.

* Menu:

* Number 1:: 
* Number 2:: 


File: python.info,  Node: Number 1,  Next: Number 2,  Up: Wrapping it Up

10.13.3.5 Number 1
..................

     from urllib2 import Request, urlopen, URLError, HTTPError
     req = Request(someurl)
     try:
         response = urlopen(req)
     except HTTPError as e:
         print 'The server couldn\'t fulfill the request.'
         print 'Error code: ', e.code
     except URLError as e:
         print 'We failed to reach a server.'
         print 'Reason: ', e.reason
     else:
         # everything is fine

     Note: The ‘except HTTPError’ _must_ come first, otherwise ‘except
     URLError’ will _also_ catch an ‘HTTPError’.


File: python.info,  Node: Number 2,  Prev: Number 1,  Up: Wrapping it Up

10.13.3.6 Number 2
..................

     from urllib2 import Request, urlopen, URLError
     req = Request(someurl)
     try:
         response = urlopen(req)
     except URLError as e:
         if hasattr(e, 'reason'):
             print 'We failed to reach a server.'
             print 'Reason: ', e.reason
         elif hasattr(e, 'code'):
             print 'The server couldn\'t fulfill the request.'
             print 'Error code: ', e.code
     else:
         # everything is fine


File: python.info,  Node: info and geturl,  Next: Openers and Handlers,  Prev: Handling Exceptions<2>,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.4 info and geturl
-----------------------

The response returned by urlopen (or the ‘HTTPError’ instance) has two
useful methods ‘info()’ and ‘geturl()’.

  *geturl* - this returns the real URL of the page fetched.  This is
useful because ‘urlopen’ (or the opener object used) may have followed a
redirect.  The URL of the page fetched may not be the same as the URL
requested.

  *info* - this returns a dictionary-like object that describes the page
fetched, particularly the headers sent by the server.  It is currently
an ‘httplib.HTTPMessage’ instance.

  Typical headers include ’Content-length’, ’Content-type’, and so on.
See the Quick Reference to HTTP Headers(1) for a useful listing of HTTP
headers with brief explanations of their meaning and use.

   ---------- Footnotes ----------

   (1) http://www.cs.tut.fi/~jkorpela/http.html


File: python.info,  Node: Openers and Handlers,  Next: Basic Authentication,  Prev: info and geturl,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.5 Openers and Handlers
----------------------------

When you fetch a URL you use an opener (an instance of the perhaps
confusingly-named *note urllib2.OpenerDirector: 1c56.).  Normally we
have been using the default opener - via ‘urlopen’ - but you can create
custom openers.  Openers use handlers.  All the "heavy lifting" is done
by the handlers.  Each handler knows how to open URLs for a particular
URL scheme (http, ftp, etc.), or how to handle an aspect of URL opening,
for example HTTP redirections or HTTP cookies.

  You will want to create openers if you want to fetch URLs with
specific handlers installed, for example to get an opener that handles
cookies, or to get an opener that does not handle redirections.

  To create an opener, instantiate an ‘OpenerDirector’, and then call
‘.add_handler(some_handler_instance)’ repeatedly.

  Alternatively, you can use ‘build_opener’, which is a convenience
function for creating opener objects with a single function call.
‘build_opener’ adds several handlers by default, but provides a quick
way to add more and/or override the default handlers.

  Other sorts of handlers you might want to can handle proxies,
authentication, and other common but slightly specialised situations.

  ‘install_opener’ can be used to make an ‘opener’ object the (global)
default opener.  This means that calls to ‘urlopen’ will use the opener
you have installed.

  Opener objects have an ‘open’ method, which can be called directly to
fetch urls in the same way as the ‘urlopen’ function: there’s no need to
call ‘install_opener’, except as a convenience.


File: python.info,  Node: Basic Authentication,  Next: Proxies,  Prev: Openers and Handlers,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.6 Basic Authentication
----------------------------

To illustrate creating and installing a handler we will use the
‘HTTPBasicAuthHandler’.  For a more detailed discussion of this subject
– including an explanation of how Basic Authentication works - see the
Basic Authentication Tutorial(1).

  When authentication is required, the server sends a header (as well as
the 401 error code) requesting authentication.  This specifies the
authentication scheme and a ’realm’.  The header looks like:
‘WWW-Authenticate: SCHEME realm="REALM"’.

  e.g.

     WWW-Authenticate: Basic realm="cPanel Users"

  The client should then retry the request with the appropriate name and
password for the realm included as a header in the request.  This is
’basic authentication’.  In order to simplify this process we can create
an instance of ‘HTTPBasicAuthHandler’ and an opener to use this handler.

  The ‘HTTPBasicAuthHandler’ uses an object called a password manager to
handle the mapping of URLs and realms to passwords and usernames.  If
you know what the realm is (from the authentication header sent by the
server), then you can use a ‘HTTPPasswordMgr’.  Frequently one doesn’t
care what the realm is.  In that case, it is convenient to use
‘HTTPPasswordMgrWithDefaultRealm’.  This allows you to specify a default
username and password for a URL. This will be supplied in the absence of
you providing an alternative combination for a specific realm.  We
indicate this by providing ‘None’ as the realm argument to the
‘add_password’ method.

  The top-level URL is the first URL that requires authentication.  URLs
"deeper" than the URL you pass to .add_password() will also match.

     # create a password manager
     password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()

     # Add the username and password.
     # If we knew the realm, we could use it instead of None.
     top_level_url = "http://example.com/foo/"
     password_mgr.add_password(None, top_level_url, username, password)

     handler = urllib2.HTTPBasicAuthHandler(password_mgr)

     # create "opener" (OpenerDirector instance)
     opener = urllib2.build_opener(handler)

     # use the opener to fetch a URL
     opener.open(a_url)

     # Install the opener.
     # Now all calls to urllib2.urlopen use our opener.
     urllib2.install_opener(opener)

     Note: In the above example we only supplied our
     ‘HTTPBasicAuthHandler’ to ‘build_opener’.  By default openers have
     the handlers for normal situations – ‘ProxyHandler’ (if a proxy
     setting such as an ‘http_proxy’ environment variable is set),
     ‘UnknownHandler’, ‘HTTPHandler’, ‘HTTPDefaultErrorHandler’,
     ‘HTTPRedirectHandler’, ‘FTPHandler’, ‘FileHandler’,
     ‘HTTPErrorProcessor’.

  ‘top_level_url’ is in fact _either_ a full URL (including the ’http:’
scheme component and the hostname and optionally the port number) e.g.
"‘http://example.com/’" _or_ an "authority" (i.e.  the hostname,
optionally including the port number) e.g.  "example.com" or
"example.com:8080" (the latter example includes a port number).  The
authority, if present, must NOT contain the "userinfo" component - for
example "joe@password:example.com" is not correct.

   ---------- Footnotes ----------

   (1) http://www.voidspace.org.uk/python/articles/authentication.shtml


File: python.info,  Node: Proxies,  Next: Sockets and Layers,  Prev: Basic Authentication,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.7 Proxies
---------------

*urllib2* will auto-detect your proxy settings and use those.  This is
through the ‘ProxyHandler’, which is part of the normal handler chain
when a proxy setting is detected.  Normally that’s a good thing, but
there are occasions when it may not be helpful (1).  One way to do this
is to setup our own ‘ProxyHandler’, with no proxies defined.  This is
done using similar steps to setting up a Basic Authentication(2)
handler:

     >>> proxy_support = urllib2.ProxyHandler({})
     >>> opener = urllib2.build_opener(proxy_support)
     >>> urllib2.install_opener(opener)

     Note: Currently ‘urllib2’ _does not_ support fetching of ‘https’
     locations through a proxy.  However, this can be enabled by
     extending urllib2 as shown in the recipe (3).

   ---------- Footnotes ----------

   (1) In my case I have to use a proxy to access the internet at work.
If you attempt to fetch _localhost_ URLs through this proxy it blocks
them.  IE is set to use the proxy, which urllib2 picks up on.  In order
to test scripts with a localhost server, I have to prevent urllib2 from
using the proxy.

   (2) http://www.voidspace.org.uk/python/articles/authentication.shtml

   (3) urllib2 opener for SSL proxy (CONNECT method): ASPN Cookbook
Recipe (http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/456195).


File: python.info,  Node: Sockets and Layers,  Next: Footnotes,  Prev: Proxies,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.8 Sockets and Layers
--------------------------

The Python support for fetching resources from the web is layered.
urllib2 uses the httplib library, which in turn uses the socket library.

  As of Python 2.3 you can specify how long a socket should wait for a
response before timing out.  This can be useful in applications which
have to fetch web pages.  By default the socket module has _no timeout_
and can hang.  Currently, the socket timeout is not exposed at the
httplib or urllib2 levels.  However, you can set the default timeout
globally for all sockets using

     import socket
     import urllib2

     # timeout in seconds
     timeout = 10
     socket.setdefaulttimeout(timeout)

     # this call to urllib2.urlopen now uses the default timeout
     # we have set in the socket module
     req = urllib2.Request('http://www.voidspace.org.uk')
     response = urllib2.urlopen(req)

    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 


File: python.info,  Node: Footnotes,  Prev: Sockets and Layers,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.9 Footnotes
-----------------

This document was reviewed and revised by John Lee.


File: python.info,  Node: HOWTO Use Python in the web,  Next: Argparse Tutorial,  Prev: HOWTO Fetch Internet Resources Using urllib2,  Up: Python HOWTOs

10.14 HOWTO Use Python in the web
=================================

     Author: Marek Kubica

Abstract
........

This document shows how Python fits into the web.  It presents some ways
to integrate Python with a web server, and general practices useful for
developing web sites.

  Programming for the Web has become a hot topic since the rise of "Web
2.0", which focuses on user-generated content on web sites.  It has
always been possible to use Python for creating web sites, but it was a
rather tedious task.  Therefore, many frameworks and helper tools have
been created to assist developers in creating faster and more robust
sites.  This HOWTO describes some of the methods used to combine Python
with a web server to create dynamic content.  It is not meant as a
complete introduction, as this topic is far too broad to be covered in
one single document.  However, a short overview of the most popular
libraries is provided.

See also
........

While this HOWTO tries to give an overview of Python in the web, it
cannot always be as up to date as desired.  Web development in Python is
rapidly moving forward, so the wiki page on Web Programming(1) may be
more in sync with recent development.

* Menu:

* The Low-Level View:: 
* Step back; WSGI: Step back WSGI. 
* Model-View-Controller:: 
* Ingredients for Websites:: 
* Frameworks:: 

The Low-Level View

* Common Gateway Interface:: 
* mod_python:: 
* FastCGI and SCGI:: 
* mod_wsgi:: 

Common Gateway Interface

* Simple script for testing CGI:: 
* Setting up CGI on your own server:: 
* Common problems with CGI scripts:: 

FastCGI and SCGI

* Setting up FastCGI:: 

Step back: WSGI

* WSGI Servers:: 
* Case study; MoinMoin: Case study MoinMoin. 

Ingredients for Websites

* Templates:: 
* Data persistence:: 

Frameworks

* Some notable frameworks:: 

Some notable frameworks

* Django:: 
* TurboGears:: 
* Zope:: 
* Other notable frameworks:: 

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/WebProgramming


File: python.info,  Node: The Low-Level View,  Next: Step back WSGI,  Up: HOWTO Use Python in the web

10.14.1 The Low-Level View
--------------------------

When a user enters a web site, their browser makes a connection to the
site’s web server (this is called the _request_).  The server looks up
the file in the file system and sends it back to the user’s browser,
which displays it (this is the _response_).  This is roughly how the
underlying protocol, HTTP, works.

  Dynamic web sites are not based on files in the file system, but
rather on programs which are run by the web server when a request comes
in, and which _generate_ the content that is returned to the user.  They
can do all sorts of useful things, like display the postings of a
bulletin board, show your email, configure software, or just display the
current time.  These programs can be written in any programming language
the server supports.  Since most servers support Python, it is easy to
use Python to create dynamic web sites.

  Most HTTP servers are written in C or C++, so they cannot execute
Python code directly – a bridge is needed between the server and the
program.  These bridges, or rather interfaces, define how programs
interact with the server.  There have been numerous attempts to create
the best possible interface, but there are only a few worth mentioning.

  Not every web server supports every interface.  Many web servers only
support old, now-obsolete interfaces; however, they can often be
extended using third-party modules to support newer ones.

* Menu:

* Common Gateway Interface:: 
* mod_python:: 
* FastCGI and SCGI:: 
* mod_wsgi:: 

Common Gateway Interface

* Simple script for testing CGI:: 
* Setting up CGI on your own server:: 
* Common problems with CGI scripts:: 

FastCGI and SCGI

* Setting up FastCGI:: 


File: python.info,  Node: Common Gateway Interface,  Next: mod_python,  Up: The Low-Level View

10.14.1.1 Common Gateway Interface
..................................

This interface, most commonly referred to as "CGI", is the oldest, and
is supported by nearly every web server out of the box.  Programs using
CGI to communicate with their web server need to be started by the
server for every request.  So, every request starts a new Python
interpreter – which takes some time to start up – thus making the whole
interface only usable for low load situations.

  The upside of CGI is that it is simple – writing a Python program
which uses CGI is a matter of about three lines of code.  This
simplicity comes at a price: it does very few things to help the
developer.

  Writing CGI programs, while still possible, is no longer recommended.
With *note WSGI: 309c, a topic covered later in this document, it is
possible to write programs that emulate CGI, so they can be run as CGI
if no better option is available.

See also
........

The Python standard library includes some modules that are helpful for
creating plain CGI programs:

   * *note cgi: 5c. – Handling of user input in CGI scripts

   * *note cgitb: 5e. – Displays nice tracebacks when errors happen in
     CGI applications, instead of presenting a "500 Internal Server
     Error" message

  The Python wiki features a page on CGI scripts(1) with some additional
information about CGI in Python.

* Menu:

* Simple script for testing CGI:: 
* Setting up CGI on your own server:: 
* Common problems with CGI scripts:: 

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/CgiScripts


File: python.info,  Node: Simple script for testing CGI,  Next: Setting up CGI on your own server,  Up: Common Gateway Interface

10.14.1.2 Simple script for testing CGI
.......................................

To test whether your web server works with CGI, you can use this short
and simple CGI program:

     #!/usr/bin/env python
     # -*- coding: UTF-8 -*-

     # enable debugging
     import cgitb
     cgitb.enable()

     print "Content-Type: text/plain;charset=utf-8"
     print

     print "Hello World!"

  Depending on your web server configuration, you may need to save this
code with a ‘.py’ or ‘.cgi’ extension.  Additionally, this file may also
need to be in a ‘cgi-bin’ folder, for security reasons.

  You might wonder what the ‘cgitb’ line is about.  This line makes it
possible to display a nice traceback instead of just crashing and
displaying an "Internal Server Error" in the user’s browser.  This is
useful for debugging, but it might risk exposing some confidential data
to the user.  You should not use ‘cgitb’ in production code for this
reason.  You should _always_ catch exceptions, and display proper error
pages – end-users don’t like to see nondescript "Internal Server Errors"
in their browsers.


File: python.info,  Node: Setting up CGI on your own server,  Next: Common problems with CGI scripts,  Prev: Simple script for testing CGI,  Up: Common Gateway Interface

10.14.1.3 Setting up CGI on your own server
...........................................

If you don’t have your own web server, this does not apply to you.  You
can check whether it works as-is, and if not you will need to talk to
the administrator of your web server.  If it is a big host, you can try
filing a ticket asking for Python support.

  If you are your own administrator or want to set up CGI for testing
purposes on your own computers, you have to configure it by yourself.
There is no single way to configure CGI, as there are many web servers
with different configuration options.  Currently the most widely used
free web server is Apache HTTPd(1), or Apache for short.  Apache can be
easily installed on nearly every system using the system’s package
management tool.  lighttpd(2) is another alternative and is said to have
better performance.  On many systems this server can also be installed
using the package management tool, so manually compiling the web server
may not be needed.

   * On Apache you can take a look at the Dynamic Content with CGI(3)
     tutorial, where everything is described.  Most of the time it is
     enough just to set ‘+ExecCGI’.  The tutorial also describes the
     most common gotchas that might arise.

   * On lighttpd you need to use the CGI module(4), which can be
     configured in a straightforward way.  It boils down to setting
     ‘cgi.assign’ properly.

   ---------- Footnotes ----------

   (1) http://httpd.apache.org/

   (2) http://www.lighttpd.net

   (3) http://httpd.apache.org/docs/2.2/howto/cgi.html

   (4) http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModCGI


File: python.info,  Node: Common problems with CGI scripts,  Prev: Setting up CGI on your own server,  Up: Common Gateway Interface

10.14.1.4 Common problems with CGI scripts
..........................................

Using CGI sometimes leads to small annoyances while trying to get these
scripts to run.  Sometimes a seemingly correct script does not work as
expected, the cause being some small hidden problem that’s difficult to
spot.

  Some of these potential problems are:

   * The Python script is not marked as executable.  When CGI scripts
     are not executable most web servers will let the user download it,
     instead of running it and sending the output to the user.  For CGI
     scripts to run properly on Unix-like operating systems, the ‘+x’
     bit needs to be set.  Using ‘chmod a+x your_script.py’ may solve
     this problem.

   * On a Unix-like system, The line endings in the program file must be
     Unix style line endings.  This is important because the web server
     checks the first line of the script (called shebang) and tries to
     run the program specified there.  It gets easily confused by
     Windows line endings (Carriage Return & Line Feed, also called
     CRLF), so you have to convert the file to Unix line endings (only
     Line Feed, LF). This can be done automatically by uploading the
     file via FTP in text mode instead of binary mode, but the preferred
     way is just telling your editor to save the files with Unix line
     endings.  Most editors support this.

   * Your web server must be able to read the file, and you need to make
     sure the permissions are correct.  On unix-like systems, the server
     often runs as user and group ‘www-data’, so it might be worth a try
     to change the file ownership, or making the file world readable by
     using ‘chmod a+r your_script.py’.

   * The web server must know that the file you’re trying to access is a
     CGI script.  Check the configuration of your web server, as it may
     be configured to expect a specific file extension for CGI scripts.

   * On Unix-like systems, the path to the interpreter in the shebang
     (‘#!/usr/bin/env python’) must be correct.  This line calls
     ‘/usr/bin/env’ to find Python, but it will fail if there is no
     ‘/usr/bin/env’, or if Python is not in the web server’s path.  If
     you know where your Python is installed, you can also use that full
     path.  The commands ‘whereis python’ and ‘type -p python’ could
     help you find where it is installed.  Once you know the path, you
     can change the shebang accordingly: ‘#!/usr/bin/python’.

   * The file must not contain a BOM (Byte Order Mark).  The BOM is
     meant for determining the byte order of UTF-16 and UTF-32
     encodings, but some editors write this also into UTF-8 files.  The
     BOM interferes with the shebang line, so be sure to tell your
     editor not to write the BOM.

   * If the web server is using *note mod_python: 30a0, ‘mod_python’ may
     be having problems.  ‘mod_python’ is able to handle CGI scripts by
     itself, but it can also be a source of issues.


File: python.info,  Node: mod_python,  Next: FastCGI and SCGI,  Prev: Common Gateway Interface,  Up: The Low-Level View

10.14.1.5 mod_python
....................

People coming from PHP often find it hard to grasp how to use Python in
the web.  Their first thought is mostly mod_python(1), because they
think that this is the equivalent to ‘mod_php’.  Actually, there are
many differences.  What ‘mod_python’ does is embed the interpreter into
the Apache process, thus speeding up requests by not having to start a
Python interpreter for each request.  On the other hand, it is not
"Python intermixed with HTML" in the way that PHP is often intermixed
with HTML. The Python equivalent of that is a template engine.
‘mod_python’ itself is much more powerful and provides more access to
Apache internals.  It can emulate CGI, work in a "Python Server Pages"
mode (similar to JSP) which is "HTML intermingled with Python", and it
has a "Publisher" which designates one file to accept all requests and
decide what to do with them.

  ‘mod_python’ does have some problems.  Unlike the PHP interpreter, the
Python interpreter uses caching when executing files, so changes to a
file will require the web server to be restarted.  Another problem is
the basic concept – Apache starts child processes to handle the
requests, and unfortunately every child process needs to load the whole
Python interpreter even if it does not use it.  This makes the whole web
server slower.  Another problem is that, because ‘mod_python’ is linked
against a specific version of ‘libpython’, it is not possible to switch
from an older version to a newer (e.g.  2.4 to 2.5) without recompiling
‘mod_python’.  ‘mod_python’ is also bound to the Apache web server, so
programs written for ‘mod_python’ cannot easily run on other web
servers.

  These are the reasons why ‘mod_python’ should be avoided when writing
new programs.  In some circumstances it still might be a good idea to
use ‘mod_python’ for deployment, but WSGI makes it possible to run WSGI
programs under ‘mod_python’ as well.

   ---------- Footnotes ----------

   (1) http://www.modpython.org/


File: python.info,  Node: FastCGI and SCGI,  Next: mod_wsgi,  Prev: mod_python,  Up: The Low-Level View

10.14.1.6 FastCGI and SCGI
..........................

FastCGI and SCGI try to solve the performance problem of CGI in another
way.  Instead of embedding the interpreter into the web server, they
create long-running background processes.  There is still a module in
the web server which makes it possible for the web server to "speak"
with the background process.  As the background process is independent
of the server, it can be written in any language, including Python.  The
language just needs to have a library which handles the communication
with the webserver.

  The difference between FastCGI and SCGI is very small, as SCGI is
essentially just a "simpler FastCGI". As the web server support for SCGI
is limited, most people use FastCGI instead, which works the same way.
Almost everything that applies to SCGI also applies to FastCGI as well,
so we’ll only cover the latter.

  These days, FastCGI is never used directly.  Just like ‘mod_python’,
it is only used for the deployment of WSGI applications.

See also
........

   * FastCGI, SCGI, and Apache: Background and Future(1) is a discussion
     on why the concept of FastCGI and SCGI is better than that of
     mod_python.

* Menu:

* Setting up FastCGI:: 

   ---------- Footnotes ----------

   (1) 
http://www.vmunix.com/mark/blog/archives/2006/01/02/fastcgi-scgi-and-apache-background-and-future/


File: python.info,  Node: Setting up FastCGI,  Up: FastCGI and SCGI

10.14.1.7 Setting up FastCGI
............................

Each web server requires a specific module.

   * Apache has both mod_fastcgi(1) and mod_fcgid(2).  ‘mod_fastcgi’ is
     the original one, but it has some licensing issues, which is why it
     is sometimes considered non-free.  ‘mod_fcgid’ is a smaller,
     compatible alternative.  One of these modules needs to be loaded by
     Apache.

   * lighttpd ships its own FastCGI module(3) as well as an SCGI
     module(4).

   * nginx(5) also supports FastCGI(6).

  Once you have installed and configured the module, you can test it
with the following WSGI-application:

     #!/usr/bin/env python
     # -*- coding: UTF-8 -*-

     from cgi import escape
     import sys, os
     from flup.server.fcgi import WSGIServer

     def app(environ, start_response):
         start_response('200 OK', [('Content-Type', 'text/html')])

         yield '<h1>FastCGI Environment</h1>'
         yield '<table>'
         for k, v in sorted(environ.items()):
              yield '<tr><th>%s</th><td>%s</td></tr>' % (escape(k), escape(v))
         yield '</table>'

     WSGIServer(app).run()

  This is a simple WSGI application, but you need to install flup(7)
first, as flup handles the low level FastCGI access.

See also
........

There is some documentation on setting up Django with FastCGI(8), most
of which can be reused for other WSGI-compliant frameworks and
libraries.  Only the ‘manage.py’ part has to be changed, the example
used here can be used instead.  Django does more or less the exact same
thing.

   ---------- Footnotes ----------

   (1) http://www.fastcgi.com/drupal/

   (2) http://httpd.apache.org/mod_fcgid/

   (3) http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModFastCGI

   (4) http://redmine.lighttpd.net/wiki/lighttpd/Docs:ModSCGI

   (5) http://nginx.org/

   (6) http://wiki.nginx.org/NginxSimplePythonFCGI

   (7) http://pypi.python.org/pypi/flup/1.0

   (8) http://docs.djangoproject.com/en/dev/howto/deployment/fastcgi/


File: python.info,  Node: mod_wsgi,  Prev: FastCGI and SCGI,  Up: The Low-Level View

10.14.1.8 mod_wsgi
..................

mod_wsgi(1) is an attempt to get rid of the low level gateways.  Given
that FastCGI, SCGI, and mod_python are mostly used to deploy WSGI
applications, mod_wsgi was started to directly embed WSGI applications
into the Apache web server.  mod_wsgi is specifically designed to host
WSGI applications.  It makes the deployment of WSGI applications much
easier than deployment using other low level methods, which need glue
code.  The downside is that mod_wsgi is limited to the Apache web
server; other servers would need their own implementations of mod_wsgi.

  mod_wsgi supports two modes: embedded mode, in which it integrates
with the Apache process, and daemon mode, which is more FastCGI-like.
Unlike FastCGI, mod_wsgi handles the worker-processes by itself, which
makes administration easier.

   ---------- Footnotes ----------

   (1) http://code.google.com/p/modwsgi/


File: python.info,  Node: Step back WSGI,  Next: Model-View-Controller,  Prev: The Low-Level View,  Up: HOWTO Use Python in the web

10.14.2 Step back: WSGI
-----------------------

WSGI has already been mentioned several times, so it has to be something
important.  In fact it really is, and now it is time to explain it.

  The _Web Server Gateway Interface_, or WSGI for short, is defined in
PEP 333(1) and is currently the best way to do Python web programming.
While it is great for programmers writing frameworks, a normal web
developer does not need to get in direct contact with it.  When choosing
a framework for web development it is a good idea to choose one which
supports WSGI.

  The big benefit of WSGI is the unification of the application
programming interface.  When your program is compatible with WSGI –
which at the outer level means that the framework you are using has
support for WSGI – your program can be deployed via any web server
interface for which there are WSGI wrappers.  You do not need to care
about whether the application user uses mod_python or FastCGI or
mod_wsgi – with WSGI your application will work on any gateway
interface.  The Python standard library contains its own WSGI server,
*note wsgiref: 199, which is a small web server that can be used for
testing.

  A really great WSGI feature is middleware.  Middleware is a layer
around your program which can add various functionality to it.  There is
quite a bit of middleware(2) already available.  For example, instead of
writing your own session management (HTTP is a stateless protocol, so to
associate multiple HTTP requests with a single user your application
must create and manage such state via a session), you can just download
middleware which does that, plug it in, and get on with coding the
unique parts of your application.  The same thing with compression –
there is existing middleware which handles compressing your HTML using
gzip to save on your server’s bandwidth.  Authentication is another a
problem easily solved using existing middleware.

  Although WSGI may seem complex, the initial phase of learning can be
very rewarding because WSGI and the associated middleware already have
solutions to many problems that might arise while developing web sites.

* Menu:

* WSGI Servers:: 
* Case study; MoinMoin: Case study MoinMoin. 

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0333

   (2) http://www.wsgi.org/en/latest/libraries.html


File: python.info,  Node: WSGI Servers,  Next: Case study MoinMoin,  Up: Step back WSGI

10.14.2.1 WSGI Servers
......................

The code that is used to connect to various low level gateways like CGI
or mod_python is called a _WSGI server_.  One of these servers is
‘flup’, which supports FastCGI and SCGI, as well as AJP(1). Some of
these servers are written in Python, as ‘flup’ is, but there also exist
others which are written in C and can be used as drop-in replacements.

  There are many servers already available, so a Python web application
can be deployed nearly anywhere.  This is one big advantage that Python
has compared with other web technologies.

See also
........

A good overview of WSGI-related code can be found in the WSGI
homepage(2), which contains an extensive list of WSGI servers(3) which
can be used by _any_ application supporting WSGI.

  You might be interested in some WSGI-supporting modules already
contained in the standard library, namely:

   * *note wsgiref: 199. – some tiny utilities and servers for WSGI

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Apache_JServ_Protocol

   (2) http://www.wsgi.org/en/latest/index.html

   (3) http://www.wsgi.org/en/latest/servers.html


File: python.info,  Node: Case study MoinMoin,  Prev: WSGI Servers,  Up: Step back WSGI

10.14.2.2 Case study: MoinMoin
..............................

What does WSGI give the web application developer?  Let’s take a look at
an application that’s been around for a while, which was written in
Python without using WSGI.

  One of the most widely used wiki software packages is MoinMoin(1).  It
was created in 2000, so it predates WSGI by about three years.  Older
versions needed separate code to run on CGI, mod_python, FastCGI and
standalone.

  It now includes support for WSGI. Using WSGI, it is possible to deploy
MoinMoin on any WSGI compliant server, with no additional glue code.
Unlike the pre-WSGI versions, this could include WSGI servers that the
authors of MoinMoin know nothing about.

   ---------- Footnotes ----------

   (1) http://moinmo.in/


File: python.info,  Node: Model-View-Controller,  Next: Ingredients for Websites,  Prev: Step back WSGI,  Up: HOWTO Use Python in the web

10.14.3 Model-View-Controller
-----------------------------

The term _MVC_ is often encountered in statements such as "framework
_foo_ supports MVC". MVC is more about the overall organization of code,
rather than any particular API. Many web frameworks use this model to
help the developer bring structure to their program.  Bigger web
applications can have lots of code, so it is a good idea to have an
effective structure right from the beginning.  That way, even users of
other frameworks (or even other languages, since MVC is not
Python-specific) can easily understand the code, given that they are
already familiar with the MVC structure.

  MVC stands for three components:

   * The _model_.  This is the data that will be displayed and modified.
     In Python frameworks, this component is often represented by the
     classes used by an object-relational mapper.

   * The _view_.  This component’s job is to display the data of the
     model to the user.  Typically this component is implemented via
     templates.

   * The _controller_.  This is the layer between the user and the
     model.  The controller reacts to user actions (like opening some
     specific URL), tells the model to modify the data if necessary, and
     tells the view code what to display,

  While one might think that MVC is a complex design pattern, in fact it
is not.  It is used in Python because it has turned out to be useful for
creating clean, maintainable web sites.

     Note: While not all Python frameworks explicitly support MVC, it is
     often trivial to create a web site which uses the MVC pattern by
     separating the data logic (the model) from the user interaction
     logic (the controller) and the templates (the view).  That’s why it
     is important not to write unnecessary Python code in the templates
     – it works against the MVC model and creates chaos in the code
     base, making it harder to understand and modify.

See also
........

The English Wikipedia has an article about the Model-View-Controller
pattern(1).  It includes a long list of web frameworks for various
programming languages.

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Model-view-controller


File: python.info,  Node: Ingredients for Websites,  Next: Frameworks,  Prev: Model-View-Controller,  Up: HOWTO Use Python in the web

10.14.4 Ingredients for Websites
--------------------------------

Websites are complex constructs, so tools have been created to help web
developers make their code easier to write and more maintainable.  Tools
like these exist for all web frameworks in all languages.  Developers
are not forced to use these tools, and often there is no "best" tool.
It is worth learning about the available tools because they can greatly
simplify the process of developing a web site.

See also
........

There are far more components than can be presented here.  The Python
wiki has a page about these components, called Web Components(1).

* Menu:

* Templates:: 
* Data persistence:: 

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/WebComponents


File: python.info,  Node: Templates,  Next: Data persistence,  Up: Ingredients for Websites

10.14.4.1 Templates
...................

Mixing of HTML and Python code is made possible by a few libraries.
While convenient at first, it leads to horribly unmaintainable code.
That’s why templates exist.  Templates are, in the simplest case, just
HTML files with placeholders.  The HTML is sent to the user’s browser
after filling in the placeholders.

  Python already includes two ways to build simple templates:

     >>> template = "<html><body><h1>Hello %s!</h1></body></html>"
     >>> print template % "Reader"
     <html><body><h1>Hello Reader!</h1></body></html>

     >>> from string import Template
     >>> template = Template("<html><body><h1>Hello ${name}</h1></body></html>")
     >>> print template.substitute(dict(name='Dinsdale'))
     <html><body><h1>Hello Dinsdale!</h1></body></html>

  To generate complex HTML based on non-trivial model data, conditional
and looping constructs like Python’s _for_ and _if_ are generally
needed.  _Template engines_ support templates of this complexity.

  There are a lot of template engines available for Python which can be
used with or without a *note framework: 30ab.  Some of these define a
plain-text programming language which is easy to learn, partly because
it is limited in scope.  Others use XML, and the template output is
guaranteed to be always be valid XML. There are many other variations.

  Some *note frameworks: 30ac. ship their own template engine or
recommend one in particular.  In the absence of a reason to use a
different template engine, using the one provided by or recommended by
the framework is a good idea.

  Popular template engines include:

        * Mako(1)

        * Genshi(2)

        * Jinja(3)

See also
........

There are many template engines competing for attention, because it is
pretty easy to create them in Python.  The page Templating(4) in the
wiki lists a big, ever-growing number of these.  The three listed above
are considered "second generation" template engines and are a good place
to start.

   ---------- Footnotes ----------

   (1) http://www.makotemplates.org/

   (2) http://genshi.edgewall.org/

   (3) http://jinja.pocoo.org/2/

   (4) http://wiki.python.org/moin/Templating


File: python.info,  Node: Data persistence,  Prev: Templates,  Up: Ingredients for Websites

10.14.4.2 Data persistence
..........................

_Data persistence_, while sounding very complicated, is just about
storing data.  This data might be the text of blog entries, the postings
on a bulletin board or the text of a wiki page.  There are, of course, a
number of different ways to store information on a web server.

  Often, relational database engines like MySQL(1) or PostgreSQL(2) are
used because of their good performance when handling very large
databases consisting of millions of entries.  There is also a small
database engine called SQLite(3), which is bundled with Python in the
*note sqlite3: 15f. module, and which uses only one file.  It has no
other dependencies.  For smaller sites SQLite is just enough.

  Relational databases are _queried_ using a language called SQL(4).
Python programmers in general do not like SQL too much, as they prefer
to work with objects.  It is possible to save Python objects into a
database using a technology called ORM(5) (Object Relational Mapping).
ORM translates all object-oriented access into SQL code under the hood,
so the developer does not need to think about it.  Most *note
frameworks: 30ac. use ORMs, and it works quite well.

  A second possibility is storing data in normal, plain text files (some
times called "flat files").  This is very easy for simple sites, but can
be difficult to get right if the web site is performing many updates to
the stored data.

  A third possibility are object oriented databases (also called "object
databases").  These databases store the object data in a form that
closely parallels the way the objects are structured in memory during
program execution.  (By contrast, ORMs store the object data as rows of
data in tables and relations between those rows.)  Storing the objects
directly has the advantage that nearly all objects can be saved in a
straightforward way, unlike in relational databases where some objects
are very hard to represent.

  *note Frameworks: 30ac. often give hints on which data storage method
to choose.  It is usually a good idea to stick to the data store
recommended by the framework unless the application has special
requirements better satisfied by an alternate storage mechanism.

See also
........

   * Persistence Tools(6) lists possibilities on how to save data in the
     file system.  Some of these modules are part of the standard
     library

   * Database Programming(7) helps with choosing a method for saving
     data

   * SQLAlchemy(8), the most powerful OR-Mapper for Python, and
     Elixir(9), which makes SQLAlchemy easier to use

   * SQLObject(10), another popular OR-Mapper

   * ZODB(11) and Durus(12), two object oriented databases

   ---------- Footnotes ----------

   (1) http://www.mysql.com/

   (2) http://www.postgresql.org/

   (3) http://www.sqlite.org/

   (4) http://en.wikipedia.org/wiki/SQL

   (5) http://en.wikipedia.org/wiki/Object-relational_mapping

   (6) http://wiki.python.org/moin/PersistenceTools

   (7) http://wiki.python.org/moin/DatabaseProgramming

   (8) http://www.sqlalchemy.org/

   (9) http://elixir.ematia.de/

   (10) http://www.sqlobject.org/

   (11) https://launchpad.net/zodb

   (12) http://www.mems-exchange.org/software/durus/


File: python.info,  Node: Frameworks,  Prev: Ingredients for Websites,  Up: HOWTO Use Python in the web

10.14.5 Frameworks
------------------

The process of creating code to run web sites involves writing code to
provide various services.  The code to provide a particular service
often works the same way regardless of the complexity or purpose of the
web site in question.  Abstracting these common solutions into reusable
code produces what are called "frameworks" for web development.  Perhaps
the most well-known framework for web development is Ruby on Rails, but
Python has its own frameworks.  Some of these were partly inspired by
Rails, or borrowed ideas from Rails, but many existed a long time before
Rails.

  Originally Python web frameworks tended to incorporate all of the
services needed to develop web sites as a giant, integrated set of
tools.  No two web frameworks were interoperable: a program developed
for one could not be deployed on a different one without considerable
re-engineering work.  This led to the development of "minimalist" web
frameworks that provided just the tools to communicate between the
Python code and the http protocol, with all other services to be added
on top via separate components.  Some ad hoc standards were developed
that allowed for limited interoperability between frameworks, such as a
standard that allowed different template engines to be used
interchangeably.

  Since the advent of WSGI, the Python web framework world has been
evolving toward interoperability based on the WSGI standard.  Now many
web frameworks, whether "full stack" (providing all the tools one needs
to deploy the most complex web sites) or minimalist, or anything in
between, are built from collections of reusable components that can be
used with more than one framework.

  The majority of users will probably want to select a "full stack"
framework that has an active community.  These frameworks tend to be
well documented, and provide the easiest path to producing a fully
functional web site in minimal time.

* Menu:

* Some notable frameworks:: 

Some notable frameworks

* Django:: 
* TurboGears:: 
* Zope:: 
* Other notable frameworks:: 


File: python.info,  Node: Some notable frameworks,  Up: Frameworks

10.14.5.1 Some notable frameworks
.................................

There are an incredible number of frameworks, so they cannot all be
covered here.  Instead we will briefly touch on some of the most
popular.

* Menu:

* Django:: 
* TurboGears:: 
* Zope:: 
* Other notable frameworks:: 


File: python.info,  Node: Django,  Next: TurboGears,  Up: Some notable frameworks

10.14.5.2 Django
................

Django(1) is a framework consisting of several tightly coupled elements
which were written from scratch and work together very well.  It
includes an ORM which is quite powerful while being simple to use, and
has a great online administration interface which makes it possible to
edit the data in the database with a browser.  The template engine is
text-based and is designed to be usable for page designers who cannot
write Python.  It supports template inheritance and filters (which work
like Unix pipes).  Django has many handy features bundled, such as
creation of RSS feeds or generic views, which make it possible to create
web sites almost without writing any Python code.

  It has a big, international community, the members of which have
created many web sites.  There are also a lot of add-on projects which
extend Django’s normal functionality.  This is partly due to Django’s
well written online documentation(2) and the Django book(3).

     Note: Although Django is an MVC-style framework, it names the
     elements differently, which is described in the Django FAQ(4).

   ---------- Footnotes ----------

   (1) http://www.djangoproject.com/

   (2) http://docs.djangoproject.com/

   (3) http://www.djangobook.com/

   (4) 
http://docs.djangoproject.com/en/dev/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names


File: python.info,  Node: TurboGears,  Next: Zope,  Prev: Django,  Up: Some notable frameworks

10.14.5.3 TurboGears
....................

Another popular web framework for Python is TurboGears(1).  TurboGears
takes the approach of using already existing components and combining
them with glue code to create a seamless experience.  TurboGears gives
the user flexibility in choosing components.  For example the ORM and
template engine can be changed to use packages different from those used
by default.

  The documentation can be found in the TurboGears wiki(2), where links
to screencasts can be found.  TurboGears has also an active user
community which can respond to most related questions.  There is also a
TurboGears book(3) published, which is a good starting point.

  The newest version of TurboGears, version 2.0, moves even further in
direction of WSGI support and a component-based architecture.
TurboGears 2 is based on the WSGI stack of another popular
component-based web framework, Pylons(4).

   ---------- Footnotes ----------

   (1) http://www.turbogears.org/

   (2) http://docs.turbogears.org/

   (3) http://turbogearsbook.com/

   (4) http://www.pylonsproject.org/


File: python.info,  Node: Zope,  Next: Other notable frameworks,  Prev: TurboGears,  Up: Some notable frameworks

10.14.5.4 Zope
..............

The Zope framework is one of the "old original" frameworks.  Its current
incarnation in Zope2 is a tightly integrated full-stack framework.  One
of its most interesting feature is its tight integration with a powerful
object database called the ZODB(1) (Zope Object Database).  Because of
its highly integrated nature, Zope wound up in a somewhat isolated
ecosystem: code written for Zope wasn’t very usable outside of Zope, and
vice-versa.  To solve this problem the Zope 3 effort was started.  Zope
3 re-engineers Zope as a set of more cleanly isolated components.  This
effort was started before the advent of the WSGI standard, but there is
WSGI support for Zope 3 from the Repoze(2) project.  Zope components
have many years of production use behind them, and the Zope 3 project
gives access to these components to the wider Python community.  There
is even a separate framework based on the Zope components: Grok(3).

  Zope is also the infrastructure used by the Plone(4) content
management system, one of the most powerful and popular content
management systems available.

   ---------- Footnotes ----------

   (1) https://launchpad.net/zodb

   (2) http://repoze.org/

   (3) http://grok.zope.org/

   (4) http://plone.org/


File: python.info,  Node: Other notable frameworks,  Prev: Zope,  Up: Some notable frameworks

10.14.5.5 Other notable frameworks
..................................

Of course these are not the only frameworks that are available.  There
are many other frameworks worth mentioning.

  Another framework that’s already been mentioned is Pylons(1).  Pylons
is much like TurboGears, but with an even stronger emphasis on
flexibility, which comes at the cost of being more difficult to use.
Nearly every component can be exchanged, which makes it necessary to use
the documentation of every single component, of which there are many.
Pylons builds upon Paste(2), an extensive set of tools which are handy
for WSGI.

  And that’s still not everything.  The most up-to-date information can
always be found in the Python wiki.

See also
........

The Python wiki contains an extensive list of web frameworks(3).

  Most frameworks also have their own mailing lists and IRC channels,
look out for these on the projects’ web sites.  There is also a general
"Python in the Web" IRC channel on freenode called #python.web(4).

   ---------- Footnotes ----------

   (1) http://www.pylonsproject.org/

   (2) http://pythonpaste.org/

   (3) http://wiki.python.org/moin/WebFrameworks

   (4) http://wiki.python.org/moin/PoundPythonWeb


File: python.info,  Node: Argparse Tutorial,  Prev: HOWTO Use Python in the web,  Up: Python HOWTOs

10.15 Argparse Tutorial
=======================

     author: Tshepang Lekhonkhobe
  This tutorial is intended to be a gentle introduction to *note
argparse: d, the recommended command-line parsing module in the Python
standard library.

     Note: There are two other modules that fulfill the same task,
     namely *note getopt: de. (an equivalent for ‘getopt()’ from the C
     language) and the deprecated *note optparse: 127.  Note also that
     *note argparse: d. is based on *note optparse: 127, and therefore
     very similar in terms of usage.

* Menu:

* Concepts:: 
* The basics:: 
* Introducing Positional arguments:: 
* Introducing Optional arguments:: 
* Combining Positional and Optional arguments:: 
* Getting a little more advanced:: 
* Conclusion:: 


File: python.info,  Node: Concepts,  Next: The basics,  Up: Argparse Tutorial

10.15.1 Concepts
----------------

Let’s show the sort of functionality that we are going to explore in
this introductory tutorial by making use of the *ls* command:

     $ ls
     cpython  devguide  prog.py  pypy  rm-unused-function.patch
     $ ls pypy
     ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...
     $ ls -l
     total 20
     drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython
     drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide
     -rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py
     drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy
     -rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch
     $ ls --help
     Usage: ls [OPTION]... [FILE]...
     List information about the FILEs (the current directory by default).
     Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
     ...

  A few concepts we can learn from the four commands:

   * The *ls* command is useful when run without any options at all.  It
     defaults to displaying the contents of the current directory.

   * If we want beyond what it provides by default, we tell it a bit
     more.  In this case, we want it to display a different directory,
     ‘pypy’.  What we did is specify what is known as a positional
     argument.  It’s named so because the program should know what to do
     with the value, solely based on where it appears on the command
     line.  This concept is more relevant to a command like *cp*, whose
     most basic usage is ‘cp SRC DEST’.  The first position is _what you
     want copied,_ and the second position is _where you want it copied
     to_.

   * Now, say we want to change behaviour of the program.  In our
     example, we display more info for each file instead of just showing
     the file names.  The ‘-l’ in that case is known as an optional
     argument.

   * That’s a snippet of the help text.  It’s very useful in that you
     can come across a program you have never used before, and can
     figure out how it works simply by reading its help text.


File: python.info,  Node: The basics,  Next: Introducing Positional arguments,  Prev: Concepts,  Up: Argparse Tutorial

10.15.2 The basics
------------------

Let us start with a very simple example which does (almost) nothing:

     import argparse
     parser = argparse.ArgumentParser()
     parser.parse_args()

  Following is a result of running the code:

     $ python prog.py
     $ python prog.py --help
     usage: prog.py [-h]

     optional arguments:
       -h, --help  show this help message and exit
     $ python prog.py --verbose
     usage: prog.py [-h]
     prog.py: error: unrecognized arguments: --verbose
     $ python prog.py foo
     usage: prog.py [-h]
     prog.py: error: unrecognized arguments: foo

  Here is what is happening:

   * Running the script without any options results in nothing displayed
     to stdout.  Not so useful.

   * The second one starts to display the usefulness of the *note
     argparse: d. module.  We have done almost nothing, but already we
     get a nice help message.

   * The ‘--help’ option, which can also be shortened to ‘-h’, is the
     only option we get for free (i.e.  no need to specify it).
     Specifying anything else results in an error.  But even then, we do
     get a useful usage message, also for free.


File: python.info,  Node: Introducing Positional arguments,  Next: Introducing Optional arguments,  Prev: The basics,  Up: Argparse Tutorial

10.15.3 Introducing Positional arguments
----------------------------------------

An example:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("echo")
     args = parser.parse_args()
     print args.echo

  And running the code:

     $ python prog.py
     usage: prog.py [-h] echo
     prog.py: error: the following arguments are required: echo
     $ python prog.py --help
     usage: prog.py [-h] echo

     positional arguments:
       echo

     optional arguments:
       -h, --help  show this help message and exit
     $ python prog.py foo
     foo

  Here is what’s happening:

   * We’ve added the ‘add_argument()’ method, which is what we use to
     specify which command-line options the program is willing to
     accept.  In this case, I’ve named it ‘echo’ so that it’s in line
     with its function.

   * Calling our program now requires us to specify an option.

   * The ‘parse_args()’ method actually returns some data from the
     options specified, in this case, ‘echo’.

   * The variable is some form of ’magic’ that *note argparse: d.
     performs for free (i.e.  no need to specify which variable that
     value is stored in).  You will also notice that its name matches
     the string argument given to the method, ‘echo’.

  Note however that, although the help display looks nice and all, it
currently is not as helpful as it can be.  For example we see that we
got ‘echo’ as a positional argument, but we don’t know what it does,
other than by guessing or by reading the source code.  So, let’s make it
a bit more useful:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("echo", help="echo the string you use here")
     args = parser.parse_args()
     print args.echo

  And we get:

     $ python prog.py -h
     usage: prog.py [-h] echo

     positional arguments:
       echo        echo the string you use here

     optional arguments:
       -h, --help  show this help message and exit

  Now, how about doing something even more useful:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", help="display a square of a given number")
     args = parser.parse_args()
     print args.square**2

  Following is a result of running the code:

     $ python prog.py 4
     Traceback (most recent call last):
       File "prog.py", line 5, in <module>
         print args.square**2
     TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

  That didn’t go so well.  That’s because *note argparse: d. treats the
options we give it as strings, unless we tell it otherwise.  So, let’s
tell *note argparse: d. to treat that input as an integer:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", help="display a square of a given number",
                         type=int)
     args = parser.parse_args()
     print args.square**2

  Following is a result of running the code:

     $ python prog.py 4
     16
     $ python prog.py four
     usage: prog.py [-h] square
     prog.py: error: argument square: invalid int value: 'four'

  That went well.  The program now even helpfully quits on bad illegal
input before proceeding.


File: python.info,  Node: Introducing Optional arguments,  Next: Combining Positional and Optional arguments,  Prev: Introducing Positional arguments,  Up: Argparse Tutorial

10.15.4 Introducing Optional arguments
--------------------------------------

So far we, have been playing with positional arguments.  Let us have a
look on how to add optional ones:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("--verbosity", help="increase output verbosity")
     args = parser.parse_args()
     if args.verbosity:
         print "verbosity turned on"

  And the output:

     $ python prog.py --verbosity 1
     verbosity turned on
     $ python prog.py
     $ python prog.py --help
     usage: prog.py [-h] [--verbosity VERBOSITY]

     optional arguments:
       -h, --help            show this help message and exit
       --verbosity VERBOSITY
                             increase output verbosity
     $ python prog.py --verbosity
     usage: prog.py [-h] [--verbosity VERBOSITY]
     prog.py: error: argument --verbosity: expected one argument

  Here is what is happening:

   * The program is written so as to display something when
     ‘--verbosity’ is specified and display nothing when not.

   * To show that the option is actually optional, there is no error
     when running the program without it.  Note that by default, if an
     optional argument isn’t used, the relevant variable, in this case
     ‘args.verbosity’, is given ‘None’ as a value, which is the reason
     it fails the truth test of the *note if: 42c. statement.

   * The help message is a bit different.

   * When using the ‘--verbosity’ option, one must also specify some
     value, any value.

  The above example accepts arbitrary integer values for ‘--verbosity’,
but for our simple program, only two values are actually useful, ‘True’
or ‘False’.  Let’s modify the code accordingly:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("--verbose", help="increase output verbosity",
                         action="store_true")
     args = parser.parse_args()
     if args.verbose:
        print "verbosity turned on"

  And the output:

     $ python prog.py --verbose
     verbosity turned on
     $ python prog.py --verbose 1
     usage: prog.py [-h] [--verbose]
     prog.py: error: unrecognized arguments: 1
     $ python prog.py --help
     usage: prog.py [-h] [--verbose]

     optional arguments:
       -h, --help  show this help message and exit
       --verbose   increase output verbosity

  Here is what is happening:

   * The option is now more of a flag than something that requires a
     value.  We even changed the name of the option to match that idea.
     Note that we now specify a new keyword, ‘action’, and give it the
     value ‘"store_true"’.  This means that, if the option is specified,
     assign the value ‘True’ to ‘args.verbose’.  Not specifying it
     implies ‘False’.

   * It complains when you specify a value, in true spirit of what flags
     actually are.

   * Notice the different help text.

* Menu:

* Short options:: 


File: python.info,  Node: Short options,  Up: Introducing Optional arguments

10.15.4.1 Short options
.......................

If you are familiar with command line usage, you will notice that I
haven’t yet touched on the topic of short versions of the options.  It’s
quite simple:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("-v", "--verbose", help="increase output verbosity",
                         action="store_true")
     args = parser.parse_args()
     if args.verbose:
         print "verbosity turned on"

  And here goes:

     $ python prog.py -v
     verbosity turned on
     $ python prog.py --help
     usage: prog.py [-h] [-v]

     optional arguments:
       -h, --help     show this help message and exit
       -v, --verbose  increase output verbosity

  Note that the new ability is also reflected in the help text.


File: python.info,  Node: Combining Positional and Optional arguments,  Next: Getting a little more advanced,  Prev: Introducing Optional arguments,  Up: Argparse Tutorial

10.15.5 Combining Positional and Optional arguments
---------------------------------------------------

Our program keeps growing in complexity:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display a square of a given number")
     parser.add_argument("-v", "--verbose", action="store_true",
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2
     if args.verbose:
         print "the square of {} equals {}".format(args.square, answer)
     else:
         print answer

  And now the output:

     $ python prog.py
     usage: prog.py [-h] [-v] square
     prog.py: error: the following arguments are required: square
     $ python prog.py 4
     16
     $ python prog.py 4 --verbose
     the square of 4 equals 16
     $ python prog.py --verbose 4
     the square of 4 equals 16

   * We’ve brought back a positional argument, hence the complaint.

   * Note that the order does not matter.

  How about we give this program of ours back the ability to have
multiple verbosity values, and actually get to use them:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display a square of a given number")
     parser.add_argument("-v", "--verbosity", type=int,
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2
     if args.verbosity == 2:
         print "the square of {} equals {}".format(args.square, answer)
     elif args.verbosity == 1:
         print "{}^2 == {}".format(args.square, answer)
     else:
         print answer

  And the output:

     $ python prog.py 4
     16
     $ python prog.py 4 -v
     usage: prog.py [-h] [-v VERBOSITY] square
     prog.py: error: argument -v/--verbosity: expected one argument
     $ python prog.py 4 -v 1
     4^2 == 16
     $ python prog.py 4 -v 2
     the square of 4 equals 16
     $ python prog.py 4 -v 3
     16

  These all look good except the last one, which exposes a bug in our
program.  Let’s fix it by restricting the values the ‘--verbosity’
option can accept:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display a square of a given number")
     parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2],
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2
     if args.verbosity == 2:
         print "the square of {} equals {}".format(args.square, answer)
     elif args.verbosity == 1:
         print "{}^2 == {}".format(args.square, answer)
     else:
         print answer

  And the output:

     $ python prog.py 4 -v 3
     usage: prog.py [-h] [-v {0,1,2}] square
     prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from 0, 1, 2)
     $ python prog.py 4 -h
     usage: prog.py [-h] [-v {0,1,2}] square

     positional arguments:
       square                display a square of a given number

     optional arguments:
       -h, --help            show this help message and exit
       -v {0,1,2}, --verbosity {0,1,2}
                             increase output verbosity

  Note that the change also reflects both in the error message as well
as the help string.

  Now, let’s use a different approach of playing with verbosity, which
is pretty common.  It also matches the way the CPython executable
handles its own verbosity argument (check the output of ‘python
--help’):

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display the square of a given number")
     parser.add_argument("-v", "--verbosity", action="count",
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2
     if args.verbosity == 2:
         print "the square of {} equals {}".format(args.square, answer)
     elif args.verbosity == 1:
         print "{}^2 == {}".format(args.square, answer)
     else:
         print answer

  We have introduced another action, "count", to count the number of
occurrences of a specific optional arguments:

     $ python prog.py 4
     16
     $ python prog.py 4 -v
     4^2 == 16
     $ python prog.py 4 -vv
     the square of 4 equals 16
     $ python prog.py 4 --verbosity --verbosity
     the square of 4 equals 16
     $ python prog.py 4 -v 1
     usage: prog.py [-h] [-v] square
     prog.py: error: unrecognized arguments: 1
     $ python prog.py 4 -h
     usage: prog.py [-h] [-v] square

     positional arguments:
       square           display a square of a given number

     optional arguments:
       -h, --help       show this help message and exit
       -v, --verbosity  increase output verbosity
     $ python prog.py 4 -vvv
     16

   * Yes, it’s now more of a flag (similar to ‘action="store_true"’) in
     the previous version of our script.  That should explain the
     complaint.

   * It also behaves similar to "store_true" action.

   * Now here’s a demonstration of what the "count" action gives.
     You’ve probably seen this sort of usage before.

   * And, just like the "store_true" action, if you don’t specify the
     ‘-v’ flag, that flag is considered to have ‘None’ value.

   * As should be expected, specifying the long form of the flag, we
     should get the same output.

   * Sadly, our help output isn’t very informative on the new ability
     our script has acquired, but that can always be fixed by improving
     the documentation for out script (e.g.  via the ‘help’ keyword
     argument).

   * That last output exposes a bug in our program.

  Let’s fix:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display a square of a given number")
     parser.add_argument("-v", "--verbosity", action="count",
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2

     # bugfix: replace == with >=
     if args.verbosity >= 2:
         print "the square of {} equals {}".format(args.square, answer)
     elif args.verbosity >= 1:
         print "{}^2 == {}".format(args.square, answer)
     else:
         print answer

  And this is what it gives:

     $ python prog.py 4 -vvv
     the square of 4 equals 16
     $ python prog.py 4 -vvvv
     the square of 4 equals 16
     $ python prog.py 4
     Traceback (most recent call last):
       File "prog.py", line 11, in <module>
         if args.verbosity >= 2:
     TypeError: unorderable types: NoneType() >= int()

   * First output went well, and fixes the bug we had before.  That is,
     we want any value >= 2 to be as verbose as possible.

   * Third output not so good.

  Let’s fix that bug:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("square", type=int,
                         help="display a square of a given number")
     parser.add_argument("-v", "--verbosity", action="count", default=0,
                         help="increase output verbosity")
     args = parser.parse_args()
     answer = args.square**2
     if args.verbosity >= 2:
         print "the square of {} equals {}".format(args.square, answer)
     elif args.verbosity >= 1:
         print "{}^2 == {}".format(args.square, answer)
     else:
         print answer

  We’ve just introduced yet another keyword, ‘default’.  We’ve set it to
‘0’ in order to make it comparable to the other int values.  Remember
that by default, if an optional argument isn’t specified, it gets the
‘None’ value, and that cannot be compared to an int value (hence the
*note TypeError: 218. exception).

  And:

     $ python prog.py 4
     16

  You can go quite far just with what we’ve learned so far, and we have
only scratched the surface.  The *note argparse: d. module is very
powerful, and we’ll explore a bit more of it before we end this
tutorial.


File: python.info,  Node: Getting a little more advanced,  Next: Conclusion,  Prev: Combining Positional and Optional arguments,  Up: Argparse Tutorial

10.15.6 Getting a little more advanced
--------------------------------------

What if we wanted to expand our tiny program to perform other powers,
not just squares:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("x", type=int, help="the base")
     parser.add_argument("y", type=int, help="the exponent")
     parser.add_argument("-v", "--verbosity", action="count", default=0)
     args = parser.parse_args()
     answer = args.x**args.y
     if args.verbosity >= 2:
         print "{} to the power {} equals {}".format(args.x, args.y, answer)
     elif args.verbosity >= 1:
         print "{}^{} == {}".format(args.x, args.y, answer)
     else:
         print answer

  Output:

     $ python prog.py
     usage: prog.py [-h] [-v] x y
     prog.py: error: the following arguments are required: x, y
     $ python prog.py -h
     usage: prog.py [-h] [-v] x y

     positional arguments:
       x                the base
       y                the exponent

     optional arguments:
       -h, --help       show this help message and exit
       -v, --verbosity
     $ python prog.py 4 2 -v
     4^2 == 16

  Notice that so far we’ve been using verbosity level to _change_ the
text that gets displayed.  The following example instead uses verbosity
level to display _more_ text instead:

     import argparse
     parser = argparse.ArgumentParser()
     parser.add_argument("x", type=int, help="the base")
     parser.add_argument("y", type=int, help="the exponent")
     parser.add_argument("-v", "--verbosity", action="count", default=0)
     args = parser.parse_args()
     answer = args.x**args.y
     if args.verbosity >= 2:
         print "Running '{}'".format(__file__)
     if args.verbosity >= 1:
         print "{}^{} ==".format(args.x, args.y),
     print answer

  Output:

     $ python prog.py 4 2
     16
     $ python prog.py 4 2 -v
     4^2 == 16
     $ python prog.py 4 2 -vv
     Running 'prog.py'
     4^2 == 16

* Menu:

* Conflicting options:: 


File: python.info,  Node: Conflicting options,  Up: Getting a little more advanced

10.15.6.1 Conflicting options
.............................

So far, we have been working with two methods of an *note
argparse.ArgumentParser: 1200. instance.  Let’s introduce a third one,
‘add_mutually_exclusive_group()’.  It allows for us to specify options
that conflict with each other.  Let’s also change the rest of the
program so that the new functionality makes more sense: we’ll introduce
the ‘--quiet’ option, which will be the opposite of the ‘--verbose’ one:

     import argparse

     parser = argparse.ArgumentParser()
     group = parser.add_mutually_exclusive_group()
     group.add_argument("-v", "--verbose", action="store_true")
     group.add_argument("-q", "--quiet", action="store_true")
     parser.add_argument("x", type=int, help="the base")
     parser.add_argument("y", type=int, help="the exponent")
     args = parser.parse_args()
     answer = args.x**args.y

     if args.quiet:
         print answer
     elif args.verbose:
         print "{} to the power {} equals {}".format(args.x, args.y, answer)
     else:
         print "{}^{} == {}".format(args.x, args.y, answer)

  Our program is now simpler, and we’ve lost some functionality for the
sake of demonstration.  Anyways, here’s the output:

     $ python prog.py 4 2
     4^2 == 16
     $ python prog.py 4 2 -q
     16
     $ python prog.py 4 2 -v
     4 to the power 2 equals 16
     $ python prog.py 4 2 -vq
     usage: prog.py [-h] [-v | -q] x y
     prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
     $ python prog.py 4 2 -v --quiet
     usage: prog.py [-h] [-v | -q] x y
     prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose

  That should be easy to follow.  I’ve added that last output so you can
see the sort of flexibility you get, i.e.  mixing long form options with
short form ones.

  Before we conclude, you probably want to tell your users the main
purpose of your program, just in case they don’t know:

     import argparse

     parser = argparse.ArgumentParser(description="calculate X to the power of Y")
     group = parser.add_mutually_exclusive_group()
     group.add_argument("-v", "--verbose", action="store_true")
     group.add_argument("-q", "--quiet", action="store_true")
     parser.add_argument("x", type=int, help="the base")
     parser.add_argument("y", type=int, help="the exponent")
     args = parser.parse_args()
     answer = args.x**args.y

     if args.quiet:
         print answer
     elif args.verbose:
         print "{} to the power {} equals {}".format(args.x, args.y, answer)
     else:
         print "{}^{} == {}".format(args.x, args.y, answer)

  Note that slight difference in the usage text.  Note the ‘[-v | -q]’,
which tells us that we can either use ‘-v’ or ‘-q’, but not both at the
same time:

     $ python prog.py --help
     usage: prog.py [-h] [-v | -q] x y

     calculate X to the power of Y

     positional arguments:
       x              the base
       y              the exponent

     optional arguments:
       -h, --help     show this help message and exit
       -v, --verbose
       -q, --quiet


File: python.info,  Node: Conclusion,  Prev: Getting a little more advanced,  Up: Argparse Tutorial

10.15.7 Conclusion
------------------

The *note argparse: d. module offers a lot more than shown here.  Its
docs are quite detailed and thorough, and full of examples.  Having gone
through this tutorial, you should easily digest them without feeling
overwhelmed.


File: python.info,  Node: Python Frequently Asked Questions,  Next: Glossary,  Prev: Python HOWTOs,  Up: Top

11 Python Frequently Asked Questions
************************************

* Menu:

* General Python FAQ:: 
* Programming FAQ:: 
* Design and History FAQ:: 
* Library and Extension FAQ:: 
* Extending/Embedding FAQ:: 
* Python on Windows FAQ:: 
* Graphic User Interface FAQ:: 
* "Why is Python Installed on my Computer?" FAQ:: 

General Python FAQ

* General Information:: 
* Python in the real world:: 
* Upgrading Python:: 

General Information

* What is Python?:: 
* What is the Python Software Foundation?:: 
* Are there copyright restrictions on the use of Python?:: 
* Why was Python created in the first place?:: 
* What is Python good for?:: 
* How does the Python version numbering scheme work?:: 
* How do I obtain a copy of the Python source?:: 
* How do I get documentation on Python?:: 
* I’ve never programmed before. Is there a Python tutorial?: I've never programmed before Is there a Python tutorial?. 
* Is there a newsgroup or mailing list devoted to Python?:: 
* How do I get a beta test version of Python?:: 
* How do I submit bug reports and patches for Python?:: 
* Are there any published articles about Python that I can reference?:: 
* Are there any books on Python?:: 
* Where in the world is www.python.org located?: Where in the world is www python org located?. 
* Why is it called Python?:: 
* Do I have to like "Monty Python's Flying Circus"?:: 

Python in the real world

* How stable is Python?:: 
* How many people are using Python?:: 
* Have any significant projects been done in Python?:: 
* What new developments are expected for Python in the future?:: 
* Is it reasonable to propose incompatible changes to Python?:: 
* Is Python Y2K (Year 2000) Compliant?: Is Python Y2K Year 2000 Compliant?. 
* Is Python a good language for beginning programmers?:: 

Upgrading Python

* What is this bsddb185 module my application keeps complaining about?:: 

Programming FAQ

* General Questions:: 
* Core Language:: 
* Numbers and strings:: 
* Sequences (Tuples/Lists): Sequences Tuples/Lists. 
* Dictionaries: Dictionaries<2>. 
* Objects:: 
* Modules: Modules<3>. 

General Questions

* Is there a source code level debugger with breakpoints, single-stepping, etc.?: Is there a source code level debugger with breakpoints single-stepping etc ?. 
* Is there a tool to help find bugs or perform static analysis?:: 
* How can I create a stand-alone binary from a Python script?:: 
* Are there coding standards or a style guide for Python programs?:: 
* My program is too slow. How do I speed it up?: My program is too slow How do I speed it up?. 

Core Language

* Why am I getting an UnboundLocalError when the variable has a value?:: 
* What are the rules for local and global variables in Python?:: 
* Why do lambdas defined in a loop with different values all return the same result?:: 
* How do I share global variables across modules?:: 
* What are the "best practices" for using import in a module?:: 
* How can I pass optional or keyword parameters from one function to another?:: 
* What is the difference between arguments and parameters?:: 
* How do I write a function with output parameters (call by reference)?: How do I write a function with output parameters call by reference ?. 
* How do you make a higher order function in Python?:: 
* How do I copy an object in Python?:: 
* How can I find the methods or attributes of an object?:: 
* How can my code discover the name of an object?:: 
* What's up with the comma operator's precedence?:: 
* Is there an equivalent of C’s "?;" ternary operator?: Is there an equivalent of C's "? " ternary operator?. 
* Is it possible to write obfuscated one-liners in Python?:: 

Numbers and strings

* How do I specify hexadecimal and octal integers?:: 
* Why does -22 // 10 return -3?:: 
* How do I convert a string to a number?:: 
* How do I convert a number to a string?:: 
* How do I modify a string in place?:: 
* How do I use strings to call functions/methods?:: 
* Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?. 
* Is there a scanf() or sscanf() equivalent?: Is there a scanf or sscanf equivalent?. 
* What does ’UnicodeError; ASCII [decoding,encoding] error; ordinal not in range(128)’ mean?: What does 'UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ' mean?. 

Sequences (Tuples/Lists)

* How do I convert between tuples and lists?:: 
* What's a negative index?:: 
* How do I iterate over a sequence in reverse order?:: 
* How do you remove duplicates from a list?:: 
* How do you make an array in Python?:: 
* How do I create a multidimensional list?:: 
* How do I apply a method to a sequence of objects?:: 
* Why does a_tuple[i] += ['item'] raise an exception when the addition works?:: 

Dictionaries

* How can I get a dictionary to display its keys in a consistent order?:: 
* I want to do a complicated sort; can you do a Schwartzian Transform in Python?: I want to do a complicated sort can you do a Schwartzian Transform in Python?. 
* How can I sort one list by values from another list?:: 

Objects

* What is a class?:: 
* What is a method?:: 
* What is self?:: 
* How do I check if an object is an instance of a given class or of a subclass of it?:: 
* What is delegation?:: 
* How do I call a method defined in a base class from a derived class that overrides it?:: 
* How can I organize my code to make it easier to change the base class?:: 
* How do I create static class data and static class methods?:: 
* How can I overload constructors (or methods) in Python?: How can I overload constructors or methods in Python?. 
* I try to use __spam and I get an error about _SomeClassName__spam.: I try to use __spam and I get an error about _SomeClassName__spam. 
* My class defines __del__ but it is not called when I delete the object.: My class defines __del__ but it is not called when I delete the object. 
* How do I get a list of all instances of a given class?:: 
* Why does the result of id() appear to be not unique?: Why does the result of id appear to be not unique?. 

Modules

* How do I create a .pyc file?: How do I create a pyc file?. 
* How do I find the current module name?:: 
* How can I have modules that mutually import each other?:: 
* __import__(’x.y.z’) returns <module ’x’>; how do I get z?: __import__ 'x y z' returns <module 'x'>; how do I get z?. 
* When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?: When I edit an imported module and reimport it the changes don't show up Why does this happen?. 

Design and History FAQ

* Why does Python use indentation for grouping of statements?:: 
* Why am I getting strange results with simple arithmetic operations?:: 
* Why are floating point calculations so inaccurate?:: 
* Why are Python strings immutable?:: 
* Why must 'self' be used explicitly in method definitions and calls?:: 
* Why can't I use an assignment in an expression?:: 
* Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?: Why does Python use methods for some functionality e g list index but functions for other e g len list ?. 
* Why is join() a string method instead of a list or tuple method?: Why is join a string method instead of a list or tuple method?. 
* How fast are exceptions?:: 
* Why isn't there a switch or case statement in Python?:: 
* Can't you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?:: 
* Why can't lambda expressions contain statements?:: 
* Can Python be compiled to machine code, C or some other language?: Can Python be compiled to machine code C or some other language?. 
* How does Python manage memory?:: 
* Why isn't all memory freed when Python exits?:: 
* Why are there separate tuple and list data types?:: 
* How are lists implemented?:: 
* How are dictionaries implemented?:: 
* Why must dictionary keys be immutable?:: 
* Why doesn’t list.sort() return the sorted list?: Why doesn't list sort return the sorted list?. 
* How do you specify and enforce an interface spec in Python?:: 
* Why are default values shared between objects?:: 
* Why is there no goto?:: 
* Why can’t raw strings (r-strings) end with a backslash?: Why can't raw strings r-strings end with a backslash?. 
* Why doesn't Python have a "with" statement for attribute assignments?:: 
* Why are colons required for the if/while/def/class statements?:: 
* Why does Python allow commas at the end of lists and tuples?:: 

Library and Extension FAQ

* General Library Questions:: 
* Common tasks:: 
* Threads:: 
* Input and Output: Input and Output<2>. 
* Network/Internet Programming:: 
* Databases:: 
* Mathematics and Numerics:: 

General Library Questions

* How do I find a module or application to perform task X?:: 
* Where is the math.py (socket.py, regex.py, etc.) source file?: Where is the math py socket py regex py etc source file?. 
* How do I make a Python script executable on Unix?:: 
* Is there a curses/termcap package for Python?:: 
* Is there an equivalent to C’s onexit() in Python?: Is there an equivalent to C's onexit in Python?. 
* Why don't my signal handlers work?:: 

Common tasks

* How do I test a Python program or component?:: 
* How do I create documentation from doc strings?:: 
* How do I get a single keypress at a time?:: 

Threads

* How do I program using threads?:: 
* None of my threads seem to run; why?: None of my threads seem to run why?. 
* How do I parcel out work among a bunch of worker threads?:: 
* What kinds of global value mutation are thread-safe?:: 
* Can't we get rid of the Global Interpreter Lock?:: 

Input and Output

* How do I delete a file? (And other file questions...): How do I delete a file? And other file questions. 
* How do I copy a file?:: 
* How do I read (or write) binary data?: How do I read or write binary data?. 
* I can’t seem to use os.read() on a pipe created with os.popen(); why?: I can't seem to use os read on a pipe created with os popen ; why?. 
* How do I run a subprocess with pipes connected to both input and output?:: 
* How do I access the serial (RS232) port?: How do I access the serial RS232 port?. 
* Why doesn’t closing sys.stdout (stdin, stderr) really close it?: Why doesn't closing sys stdout stdin stderr really close it?. 

Network/Internet Programming

* What WWW tools are there for Python?:: 
* How can I mimic CGI form submission (METHOD=POST)?: How can I mimic CGI form submission METHOD=POST ?. 
* What module should I use to help with generating HTML?:: 
* How do I send mail from a Python script?:: 
* How do I avoid blocking in the connect() method of a socket?: How do I avoid blocking in the connect method of a socket?. 

Databases

* Are there any interfaces to database packages in Python?:: 
* How do you implement persistent objects in Python?:: 
* Why is cPickle so slow?:: 
* If my program crashes with a bsddb (or anydbm) database open, it gets corrupted. How come?: If my program crashes with a bsddb or anydbm database open it gets corrupted How come?. 
* I tried to open Berkeley DB file, but bsddb produces bsddb.error; (22, ’Invalid argument’). Help! How can I restore my data?: I tried to open Berkeley DB file but bsddb produces bsddb error 22 'Invalid argument' Help! How can I restore my data?. 

Mathematics and Numerics

* How do I generate random numbers in Python?:: 

Extending/Embedding FAQ

* Can I create my own functions in C?:: 
* Can I create my own functions in C++?:: 
* Writing C is hard; are there any alternatives?:: 
* How can I execute arbitrary Python statements from C?:: 
* How can I evaluate an arbitrary Python expression from C?:: 
* How do I extract C values from a Python object?:: 
* How do I use Py_BuildValue() to create a tuple of arbitrary length?: How do I use Py_BuildValue to create a tuple of arbitrary length?. 
* How do I call an object's method from C?:: 
* How do I catch the output from PyErr_Print() (or anything that prints to stdout/stderr)?: How do I catch the output from PyErr_Print or anything that prints to stdout/stderr ?. 
* How do I access a module written in Python from C?:: 
* How do I interface to C++ objects from Python?:: 
* I added a module using the Setup file and the make fails; why?:: 
* How do I debug an extension?:: 
* I want to compile a Python module on my Linux system, but some files are missing. Why?: I want to compile a Python module on my Linux system but some files are missing Why?. 
* What does "SystemError; _PyImport_FixupExtension; module yourmodule not loaded" mean?: What does "SystemError _PyImport_FixupExtension module yourmodule not loaded" mean?. 
* How do I tell "incomplete input" from "invalid input"?:: 
* How do I find undefined g++ symbols __builtin_new or __pure_virtual?:: 
* Can I create an object class with some methods implemented in C and others in Python (e.g. through inheritance)?: Can I create an object class with some methods implemented in C and others in Python e g through inheritance ?. 
* When importing module X, why do I get "undefined symbol; PyUnicodeUCS2*"?: When importing module X why do I get "undefined symbol PyUnicodeUCS2*"?. 

Python on Windows FAQ

* How do I run a Python program under Windows?:: 
* How do I make Python scripts executable?:: 
* Why does Python sometimes take so long to start?:: 
* How do I make an executable from a Python script?:: 
* Is a *.pyd file the same as a DLL?: Is a * pyd file the same as a DLL?. 
* How can I embed Python into a Windows application?:: 
* How do I keep editors from inserting tabs into my Python source?:: 
* How do I check for a keypress without blocking?:: 
* How do I emulate os.kill() in Windows?: How do I emulate os kill in Windows?. 
* How do I extract the downloaded documentation on Windows?:: 

Graphic User Interface FAQ

* What platform-independent GUI toolkits exist for Python?:: 
* What platform-specific GUI toolkits exist for Python?:: 
* Tkinter questions:: 

What platform-independent GUI toolkits exist for Python?

* Tkinter:: 
* wxWidgets:: 
* Qt:: 
* Gtk+:: 
* FLTK:: 
* FOX:: 
* OpenGL:: 

Tkinter questions

* How do I freeze Tkinter applications?:: 
* Can I have Tk events handled while waiting for I/O?:: 
* I can’t get key bindings to work in Tkinter; why?: I can't get key bindings to work in Tkinter why?. 

"Why is Python Installed on my Computer?" FAQ

* What is Python?: What is Python?<2>. 
* Why is Python installed on my machine?:: 
* Can I delete Python?:: 


File: python.info,  Node: General Python FAQ,  Next: Programming FAQ,  Up: Python Frequently Asked Questions

11.1 General Python FAQ
=======================

* Menu:

* General Information:: 
* Python in the real world:: 
* Upgrading Python:: 

General Information

* What is Python?:: 
* What is the Python Software Foundation?:: 
* Are there copyright restrictions on the use of Python?:: 
* Why was Python created in the first place?:: 
* What is Python good for?:: 
* How does the Python version numbering scheme work?:: 
* How do I obtain a copy of the Python source?:: 
* How do I get documentation on Python?:: 
* I’ve never programmed before. Is there a Python tutorial?: I've never programmed before Is there a Python tutorial?. 
* Is there a newsgroup or mailing list devoted to Python?:: 
* How do I get a beta test version of Python?:: 
* How do I submit bug reports and patches for Python?:: 
* Are there any published articles about Python that I can reference?:: 
* Are there any books on Python?:: 
* Where in the world is www.python.org located?: Where in the world is www python org located?. 
* Why is it called Python?:: 
* Do I have to like "Monty Python's Flying Circus"?:: 

Python in the real world

* How stable is Python?:: 
* How many people are using Python?:: 
* Have any significant projects been done in Python?:: 
* What new developments are expected for Python in the future?:: 
* Is it reasonable to propose incompatible changes to Python?:: 
* Is Python Y2K (Year 2000) Compliant?: Is Python Y2K Year 2000 Compliant?. 
* Is Python a good language for beginning programmers?:: 

Upgrading Python

* What is this bsddb185 module my application keeps complaining about?:: 


File: python.info,  Node: General Information,  Next: Python in the real world,  Up: General Python FAQ

11.1.1 General Information
--------------------------

* Menu:

* What is Python?:: 
* What is the Python Software Foundation?:: 
* Are there copyright restrictions on the use of Python?:: 
* Why was Python created in the first place?:: 
* What is Python good for?:: 
* How does the Python version numbering scheme work?:: 
* How do I obtain a copy of the Python source?:: 
* How do I get documentation on Python?:: 
* I’ve never programmed before. Is there a Python tutorial?: I've never programmed before Is there a Python tutorial?. 
* Is there a newsgroup or mailing list devoted to Python?:: 
* How do I get a beta test version of Python?:: 
* How do I submit bug reports and patches for Python?:: 
* Are there any published articles about Python that I can reference?:: 
* Are there any books on Python?:: 
* Where in the world is www.python.org located?: Where in the world is www python org located?. 
* Why is it called Python?:: 
* Do I have to like "Monty Python's Flying Circus"?:: 


File: python.info,  Node: What is Python?,  Next: What is the Python Software Foundation?,  Up: General Information

11.1.1.1 What is Python?
........................

Python is an interpreted, interactive, object-oriented programming
language.  It incorporates modules, exceptions, dynamic typing, very
high level dynamic data types, and classes.  Python combines remarkable
power with very clear syntax.  It has interfaces to many system calls
and libraries, as well as to various window systems, and is extensible
in C or C++.  It is also usable as an extension language for
applications that need a programmable interface.  Finally, Python is
portable: it runs on many Unix variants, on the Mac, and on PCs under
MS-DOS, Windows, Windows NT, and OS/2.

  To find out more, start with *note The Python Tutorial: 4f7.  The
Beginner’s Guide to Python(1) links to other introductory tutorials and
resources for learning Python.

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/BeginnersGuide


File: python.info,  Node: What is the Python Software Foundation?,  Next: Are there copyright restrictions on the use of Python?,  Prev: What is Python?,  Up: General Information

11.1.1.2 What is the Python Software Foundation?
................................................

The Python Software Foundation is an independent non-profit organization
that holds the copyright on Python versions 2.1 and newer.  The PSF’s
mission is to advance open source technology related to the Python
programming language and to publicize the use of Python.  The PSF’s home
page is at ‘http://www.python.org/psf/’.

  Donations to the PSF are tax-exempt in the US. If you use Python and
find it helpful, please contribute via the PSF donation page(1).

   ---------- Footnotes ----------

   (1) http://www.python.org/psf/donations/


File: python.info,  Node: Are there copyright restrictions on the use of Python?,  Next: Why was Python created in the first place?,  Prev: What is the Python Software Foundation?,  Up: General Information

11.1.1.3 Are there copyright restrictions on the use of Python?
...............................................................

You can do anything you want with the source, as long as you leave the
copyrights in and display those copyrights in any documentation about
Python that you produce.  If you honor the copyright rules, it’s OK to
use Python for commercial use, to sell copies of Python in source or
binary form (modified or unmodified), or to sell products that
incorporate Python in some form.  We would still like to know about all
commercial use of Python, of course.

  See the PSF license page(1) to find further explanations and a link to
the full text of the license.

  The Python logo is trademarked, and in certain cases permission is
required to use it.  Consult the Trademark Usage Policy(2) for more
information.

   ---------- Footnotes ----------

   (1) http://python.org/psf/license/

   (2) http://www.python.org/psf/trademarks/


File: python.info,  Node: Why was Python created in the first place?,  Next: What is Python good for?,  Prev: Are there copyright restrictions on the use of Python?,  Up: General Information

11.1.1.4 Why was Python created in the first place?
...................................................

Here’s a _very_ brief summary of what started it all, written by Guido
van Rossum:

     I had extensive experience with implementing an interpreted
     language in the ABC group at CWI, and from working with this group
     I had learned a lot about language design.  This is the origin of
     many Python features, including the use of indentation for
     statement grouping and the inclusion of very-high-level data types
     (although the details are all different in Python).

     I had a number of gripes about the ABC language, but also liked
     many of its features.  It was impossible to extend the ABC language
     (or its implementation) to remedy my complaints – in fact its lack
     of extensibility was one of its biggest problems.  I had some
     experience with using Modula-2+ and talked with the designers of
     Modula-3 and read the Modula-3 report.  Modula-3 is the origin of
     the syntax and semantics used for exceptions, and some other Python
     features.

     I was working in the Amoeba distributed operating system group at
     CWI. We needed a better way to do system administration than by
     writing either C programs or Bourne shell scripts, since Amoeba had
     its own system call interface which wasn’t easily accessible from
     the Bourne shell.  My experience with error handling in Amoeba made
     me acutely aware of the importance of exceptions as a programming
     language feature.

     It occurred to me that a scripting language with a syntax like ABC
     but with access to the Amoeba system calls would fill the need.  I
     realized that it would be foolish to write an Amoeba-specific
     language, so I decided that I needed a language that was generally
     extensible.

     During the 1989 Christmas holidays, I had a lot of time on my hand,
     so I decided to give it a try.  During the next year, while still
     mostly working on it in my own time, Python was used in the Amoeba
     project with increasing success, and the feedback from colleagues
     made me add many early improvements.

     In February 1991, after just over a year of development, I decided
     to post to USENET. The rest is in the ‘Misc/HISTORY’ file.


File: python.info,  Node: What is Python good for?,  Next: How does the Python version numbering scheme work?,  Prev: Why was Python created in the first place?,  Up: General Information

11.1.1.5 What is Python good for?
.................................

Python is a high-level general-purpose programming language that can be
applied to many different classes of problems.

  The language comes with a large standard library that covers areas
such as string processing (regular expressions, Unicode, calculating
differences between files), Internet protocols (HTTP, FTP, SMTP,
XML-RPC, POP, IMAP, CGI programming), software engineering (unit
testing, logging, profiling, parsing Python code), and operating system
interfaces (system calls, filesystems, TCP/IP sockets).  Look at the
table of contents for *note The Python Standard Library: 4f8. to get an
idea of what’s available.  A wide variety of third-party extensions are
also available.  Consult the Python Package Index(1) to find packages of
interest to you.

   ---------- Footnotes ----------

   (1) http://pypi.python.org/pypi


File: python.info,  Node: How does the Python version numbering scheme work?,  Next: How do I obtain a copy of the Python source?,  Prev: What is Python good for?,  Up: General Information

11.1.1.6 How does the Python version numbering scheme work?
...........................................................

Python versions are numbered A.B.C or A.B. A is the major version number
– it is only incremented for really major changes in the language.  B is
the minor version number, incremented for less earth-shattering changes.
C is the micro-level – it is incremented for each bugfix release.  See
PEP 6(1) for more information about bugfix releases.

  Not all releases are bugfix releases.  In the run-up to a new major
release, a series of development releases are made, denoted as alpha,
beta, or release candidate.  Alphas are early releases in which
interfaces aren’t yet finalized; it’s not unexpected to see an interface
change between two alpha releases.  Betas are more stable, preserving
existing interfaces but possibly adding new modules, and release
candidates are frozen, making no changes except as needed to fix
critical bugs.

  Alpha, beta and release candidate versions have an additional suffix.
The suffix for an alpha version is "aN" for some small number N, the
suffix for a beta version is "bN" for some small number N, and the
suffix for a release candidate version is "cN" for some small number N.
In other words, all versions labeled 2.0aN precede the versions labeled
2.0bN, which precede versions labeled 2.0cN, and _those_ precede 2.0.

  You may also find version numbers with a "+" suffix, e.g.  "2.2+".
These are unreleased versions, built directly from the Subversion trunk.
In practice, after a final minor release is made, the Subversion trunk
is incremented to the next minor version, which becomes the "a0"
version, e.g.  "2.4a0".

  See also the documentation for ‘sys.version’, ‘sys.hexversion’, and
‘sys.version_info’.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0006


File: python.info,  Node: How do I obtain a copy of the Python source?,  Next: How do I get documentation on Python?,  Prev: How does the Python version numbering scheme work?,  Up: General Information

11.1.1.7 How do I obtain a copy of the Python source?
.....................................................

The latest Python source distribution is always available from
python.org, at ‘http://www.python.org/download/’.  The latest
development sources can be obtained via anonymous Mercurial access at
‘http://hg.python.org/cpython’.

  The source distribution is a gzipped tar file containing the complete
C source, Sphinx-formatted documentation, Python library modules,
example programs, and several useful pieces of freely distributable
software.  The source will compile and run out of the box on most UNIX
platforms.

  Consult the Developer FAQ(1) for more information on getting the
source code and compiling it.

   ---------- Footnotes ----------

   (1) http://docs.python.org/devguide/faq


File: python.info,  Node: How do I get documentation on Python?,  Next: I've never programmed before Is there a Python tutorial?,  Prev: How do I obtain a copy of the Python source?,  Up: General Information

11.1.1.8 How do I get documentation on Python?
..............................................

The standard documentation for the current stable version of Python is
available at ‘http://docs.python.org/’.  PDF, plain text, and
downloadable HTML versions are also available at
‘http://docs.python.org/download.html’.

  The documentation is written in reStructuredText and processed by the
Sphinx documentation tool(1).  The reStructuredText source for the
documentation is part of the Python source distribution.

   ---------- Footnotes ----------

   (1) http://sphinx-doc.org/


File: python.info,  Node: I've never programmed before Is there a Python tutorial?,  Next: Is there a newsgroup or mailing list devoted to Python?,  Prev: How do I get documentation on Python?,  Up: General Information

11.1.1.9 I’ve never programmed before. Is there a Python tutorial?
..................................................................

There are numerous tutorials and books available.  The standard
documentation includes *note The Python Tutorial: 4f7.

  Consult the Beginner’s Guide(1) to find information for beginning
Python programmers, including lists of tutorials.

   ---------- Footnotes ----------

   (1) http://wiki.python.org/moin/BeginnersGuide


File: python.info,  Node: Is there a newsgroup or mailing list devoted to Python?,  Next: How do I get a beta test version of Python?,  Prev: I've never programmed before Is there a Python tutorial?,  Up: General Information

11.1.1.10 Is there a newsgroup or mailing list devoted to Python?
.................................................................

There is a newsgroup, ‘comp.lang.python’, and a mailing list,
python-list(1).  The newsgroup and mailing list are gatewayed into each
other – if you can read news it’s unnecessary to subscribe to the
mailing list.  ‘comp.lang.python’ is high-traffic, receiving hundreds of
postings every day, and Usenet readers are often more able to cope with
this volume.

  Announcements of new software releases and events can be found in
comp.lang.python.announce, a low-traffic moderated list that receives
about five postings per day.  It’s available as the python-announce
mailing list(2).

  More info about other mailing lists and newsgroups can be found at
‘http://www.python.org/community/lists/’.

   ---------- Footnotes ----------

   (1) http://mail.python.org/mailman/listinfo/python-list

   (2) http://mail.python.org/mailman/listinfo/python-announce-list


File: python.info,  Node: How do I get a beta test version of Python?,  Next: How do I submit bug reports and patches for Python?,  Prev: Is there a newsgroup or mailing list devoted to Python?,  Up: General Information

11.1.1.11 How do I get a beta test version of Python?
.....................................................

Alpha and beta releases are available from
‘http://www.python.org/download/’.  All releases are announced on the
comp.lang.python and comp.lang.python.announce newsgroups and on the
Python home page at ‘http://www.python.org/’; an RSS feed of news is
available.

  You can also access the development version of Python through
Subversion.  See ‘http://docs.python.org/devguide/faq’ for details.


File: python.info,  Node: How do I submit bug reports and patches for Python?,  Next: Are there any published articles about Python that I can reference?,  Prev: How do I get a beta test version of Python?,  Up: General Information

11.1.1.12 How do I submit bug reports and patches for Python?
.............................................................

To report a bug or submit a patch, please use the Roundup installation
at ‘http://bugs.python.org/’.

  You must have a Roundup account to report bugs; this makes it possible
for us to contact you if we have follow-up questions.  It will also
enable Roundup to send you updates as we act on your bug.  If you had
previously used SourceForge to report bugs to Python, you can obtain
your Roundup password through Roundup’s password reset procedure(1).

  For more information on how Python is developed, consult the Python
Developer’s Guide(2).

   ---------- Footnotes ----------

   (1) http://bugs.python.org/user?@template=forgotten

   (2) http://docs.python.org/devguide/


File: python.info,  Node: Are there any published articles about Python that I can reference?,  Next: Are there any books on Python?,  Prev: How do I submit bug reports and patches for Python?,  Up: General Information

11.1.1.13 Are there any published articles about Python that I can reference?
.............................................................................

It’s probably best to cite your favorite book about Python.

  The very first article about Python was written in 1991 and is now
quite outdated.

     Guido van Rossum and Jelke de Boer, "Interactively Testing Remote
     Servers Using the Python Programming Language", CWI Quarterly,
     Volume 4, Issue 4 (December 1991), Amsterdam, pp 283-303.


File: python.info,  Node: Are there any books on Python?,  Next: Where in the world is www python org located?,  Prev: Are there any published articles about Python that I can reference?,  Up: General Information

11.1.1.14 Are there any books on Python?
........................................

Yes, there are many, and more are being published.  See the python.org
wiki at ‘http://wiki.python.org/moin/PythonBooks’ for a list.

  You can also search online bookstores for "Python" and filter out the
Monty Python references; or perhaps search for "Python" and "language".


File: python.info,  Node: Where in the world is www python org located?,  Next: Why is it called Python?,  Prev: Are there any books on Python?,  Up: General Information

11.1.1.15 Where in the world is www.python.org located?
.......................................................

The Python project’s infrastructure is located all over the world.
www.python.org(1) is currently in Amsterdam, graciously hosted by
XS4ALL(2). Upfront Systems(3) hosts bugs.python.org(4).  Most other
Python services like PyPI(5) and hg.python.org are hosted by Oregon
State University Open Source Lab(6).

   ---------- Footnotes ----------

   (1) http://www.python.org

   (2) http://www.xs4all.nl

   (3) http://www.upfrontsystems.co.za

   (4) http://bugs.python.org

   (5) https://pypi.python.org

   (6) https://osuosl.org


File: python.info,  Node: Why is it called Python?,  Next: Do I have to like "Monty Python's Flying Circus"?,  Prev: Where in the world is www python org located?,  Up: General Information

11.1.1.16 Why is it called Python?
..................................

When he began implementing Python, Guido van Rossum was also reading the
published scripts from "Monty Python’s Flying Circus"(1), a BBC comedy
series from the 1970s.  Van Rossum thought he needed a name that was
short, unique, and slightly mysterious, so he decided to call the
language Python.

   ---------- Footnotes ----------

   (1) http://pythonline.com/


File: python.info,  Node: Do I have to like "Monty Python's Flying Circus"?,  Prev: Why is it called Python?,  Up: General Information

11.1.1.17 Do I have to like "Monty Python’s Flying Circus"?
...........................................................

No, but it helps.  :)


File: python.info,  Node: Python in the real world,  Next: Upgrading Python,  Prev: General Information,  Up: General Python FAQ

11.1.2 Python in the real world
-------------------------------

* Menu:

* How stable is Python?:: 
* How many people are using Python?:: 
* Have any significant projects been done in Python?:: 
* What new developments are expected for Python in the future?:: 
* Is it reasonable to propose incompatible changes to Python?:: 
* Is Python Y2K (Year 2000) Compliant?: Is Python Y2K Year 2000 Compliant?. 
* Is Python a good language for beginning programmers?:: 


File: python.info,  Node: How stable is Python?,  Next: How many people are using Python?,  Up: Python in the real world

11.1.2.1 How stable is Python?
..............................

Very stable.  New, stable releases have been coming out roughly every 6
to 18 months since 1991, and this seems likely to continue.  Currently
there are usually around 18 months between major releases.

  The developers issue "bugfix" releases of older versions, so the
stability of existing releases gradually improves.  Bugfix releases,
indicated by a third component of the version number (e.g.  2.5.3,
2.6.2), are managed for stability; only fixes for known problems are
included in a bugfix release, and it’s guaranteed that interfaces will
remain the same throughout a series of bugfix releases.

  The latest stable releases can always be found on the Python download
page(1).  There are two recommended production-ready versions at this
point in time, because at the moment there are two branches of stable
releases: 2.x and 3.x.  Python 3.x may be less useful than 2.x, since
currently there is more third party software available for Python 2 than
for Python 3.  Python 2 code will generally not run unchanged in Python
3.

   ---------- Footnotes ----------

   (1) http://python.org/download/


File: python.info,  Node: How many people are using Python?,  Next: Have any significant projects been done in Python?,  Prev: How stable is Python?,  Up: Python in the real world

11.1.2.2 How many people are using Python?
..........................................

There are probably tens of thousands of users, though it’s difficult to
obtain an exact count.

  Python is available for free download, so there are no sales figures,
and it’s available from many different sites and packaged with many
Linux distributions, so download statistics don’t tell the whole story
either.

  The comp.lang.python newsgroup is very active, but not all Python
users post to the group or even read it.


File: python.info,  Node: Have any significant projects been done in Python?,  Next: What new developments are expected for Python in the future?,  Prev: How many people are using Python?,  Up: Python in the real world

11.1.2.3 Have any significant projects been done in Python?
...........................................................

See ‘http://python.org/about/success’ for a list of projects that use
Python.  Consulting the proceedings for past Python conferences(1) will
reveal contributions from many different companies and organizations.

  High-profile Python projects include the Mailman mailing list
manager(2) and the Zope application server(3).  Several Linux
distributions, most notably Red Hat(4), have written part or all of
their installer and system administration software in Python.  Companies
that use Python internally include Google, Yahoo, and Lucasfilm Ltd.

   ---------- Footnotes ----------

   (1) http://python.org/community/workshops/

   (2) http://www.list.org

   (3) http://www.zope.org

   (4) http://www.redhat.com


File: python.info,  Node: What new developments are expected for Python in the future?,  Next: Is it reasonable to propose incompatible changes to Python?,  Prev: Have any significant projects been done in Python?,  Up: Python in the real world

11.1.2.4 What new developments are expected for Python in the future?
.....................................................................

See ‘http://www.python.org/dev/peps/’ for the Python Enhancement
Proposals (PEPs).  PEPs are design documents describing a suggested new
feature for Python, providing a concise technical specification and a
rationale.  Look for a PEP titled "Python X.Y Release Schedule", where
X.Y is a version that hasn’t been publicly released yet.

  New development is discussed on the python-dev mailing list(1).

   ---------- Footnotes ----------

   (1) http://mail.python.org/mailman/listinfo/python-dev/


File: python.info,  Node: Is it reasonable to propose incompatible changes to Python?,  Next: Is Python Y2K Year 2000 Compliant?,  Prev: What new developments are expected for Python in the future?,  Up: Python in the real world

11.1.2.5 Is it reasonable to propose incompatible changes to Python?
....................................................................

In general, no.  There are already millions of lines of Python code
around the world, so any change in the language that invalidates more
than a very small fraction of existing programs has to be frowned upon.
Even if you can provide a conversion program, there’s still the problem
of updating all documentation; many books have been written about
Python, and we don’t want to invalidate them all at a single stroke.

  Providing a gradual upgrade path is necessary if a feature has to be
changed.  PEP 5(1) describes the procedure followed for introducing
backward-incompatible changes while minimizing disruption for users.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0005


File: python.info,  Node: Is Python Y2K Year 2000 Compliant?,  Next: Is Python a good language for beginning programmers?,  Prev: Is it reasonable to propose incompatible changes to Python?,  Up: Python in the real world

11.1.2.6 Is Python Y2K (Year 2000) Compliant?
.............................................

As of August, 2003 no major problems have been reported and Y2K
compliance seems to be a non-issue.

  Python does very few date calculations and for those it does perform
relies on the C library functions.  Python generally represents times
either as seconds since 1970 or as a ‘(year, month, day, ...)’ tuple
where the year is expressed with four digits, which makes Y2K bugs
unlikely.  So as long as your C library is okay, Python should be okay.
Of course, it’s possible that a particular application written in Python
makes assumptions about 2-digit years.

  Because Python is available free of charge, there are no absolute
guarantees.  If there _are_ unforeseen problems, liability is the user’s
problem rather than the developers’, and there is nobody you can sue for
damages.  The Python copyright notice contains the following disclaimer:

     4.  PSF is making Python 2.3 available to Licensee on an "AS IS"
     basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.3
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

     5.  PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF
     PYTHON 2.3 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 2.3, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  The good news is that _if_ you encounter a problem, you have full
source available to track it down and fix it.  This is one advantage of
an open source programming environment.


File: python.info,  Node: Is Python a good language for beginning programmers?,  Prev: Is Python Y2K Year 2000 Compliant?,  Up: Python in the real world

11.1.2.7 Is Python a good language for beginning programmers?
.............................................................

Yes.

  It is still common to start students with a procedural and statically
typed language such as Pascal, C, or a subset of C++ or Java.  Students
may be better served by learning Python as their first language.  Python
has a very simple and consistent syntax and a large standard library
and, most importantly, using Python in a beginning programming course
lets students concentrate on important programming skills such as
problem decomposition and data type design.  With Python, students can
be quickly introduced to basic concepts such as loops and procedures.
They can probably even work with user-defined objects in their very
first course.

  For a student who has never programmed before, using a statically
typed language seems unnatural.  It presents additional complexity that
the student must master and slows the pace of the course.  The students
are trying to learn to think like a computer, decompose problems, design
consistent interfaces, and encapsulate data.  While learning to use a
statically typed language is important in the long term, it is not
necessarily the best topic to address in the students’ first programming
course.

  Many other aspects of Python make it a good first language.  Like
Java, Python has a large standard library so that students can be
assigned programming projects very early in the course that _do_
something.  Assignments aren’t restricted to the standard four-function
calculator and check balancing programs.  By using the standard library,
students can gain the satisfaction of working on realistic applications
as they learn the fundamentals of programming.  Using the standard
library also teaches students about code reuse.  Third-party modules
such as PyGame are also helpful in extending the students’ reach.

  Python’s interactive interpreter enables students to test language
features while they’re programming.  They can keep a window with the
interpreter running while they enter their program’s source in another
window.  If they can’t remember the methods for a list, they can do
something like this:

     >>> L = []
     >>> dir(L)
     ['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
     'reverse', 'sort']
     >>> help(L.append)
     Help on built-in function append:

     append(...)
         L.append(object) -- append object to end
     >>> L.append(1)
     >>> L
     [1]

  With the interpreter, documentation is never far from the student as
he’s programming.

  There are also good IDEs for Python.  IDLE is a cross-platform IDE for
Python that is written in Python using Tkinter.  PythonWin is a
Windows-specific IDE. Emacs users will be happy to know that there is a
very good Python mode for Emacs.  All of these programming environments
provide syntax highlighting, auto-indenting, and access to the
interactive interpreter while coding.  Consult the Python wiki(1) for a
full list of Python editing environments.

  If you want to discuss Python’s use in education, you may be
interested in joining the edu-sig mailing list(2).

   ---------- Footnotes ----------

   (1) https://wiki.python.org/moin/PythonEditors

   (2) http://python.org/community/sigs/current/edu-sig


File: python.info,  Node: Upgrading Python,  Prev: Python in the real world,  Up: General Python FAQ

11.1.3 Upgrading Python
-----------------------

* Menu:

* What is this bsddb185 module my application keeps complaining about?:: 


File: python.info,  Node: What is this bsddb185 module my application keeps complaining about?,  Up: Upgrading Python

11.1.3.1 What is this bsddb185 module my application keeps complaining about?
.............................................................................

Starting with Python2.3, the distribution includes the ‘PyBSDDB package
<http://pybsddb.sf.net/>’ as a replacement for the old bsddb module.  It
includes functions which provide backward compatibility at the API
level, but requires a newer version of the underlying Berkeley DB(1)
library.  Files created with the older bsddb module can’t be opened
directly using the new module.

  Using your old version of Python and a pair of scripts which are part
of Python 2.3 (db2pickle.py and pickle2db.py, in the Tools/scripts
directory) you can convert your old database files to the new format.
Using your old Python version, run the db2pickle.py script to convert it
to a pickle, e.g.:

     python2.2 <pathto>/db2pickley.py database.db database.pck

  Rename your database file:

     mv database.db olddatabase.db

  Now convert the pickle file to a new format database:

     python <pathto>/pickle2db.py database.db database.pck

  The precise commands you use will vary depending on the particulars of
your installation.  For full details about operation of these two
scripts check the doc string at the start of each one.

   ---------- Footnotes ----------

   (1) http://www.sleepycat.com


File: python.info,  Node: Programming FAQ,  Next: Design and History FAQ,  Prev: General Python FAQ,  Up: Python Frequently Asked Questions

11.2 Programming FAQ
====================

* Menu:

* General Questions:: 
* Core Language:: 
* Numbers and strings:: 
* Sequences (Tuples/Lists): Sequences Tuples/Lists. 
* Dictionaries: Dictionaries<2>. 
* Objects:: 
* Modules: Modules<3>. 

General Questions

* Is there a source code level debugger with breakpoints, single-stepping, etc.?: Is there a source code level debugger with breakpoints single-stepping etc ?. 
* Is there a tool to help find bugs or perform static analysis?:: 
* How can I create a stand-alone binary from a Python script?:: 
* Are there coding standards or a style guide for Python programs?:: 
* My program is too slow. How do I speed it up?: My program is too slow How do I speed it up?. 

Core Language

* Why am I getting an UnboundLocalError when the variable has a value?:: 
* What are the rules for local and global variables in Python?:: 
* Why do lambdas defined in a loop with different values all return the same result?:: 
* How do I share global variables across modules?:: 
* What are the "best practices" for using import in a module?:: 
* How can I pass optional or keyword parameters from one function to another?:: 
* What is the difference between arguments and parameters?:: 
* How do I write a function with output parameters (call by reference)?: How do I write a function with output parameters call by reference ?. 
* How do you make a higher order function in Python?:: 
* How do I copy an object in Python?:: 
* How can I find the methods or attributes of an object?:: 
* How can my code discover the name of an object?:: 
* What's up with the comma operator's precedence?:: 
* Is there an equivalent of C’s "?;" ternary operator?: Is there an equivalent of C's "? " ternary operator?. 
* Is it possible to write obfuscated one-liners in Python?:: 

Numbers and strings

* How do I specify hexadecimal and octal integers?:: 
* Why does -22 // 10 return -3?:: 
* How do I convert a string to a number?:: 
* How do I convert a number to a string?:: 
* How do I modify a string in place?:: 
* How do I use strings to call functions/methods?:: 
* Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?. 
* Is there a scanf() or sscanf() equivalent?: Is there a scanf or sscanf equivalent?. 
* What does ’UnicodeError; ASCII [decoding,encoding] error; ordinal not in range(128)’ mean?: What does 'UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ' mean?. 

Sequences (Tuples/Lists)

* How do I convert between tuples and lists?:: 
* What's a negative index?:: 
* How do I iterate over a sequence in reverse order?:: 
* How do you remove duplicates from a list?:: 
* How do you make an array in Python?:: 
* How do I create a multidimensional list?:: 
* How do I apply a method to a sequence of objects?:: 
* Why does a_tuple[i] += ['item'] raise an exception when the addition works?:: 

Dictionaries

* How can I get a dictionary to display its keys in a consistent order?:: 
* I want to do a complicated sort; can you do a Schwartzian Transform in Python?: I want to do a complicated sort can you do a Schwartzian Transform in Python?. 
* How can I sort one list by values from another list?:: 

Objects

* What is a class?:: 
* What is a method?:: 
* What is self?:: 
* How do I check if an object is an instance of a given class or of a subclass of it?:: 
* What is delegation?:: 
* How do I call a method defined in a base class from a derived class that overrides it?:: 
* How can I organize my code to make it easier to change the base class?:: 
* How do I create static class data and static class methods?:: 
* How can I overload constructors (or methods) in Python?: How can I overload constructors or methods in Python?. 
* I try to use __spam and I get an error about _SomeClassName__spam.: I try to use __spam and I get an error about _SomeClassName__spam. 
* My class defines __del__ but it is not called when I delete the object.: My class defines __del__ but it is not called when I delete the object. 
* How do I get a list of all instances of a given class?:: 
* Why does the result of id() appear to be not unique?: Why does the result of id appear to be not unique?. 

Modules

* How do I create a .pyc file?: How do I create a pyc file?. 
* How do I find the current module name?:: 
* How can I have modules that mutually import each other?:: 
* __import__(’x.y.z’) returns <module ’x’>; how do I get z?: __import__ 'x y z' returns <module 'x'>; how do I get z?. 
* When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?: When I edit an imported module and reimport it the changes don't show up Why does this happen?. 


File: python.info,  Node: General Questions,  Next: Core Language,  Up: Programming FAQ

11.2.1 General Questions
------------------------

* Menu:

* Is there a source code level debugger with breakpoints, single-stepping, etc.?: Is there a source code level debugger with breakpoints single-stepping etc ?. 
* Is there a tool to help find bugs or perform static analysis?:: 
* How can I create a stand-alone binary from a Python script?:: 
* Are there coding standards or a style guide for Python programs?:: 
* My program is too slow. How do I speed it up?: My program is too slow How do I speed it up?. 


File: python.info,  Node: Is there a source code level debugger with breakpoints single-stepping etc ?,  Next: Is there a tool to help find bugs or perform static analysis?,  Up: General Questions

11.2.1.1 Is there a source code level debugger with breakpoints, single-stepping, etc.?
.......................................................................................

Yes.

  The pdb module is a simple but adequate console-mode debugger for
Python.  It is part of the standard Python library, and is *note
documented in the Library Reference Manual: 12c.  You can also write
your own debugger by using the code for pdb as an example.

  The IDLE interactive development environment, which is part of the
standard Python distribution (normally available as Tools/scripts/idle),
includes a graphical debugger.  There is documentation for the IDLE
debugger at ‘http://www.python.org/idle/doc/idle2.html#Debugger’.

  PythonWin is a Python IDE that includes a GUI debugger based on pdb.
The Pythonwin debugger colors breakpoints and has quite a few cool
features such as debugging non-Pythonwin programs.  Pythonwin is
available as part of the Python for Windows Extensions(1) project and as
a part of the ActivePython distribution (see
‘http://www.activestate.com/Products/ActivePython/index.html’).

  Boa Constructor(2) is an IDE and GUI builder that uses wxWidgets.  It
offers visual frame creation and manipulation, an object inspector, many
views on the source like object browsers, inheritance hierarchies, doc
string generated html documentation, an advanced debugger, integrated
help, and Zope support.

  Eric(3) is an IDE built on PyQt and the Scintilla editing component.

  Pydb is a version of the standard Python debugger pdb, modified for
use with DDD (Data Display Debugger), a popular graphical debugger front
end.  Pydb can be found at ‘http://bashdb.sourceforge.net/pydb/’ and DDD
can be found at ‘http://www.gnu.org/software/ddd’.

  There are a number of commercial Python IDEs that include graphical
debuggers.  They include:

   * Wing IDE (‘http://wingware.com/’)

   * Komodo IDE (‘http://www.activestate.com/Products/Komodo’)

   ---------- Footnotes ----------

   (1) http://sourceforge.net/projects/pywin32/

   (2) http://boa-constructor.sourceforge.net/

   (3) http://www.die-offenbachs.de/eric/index.html


File: python.info,  Node: Is there a tool to help find bugs or perform static analysis?,  Next: How can I create a stand-alone binary from a Python script?,  Prev: Is there a source code level debugger with breakpoints single-stepping etc ?,  Up: General Questions

11.2.1.2 Is there a tool to help find bugs or perform static analysis?
......................................................................

Yes.

  PyChecker is a static analysis tool that finds bugs in Python source
code and warns about code complexity and style.  You can get PyChecker
from ‘http://pychecker.sf.net’.

  Pylint(1) is another tool that checks if a module satisfies a coding
standard, and also makes it possible to write plug-ins to add a custom
feature.  In addition to the bug checking that PyChecker performs,
Pylint offers some additional features such as checking line length,
whether variable names are well-formed according to your coding
standard, whether declared interfaces are fully implemented, and more.
‘http://www.logilab.org/card/pylint_manual’ provides a full list of
Pylint’s features.

   ---------- Footnotes ----------

   (1) http://www.logilab.org/projects/pylint


File: python.info,  Node: How can I create a stand-alone binary from a Python script?,  Next: Are there coding standards or a style guide for Python programs?,  Prev: Is there a tool to help find bugs or perform static analysis?,  Up: General Questions

11.2.1.3 How can I create a stand-alone binary from a Python script?
....................................................................

You don’t need the ability to compile Python to C code if all you want
is a stand-alone program that users can download and run without having
to install the Python distribution first.  There are a number of tools
that determine the set of modules required by a program and bind these
modules together with a Python binary to produce a single executable.

  One is to use the freeze tool, which is included in the Python source
tree as ‘Tools/freeze’.  It converts Python byte code to C arrays; a C
compiler you can embed all your modules into a new program, which is
then linked with the standard Python modules.

  It works by scanning your source recursively for import statements (in
both forms) and looking for the modules in the standard Python path as
well as in the source directory (for built-in modules).  It then turns
the bytecode for modules written in Python into C code (array
initializers that can be turned into code objects using the marshal
module) and creates a custom-made config file that only contains those
built-in modules which are actually used in the program.  It then
compiles the generated C code and links it with the rest of the Python
interpreter to form a self-contained binary which acts exactly like your
script.

  Obviously, freeze requires a C compiler.  There are several other
utilities which don’t.  One is Thomas Heller’s py2exe (Windows only) at

     ‘http://www.py2exe.org/’

  Another is Christian Tismer’s SQFREEZE(1) which appends the byte code
to a specially-prepared Python interpreter that can find the byte code
in the executable.

  Other tools include Fredrik Lundh’s Squeeze(2) and Anthony Tuininga’s
cx_Freeze(3).

   ---------- Footnotes ----------

   (1) http://starship.python.net/crew/pirx

   (2) http://www.pythonware.com/products/python/squeeze

   (3) http://starship.python.net/crew/atuining/cx_Freeze/index.html


File: python.info,  Node: Are there coding standards or a style guide for Python programs?,  Next: My program is too slow How do I speed it up?,  Prev: How can I create a stand-alone binary from a Python script?,  Up: General Questions

11.2.1.4 Are there coding standards or a style guide for Python programs?
.........................................................................

Yes.  The coding style required for standard library modules is
documented as PEP 8(1).

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0008


File: python.info,  Node: My program is too slow How do I speed it up?,  Prev: Are there coding standards or a style guide for Python programs?,  Up: General Questions

11.2.1.5 My program is too slow. How do I speed it up?
......................................................

That’s a tough one, in general.  There are many tricks to speed up
Python code; consider rewriting parts in C as a last resort.

  In some cases it’s possible to automatically translate Python to C or
x86 assembly language, meaning that you don’t have to modify your code
to gain increased speed.

  Pyrex(1) can compile a slightly modified version of Python code into a
C extension, and can be used on many different platforms.

  Psyco(2) is a just-in-time compiler that translates Python code into
x86 assembly language.  If you can use it, Psyco can provide dramatic
speedups for critical functions.

  The rest of this answer will discuss various tricks for squeezing a
bit more speed out of Python code.  _Never_ apply any optimization
tricks unless you know you need them, after profiling has indicated that
a particular function is the heavily executed hot spot in the code.
Optimizations almost always make the code less clear, and you shouldn’t
pay the costs of reduced clarity (increased development time, greater
likelihood of bugs) unless the resulting performance benefit is worth
it.

  There is a page on the wiki devoted to performance tips(3).

  Guido van Rossum has written up an anecdote related to optimization at
‘http://www.python.org/doc/essays/list2str’.

  One thing to notice is that function and (especially) method calls are
rather expensive; if you have designed a purely OO interface with lots
of tiny functions that don’t do much more than get or set an instance
variable or call another method, you might consider using a more direct
way such as directly accessing instance variables.  Also see the
standard module *note profile: 139. which makes it possible to find out
where your program is spending most of its time (if you have some
patience – the profiling itself can slow your program down by an order
of magnitude).

  Remember that many standard optimization heuristics you may know from
other programming experience may well apply to Python.  For example it
may be faster to send output to output devices using larger writes
rather than smaller ones in order to reduce the overhead of kernel
system calls.  Thus CGI scripts that write all output in "one shot" may
be faster than those that write lots of small pieces of output.

  Also, be sure to use Python’s core features where appropriate.  For
example, slicing allows programs to chop up lists and other sequence
objects in a single tick of the interpreter’s mainloop using highly
optimized C implementations.  Thus to get the same effect as:

     L2 = []
     for i in range(3):
         L2.append(L1[i])

  it is much shorter and far faster to use

     L2 = list(L1[:3])  # "list" is redundant if L1 is a list.

  Note that the functionally-oriented built-in functions such as *note
map(): 304, *note zip(): 405, and friends can be a convenient
accelerator for loops that perform a single task.  For example to pair
the elements of two lists together:

     >>> zip([1, 2, 3], [4, 5, 6])
     [(1, 4), (2, 5), (3, 6)]

  or to compute a number of sines:

     >>> map(math.sin, (1, 2, 3, 4))
     [0.841470984808, 0.909297426826, 0.14112000806, -0.756802495308]

  The operation completes very quickly in such cases.

  Other examples include the ‘join()’ and ‘split()’ *note methods of
string objects: 522.  For example if s1..s7 are large (10K+) strings
then ‘"".join([s1,s2,s3,s4,s5,s6,s7])’ may be far faster than the more
obvious ‘s1+s2+s3+s4+s5+s6+s7’, since the "summation" will compute many
subexpressions, whereas ‘join()’ does all the copying in one pass.  For
manipulating strings, use the ‘replace()’ and the ‘format()’ *note
methods on string objects: 522.  Use regular expressions only when
you’re not dealing with constant string patterns.  You may still use
*note the old % operations: 524. ‘string % tuple’ and ‘string %
dictionary’.

  Be sure to use the ‘list.sort()’ built-in method to do sorting, and
see the sorting mini-HOWTO(4) for examples of moderately advanced usage.
‘list.sort()’ beats other techniques for sorting in all but the most
extreme circumstances.

  Another common trick is to "push loops into functions or methods."
For example suppose you have a program that runs slowly and you use the
profiler to determine that a Python function ‘ff()’ is being called lots
of times.  If you notice that ‘ff()’:

     def ff(x):
         ... # do something with x computing result...
         return result

  tends to be called in loops like:

     list = map(ff, oldlist)

  or:

     for x in sequence:
         value = ff(x)
         ... # do something with value...

  then you can often eliminate function call overhead by rewriting
‘ff()’ to:

     def ffseq(seq):
         resultseq = []
         for x in seq:
             ... # do something with x computing result...
             resultseq.append(result)
         return resultseq

  and rewrite the two examples to ‘list = ffseq(oldlist)’ and to:

     for value in ffseq(sequence):
         ... # do something with value...

  Single calls to ‘ff(x)’ translate to ‘ffseq([x])[0]’ with little
penalty.  Of course this technique is not always appropriate and there
are other variants which you can figure out.

  You can gain some performance by explicitly storing the results of a
function or method lookup into a local variable.  A loop like:

     for key in token:
         dict[key] = dict.get(key, 0) + 1

  resolves ‘dict.get’ every iteration.  If the method isn’t going to
change, a slightly faster implementation is:

     dict_get = dict.get  # look up the method once
     for key in token:
         dict[key] = dict_get(key, 0) + 1

  Default arguments can be used to determine values once, at compile
time instead of at run time.  This can only be done for functions or
objects which will not be changed during program execution, such as
replacing

     def degree_sin(deg):
         return math.sin(deg * math.pi / 180.0)

  with

     def degree_sin(deg, factor=math.pi/180.0, sin=math.sin):
         return sin(deg * factor)

  Because this trick uses default arguments for terms which should not
be changed, it should only be used when you are not concerned with
presenting a possibly confusing API to your users.

   ---------- Footnotes ----------

   (1) http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/

   (2) http://psyco.sourceforge.net

   (3) http://wiki.python.org/moin/PythonSpeed/PerformanceTips

   (4) http://wiki.python.org/moin/HowTo/Sorting


File: python.info,  Node: Core Language,  Next: Numbers and strings,  Prev: General Questions,  Up: Programming FAQ

11.2.2 Core Language
--------------------

* Menu:

* Why am I getting an UnboundLocalError when the variable has a value?:: 
* What are the rules for local and global variables in Python?:: 
* Why do lambdas defined in a loop with different values all return the same result?:: 
* How do I share global variables across modules?:: 
* What are the "best practices" for using import in a module?:: 
* How can I pass optional or keyword parameters from one function to another?:: 
* What is the difference between arguments and parameters?:: 
* How do I write a function with output parameters (call by reference)?: How do I write a function with output parameters call by reference ?. 
* How do you make a higher order function in Python?:: 
* How do I copy an object in Python?:: 
* How can I find the methods or attributes of an object?:: 
* How can my code discover the name of an object?:: 
* What's up with the comma operator's precedence?:: 
* Is there an equivalent of C’s "?;" ternary operator?: Is there an equivalent of C's "? " ternary operator?. 
* Is it possible to write obfuscated one-liners in Python?:: 


File: python.info,  Node: Why am I getting an UnboundLocalError when the variable has a value?,  Next: What are the rules for local and global variables in Python?,  Up: Core Language

11.2.2.1 Why am I getting an UnboundLocalError when the variable has a value?
.............................................................................

It can be a surprise to get the UnboundLocalError in previously working
code when it is modified by adding an assignment statement somewhere in
the body of a function.

  This code:

     >>> x = 10
     >>> def bar():
     ...     print x
     >>> bar()
     10

  works, but this code:

     >>> x = 10
     >>> def foo():
     ...     print x
     ...     x += 1

  results in an UnboundLocalError:

     >>> foo()
     Traceback (most recent call last):
       ...
     UnboundLocalError: local variable 'x' referenced before assignment

  This is because when you make an assignment to a variable in a scope,
that variable becomes local to that scope and shadows any similarly
named variable in the outer scope.  Since the last statement in foo
assigns a new value to ‘x’, the compiler recognizes it as a local
variable.  Consequently when the earlier ‘print x’ attempts to print the
uninitialized local variable and an error results.

  In the example above you can access the outer scope variable by
declaring it global:

     >>> x = 10
     >>> def foobar():
     ...     global x
     ...     print x
     ...     x += 1
     >>> foobar()
     10

  This explicit declaration is required in order to remind you that
(unlike the superficially analogous situation with class and instance
variables) you are actually modifying the value of the variable in the
outer scope:

     >>> print x
     11


File: python.info,  Node: What are the rules for local and global variables in Python?,  Next: Why do lambdas defined in a loop with different values all return the same result?,  Prev: Why am I getting an UnboundLocalError when the variable has a value?,  Up: Core Language

11.2.2.2 What are the rules for local and global variables in Python?
.....................................................................

In Python, variables that are only referenced inside a function are
implicitly global.  If a variable is assigned a new value anywhere
within the function’s body, it’s assumed to be a local.  If a variable
is ever assigned a new value inside the function, the variable is
implicitly local, and you need to explicitly declare it as ’global’.

  Though a bit surprising at first, a moment’s consideration explains
this.  On one hand, requiring *note global: 543. for assigned variables
provides a bar against unintended side-effects.  On the other hand, if
‘global’ was required for all global references, you’d be using ‘global’
all the time.  You’d have to declare as global every reference to a
built-in function or to a component of an imported module.  This clutter
would defeat the usefulness of the ‘global’ declaration for identifying
side-effects.


File: python.info,  Node: Why do lambdas defined in a loop with different values all return the same result?,  Next: How do I share global variables across modules?,  Prev: What are the rules for local and global variables in Python?,  Up: Core Language

11.2.2.3 Why do lambdas defined in a loop with different values all return the same result?
...........................................................................................

Assume you use a for loop to define a few different lambdas (or even
plain functions), e.g.:

     >>> squares = []
     >>> for x in range(5):
     ...    squares.append(lambda: x**2)

  This gives you a list that contains 5 lambdas that calculate ‘x**2’.
You might expect that, when called, they would return, respectively,
‘0’, ‘1’, ‘4’, ‘9’, and ‘16’.  However, when you actually try you will
see that they all return ‘16’:

     >>> squares[2]()
     16
     >>> squares[4]()
     16

  This happens because ‘x’ is not local to the lambdas, but is defined
in the outer scope, and it is accessed when the lambda is called — not
when it is defined.  At the end of the loop, the value of ‘x’ is ‘4’, so
all the functions now return ‘4**2’, i.e.  ‘16’.  You can also verify
this by changing the value of ‘x’ and see how the results of the lambdas
change:

     >>> x = 8
     >>> squares[2]()
     64

  In order to avoid this, you need to save the values in variables local
to the lambdas, so that they don’t rely on the value of the global ‘x’:

     >>> squares = []
     >>> for x in range(5):
     ...    squares.append(lambda n=x: n**2)

  Here, ‘n=x’ creates a new variable ‘n’ local to the lambda and
computed when the lambda is defined so that it has the same value that
‘x’ had at that point in the loop.  This means that the value of ‘n’
will be ‘0’ in the first lambda, ‘1’ in the second, ‘2’ in the third,
and so on.  Therefore each lambda will now return the correct result:

     >>> squares[2]()
     4
     >>> squares[4]()
     16

  Note that this behaviour is not peculiar to lambdas, but applies to
regular functions too.


File: python.info,  Node: How do I share global variables across modules?,  Next: What are the "best practices" for using import in a module?,  Prev: Why do lambdas defined in a loop with different values all return the same result?,  Up: Core Language

11.2.2.4 How do I share global variables across modules?
........................................................

The canonical way to share information across modules within a single
program is to create a special module (often called config or cfg).
Just import the config module in all modules of your application; the
module then becomes available as a global name.  Because there is only
one instance of each module, any changes made to the module object get
reflected everywhere.  For example:

  config.py:

     x = 0   # Default value of the 'x' configuration setting

  mod.py:

     import config
     config.x = 1

  main.py:

     import config
     import mod
     print config.x

  Note that using a module is also the basis for implementing the
Singleton design pattern, for the same reason.


File: python.info,  Node: What are the "best practices" for using import in a module?,  Next: How can I pass optional or keyword parameters from one function to another?,  Prev: How do I share global variables across modules?,  Up: Core Language

11.2.2.5 What are the "best practices" for using import in a module?
....................................................................

In general, don’t use ‘from modulename import *’.  Doing so clutters the
importer’s namespace.  Some people avoid this idiom even with the few
modules that were designed to be imported in this manner.  Modules
designed in this manner include *note Tkinter: 17d, and *note threading:
179.

  Import modules at the top of a file.  Doing so makes it clear what
other modules your code requires and avoids questions of whether the
module name is in scope.  Using one import per line makes it easy to add
and delete module imports, but using multiple imports per line uses less
screen space.

  It’s good practice if you import modules in the following order:

  1. standard library modules – e.g.  ‘sys’, ‘os’, ‘getopt’, ‘re’

  2. third-party library modules (anything installed in Python’s
     site-packages directory) – e.g.  mx.DateTime, ZODB, PIL.Image, etc.

  3. locally-developed modules

  Never use relative package imports.  If you’re writing code that’s in
the ‘package.sub.m1’ module and want to import ‘package.sub.m2’, do not
just write ‘import m2’, even though it’s legal.  Write ‘from package.sub
import m2’ instead.  Relative imports can lead to a module being
initialized twice, leading to confusing bugs.  See PEP 328(1) for
details.

  It is sometimes necessary to move imports to a function or class to
avoid problems with circular imports.  Gordon McMillan says:

     Circular imports are fine where both modules use the "import
     <module>" form of import.  They fail when the 2nd module wants to
     grab a name out of the first ("from module import name") and the
     import is at the top level.  That’s because names in the 1st are
     not yet available, because the first module is busy importing the
     2nd.

  In this case, if the second module is only used in one function, then
the import can easily be moved into that function.  By the time the
import is called, the first module will have finished initializing, and
the second module can do its import.

  It may also be necessary to move imports out of the top level of code
if some of the modules are platform-specific.  In that case, it may not
even be possible to import all of the modules at the top of the file.
In this case, importing the correct modules in the corresponding
platform-specific code is a good option.

  Only move imports into a local scope, such as inside a function
definition, if it’s necessary to solve a problem such as avoiding a
circular import or are trying to reduce the initialization time of a
module.  This technique is especially helpful if many of the imports are
unnecessary depending on how the program executes.  You may also want to
move imports into a function if the modules are only ever used in that
function.  Note that loading a module the first time may be expensive
because of the one time initialization of the module, but loading a
module multiple times is virtually free, costing only a couple of
dictionary lookups.  Even if the module name has gone out of scope, the
module is probably available in *note sys.modules: 824.

  If only instances of a specific class use a module, then it is
reasonable to import the module in the class’s ‘__init__’ method and
then assign the module to an instance variable so that the module is
always available (via that instance variable) during the life of the
object.  Note that to delay an import until the class is instantiated,
the import must be inside a method.  Putting the import inside the class
but outside of any method still causes the import to occur when the
module is initialized.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0328


File: python.info,  Node: How can I pass optional or keyword parameters from one function to another?,  Next: What is the difference between arguments and parameters?,  Prev: What are the "best practices" for using import in a module?,  Up: Core Language

11.2.2.6 How can I pass optional or keyword parameters from one function to another?
....................................................................................

Collect the arguments using the ‘*’ and ‘**’ specifiers in the
function’s parameter list; this gives you the positional arguments as a
tuple and the keyword arguments as a dictionary.  You can then pass
these arguments when calling another function by using ‘*’ and ‘**’:

     def f(x, *args, **kwargs):
         ...
         kwargs['width'] = '14.3c'
         ...
         g(x, *args, **kwargs)

  In the unlikely case that you care about Python versions older than
2.0, use *note apply(): 303.:

     def f(x, *args, **kwargs):
         ...
         kwargs['width'] = '14.3c'
         ...
         apply(g, (x,)+args, kwargs)


File: python.info,  Node: What is the difference between arguments and parameters?,  Next: How do I write a function with output parameters call by reference ?,  Prev: How can I pass optional or keyword parameters from one function to another?,  Up: Core Language

11.2.2.7 What is the difference between arguments and parameters?
.................................................................

*note Parameters: 7c6. are defined by the names that appear in a
function definition, whereas *note arguments: 7c0. are the values
actually passed to a function when calling it.  Parameters define what
types of arguments a function can accept.  For example, given the
function definition:

     def func(foo, bar=None, **kwargs):
         pass

  _foo_, _bar_ and _kwargs_ are parameters of ‘func’.  However, when
calling ‘func’, for example:

     func(42, bar=314, extra=somevar)

  the values ‘42’, ‘314’, and ‘somevar’ are arguments.


File: python.info,  Node: How do I write a function with output parameters call by reference ?,  Next: How do you make a higher order function in Python?,  Prev: What is the difference between arguments and parameters?,  Up: Core Language

11.2.2.8 How do I write a function with output parameters (call by reference)?
..............................................................................

Remember that arguments are passed by assignment in Python.  Since
assignment just creates references to objects, there’s no alias between
an argument name in the caller and callee, and so no call-by-reference
per se.  You can achieve the desired effect in a number of ways.

  1. By returning a tuple of the results:

          def func2(a, b):
              a = 'new-value'        # a and b are local names
              b = b + 1              # assigned to new objects
              return a, b            # return new values

          x, y = 'old-value', 99
          x, y = func2(x, y)
          print x, y                 # output: new-value 100

     This is almost always the clearest solution.

  2. By using global variables.  This isn’t thread-safe, and is not
     recommended.

  3. By passing a mutable (changeable in-place) object:

          def func1(a):
              a[0] = 'new-value'     # 'a' references a mutable list
              a[1] = a[1] + 1        # changes a shared object

          args = ['old-value', 99]
          func1(args)
          print args[0], args[1]     # output: new-value 100

  4. By passing in a dictionary that gets mutated:

          def func3(args):
              args['a'] = 'new-value'     # args is a mutable dictionary
              args['b'] = args['b'] + 1   # change it in-place

          args = {'a':' old-value', 'b': 99}
          func3(args)
          print args['a'], args['b']

  5. Or bundle up values in a class instance:

          class callByRef:
              def __init__(self, **args):
                  for (key, value) in args.items():
                      setattr(self, key, value)

          def func4(args):
              args.a = 'new-value'        # args is a mutable callByRef
              args.b = args.b + 1         # change object in-place

          args = callByRef(a='old-value', b=99)
          func4(args)
          print args.a, args.b

     There’s almost never a good reason to get this complicated.

  Your best choice is to return a tuple containing the multiple results.


File: python.info,  Node: How do you make a higher order function in Python?,  Next: How do I copy an object in Python?,  Prev: How do I write a function with output parameters call by reference ?,  Up: Core Language

11.2.2.9 How do you make a higher order function in Python?
...........................................................

You have two choices: you can use nested scopes or you can use callable
objects.  For example, suppose you wanted to define ‘linear(a,b)’ which
returns a function ‘f(x)’ that computes the value ‘a*x+b’.  Using nested
scopes:

     def linear(a, b):
         def result(x):
             return a * x + b
         return result

  Or using a callable object:

     class linear:

         def __init__(self, a, b):
             self.a, self.b = a, b

         def __call__(self, x):
             return self.a * x + self.b

  In both cases,

     taxes = linear(0.3, 2)

  gives a callable object where ‘taxes(10e6) == 0.3 * 10e6 + 2’.

  The callable object approach has the disadvantage that it is a bit
slower and results in slightly longer code.  However, note that a
collection of callables can share their signature via inheritance:

     class exponential(linear):
         # __init__ inherited
         def __call__(self, x):
             return self.a * (x ** self.b)

  Object can encapsulate state for several methods:

     class counter:

         value = 0

         def set(self, x):
             self.value = x

         def up(self):
             self.value = self.value + 1

         def down(self):
             self.value = self.value - 1

     count = counter()
     inc, dec, reset = count.up, count.down, count.set

  Here ‘inc()’, ‘dec()’ and ‘reset()’ act like functions which share the
same counting variable.


File: python.info,  Node: How do I copy an object in Python?,  Next: How can I find the methods or attributes of an object?,  Prev: How do you make a higher order function in Python?,  Up: Core Language

11.2.2.10 How do I copy an object in Python?
............................................

In general, try *note copy.copy(): c3a. or *note copy.deepcopy(): 20f.
for the general case.  Not all objects can be copied, but most can.

  Some objects can be copied more easily.  Dictionaries have a *note
copy(): 8fb. method:

     newdict = olddict.copy()

  Sequences can be copied by slicing:

     new_l = l[:]


File: python.info,  Node: How can I find the methods or attributes of an object?,  Next: How can my code discover the name of an object?,  Prev: How do I copy an object in Python?,  Up: Core Language

11.2.2.11 How can I find the methods or attributes of an object?
................................................................

For an instance x of a user-defined class, ‘dir(x)’ returns an
alphabetized list of the names containing the instance attributes and
methods and attributes defined by its class.


File: python.info,  Node: How can my code discover the name of an object?,  Next: What's up with the comma operator's precedence?,  Prev: How can I find the methods or attributes of an object?,  Up: Core Language

11.2.2.12 How can my code discover the name of an object?
.........................................................

Generally speaking, it can’t, because objects don’t really have names.
Essentially, assignment always binds a name to a value; The same is true
of ‘def’ and ‘class’ statements, but in that case the value is a
callable.  Consider the following code:

     class A:
         pass

     B = A

     a = B()
     b = a
     print b
     <__main__.A instance at 0x16D07CC>
     print a
     <__main__.A instance at 0x16D07CC>

  Arguably the class has a name: even though it is bound to two names
and invoked through the name B the created instance is still reported as
an instance of class A. However, it is impossible to say whether the
instance’s name is a or b, since both names are bound to the same value.

  Generally speaking it should not be necessary for your code to "know
the names" of particular values.  Unless you are deliberately writing
introspective programs, this is usually an indication that a change of
approach might be beneficial.

  In comp.lang.python, Fredrik Lundh once gave an excellent analogy in
answer to this question:

     The same way as you get the name of that cat you found on your
     porch: the cat (object) itself cannot tell you its name, and it
     doesn’t really care – so the only way to find out what it’s called
     is to ask all your neighbours (namespaces) if it’s their cat
     (object)...

     ....and don’t be surprised if you’ll find that it’s known by many
     names, or no name at all!


File: python.info,  Node: What's up with the comma operator's precedence?,  Next: Is there an equivalent of C's "? " ternary operator?,  Prev: How can my code discover the name of an object?,  Up: Core Language

11.2.2.13 What’s up with the comma operator’s precedence?
.........................................................

Comma is not an operator in Python.  Consider this session:

     >>> "a" in "b", "a"
     (False, 'a')

  Since the comma is not an operator, but a separator between
expressions the above is evaluated as if you had entered:

     ("a" in "b"), "a"

  not:

     "a" in ("b", "a")

  The same is true of the various assignment operators (‘=’, ‘+=’ etc).
They are not truly operators but syntactic delimiters in assignment
statements.


File: python.info,  Node: Is there an equivalent of C's "? " ternary operator?,  Next: Is it possible to write obfuscated one-liners in Python?,  Prev: What's up with the comma operator's precedence?,  Up: Core Language

11.2.2.14 Is there an equivalent of C’s "?:" ternary operator?
..............................................................

Yes, this feature was added in Python 2.5.  The syntax would be as
follows:

     [on_true] if [expression] else [on_false]

     x, y = 50, 25

     small = x if x < y else y

  For versions previous to 2.5 the answer would be ’No’.


File: python.info,  Node: Is it possible to write obfuscated one-liners in Python?,  Prev: Is there an equivalent of C's "? " ternary operator?,  Up: Core Language

11.2.2.15 Is it possible to write obfuscated one-liners in Python?
..................................................................

Yes.  Usually this is done by nesting *note lambda: 403. within *note
lambda: 403.  See the following three examples, due to Ulf Bartelt:

     # Primes < 1000
     print filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
     map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))

     # First 10 Fibonacci numbers
     print map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1: f(x,f),
     range(10))

     # Mandelbrot set
     print (lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,
     Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
     Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
     i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y
     >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
     64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
     ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24)
     #    \___ ___/  \___ ___/  |   |   |__ lines on screen
     #        V          V      |   |______ columns on screen
     #        |          |      |__________ maximum of "iterations"
     #        |          |_________________ range on y axis
     #        |____________________________ range on x axis

  Don’t try this at home, kids!


File: python.info,  Node: Numbers and strings,  Next: Sequences Tuples/Lists,  Prev: Core Language,  Up: Programming FAQ

11.2.3 Numbers and strings
--------------------------

* Menu:

* How do I specify hexadecimal and octal integers?:: 
* Why does -22 // 10 return -3?:: 
* How do I convert a string to a number?:: 
* How do I convert a number to a string?:: 
* How do I modify a string in place?:: 
* How do I use strings to call functions/methods?:: 
* Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?. 
* Is there a scanf() or sscanf() equivalent?: Is there a scanf or sscanf equivalent?. 
* What does ’UnicodeError; ASCII [decoding,encoding] error; ordinal not in range(128)’ mean?: What does 'UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ' mean?. 


File: python.info,  Node: How do I specify hexadecimal and octal integers?,  Next: Why does -22 // 10 return -3?,  Up: Numbers and strings

11.2.3.1 How do I specify hexadecimal and octal integers?
.........................................................

To specify an octal digit, precede the octal value with a zero, and then
a lower or uppercase "o".  For example, to set the variable "a" to the
octal value "10" (8 in decimal), type:

     >>> a = 0o10
     >>> a
     8

  Hexadecimal is just as easy.  Simply precede the hexadecimal number
with a zero, and then a lower or uppercase "x".  Hexadecimal digits can
be specified in lower or uppercase.  For example, in the Python
interpreter:

     >>> a = 0xa5
     >>> a
     165
     >>> b = 0XB2
     >>> b
     178


File: python.info,  Node: Why does -22 // 10 return -3?,  Next: How do I convert a string to a number?,  Prev: How do I specify hexadecimal and octal integers?,  Up: Numbers and strings

11.2.3.2 Why does -22 // 10 return -3?
......................................

It’s primarily driven by the desire that ‘i % j’ have the same sign as
‘j’.  If you want that, and also want:

     i == (i // j) * j + (i % j)

  then integer division has to return the floor.  C also requires that
identity to hold, and then compilers that truncate ‘i // j’ need to make
‘i % j’ have the same sign as ‘i’.

  There are few real use cases for ‘i % j’ when ‘j’ is negative.  When
‘j’ is positive, there are many, and in virtually all of them it’s more
useful for ‘i % j’ to be ‘>= 0’.  If the clock says 10 now, what did it
say 200 hours ago?  ‘-190 % 12 == 2’ is useful; ‘-190 % 12 == -10’ is a
bug waiting to bite.

     Note: On Python 2, ‘a / b’ returns the same as ‘a // b’ if
     ‘__future__.division’ is not in effect.  This is also known as
     "classic" division.


File: python.info,  Node: How do I convert a string to a number?,  Next: How do I convert a number to a string?,  Prev: Why does -22 // 10 return -3?,  Up: Numbers and strings

11.2.3.3 How do I convert a string to a number?
...............................................

For integers, use the built-in *note int(): 1f2. type constructor, e.g.
‘int('144') == 144’.  Similarly, *note float(): 1eb. converts to
floating-point, e.g.  ‘float('144') == 144.0’.

  By default, these interpret the number as decimal, so that
‘int('0144') == 144’ and ‘int('0x144')’ raises *note ValueError: 236.
‘int(string, base)’ takes the base to convert from as a second optional
argument, so ‘int('0x144', 16) == 324’.  If the base is specified as 0,
the number is interpreted using Python’s rules: a leading ’0’ indicates
octal, and ’0x’ indicates a hex number.

  Do not use the built-in function *note eval(): 360. if all you need is
to convert strings to numbers.  *note eval(): 360. will be significantly
slower and it presents a security risk: someone could pass you a Python
expression that might have unwanted side effects.  For example, someone
could pass ‘__import__('os').system("rm -rf $HOME")’ which would erase
your home directory.

  *note eval(): 360. also has the effect of interpreting numbers as
Python expressions, so that e.g.  ‘eval('09')’ gives a syntax error
because Python regards numbers starting with ’0’ as octal (base 8).


File: python.info,  Node: How do I convert a number to a string?,  Next: How do I modify a string in place?,  Prev: How do I convert a string to a number?,  Up: Numbers and strings

11.2.3.4 How do I convert a number to a string?
...............................................

To convert, e.g., the number 144 to the string ’144’, use the built-in
type constructor *note str(): 1ea.  If you want a hexadecimal or octal
representation, use the built-in functions *note hex(): 334. or *note
oct(): 325.  For fancy formatting, see the *note Format String Syntax:
308. section, e.g.  ‘"{:04d}".format(144)’ yields ‘'0144'’ and
‘"{:.3f}".format(1/3)’ yields ‘'0.333'’.  You may also use *note the %
operator: 524. on strings.  See the library reference manual for
details.


File: python.info,  Node: How do I modify a string in place?,  Next: How do I use strings to call functions/methods?,  Prev: How do I convert a number to a string?,  Up: Numbers and strings

11.2.3.5 How do I modify a string in place?
...........................................

You can’t, because strings are immutable.  If you need an object with
this ability, try converting the string to a list or use the array
module:

     >>> import io
     >>> s = "Hello, world"
     >>> a = list(s)
     >>> print a
     ['H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd']
     >>> a[7:] = list("there!")
     >>> ''.join(a)
     'Hello, there!'

     >>> import array
     >>> a = array.array('c', s)
     >>> print a
     array('c', 'Hello, world')
     >>> a[0] = 'y'; print a
     array('c', 'yello, world')
     >>> a.tostring()
     'yello, world'


File: python.info,  Node: How do I use strings to call functions/methods?,  Next: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?,  Prev: How do I modify a string in place?,  Up: Numbers and strings

11.2.3.6 How do I use strings to call functions/methods?
........................................................

There are various techniques.

   * The best is to use a dictionary that maps strings to functions.
     The primary advantage of this technique is that the strings do not
     need to match the names of the functions.  This is also the primary
     technique used to emulate a case construct:

          def a():
              pass

          def b():
              pass

          dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

          dispatch[get_input()]()  # Note trailing parens to call function

   * Use the built-in function *note getattr(): 875.:

          import foo
          getattr(foo, 'bar')()

     Note that *note getattr(): 875. works on any object, including
     classes, class instances, modules, and so on.

     This is used in several places in the standard library, like this:

          class Foo:
              def do_foo(self):
                  ...

              def do_bar(self):
                  ...

          f = getattr(foo_instance, 'do_' + opname)
          f()

   * Use *note locals(): 33c. or *note eval(): 360. to resolve the
     function name:

          def myFunc():
              print "hello"

          fname = "myFunc"

          f = locals()[fname]
          f()

          f = eval(fname)
          f()

     Note: Using *note eval(): 360. is slow and dangerous.  If you don’t
     have absolute control over the contents of the string, someone
     could pass a string that resulted in an arbitrary function being
     executed.


File: python.info,  Node: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?,  Next: Is there a scanf or sscanf equivalent?,  Prev: How do I use strings to call functions/methods?,  Up: Numbers and strings

11.2.3.7 Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?
..............................................................................................

Starting with Python 2.2, you can use ‘S.rstrip("\r\n")’ to remove all
occurrences of any line terminator from the end of the string ‘S’
without removing other trailing whitespace.  If the string ‘S’
represents more than one line, with several empty lines at the end, the
line terminators for all the blank lines will be removed:

     >>> lines = ("line 1 \r\n"
     ...          "\r\n"
     ...          "\r\n")
     >>> lines.rstrip("\n\r")
     'line 1 '

  Since this is typically only desired when reading text one line at a
time, using ‘S.rstrip()’ this way works well.

  For older versions of Python, there are two partial substitutes:

   - If you want to remove all trailing whitespace, use the ‘rstrip()’
     method of string objects.  This removes all trailing whitespace,
     not just a single newline.

   - Otherwise, if there is only one line in the string ‘S’, use
     ‘S.splitlines()[0]’.


File: python.info,  Node: Is there a scanf or sscanf equivalent?,  Next: What does 'UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ' mean?,  Prev: Is there an equivalent to Perl's chomp for removing trailing newlines from strings?,  Up: Numbers and strings

11.2.3.8 Is there a scanf() or sscanf() equivalent?
...................................................

Not as such.

  For simple input parsing, the easiest approach is usually to split the
line into whitespace-delimited words using the *note split(): 8d5.
method of string objects and then convert decimal strings to numeric
values using *note int(): 1f2. or *note float(): 1eb.  ‘split()’
supports an optional "sep" parameter which is useful if the line uses
something other than whitespace as a separator.

  For more complicated input parsing, regular expressions are more
powerful than C’s ‘sscanf()’ and better suited for the task.


File: python.info,  Node: What does 'UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ' mean?,  Prev: Is there a scanf or sscanf equivalent?,  Up: Numbers and strings

11.2.3.9 What does ’UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)’ mean?
...................................................................................................

This error indicates that your Python installation can handle only 7-bit
ASCII strings.  There are a couple ways to fix or work around the
problem.

  If your programs must handle data in arbitrary character set
encodings, the environment the application runs in will generally
identify the encoding of the data it is handing you.  You need to
convert the input to Unicode data using that encoding.  For example, a
program that handles email or web input will typically find character
set encoding information in Content-Type headers.  This can then be used
to properly convert input data to Unicode.  Assuming the string referred
to by ‘value’ is encoded as UTF-8:

     value = unicode(value, "utf-8")

  will return a Unicode object.  If the data is not correctly encoded as
UTF-8, the above call will raise a *note UnicodeError: 433. exception.

  If you only want strings converted to Unicode which have non-ASCII
data, you can try converting them first assuming an ASCII encoding, and
then generate Unicode objects if that fails:

     try:
         x = unicode(value, "ascii")
     except UnicodeError:
         value = unicode(value, "utf-8")
     else:
         # value was valid ASCII data
         pass

  It’s possible to set a default encoding in a file called
‘sitecustomize.py’ that’s part of the Python library.  However, this
isn’t recommended because changing the Python-wide default encoding may
cause third-party extension modules to fail.

  Note that on Windows, there is an encoding known as "mbcs", which uses
an encoding specific to your current locale.  In many cases, and
particularly when working with COM, this may be an appropriate default
encoding to use.


File: python.info,  Node: Sequences Tuples/Lists,  Next: Dictionaries<2>,  Prev: Numbers and strings,  Up: Programming FAQ

11.2.4 Sequences (Tuples/Lists)
-------------------------------

* Menu:

* How do I convert between tuples and lists?:: 
* What's a negative index?:: 
* How do I iterate over a sequence in reverse order?:: 
* How do you remove duplicates from a list?:: 
* How do you make an array in Python?:: 
* How do I create a multidimensional list?:: 
* How do I apply a method to a sequence of objects?:: 
* Why does a_tuple[i] += ['item'] raise an exception when the addition works?:: 


File: python.info,  Node: How do I convert between tuples and lists?,  Next: What's a negative index?,  Up: Sequences Tuples/Lists

11.2.4.1 How do I convert between tuples and lists?
...................................................

The type constructor ‘tuple(seq)’ converts any sequence (actually, any
iterable) into a tuple with the same items in the same order.

  For example, ‘tuple([1, 2, 3])’ yields ‘(1, 2, 3)’ and ‘tuple('abc')’
yields ‘('a', 'b', 'c')’.  If the argument is a tuple, it does not make
a copy but returns the same object, so it is cheap to call *note
tuple(): 408. when you aren’t sure that an object is already a tuple.

  The type constructor ‘list(seq)’ converts any sequence or iterable
into a list with the same items in the same order.  For example,
‘list((1, 2, 3))’ yields ‘[1, 2, 3]’ and ‘list('abc')’ yields ‘['a',
'b', 'c']’.  If the argument is a list, it makes a copy just like
‘seq[:]’ would.


File: python.info,  Node: What's a negative index?,  Next: How do I iterate over a sequence in reverse order?,  Prev: How do I convert between tuples and lists?,  Up: Sequences Tuples/Lists

11.2.4.2 What’s a negative index?
.................................

Python sequences are indexed with positive numbers and negative numbers.
For positive numbers 0 is the first index 1 is the second index and so
forth.  For negative indices -1 is the last index and -2 is the
penultimate (next to last) index and so forth.  Think of ‘seq[-n]’ as
the same as ‘seq[len(seq)-n]’.

  Using negative indices can be very convenient.  For example ‘S[:-1]’
is all of the string except for its last character, which is useful for
removing the trailing newline from a string.


File: python.info,  Node: How do I iterate over a sequence in reverse order?,  Next: How do you remove duplicates from a list?,  Prev: What's a negative index?,  Up: Sequences Tuples/Lists

11.2.4.3 How do I iterate over a sequence in reverse order?
...........................................................

Use the *note reversed(): 3f8. built-in function, which is new in Python
2.4:

     for x in reversed(sequence):
         ... # do something with x...

  This won’t touch your original sequence, but build a new copy with
reversed order to iterate over.

  With Python 2.3, you can use an extended slice syntax:

     for x in sequence[::-1]:
         ... # do something with x...


File: python.info,  Node: How do you remove duplicates from a list?,  Next: How do you make an array in Python?,  Prev: How do I iterate over a sequence in reverse order?,  Up: Sequences Tuples/Lists

11.2.4.4 How do you remove duplicates from a list?
..................................................

See the Python Cookbook for a long discussion of many ways to do this:

     ‘http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560’

  If you don’t mind reordering the list, sort it and then scan from the
end of the list, deleting duplicates as you go:

     if mylist:
         mylist.sort()
         last = mylist[-1]
         for i in range(len(mylist)-2, -1, -1):
             if last == mylist[i]:
                 del mylist[i]
             else:
                 last = mylist[i]

  If all elements of the list may be used as dictionary keys (i.e.  they
are all hashable) this is often faster

     d = {}
     for x in mylist:
         d[x] = 1
     mylist = list(d.keys())

  In Python 2.5 and later, the following is possible instead:

     mylist = list(set(mylist))

  This converts the list into a set, thereby removing duplicates, and
then back into a list.


File: python.info,  Node: How do you make an array in Python?,  Next: How do I create a multidimensional list?,  Prev: How do you remove duplicates from a list?,  Up: Sequences Tuples/Lists

11.2.4.5 How do you make an array in Python?
............................................

Use a list:

     ["this", 1, "is", "an", "array"]

  Lists are equivalent to C or Pascal arrays in their time complexity;
the primary difference is that a Python list can contain objects of many
different types.

  The ‘array’ module also provides methods for creating arrays of fixed
types with compact representations, but they are slower to index than
lists.  Also note that the Numeric extensions and others define
array-like structures with various characteristics as well.

  To get Lisp-style linked lists, you can emulate cons cells using
tuples:

     lisp_list = ("like",  ("this",  ("example", None) ) )

  If mutability is desired, you could use lists instead of tuples.  Here
the analogue of lisp car is ‘lisp_list[0]’ and the analogue of cdr is
‘lisp_list[1]’.  Only do this if you’re sure you really need to, because
it’s usually a lot slower than using Python lists.


File: python.info,  Node: How do I create a multidimensional list?,  Next: How do I apply a method to a sequence of objects?,  Prev: How do you make an array in Python?,  Up: Sequences Tuples/Lists

11.2.4.6 How do I create a multidimensional list?
.................................................

You probably tried to make a multidimensional array like this:

     >>> A = [[None] * 2] * 3

  This looks correct if you print it:

     >>> A
     [[None, None], [None, None], [None, None]]

  But when you assign a value, it shows up in multiple places:

     >>> A[0][0] = 5
     >>> A
     [[5, None], [5, None], [5, None]]

  The reason is that replicating a list with ‘*’ doesn’t create copies,
it only creates references to the existing objects.  The ‘*3’ creates a
list containing 3 references to the same list of length two.  Changes to
one row will show in all rows, which is almost certainly not what you
want.

  The suggested approach is to create a list of the desired length first
and then fill in each element with a newly created list:

     A = [None] * 3
     for i in range(3):
         A[i] = [None] * 2

  This generates a list containing 3 different lists of length two.  You
can also use a list comprehension:

     w, h = 2, 3
     A = [[None] * w for i in range(h)]

  Or, you can use an extension that provides a matrix datatype; Numeric
Python(1) is the best known.

   ---------- Footnotes ----------

   (1) http://www.numpy.org/


File: python.info,  Node: How do I apply a method to a sequence of objects?,  Next: Why does a_tuple[i] += ['item'] raise an exception when the addition works?,  Prev: How do I create a multidimensional list?,  Up: Sequences Tuples/Lists

11.2.4.7 How do I apply a method to a sequence of objects?
..........................................................

Use a list comprehension:

     result = [obj.method() for obj in mylist]

  More generically, you can try the following function:

     def method_map(objects, method, arguments):
         """method_map([a,b], "meth", (1,2)) gives [a.meth(1,2), b.meth(1,2)]"""
         nobjects = len(objects)
         methods = map(getattr, objects, [method]*nobjects)
         return map(apply, methods, [arguments]*nobjects)


File: python.info,  Node: Why does a_tuple[i] += ['item'] raise an exception when the addition works?,  Prev: How do I apply a method to a sequence of objects?,  Up: Sequences Tuples/Lists

11.2.4.8 Why does a_tuple[i] += [’item’] raise an exception when the addition works?
....................................................................................

This is because of a combination of the fact that augmented assignment
operators are _assignment_ operators, and the difference between mutable
and immutable objects in Python.

  This discussion applies in general when augmented assignment operators
are applied to elements of a tuple that point to mutable objects, but
we’ll use a ‘list’ and ‘+=’ as our exemplar.

  If you wrote:

     >>> a_tuple = (1, 2)
     >>> a_tuple[0] += 1
     Traceback (most recent call last):
        ...
     TypeError: 'tuple' object does not support item assignment

  The reason for the exception should be immediately clear: ‘1’ is added
to the object ‘a_tuple[0]’ points to (‘1’), producing the result object,
‘2’, but when we attempt to assign the result of the computation, ‘2’,
to element ‘0’ of the tuple, we get an error because we can’t change
what an element of a tuple points to.

  Under the covers, what this augmented assignment statement is doing is
approximately this:

     >>> result = a_tuple[0] + 1
     >>> a_tuple[0] = result
     Traceback (most recent call last):
       ...
     TypeError: 'tuple' object does not support item assignment

  It is the assignment part of the operation that produces the error,
since a tuple is immutable.

  When you write something like:

     >>> a_tuple = (['foo'], 'bar')
     >>> a_tuple[0] += ['item']
     Traceback (most recent call last):
       ...
     TypeError: 'tuple' object does not support item assignment

  The exception is a bit more surprising, and even more surprising is
the fact that even though there was an error, the append worked:

     >>> a_tuple[0]
     ['foo', 'item']

  To see why this happens, you need to know that (a) if an object
implements an ‘__iadd__’ magic method, it gets called when the ‘+=’
augmented assignment is executed, and its return value is what gets used
in the assignment statement; and (b) for lists, ‘__iadd__’ is equivalent
to calling ‘extend’ on the list and returning the list.  That’s why we
say that for lists, ‘+=’ is a "shorthand" for ‘list.extend’:

     >>> a_list = []
     >>> a_list += [1]
     >>> a_list
     [1]

  This is equivalent to:

     >>> result = a_list.__iadd__([1])
     >>> a_list = result

  The object pointed to by a_list has been mutated, and the pointer to
the mutated object is assigned back to ‘a_list’.  The end result of the
assignment is a no-op, since it is a pointer to the same object that
‘a_list’ was previously pointing to, but the assignment still happens.

  Thus, in our tuple example what is happening is equivalent to:

     >>> result = a_tuple[0].__iadd__(['item'])
     >>> a_tuple[0] = result
     Traceback (most recent call last):
       ...
     TypeError: 'tuple' object does not support item assignment

  The ‘__iadd__’ succeeds, and thus the list is extended, but even
though ‘result’ points to the same object that ‘a_tuple[0]’ already
points to, that final assignment still results in an error, because
tuples are immutable.


File: python.info,  Node: Dictionaries<2>,  Next: Objects,  Prev: Sequences Tuples/Lists,  Up: Programming FAQ

11.2.5 Dictionaries
-------------------

* Menu:

* How can I get a dictionary to display its keys in a consistent order?:: 
* I want to do a complicated sort; can you do a Schwartzian Transform in Python?: I want to do a complicated sort can you do a Schwartzian Transform in Python?. 
* How can I sort one list by values from another list?:: 


File: python.info,  Node: How can I get a dictionary to display its keys in a consistent order?,  Next: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Up: Dictionaries<2>

11.2.5.1 How can I get a dictionary to display its keys in a consistent order?
..............................................................................

You can’t.  Dictionaries store their keys in an unpredictable order, so
the display order of a dictionary’s elements will be similarly
unpredictable.

  This can be frustrating if you want to save a printable version to a
file, make some changes and then compare it with some other printed
dictionary.  In this case, use the ‘pprint’ module to pretty-print the
dictionary; the items will be presented in order sorted by the key.

  A more complicated solution is to subclass ‘dict’ to create a
‘SortedDict’ class that prints itself in a predictable order.  Here’s
one simpleminded implementation of such a class:

     class SortedDict(dict):
         def __repr__(self):
             keys = sorted(self.keys())
             result = ("{!r}: {!r}".format(k, self[k]) for k in keys)
             return "{{{}}}".format(", ".join(result))

         __str__ = __repr__

  This will work for many common situations you might encounter, though
it’s far from a perfect solution.  The largest flaw is that if some
values in the dictionary are also dictionaries, their values won’t be
presented in any particular order.


File: python.info,  Node: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Next: How can I sort one list by values from another list?,  Prev: How can I get a dictionary to display its keys in a consistent order?,  Up: Dictionaries<2>

11.2.5.2 I want to do a complicated sort: can you do a Schwartzian Transform in Python?
.......................................................................................

The technique, attributed to Randal Schwartz of the Perl community,
sorts the elements of a list by a metric which maps each element to its
"sort value".  In Python, just use the ‘key’ argument for the ‘sort()’
method:

     Isorted = L[:]
     Isorted.sort(key=lambda s: int(s[10:15]))

  The ‘key’ argument is new in Python 2.4, for older versions this kind
of sorting is quite simple to do with list comprehensions.  To sort a
list of strings by their uppercase values:

     tmp1 = [(x.upper(), x) for x in L]  # Schwartzian transform
     tmp1.sort()
     Usorted = [x[1] for x in tmp1]

  To sort by the integer value of a subfield extending from positions
10-15 in each string:

     tmp2 = [(int(s[10:15]), s) for s in L]  # Schwartzian transform
     tmp2.sort()
     Isorted = [x[1] for x in tmp2]

  Note that Isorted may also be computed by

     def intfield(s):
         return int(s[10:15])

     def Icmp(s1, s2):
         return cmp(intfield(s1), intfield(s2))

     Isorted = L[:]
     Isorted.sort(Icmp)

  but since this method calls ‘intfield()’ many times for each element
of L, it is slower than the Schwartzian Transform.


File: python.info,  Node: How can I sort one list by values from another list?,  Prev: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Up: Dictionaries<2>

11.2.5.3 How can I sort one list by values from another list?
.............................................................

Merge them into a single list of tuples, sort the resulting list, and
then pick out the element you want.

     >>> list1 = ["what", "I'm", "sorting", "by"]
     >>> list2 = ["something", "else", "to", "sort"]
     >>> pairs = zip(list1, list2)
     >>> pairs
     [('what', 'something'), ("I'm", 'else'), ('sorting', 'to'), ('by', 'sort')]
     >>> pairs.sort()
     >>> result = [ x[1] for x in pairs ]
     >>> result
     ['else', 'sort', 'to', 'something']

  An alternative for the last step is:

     >>> result = []
     >>> for p in pairs: result.append(p[1])

  If you find this more legible, you might prefer to use this instead of
the final list comprehension.  However, it is almost twice as slow for
long lists.  Why?  First, the ‘append()’ operation has to reallocate
memory, and while it uses some tricks to avoid doing that each time, it
still has to do it occasionally, and that costs quite a bit.  Second,
the expression "result.append" requires an extra attribute lookup, and
third, there’s a speed reduction from having to make all those function
calls.


File: python.info,  Node: Objects,  Next: Modules<3>,  Prev: Dictionaries<2>,  Up: Programming FAQ

11.2.6 Objects
--------------

* Menu:

* What is a class?:: 
* What is a method?:: 
* What is self?:: 
* How do I check if an object is an instance of a given class or of a subclass of it?:: 
* What is delegation?:: 
* How do I call a method defined in a base class from a derived class that overrides it?:: 
* How can I organize my code to make it easier to change the base class?:: 
* How do I create static class data and static class methods?:: 
* How can I overload constructors (or methods) in Python?: How can I overload constructors or methods in Python?. 
* I try to use __spam and I get an error about _SomeClassName__spam.: I try to use __spam and I get an error about _SomeClassName__spam. 
* My class defines __del__ but it is not called when I delete the object.: My class defines __del__ but it is not called when I delete the object. 
* How do I get a list of all instances of a given class?:: 
* Why does the result of id() appear to be not unique?: Why does the result of id appear to be not unique?. 


File: python.info,  Node: What is a class?,  Next: What is a method?,  Up: Objects

11.2.6.1 What is a class?
.........................

A class is the particular object type created by executing a class
statement.  Class objects are used as templates to create instance
objects, which embody both the data (attributes) and code (methods)
specific to a datatype.

  A class can be based on one or more other classes, called its base
class(es).  It then inherits the attributes and methods of its base
classes.  This allows an object model to be successively refined by
inheritance.  You might have a generic ‘Mailbox’ class that provides
basic accessor methods for a mailbox, and subclasses such as
‘MboxMailbox’, ‘MaildirMailbox’, ‘OutlookMailbox’ that handle various
specific mailbox formats.


File: python.info,  Node: What is a method?,  Next: What is self?,  Prev: What is a class?,  Up: Objects

11.2.6.2 What is a method?
..........................

A method is a function on some object ‘x’ that you normally call as
‘x.name(arguments...)’.  Methods are defined as functions inside the
class definition:

     class C:
         def meth (self, arg):
             return arg * 2 + self.attribute


File: python.info,  Node: What is self?,  Next: How do I check if an object is an instance of a given class or of a subclass of it?,  Prev: What is a method?,  Up: Objects

11.2.6.3 What is self?
......................

Self is merely a conventional name for the first argument of a method.
A method defined as ‘meth(self, a, b, c)’ should be called as ‘x.meth(a,
b, c)’ for some instance ‘x’ of the class in which the definition
occurs; the called method will think it is called as ‘meth(x, a, b, c)’.

  See also *note Why must ’self’ be used explicitly in method
definitions and calls?: 3112.


File: python.info,  Node: How do I check if an object is an instance of a given class or of a subclass of it?,  Next: What is delegation?,  Prev: What is self?,  Up: Objects

11.2.6.4 How do I check if an object is an instance of a given class or of a subclass of it?
............................................................................................

Use the built-in function ‘isinstance(obj, cls)’.  You can check if an
object is an instance of any of a number of classes by providing a tuple
instead of a single class, e.g.  ‘isinstance(obj, (class1, class2,
...))’, and can also check whether an object is one of Python’s built-in
types, e.g.  ‘isinstance(obj, str)’ or ‘isinstance(obj, (int, long,
float, complex))’.

  Note that most programs do not use *note isinstance(): 31e. on
user-defined classes very often.  If you are developing the classes
yourself, a more proper object-oriented style is to define methods on
the classes that encapsulate a particular behaviour, instead of checking
the object’s class and doing a different thing based on what class it
is.  For example, if you have a function that does something:

     def search(obj):
         if isinstance(obj, Mailbox):
             # ... code to search a mailbox
         elif isinstance(obj, Document):
             # ... code to search a document
         elif ...

  A better approach is to define a ‘search()’ method on all the classes
and just call it:

     class Mailbox:
         def search(self):
             # ... code to search a mailbox

     class Document:
         def search(self):
             # ... code to search a document

     obj.search()

