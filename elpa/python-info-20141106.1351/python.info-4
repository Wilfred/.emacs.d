This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: Numbers,  Next: Strings,  Up: Using Python as a Calculator

2.3.1.1 Numbers
...............

The interpreter acts as a simple calculator: you can type an expression
at it and it will write the value.  Expression syntax is
straightforward: the operators ‘+’, ‘-’, ‘*’ and ‘/’ work just like in
most other languages (for example, Pascal or C); parentheses can be used
for grouping.  For example:

     >>> 2+2
     4
     >>> # This is a comment
     ... 2+2
     4
     >>> 2+2  # and a comment on the same line as code
     4
     >>> (50-5*6)/4
     5
     >>> # Integer division returns the floor:
     ... 7/3
     2
     >>> 7/-3
     -3

  The equal sign (‘'='’) is used to assign a value to a variable.
Afterwards, no result is displayed before the next interactive prompt:

     >>> width = 20
     >>> height = 5*9
     >>> width * height
     900

  A value can be assigned to several variables simultaneously:

     >>> x = y = z = 0  # Zero x, y and z
     >>> x
     0
     >>> y
     0
     >>> z
     0

  Variables must be "defined" (assigned a value) before they can be
used, or an error will occur:

     >>> n  # try to access an undefined variable
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     NameError: name 'n' is not defined

  There is full support for floating point; operators with mixed type
operands convert the integer operand to floating point:

     >>> 3 * 3.75 / 1.5
     7.5
     >>> 7.0 / 2
     3.5

  Complex numbers are also supported; imaginary numbers are written with
a suffix of ‘j’ or ‘J’.  Complex numbers with a nonzero real component
are written as ‘(real+imagj)’, or can be created with the ‘complex(real,
imag)’ function.

     >>> 1j * 1J
     (-1+0j)
     >>> 1j * complex(0,1)
     (-1+0j)
     >>> 3+1j*3
     (3+3j)
     >>> (3+1j)*3
     (9+3j)
     >>> (1+2j)/(1+1j)
     (1.5+0.5j)

  Complex numbers are always represented as two floating point numbers,
the real and imaginary part.  To extract these parts from a complex
number _z_, use ‘z.real’ and ‘z.imag’.

     >>> a=1.5+0.5j
     >>> a.real
     1.5
     >>> a.imag
     0.5

  The conversion functions to floating point and integer (*note float():
1eb, *note int(): 1f2. and *note long(): 1f3.) don’t work for complex
numbers — there is no one correct way to convert a complex number to a
real number.  Use ‘abs(z)’ to get its magnitude (as a float) or ‘z.real’
to get its real part.

     >>> a=3.0+4.0j
     >>> float(a)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: can't convert complex to float; use abs(z)
     >>> a.real
     3.0
     >>> a.imag
     4.0
     >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
     5.0

  In interactive mode, the last printed expression is assigned to the
variable ‘_’.  This means that when you are using Python as a desk
calculator, it is somewhat easier to continue calculations, for example:

     >>> tax = 12.5 / 100
     >>> price = 100.50
     >>> price * tax
     12.5625
     >>> price + _
     113.0625
     >>> round(_, 2)
     113.06

  This variable should be treated as read-only by the user.  Don’t
explicitly assign a value to it — you would create an independent local
variable with the same name masking the built-in variable with its magic
behavior.


File: python.info,  Node: Strings,  Next: Unicode Strings,  Prev: Numbers,  Up: Using Python as a Calculator

2.3.1.2 Strings
...............

Besides numbers, Python can also manipulate strings, which can be
expressed in several ways.  They can be enclosed in single quotes or
double quotes:

     >>> 'spam eggs'
     'spam eggs'
     >>> 'doesn\'t'
     "doesn't"
     >>> "doesn't"
     "doesn't"
     >>> '"Yes," he said.'
     '"Yes," he said.'
     >>> "\"Yes,\" he said."
     '"Yes," he said.'
     >>> '"Isn\'t," she said.'
     '"Isn\'t," she said.'

  The interpreter prints the result of string operations in the same way
as they are typed for input: inside quotes, and with quotes and other
funny characters escaped by backslashes, to show the precise value.  The
string is enclosed in double quotes if the string contains a single
quote and no double quotes, else it’s enclosed in single quotes.  The
*note print: 4e0. statement produces a more readable output for such
input strings.

  String literals can span multiple lines in several ways.  Continuation
lines can be used, with a backslash as the last character on the line
indicating that the next line is a logical continuation of the line:

     hello = "This is a rather long string containing\n\
     several lines of text just as you would do in C.\n\
         Note that whitespace at the beginning of the line is\
      significant."

     print hello

  Note that newlines still need to be embedded in the string using ‘\n’
– the newline following the trailing backslash is discarded.  This
example would print the following:

     This is a rather long string containing
     several lines of text just as you would do in C.
         Note that whitespace at the beginning of the line is significant.

  Or, strings can be surrounded in a pair of matching triple-quotes:
‘"""’ or ‘'''’.  End of lines do not need to be escaped when using
triple-quotes, but they will be included in the string.

     print """
     Usage: thingy [OPTIONS]
          -h                        Display this usage message
          -H hostname               Hostname to connect to
     """

  produces the following output:

     Usage: thingy [OPTIONS]
          -h                        Display this usage message
          -H hostname               Hostname to connect to

  If we make the string literal a "raw" string, ‘\n’ sequences are not
converted to newlines, but the backslash at the end of the line, and the
newline character in the source, are both included in the string as
data.  Thus, the example:

     hello = r"This is a rather long string containing\n\
     several lines of text much as you would do in C."

     print hello

  would print:

     This is a rather long string containing\n\
     several lines of text much as you would do in C.

  Strings can be concatenated (glued together) with the ‘+’ operator,
and repeated with ‘*’:

     >>> word = 'Help' + 'A'
     >>> word
     'HelpA'
     >>> '<' + word*5 + '>'
     '<HelpAHelpAHelpAHelpAHelpA>'

  Two string literals next to each other are automatically concatenated;
the first line above could also have been written ‘word = 'Help' 'A'’;
this only works with two literals, not with arbitrary string
expressions:

     >>> 'str' 'ing'                   #  <-  This is ok
     'string'
     >>> 'str'.strip() + 'ing'   #  <-  This is ok
     'string'
     >>> 'str'.strip() 'ing'     #  <-  This is invalid
       File "<stdin>", line 1, in ?
         'str'.strip() 'ing'
                           ^
     SyntaxError: invalid syntax

  Strings can be subscripted (indexed); like in C, the first character
of a string has subscript (index) 0.  There is no separate character
type; a character is simply a string of size one.  Like in Icon,
substrings can be specified with the _slice notation_: two indices
separated by a colon.

     >>> word[4]
     'A'
     >>> word[0:2]
     'He'
     >>> word[2:4]
     'lp'

  Slice indices have useful defaults; an omitted first index defaults to
zero, an omitted second index defaults to the size of the string being
sliced.

     >>> word[:2]    # The first two characters
     'He'
     >>> word[2:]    # Everything except the first two characters
     'lpA'

  Unlike a C string, Python strings cannot be changed.  Assigning to an
indexed position in the string results in an error:

     >>> word[0] = 'x'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: object does not support item assignment
     >>> word[:1] = 'Splat'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: object does not support slice assignment

  However, creating a new string with the combined content is easy and
efficient:

     >>> 'x' + word[1:]
     'xelpA'
     >>> 'Splat' + word[4]
     'SplatA'

  Here’s a useful invariant of slice operations: ‘s[:i] + s[i:]’ equals
‘s’.

     >>> word[:2] + word[2:]
     'HelpA'
     >>> word[:3] + word[3:]
     'HelpA'

  Degenerate slice indices are handled gracefully: an index that is too
large is replaced by the string size, an upper bound smaller than the
lower bound returns an empty string.

     >>> word[1:100]
     'elpA'
     >>> word[10:]
     ''
     >>> word[2:1]
     ''

  Indices may be negative numbers, to start counting from the right.
For example:

     >>> word[-1]     # The last character
     'A'
     >>> word[-2]     # The last-but-one character
     'p'
     >>> word[-2:]    # The last two characters
     'pA'
     >>> word[:-2]    # Everything except the last two characters
     'Hel'

  But note that -0 is really the same as 0, so it does not count from
the right!

     >>> word[-0]     # (since -0 equals 0)
     'H'

  Out-of-range negative slice indices are truncated, but don’t try this
for single-element (non-slice) indices:

     >>> word[-100:]
     'HelpA'
     >>> word[-10]    # error
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     IndexError: string index out of range

  One way to remember how slices work is to think of the indices as
pointing _between_ characters, with the left edge of the first character
numbered 0.  Then the right edge of the last character of a string of
_n_ characters has index _n_, for example:

      +---+---+---+---+---+
      | H | e | l | p | A |
      +---+---+---+---+---+
      0   1   2   3   4   5
     -5  -4  -3  -2  -1

  The first row of numbers gives the position of the indices 0...5 in
the string; the second row gives the corresponding negative indices.
The slice from _i_ to _j_ consists of all characters between the edges
labeled _i_ and _j_, respectively.

  For non-negative indices, the length of a slice is the difference of
the indices, if both are within bounds.  For example, the length of
‘word[1:3]’ is 2.

  The built-in function *note len(): 520. returns the length of a
string:

     >>> s = 'supercalifragilisticexpialidocious'
     >>> len(s)
     34

See also
........

*note Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange: 521.

     Strings, and the Unicode strings described in the next section, are
     examples of _sequence types_, and support the common operations
     supported by such types.

*note String Methods: 522.

     Both strings and Unicode strings support a large number of methods
     for basic transformations and searching.

*note String Formatting: 523.

     Information about string formatting with *note str.format(): 1d2.
     is described here.

*note String Formatting Operations: 524.

     The old formatting operations invoked when strings and Unicode
     strings are the left operand of the ‘%’ operator are described in
     more detail here.


File: python.info,  Node: Unicode Strings,  Next: Lists,  Prev: Strings,  Up: Using Python as a Calculator

2.3.1.3 Unicode Strings
.......................

Starting with Python 2.0 a new data type for storing text data is
available to the programmer: the Unicode object.  It can be used to
store and manipulate Unicode data (see ‘http://www.unicode.org/’) and
integrates well with the existing string objects, providing
auto-conversions where necessary.

  Unicode has the advantage of providing one ordinal for every character
in every script used in modern and ancient texts.  Previously, there
were only 256 possible ordinals for script characters.  Texts were
typically bound to a code page which mapped the ordinals to script
characters.  This lead to very much confusion especially with respect to
internationalization (usually written as ‘i18n’ — ‘'i'’ + 18 characters
+ ‘'n'’) of software.  Unicode solves these problems by defining one
code page for all scripts.

  Creating Unicode strings in Python is just as simple as creating
normal strings:

     >>> u'Hello World !'
     u'Hello World !'

  The small ‘'u'’ in front of the quote indicates that a Unicode string
is supposed to be created.  If you want to include special characters in
the string, you can do so by using the Python _Unicode-Escape_ encoding.
The following example shows how:

     >>> u'Hello\u0020World !'
     u'Hello World !'

  The escape sequence ‘\u0020’ indicates to insert the Unicode character
with the ordinal value 0x0020 (the space character) at the given
position.

  Other characters are interpreted by using their respective ordinal
values directly as Unicode ordinals.  If you have literal strings in the
standard Latin-1 encoding that is used in many Western countries, you
will find it convenient that the lower 256 characters of Unicode are the
same as the 256 characters of Latin-1.

  For experts, there is also a raw mode just like the one for normal
strings.  You have to prefix the opening quote with ’ur’ to have Python
use the _Raw-Unicode-Escape_ encoding.  It will only apply the above
‘\uXXXX’ conversion if there is an uneven number of backslashes in front
of the small ’u’.

     >>> ur'Hello\u0020World !'
     u'Hello World !'
     >>> ur'Hello\\u0020World !'
     u'Hello\\\\u0020World !'

  The raw mode is most useful when you have to enter lots of
backslashes, as can be necessary in regular expressions.

  Apart from these standard encodings, Python provides a whole set of
other ways of creating Unicode strings on the basis of a known encoding.

  The built-in function *note unicode(): 1f5. provides access to all
registered Unicode codecs (COders and DECoders).  Some of the more well
known encodings which these codecs can convert are _Latin-1_, _ASCII_,
_UTF-8_, and _UTF-16_.  The latter two are variable-length encodings
that store each Unicode character in one or more bytes.  The default
encoding is normally set to ASCII, which passes through characters in
the range 0 to 127 and rejects any other characters with an error.  When
a Unicode string is printed, written to a file, or converted with *note
str(): 1ea, conversion takes place using this default encoding.

     >>> u"abc"
     u'abc'
     >>> str(u"abc")
     'abc'
     >>> u"äöü"
     u'\xe4\xf6\xfc'
     >>> str(u"äöü")
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-2: ordinal not in range(128)

  To convert a Unicode string into an 8-bit string using a specific
encoding, Unicode objects provide an ‘encode()’ method that takes one
argument, the name of the encoding.  Lowercase names for encodings are
preferred.

     >>> u"äöü".encode('utf-8')
     '\xc3\xa4\xc3\xb6\xc3\xbc'

  If you have data in a specific encoding and want to produce a
corresponding Unicode string from it, you can use the *note unicode():
1f5. function with the encoding name as the second argument.

     >>> unicode('\xc3\xa4\xc3\xb6\xc3\xbc', 'utf-8')
     u'\xe4\xf6\xfc'


File: python.info,  Node: Lists,  Prev: Unicode Strings,  Up: Using Python as a Calculator

2.3.1.4 Lists
.............

Python knows a number of _compound_ data types, used to group together
other values.  The most versatile is the _list_, which can be written as
a list of comma-separated values (items) between square brackets.  List
items need not all have the same type.

     >>> a = ['spam', 'eggs', 100, 1234]
     >>> a
     ['spam', 'eggs', 100, 1234]

  Like string indices, list indices start at 0, and lists can be sliced,
concatenated and so on:

     >>> a[0]
     'spam'
     >>> a[3]
     1234
     >>> a[-2]
     100
     >>> a[1:-1]
     ['eggs', 100]
     >>> a[:2] + ['bacon', 2*2]
     ['spam', 'eggs', 'bacon', 4]
     >>> 3*a[:3] + ['Boo!']
     ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boo!']

  All slice operations return a new list containing the requested
elements.  This means that the following slice returns a shallow copy of
the list _a_:

     >>> a[:]
     ['spam', 'eggs', 100, 1234]

  Unlike strings, which are _immutable_, it is possible to change
individual elements of a list:

     >>> a
     ['spam', 'eggs', 100, 1234]
     >>> a[2] = a[2] + 23
     >>> a
     ['spam', 'eggs', 123, 1234]

  Assignment to slices is also possible, and this can even change the
size of the list or clear it entirely:

     >>> # Replace some items:
     ... a[0:2] = [1, 12]
     >>> a
     [1, 12, 123, 1234]
     >>> # Remove some:
     ... a[0:2] = []
     >>> a
     [123, 1234]
     >>> # Insert some:
     ... a[1:1] = ['bletch', 'xyzzy']
     >>> a
     [123, 'bletch', 'xyzzy', 1234]
     >>> # Insert (a copy of) itself at the beginning
     >>> a[:0] = a
     >>> a
     [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]
     >>> # Clear the list: replace all items with an empty list
     >>> a[:] = []
     >>> a
     []

  The built-in function *note len(): 520. also applies to lists:

     >>> a = ['a', 'b', 'c', 'd']
     >>> len(a)
     4

  It is possible to nest lists (create lists containing other lists),
for example:

     >>> q = [2, 3]
     >>> p = [1, q, 4]
     >>> len(p)
     3
     >>> p[1]
     [2, 3]
     >>> p[1][0]
     2
     >>> p[1].append('xtra')     # See section 5.1
     >>> p
     [1, [2, 3, 'xtra'], 4]
     >>> q
     [2, 3, 'xtra']

  Note that in the last example, ‘p[1]’ and ‘q’ really refer to the same
object!  We’ll come back to _object semantics_ later.


File: python.info,  Node: First Steps Towards Programming,  Prev: Using Python as a Calculator,  Up: An Informal Introduction to Python

2.3.2 First Steps Towards Programming
-------------------------------------

Of course, we can use Python for more complicated tasks than adding two
and two together.  For instance, we can write an initial sub-sequence of
the _Fibonacci_ series as follows:

     >>> # Fibonacci series:
     ... # the sum of two elements defines the next
     ... a, b = 0, 1
     >>> while b < 10:
     ...     print b
     ...     a, b = b, a+b
     ...
     1
     1
     2
     3
     5
     8

  This example introduces several new features.

   * The first line contains a _multiple assignment_: the variables ‘a’
     and ‘b’ simultaneously get the new values 0 and 1.  On the last
     line this is used again, demonstrating that the expressions on the
     right-hand side are all evaluated first before any of the
     assignments take place.  The right-hand side expressions are
     evaluated from the left to the right.

   * The *note while: 52b. loop executes as long as the condition (here:
     ‘b < 10’) remains true.  In Python, like in C, any non-zero integer
     value is true; zero is false.  The condition may also be a string
     or list value, in fact any sequence; anything with a non-zero
     length is true, empty sequences are false.  The test used in the
     example is a simple comparison.  The standard comparison operators
     are written the same as in C: ‘<’ (less than), ‘>’ (greater than),
     ‘==’ (equal to), ‘<=’ (less than or equal to), ‘>=’ (greater than
     or equal to) and ‘!=’ (not equal to).

   * The _body_ of the loop is _indented_: indentation is Python’s way
     of grouping statements.  At the interactive prompt, you have to
     type a tab or space(s) for each indented line.  In practice you
     will prepare more complicated input for Python with a text editor;
     all decent text editors have an auto-indent facility.  When a
     compound statement is entered interactively, it must be followed by
     a blank line to indicate completion (since the parser cannot guess
     when you have typed the last line).  Note that each line within a
     basic block must be indented by the same amount.

   * The *note print: 4e0. statement writes the value of the
     expression(s) it is given.  It differs from just writing the
     expression you want to write (as we did earlier in the calculator
     examples) in the way it handles multiple expressions and strings.
     Strings are printed without quotes, and a space is inserted between
     items, so you can format things nicely, like this:

          >>> i = 256*256
          >>> print 'The value of i is', i
          The value of i is 65536

     A trailing comma avoids the newline after the output:

          >>> a, b = 0, 1
          >>> while b < 1000:
          ...     print b,
          ...     a, b = b, a+b
          ...
          1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

     Note that the interpreter inserts a newline before it prints the
     next prompt if the last line was not completed.


File: python.info,  Node: More Control Flow Tools,  Next: Data Structures,  Prev: An Informal Introduction to Python,  Up: The Python Tutorial

2.4 More Control Flow Tools
===========================

Besides the *note while: 52b. statement just introduced, Python knows
the usual control flow statements known from other languages, with some
twists.

* Menu:

* if Statements:: 
* for Statements:: 
* The range() Function: The range Function. 
* break and continue Statements, and else Clauses on Loops: break and continue Statements and else Clauses on Loops. 
* pass Statements:: 
* Defining Functions:: 
* More on Defining Functions:: 
* Intermezzo; Coding Style: Intermezzo Coding Style. 


File: python.info,  Node: if Statements,  Next: for Statements,  Up: More Control Flow Tools

2.4.1 ‘if’ Statements
---------------------

Perhaps the most well-known statement type is the *note if: 42c.
statement.  For example:

     >>> x = int(raw_input("Please enter an integer: "))
     Please enter an integer: 42
     >>> if x < 0:
     ...     x = 0
     ...     print 'Negative changed to zero'
     ... elif x == 0:
     ...     print 'Zero'
     ... elif x == 1:
     ...     print 'Single'
     ... else:
     ...     print 'More'
     ...
     More

  There can be zero or more *note elif: 531. parts, and the *note else:
532. part is optional.  The keyword ’*note elif: 531.’ is short for
’else if’, and is useful to avoid excessive indentation.  An *note if:
42c. ...  *note elif: 531. ...  *note elif: 531. ...  sequence is a
substitute for the ‘switch’ or ‘case’ statements found in other
languages.


File: python.info,  Node: for Statements,  Next: The range Function,  Prev: if Statements,  Up: More Control Flow Tools

2.4.2 ‘for’ Statements
----------------------

The *note for: 2f0. statement in Python differs a bit from what you may
be used to in C or Pascal.  Rather than always iterating over an
arithmetic progression of numbers (like in Pascal), or giving the user
the ability to define both the iteration step and halting condition (as
C), Python’s *note for: 2f0. statement iterates over the items of any
sequence (a list or a string), in the order that they appear in the
sequence.  For example (no pun intended):

     >>> # Measure some strings:
     ... words = ['cat', 'window', 'defenestrate']
     >>> for w in words:
     ...     print w, len(w)
     ...
     cat 3
     window 6
     defenestrate 12

  If you need to modify the sequence you are iterating over while inside
the loop (for example to duplicate selected items), it is recommended
that you first make a copy.  Iterating over a sequence does not
implicitly make a copy.  The slice notation makes this especially
convenient:

     >>> for w in words[:]:  # Loop over a slice copy of the entire list.
     ...     if len(w) > 6:
     ...         words.insert(0, w)
     ...
     >>> words
     ['defenestrate', 'cat', 'window', 'defenestrate']


File: python.info,  Node: The range Function,  Next: break and continue Statements and else Clauses on Loops,  Prev: for Statements,  Up: More Control Flow Tools

2.4.3 The ‘range()’ Function
----------------------------

If you do need to iterate over a sequence of numbers, the built-in
function *note range(): 2d9. comes in handy.  It generates lists
containing arithmetic progressions:

     >>> range(10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  The given end point is never part of the generated list; ‘range(10)’
generates a list of 10 values, the legal indices for items of a sequence
of length 10.  It is possible to let the range start at another number,
or to specify a different increment (even negative; sometimes this is
called the ’step’):

     >>> range(5, 10)
     [5, 6, 7, 8, 9]
     >>> range(0, 10, 3)
     [0, 3, 6, 9]
     >>> range(-10, -100, -30)
     [-10, -40, -70]

  To iterate over the indices of a sequence, you can combine *note
range(): 2d9. and *note len(): 520. as follows:

     >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
     >>> for i in range(len(a)):
     ...     print i, a[i]
     ...
     0 Mary
     1 had
     2 a
     3 little
     4 lamb

  In most such cases, however, it is convenient to use the *note
enumerate(): 427. function, see *note Looping Techniques: 537.


File: python.info,  Node: break and continue Statements and else Clauses on Loops,  Next: pass Statements,  Prev: The range Function,  Up: More Control Flow Tools

2.4.4 ‘break’ and ‘continue’ Statements, and ‘else’ Clauses on Loops
--------------------------------------------------------------------

The *note break: 53a. statement, like in C, breaks out of the smallest
enclosing *note for: 2f0. or *note while: 52b. loop.

  Loop statements may have an ‘else’ clause; it is executed when the
loop terminates through exhaustion of the list (with *note for: 2f0.) or
when the condition becomes false (with *note while: 52b.), but not when
the loop is terminated by a *note break: 53a. statement.  This is
exemplified by the following loop, which searches for prime numbers:

     >>> for n in range(2, 10):
     ...     for x in range(2, n):
     ...         if n % x == 0:
     ...             print n, 'equals', x, '*', n/x
     ...             break
     ...     else:
     ...         # loop fell through without finding a factor
     ...         print n, 'is a prime number'
     ...
     2 is a prime number
     3 is a prime number
     4 equals 2 * 2
     5 is a prime number
     6 equals 2 * 3
     7 is a prime number
     8 equals 2 * 4
     9 equals 3 * 3

  (Yes, this is the correct code.  Look closely: the ‘else’ clause
belongs to the *note for: 2f0. loop, *not* the *note if: 42c.
statement.)

  When used with a loop, the ‘else’ clause has more in common with the
‘else’ clause of a *note try: 395. statement than it does that of *note
if: 42c. statements: a *note try: 395. statement’s ‘else’ clause runs
when no exception occurs, and a loop’s ‘else’ clause runs when no
‘break’ occurs.  For more on the *note try: 395. statement and
exceptions, see *note Handling Exceptions: 53b.

  The *note continue: 53c. statement, also borrowed from C, continues
with the next iteration of the loop:

     >>> for num in range(2, 10):
     ...     if num % 2 == 0:
     ...         print "Found an even number", num
     ...         continue
     ...     print "Found a number", num
     Found an even number 2
     Found a number 3
     Found an even number 4
     Found a number 5
     Found an even number 6
     Found a number 7
     Found an even number 8
     Found a number 9


File: python.info,  Node: pass Statements,  Next: Defining Functions,  Prev: break and continue Statements and else Clauses on Loops,  Up: More Control Flow Tools

2.4.5 ‘pass’ Statements
-----------------------

The *note pass: 53f. statement does nothing.  It can be used when a
statement is required syntactically but the program requires no action.
For example:

     >>> while True:
     ...     pass  # Busy-wait for keyboard interrupt (Ctrl+C)
     ...

  This is commonly used for creating minimal classes:

     >>> class MyEmptyClass:
     ...     pass
     ...

  Another place *note pass: 53f. can be used is as a place-holder for a
function or conditional body when you are working on new code, allowing
you to keep thinking at a more abstract level.  The *note pass: 53f. is
silently ignored:

     >>> def initlog(*args):
     ...     pass   # Remember to implement this!
     ...


File: python.info,  Node: Defining Functions,  Next: More on Defining Functions,  Prev: pass Statements,  Up: More Control Flow Tools

2.4.6 Defining Functions
------------------------

We can create a function that writes the Fibonacci series to an
arbitrary boundary:

     >>> def fib(n):    # write Fibonacci series up to n
     ...     """Print a Fibonacci series up to n."""
     ...     a, b = 0, 1
     ...     while a < n:
     ...         print a,
     ...         a, b = b, a+b
     ...
     >>> # Now call the function we just defined:
     ... fib(2000)
     0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

  The keyword *note def: 3f4. introduces a function _definition_.  It
must be followed by the function name and the parenthesized list of
formal parameters.  The statements that form the body of the function
start at the next line, and must be indented.

  The first statement of the function body can optionally be a string
literal; this string literal is the function’s documentation string, or
_docstring_.  (More about docstrings can be found in the section *note
Documentation Strings: 542.)  There are tools which use docstrings to
automatically produce online or printed documentation, or to let the
user interactively browse through code; it’s good practice to include
docstrings in code that you write, so make a habit of it.

  The _execution_ of a function introduces a new symbol table used for
the local variables of the function.  More precisely, all variable
assignments in a function store the value in the local symbol table;
whereas variable references first look in the local symbol table, then
in the local symbol tables of enclosing functions, then in the global
symbol table, and finally in the table of built-in names.  Thus, global
variables cannot be directly assigned a value within a function (unless
named in a *note global: 543. statement), although they may be
referenced.

  The actual parameters (arguments) to a function call are introduced in
the local symbol table of the called function when it is called; thus,
arguments are passed using _call by value_ (where the _value_ is always
an object _reference_, not the value of the object).  (1) When a
function calls another function, a new local symbol table is created for
that call.

  A function definition introduces the function name in the current
symbol table.  The value of the function name has a type that is
recognized by the interpreter as a user-defined function.  This value
can be assigned to another name which can then also be used as a
function.  This serves as a general renaming mechanism:

     >>> fib
     <function fib at 10042ed0>
     >>> f = fib
     >>> f(100)
     0 1 1 2 3 5 8 13 21 34 55 89

  Coming from other languages, you might object that ‘fib’ is not a
function but a procedure since it doesn’t return a value.  In fact, even
functions without a *note return: 2f4. statement do return a value,
albeit a rather boring one.  This value is called ‘None’ (it’s a
built-in name).  Writing the value ‘None’ is normally suppressed by the
interpreter if it would be the only value written.  You can see it if
you really want to using *note print: 4e0.:

     >>> fib(0)
     >>> print fib(0)
     None

  It is simple to write a function that returns a list of the numbers of
the Fibonacci series, instead of printing it:

     >>> def fib2(n): # return Fibonacci series up to n
     ...     """Return a list containing the Fibonacci series up to n."""
     ...     result = []
     ...     a, b = 0, 1
     ...     while a < n:
     ...         result.append(a)    # see below
     ...         a, b = b, a+b
     ...     return result
     ...
     >>> f100 = fib2(100)    # call it
     >>> f100                # write the result
     [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

  This example, as usual, demonstrates some new Python features:

   * The *note return: 2f4. statement returns with a value from a
     function.  *note return: 2f4. without an expression argument
     returns ‘None’.  Falling off the end of a function also returns
     ‘None’.

   * The statement ‘result.append(a)’ calls a _method_ of the list
     object ‘result’.  A method is a function that ’belongs’ to an
     object and is named ‘obj.methodname’, where ‘obj’ is some object
     (this may be an expression), and ‘methodname’ is the name of a
     method that is defined by the object’s type.  Different types
     define different methods.  Methods of different types may have the
     same name without causing ambiguity.  (It is possible to define
     your own object types and methods, using _classes_, see *note
     Classes: 544.) The method ‘append()’ shown in the example is
     defined for list objects; it adds a new element at the end of the
     list.  In this example it is equivalent to ‘result = result + [a]’,
     but more efficient.

   ---------- Footnotes ----------

   (1) Actually, _call by object reference_ would be a better
description, since if a mutable object is passed, the caller will see
any changes the callee makes to it (items inserted into a list).


File: python.info,  Node: More on Defining Functions,  Next: Intermezzo Coding Style,  Prev: Defining Functions,  Up: More Control Flow Tools

2.4.7 More on Defining Functions
--------------------------------

It is also possible to define functions with a variable number of
arguments.  There are three forms, which can be combined.

* Menu:

* Default Argument Values:: 
* Keyword Arguments:: 
* Arbitrary Argument Lists:: 
* Unpacking Argument Lists:: 
* Lambda Expressions:: 
* Documentation Strings:: 


File: python.info,  Node: Default Argument Values,  Next: Keyword Arguments,  Up: More on Defining Functions

2.4.7.1 Default Argument Values
...............................

The most useful form is to specify a default value for one or more
arguments.  This creates a function that can be called with fewer
arguments than it is defined to allow.  For example:

     def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
         while True:
             ok = raw_input(prompt)
             if ok in ('y', 'ye', 'yes'):
                 return True
             if ok in ('n', 'no', 'nop', 'nope'):
                 return False
             retries = retries - 1
             if retries < 0:
                 raise IOError('refusenik user')
             print complaint

  This function can be called in several ways:

   * giving only the mandatory argument: ‘ask_ok('Do you really want to
     quit?')’

   * giving one of the optional arguments: ‘ask_ok('OK to overwrite the
     file?', 2)’

   * or even giving all arguments: ‘ask_ok('OK to overwrite the file?',
     2, 'Come on, only yes or no!')’

  This example also introduces the *note in: 428. keyword.  This tests
whether or not a sequence contains a certain value.

  The default values are evaluated at the point of function definition
in the _defining_ scope, so that

     i = 5

     def f(arg=i):
         print arg

     i = 6
     f()

  will print ‘5’.

  *Important warning:* The default value is evaluated only once.  This
makes a difference when the default is a mutable object such as a list,
dictionary, or instances of most classes.  For example, the following
function accumulates the arguments passed to it on subsequent calls:

     def f(a, L=[]):
         L.append(a)
         return L

     print f(1)
     print f(2)
     print f(3)

  This will print

     [1]
     [1, 2]
     [1, 2, 3]

  If you don’t want the default to be shared between subsequent calls,
you can write the function like this instead:

     def f(a, L=None):
         if L is None:
             L = []
         L.append(a)
         return L


File: python.info,  Node: Keyword Arguments,  Next: Arbitrary Argument Lists,  Prev: Default Argument Values,  Up: More on Defining Functions

2.4.7.2 Keyword Arguments
.........................

Functions can also be called using *note keyword arguments: 54b. of the
form ‘kwarg=value’.  For instance, the following function:

     def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
         print "-- This parrot wouldn't", action,
         print "if you put", voltage, "volts through it."
         print "-- Lovely plumage, the", type
         print "-- It's", state, "!"

  accepts one required argument (‘voltage’) and three optional arguments
(‘state’, ‘action’, and ‘type’).  This function can be called in any of
the following ways:

     parrot(1000)                                          # 1 positional argument
     parrot(voltage=1000)                                  # 1 keyword argument
     parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
     parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
     parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
     parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

  but all the following calls would be invalid:

     parrot()                     # required argument missing
     parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument
     parrot(110, voltage=220)     # duplicate value for the same argument
     parrot(actor='John Cleese')  # unknown keyword argument

  In a function call, keyword arguments must follow positional
arguments.  All the keyword arguments passed must match one of the
arguments accepted by the function (e.g.  ‘actor’ is not a valid
argument for the ‘parrot’ function), and their order is not important.
This also includes non-optional arguments (e.g.  ‘parrot(voltage=1000)’
is valid too).  No argument may receive a value more than once.  Here’s
an example that fails due to this restriction:

     >>> def function(a):
     ...     pass
     ...
     >>> function(0, a=0)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: function() got multiple values for keyword argument 'a'

  When a final formal parameter of the form ‘**name’ is present, it
receives a dictionary (see *note Mapping Types — dict: 54c.) containing
all keyword arguments except for those corresponding to a formal
parameter.  This may be combined with a formal parameter of the form
‘*name’ (described in the next subsection) which receives a tuple
containing the positional arguments beyond the formal parameter list.
(‘*name’ must occur before ‘**name’.)  For example, if we define a
function like this:

     def cheeseshop(kind, *arguments, **keywords):
         print "-- Do you have any", kind, "?"
         print "-- I'm sorry, we're all out of", kind
         for arg in arguments:
             print arg
         print "-" * 40
         keys = sorted(keywords.keys())
         for kw in keys:
             print kw, ":", keywords[kw]

  It could be called like this:

     cheeseshop("Limburger", "It's very runny, sir.",
                "It's really very, VERY runny, sir.",
                shopkeeper='Michael Palin',
                client="John Cleese",
                sketch="Cheese Shop Sketch")

  and of course it would print:

     -- Do you have any Limburger ?
     -- I'm sorry, we're all out of Limburger
     It's very runny, sir.
     It's really very, VERY runny, sir.
     ----------------------------------------
     client : John Cleese
     shopkeeper : Michael Palin
     sketch : Cheese Shop Sketch

  Note that the list of keyword argument names is created by sorting the
result of the keywords dictionary’s ‘keys()’ method before printing its
contents; if this is not done, the order in which the arguments are
printed is undefined.


File: python.info,  Node: Arbitrary Argument Lists,  Next: Unpacking Argument Lists,  Prev: Keyword Arguments,  Up: More on Defining Functions

2.4.7.3 Arbitrary Argument Lists
................................

Finally, the least frequently used option is to specify that a function
can be called with an arbitrary number of arguments.  These arguments
will be wrapped up in a tuple (see *note Tuples and Sequences: 54f.).
Before the variable number of arguments, zero or more normal arguments
may occur.

     def write_multiple_items(file, separator, *args):
         file.write(separator.join(args))


File: python.info,  Node: Unpacking Argument Lists,  Next: Lambda Expressions,  Prev: Arbitrary Argument Lists,  Up: More on Defining Functions

2.4.7.4 Unpacking Argument Lists
................................

The reverse situation occurs when the arguments are already in a list or
tuple but need to be unpacked for a function call requiring separate
positional arguments.  For instance, the built-in *note range(): 2d9.
function expects separate _start_ and _stop_ arguments.  If they are not
available separately, write the function call with the ‘*’-operator to
unpack the arguments out of a list or tuple:

     >>> range(3, 6)             # normal call with separate arguments
     [3, 4, 5]
     >>> args = [3, 6]
     >>> range(*args)            # call with arguments unpacked from a list
     [3, 4, 5]

  In the same fashion, dictionaries can deliver keyword arguments with
the ‘**’-operator:

     >>> def parrot(voltage, state='a stiff', action='voom'):
     ...     print "-- This parrot wouldn't", action,
     ...     print "if you put", voltage, "volts through it.",
     ...     print "E's", state, "!"
     ...
     >>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
     >>> parrot(**d)
     -- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !


File: python.info,  Node: Lambda Expressions,  Next: Documentation Strings,  Prev: Unpacking Argument Lists,  Up: More on Defining Functions

2.4.7.5 Lambda Expressions
..........................

Small anonymous functions can be created with the *note lambda: 403.
keyword.  This function returns the sum of its two arguments: ‘lambda a,
b: a+b’.  Lambda functions can be used wherever function objects are
required.  They are syntactically restricted to a single expression.
Semantically, they are just syntactic sugar for a normal function
definition.  Like nested function definitions, lambda functions can
reference variables from the containing scope:

     >>> def make_incrementor(n):
     ...     return lambda x: x + n
     ...
     >>> f = make_incrementor(42)
     >>> f(0)
     42
     >>> f(1)
     43

  The above example uses a lambda expression to return a function.
Another use is to pass a small function as an argument:

     >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
     >>> pairs.sort(key=lambda pair: pair[1])
     >>> pairs
     [(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]


File: python.info,  Node: Documentation Strings,  Prev: Lambda Expressions,  Up: More on Defining Functions

2.4.7.6 Documentation Strings
.............................

There are emerging conventions about the content and formatting of
documentation strings.

  The first line should always be a short, concise summary of the
object’s purpose.  For brevity, it should not explicitly state the
object’s name or type, since these are available by other means (except
if the name happens to be a verb describing a function’s operation).
This line should begin with a capital letter and end with a period.

  If there are more lines in the documentation string, the second line
should be blank, visually separating the summary from the rest of the
description.  The following lines should be one or more paragraphs
describing the object’s calling conventions, its side effects, etc.

  The Python parser does not strip indentation from multi-line string
literals in Python, so tools that process documentation have to strip
indentation if desired.  This is done using the following convention.
The first non-blank line _after_ the first line of the string determines
the amount of indentation for the entire documentation string.  (We
can’t use the first line since it is generally adjacent to the string’s
opening quotes so its indentation is not apparent in the string
literal.)  Whitespace "equivalent" to this indentation is then stripped
from the start of all lines of the string.  Lines that are indented less
should not occur, but if they occur all their leading whitespace should
be stripped.  Equivalence of whitespace should be tested after expansion
of tabs (to 8 spaces, normally).

  Here is an example of a multi-line docstring:

     >>> def my_function():
     ...     """Do nothing, but document it.
     ...
     ...     No, really, it doesn't do anything.
     ...     """
     ...     pass
     ...
     >>> print my_function.__doc__
     Do nothing, but document it.

         No, really, it doesn't do anything.


File: python.info,  Node: Intermezzo Coding Style,  Prev: More on Defining Functions,  Up: More Control Flow Tools

2.4.8 Intermezzo: Coding Style
------------------------------

Now that you are about to write longer, more complex pieces of Python,
it is a good time to talk about _coding style_.  Most languages can be
written (or more concise, _formatted_) in different styles; some are
more readable than others.  Making it easy for others to read your code
is always a good idea, and adopting a nice coding style helps
tremendously for that.

  For Python, PEP 8(1) has emerged as the style guide that most projects
adhere to; it promotes a very readable and eye-pleasing coding style.
Every Python developer should read it at some point; here are the most
important points extracted for you:

   * Use 4-space indentation, and no tabs.

     4 spaces are a good compromise between small indentation (allows
     greater nesting depth) and large indentation (easier to read).
     Tabs introduce confusion, and are best left out.

   * Wrap lines so that they don’t exceed 79 characters.

     This helps users with small displays and makes it possible to have
     several code files side-by-side on larger displays.

   * Use blank lines to separate functions and classes, and larger
     blocks of code inside functions.

   * When possible, put comments on a line of their own.

   * Use docstrings.

   * Use spaces around operators and after commas, but not directly
     inside bracketing constructs: ‘a = f(1, 2) + g(3, 4)’.

   * Name your classes and functions consistently; the convention is to
     use ‘CamelCase’ for classes and ‘lower_case_with_underscores’ for
     functions and methods.  Always use ‘self’ as the name for the first
     method argument (see *note A First Look at Classes: 557. for more
     on classes and methods).

   * Don’t use fancy encodings if your code is meant to be used in
     international environments.  Plain ASCII works best in any case.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0008


File: python.info,  Node: Data Structures,  Next: Modules,  Prev: More Control Flow Tools,  Up: The Python Tutorial

2.5 Data Structures
===================

This chapter describes some things you’ve learned about already in more
detail, and adds some new things as well.

* Menu:

* More on Lists:: 
* The del statement:: 
* Tuples and Sequences:: 
* Sets:: 
* Dictionaries:: 
* Looping Techniques:: 
* More on Conditions:: 
* Comparing Sequences and Other Types:: 

More on Lists

* Using Lists as Stacks:: 
* Using Lists as Queues:: 
* Functional Programming Tools:: 
* List Comprehensions: List Comprehensions<2>. 

List Comprehensions

* Nested List Comprehensions:: 


File: python.info,  Node: More on Lists,  Next: The del statement,  Up: Data Structures

2.5.1 More on Lists
-------------------

The list data type has some more methods.  Here are all of the methods
of list objects:

 -- Method: list.append (x)

     Add an item to the end of the list; equivalent to ‘a[len(a):] =
     [x]’.

 -- Method: list.extend (L)

     Extend the list by appending all the items in the given list;
     equivalent to ‘a[len(a):] = L’.

 -- Method: list.insert (i, x)

     Insert an item at a given position.  The first argument is the
     index of the element before which to insert, so ‘a.insert(0, x)’
     inserts at the front of the list, and ‘a.insert(len(a), x)’ is
     equivalent to ‘a.append(x)’.

 -- Method: list.remove (x)

     Remove the first item from the list whose value is _x_.  It is an
     error if there is no such item.

 -- Method: list.pop ([i])

     Remove the item at the given position in the list, and return it.
     If no index is specified, ‘a.pop()’ removes and returns the last
     item in the list.  (The square brackets around the _i_ in the
     method signature denote that the parameter is optional, not that
     you should type square brackets at that position.  You will see
     this notation frequently in the Python Library Reference.)

 -- Method: list.index (x)

     Return the index in the list of the first item whose value is _x_.
     It is an error if there is no such item.

 -- Method: list.count (x)

     Return the number of times _x_ appears in the list.

 -- Method: list.sort (cmp=None, key=None, reverse=False)

     Sort the items of the list in place (the arguments can be used for
     sort customization, see *note sorted(): 223. for their
     explanation).

 -- Method: list.reverse ()

     Reverse the elements of the list, in place.

  An example that uses most of the list methods:

     >>> a = [66.25, 333, 333, 1, 1234.5]
     >>> print a.count(333), a.count(66.25), a.count('x')
     2 1 0
     >>> a.insert(2, -1)
     >>> a.append(333)
     >>> a
     [66.25, 333, -1, 333, 1, 1234.5, 333]
     >>> a.index(333)
     1
     >>> a.remove(333)
     >>> a
     [66.25, -1, 333, 1, 1234.5, 333]
     >>> a.reverse()
     >>> a
     [333, 1234.5, 1, 333, -1, 66.25]
     >>> a.sort()
     >>> a
     [-1, 1, 66.25, 333, 333, 1234.5]
     >>> a.pop()
     1234.5
     >>> a
     [-1, 1, 66.25, 333, 333]

  You might have noticed that methods like ‘insert’, ‘remove’ or ‘sort’
that only modify the list have no return value printed – they return the
default ‘None’.  (1) This is a design principle for all mutable data
structures in Python.

* Menu:

* Using Lists as Stacks:: 
* Using Lists as Queues:: 
* Functional Programming Tools:: 
* List Comprehensions: List Comprehensions<2>. 

   ---------- Footnotes ----------

   (1) The rules for comparing objects of different types should not be
relied upon; they may change in a future version of the language.


File: python.info,  Node: Using Lists as Stacks,  Next: Using Lists as Queues,  Up: More on Lists

2.5.1.1 Using Lists as Stacks
.............................

The list methods make it very easy to use a list as a stack, where the
last element added is the first element retrieved ("last-in,
first-out").  To add an item to the top of the stack, use ‘append()’.
To retrieve an item from the top of the stack, use ‘pop()’ without an
explicit index.  For example:

     >>> stack = [3, 4, 5]
     >>> stack.append(6)
     >>> stack.append(7)
     >>> stack
     [3, 4, 5, 6, 7]
     >>> stack.pop()
     7
     >>> stack
     [3, 4, 5, 6]
     >>> stack.pop()
     6
     >>> stack.pop()
     5
     >>> stack
     [3, 4]


File: python.info,  Node: Using Lists as Queues,  Next: Functional Programming Tools,  Prev: Using Lists as Stacks,  Up: More on Lists

2.5.1.2 Using Lists as Queues
.............................

It is also possible to use a list as a queue, where the first element
added is the first element retrieved ("first-in, first-out"); however,
lists are not efficient for this purpose.  While appends and pops from
the end of list are fast, doing inserts or pops from the beginning of a
list is slow (because all of the other elements have to be shifted by
one).

  To implement a queue, use *note collections.deque: 209. which was
designed to have fast appends and pops from both ends.  For example:

     >>> from collections import deque
     >>> queue = deque(["Eric", "John", "Michael"])
     >>> queue.append("Terry")           # Terry arrives
     >>> queue.append("Graham")          # Graham arrives
     >>> queue.popleft()                 # The first to arrive now leaves
     'Eric'
     >>> queue.popleft()                 # The second to arrive now leaves
     'John'
     >>> queue                           # Remaining queue in order of arrival
     deque(['Michael', 'Terry', 'Graham'])


File: python.info,  Node: Functional Programming Tools,  Next: List Comprehensions<2>,  Prev: Using Lists as Queues,  Up: More on Lists

2.5.1.3 Functional Programming Tools
....................................

There are three built-in functions that are very useful when used with
lists: *note filter(): 409, *note map(): 304, and *note reduce(): 2e9.

  ‘filter(function, sequence)’ returns a sequence consisting of those
items from the sequence for which ‘function(item)’ is true.  If
_sequence_ is a *note string: 163. or *note tuple: 408, the result will
be of the same type; otherwise, it is always a *note list: 3bc.  For
example, to compute a sequence of numbers not divisible by 2 or 3:

     >>> def f(x): return x % 2 != 0 and x % 3 != 0
     ...
     >>> filter(f, range(2, 25))
     [5, 7, 11, 13, 17, 19, 23]

  ‘map(function, sequence)’ calls ‘function(item)’ for each of the
sequence’s items and returns a list of the return values.  For example,
to compute some cubes:

     >>> def cube(x): return x*x*x
     ...
     >>> map(cube, range(1, 11))
     [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

  More than one sequence may be passed; the function must then have as
many arguments as there are sequences and is called with the
corresponding item from each sequence (or ‘None’ if some sequence is
shorter than another).  For example:

     >>> seq = range(8)
     >>> def add(x, y): return x+y
     ...
     >>> map(add, seq, seq)
     [0, 2, 4, 6, 8, 10, 12, 14]

  ‘reduce(function, sequence)’ returns a single value constructed by
calling the binary function _function_ on the first two items of the
sequence, then on the result and the next item, and so on.  For example,
to compute the sum of the numbers 1 through 10:

     >>> def add(x,y): return x+y
     ...
     >>> reduce(add, range(1, 11))
     55

  If there’s only one item in the sequence, its value is returned; if
the sequence is empty, an exception is raised.

  A third argument can be passed to indicate the starting value.  In
this case the starting value is returned for an empty sequence, and the
function is first applied to the starting value and the first sequence
item, then to the result and the next item, and so on.  For example,

     >>> def sum(seq):
     ...     def add(x,y): return x+y
     ...     return reduce(add, seq, 0)
     ...
     >>> sum(range(1, 11))
     55
     >>> sum([])
     0

  Don’t use this example’s definition of *note sum(): 426.: since
summing numbers is such a common need, a built-in function
‘sum(sequence)’ is already provided, and works exactly like this.


File: python.info,  Node: List Comprehensions<2>,  Prev: Functional Programming Tools,  Up: More on Lists

2.5.1.4 List Comprehensions
...........................

List comprehensions provide a concise way to create lists.  Common
applications are to make new lists where each element is the result of
some operations applied to each member of another sequence or iterable,
or to create a subsequence of those elements that satisfy a certain
condition.

  For example, assume we want to create a list of squares, like:

     >>> squares = []
     >>> for x in range(10):
     ...     squares.append(x**2)
     ...
     >>> squares
     [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

  We can obtain the same result with:

     squares = [x**2 for x in range(10)]

  This is also equivalent to ‘squares = map(lambda x: x**2, range(10))’,
but it’s more concise and readable.

  A list comprehension consists of brackets containing an expression
followed by a *note for: 2f0. clause, then zero or more *note for: 2f0.
or *note if: 42c. clauses.  The result will be a new list resulting from
evaluating the expression in the context of the *note for: 2f0. and
*note if: 42c. clauses which follow it.  For example, this listcomp
combines the elements of two lists if they are not equal:

     >>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
     [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

  and it’s equivalent to:

     >>> combs = []
     >>> for x in [1,2,3]:
     ...     for y in [3,1,4]:
     ...         if x != y:
     ...             combs.append((x, y))
     ...
     >>> combs
     [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]

  Note how the order of the *note for: 2f0. and *note if: 42c.
statements is the same in both these snippets.

  If the expression is a tuple (e.g.  the ‘(x, y)’ in the previous
example), it must be parenthesized.

     >>> vec = [-4, -2, 0, 2, 4]
     >>> # create a new list with the values doubled
     >>> [x*2 for x in vec]
     [-8, -4, 0, 4, 8]
     >>> # filter the list to exclude negative numbers
     >>> [x for x in vec if x >= 0]
     [0, 2, 4]
     >>> # apply a function to all the elements
     >>> [abs(x) for x in vec]
     [4, 2, 0, 2, 4]
     >>> # call a method on each element
     >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
     >>> [weapon.strip() for weapon in freshfruit]
     ['banana', 'loganberry', 'passion fruit']
     >>> # create a list of 2-tuples like (number, square)
     >>> [(x, x**2) for x in range(6)]
     [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
     >>> # the tuple must be parenthesized, otherwise an error is raised
     >>> [x, x**2 for x in range(6)]
       File "<stdin>", line 1
         [x, x**2 for x in range(6)]
                    ^
     SyntaxError: invalid syntax
     >>> # flatten a list using a listcomp with two 'for'
     >>> vec = [[1,2,3], [4,5,6], [7,8,9]]
     >>> [num for elem in vec for num in elem]
     [1, 2, 3, 4, 5, 6, 7, 8, 9]

  List comprehensions can contain complex expressions and nested
functions:

     >>> from math import pi
     >>> [str(round(pi, i)) for i in range(1, 6)]
     ['3.1', '3.14', '3.142', '3.1416', '3.14159']

* Menu:

* Nested List Comprehensions:: 


File: python.info,  Node: Nested List Comprehensions,  Up: List Comprehensions<2>

2.5.1.5 Nested List Comprehensions
..................................

The initial expression in a list comprehension can be any arbitrary
expression, including another list comprehension.

  Consider the following example of a 3x4 matrix implemented as a list
of 3 lists of length 4:

     >>> matrix = [
     ...     [1, 2, 3, 4],
     ...     [5, 6, 7, 8],
     ...     [9, 10, 11, 12],
     ... ]

  The following list comprehension will transpose rows and columns:

     >>> [[row[i] for row in matrix] for i in range(4)]
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

  As we saw in the previous section, the nested listcomp is evaluated in
the context of the *note for: 2f0. that follows it, so this example is
equivalent to:

     >>> transposed = []
     >>> for i in range(4):
     ...     transposed.append([row[i] for row in matrix])
     ...
     >>> transposed
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

  which, in turn, is the same as:

     >>> transposed = []
     >>> for i in range(4):
     ...     # the following 3 lines implement the nested listcomp
     ...     transposed_row = []
     ...     for row in matrix:
     ...         transposed_row.append(row[i])
     ...     transposed.append(transposed_row)
     ...
     >>> transposed
     [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

  In the real world, you should prefer built-in functions to complex
flow statements.  The *note zip(): 405. function would do a great job
for this use case:

     >>> zip(*matrix)
     [(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]

  See *note Unpacking Argument Lists: 550. for details on the asterisk
in this line.


File: python.info,  Node: The del statement,  Next: Tuples and Sequences,  Prev: More on Lists,  Up: Data Structures

2.5.2 The ‘del’ statement
-------------------------

There is a way to remove an item from a list given its index instead of
its value: the *note del: 568. statement.  This differs from the ‘pop()’
method which returns a value.  The *note del: 568. statement can also be
used to remove slices from a list or clear the entire list (which we did
earlier by assignment of an empty list to the slice).  For example:

     >>> a = [-1, 1, 66.25, 333, 333, 1234.5]
     >>> del a[0]
     >>> a
     [1, 66.25, 333, 333, 1234.5]
     >>> del a[2:4]
     >>> a
     [1, 66.25, 1234.5]
     >>> del a[:]
     >>> a
     []

  *note del: 568. can also be used to delete entire variables:

     >>> del a

  Referencing the name ‘a’ hereafter is an error (at least until another
value is assigned to it).  We’ll find other uses for *note del: 568.
later.


File: python.info,  Node: Tuples and Sequences,  Next: Sets,  Prev: The del statement,  Up: Data Structures

2.5.3 Tuples and Sequences
--------------------------

We saw that lists and strings have many common properties, such as
indexing and slicing operations.  They are two examples of _sequence_
data types (see *note Sequence Types — str, unicode, list, tuple,
bytearray, buffer, xrange: 521.).  Since Python is an evolving language,
other sequence data types may be added.  There is also another standard
sequence data type: the _tuple_.

  A tuple consists of a number of values separated by commas, for
instance:

     >>> t = 12345, 54321, 'hello!'
     >>> t[0]
     12345
     >>> t
     (12345, 54321, 'hello!')
     >>> # Tuples may be nested:
     ... u = t, (1, 2, 3, 4, 5)
     >>> u
     ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
     >>> # Tuples are immutable:
     ... t[0] = 88888
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: 'tuple' object does not support item assignment
     >>> # but they can contain mutable objects:
     ... v = ([1, 2, 3], [3, 2, 1])
     >>> v
     ([1, 2, 3], [3, 2, 1])

  As you see, on output tuples are always enclosed in parentheses, so
that nested tuples are interpreted correctly; they may be input with or
without surrounding parentheses, although often parentheses are
necessary anyway (if the tuple is part of a larger expression).  It is
not possible to assign to the individual items of a tuple, however it is
possible to create tuples which contain mutable objects, such as lists.

  Though tuples may seem similar to lists, they are often used in
different situations and for different purposes.  Tuples are *note
immutable: 56a, and usually contain an heterogeneous sequence of
elements that are accessed via unpacking (see later in this section) or
indexing (or even by attribute in the case of *note namedtuples: 1cf.).
Lists are *note mutable: 56b, and their elements are usually homogeneous
and are accessed by iterating over the list.

  A special problem is the construction of tuples containing 0 or 1
items: the syntax has some extra quirks to accommodate these.  Empty
tuples are constructed by an empty pair of parentheses; a tuple with one
item is constructed by following a value with a comma (it is not
sufficient to enclose a single value in parentheses).  Ugly, but
effective.  For example:

     >>> empty = ()
     >>> singleton = 'hello',    # <-- note trailing comma
     >>> len(empty)
     0
     >>> len(singleton)
     1
     >>> singleton
     ('hello',)

  The statement ‘t = 12345, 54321, 'hello!'’ is an example of _tuple
packing_: the values ‘12345’, ‘54321’ and ‘'hello!'’ are packed together
in a tuple.  The reverse operation is also possible:

     >>> x, y, z = t

  This is called, appropriately enough, _sequence unpacking_ and works
for any sequence on the right-hand side.  Sequence unpacking requires
the list of variables on the left to have the same number of elements as
the length of the sequence.  Note that multiple assignment is really
just a combination of tuple packing and sequence unpacking.


File: python.info,  Node: Sets,  Next: Dictionaries,  Prev: Tuples and Sequences,  Up: Data Structures

2.5.4 Sets
----------

Python also includes a data type for _sets_.  A set is an unordered
collection with no duplicate elements.  Basic uses include membership
testing and eliminating duplicate entries.  Set objects also support
mathematical operations like union, intersection, difference, and
symmetric difference.

  Curly braces or the *note set(): 36a. function can be used to create
sets.  Note: to create an empty set you have to use ‘set()’, not ‘{}’;
the latter creates an empty dictionary, a data structure that we discuss
in the next section.

  Here is a brief demonstration:

     >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
     >>> fruit = set(basket)               # create a set without duplicates
     >>> fruit
     set(['orange', 'pear', 'apple', 'banana'])
     >>> 'orange' in fruit                 # fast membership testing
     True
     >>> 'crabgrass' in fruit
     False

     >>> # Demonstrate set operations on unique letters from two words
     ...
     >>> a = set('abracadabra')
     >>> b = set('alacazam')
     >>> a                                  # unique letters in a
     set(['a', 'r', 'b', 'c', 'd'])
     >>> a - b                              # letters in a but not in b
     set(['r', 'd', 'b'])
     >>> a | b                              # letters in either a or b
     set(['a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'])
     >>> a & b                              # letters in both a and b
     set(['a', 'c'])
     >>> a ^ b                              # letters in a or b but not both
     set(['r', 'd', 'b', 'm', 'z', 'l'])

  Similarly to *note list comprehensions: 563, set comprehensions are
also supported:

     >>> a = {x for x in 'abracadabra' if x not in 'abc'}
     >>> a
     set(['r', 'd'])


File: python.info,  Node: Dictionaries,  Next: Looping Techniques,  Prev: Sets,  Up: Data Structures

2.5.5 Dictionaries
------------------

Another useful data type built into Python is the _dictionary_ (see
*note Mapping Types — dict: 54c.).  Dictionaries are sometimes found in
other languages as "associative memories" or "associative arrays".
Unlike sequences, which are indexed by a range of numbers, dictionaries
are indexed by _keys_, which can be any immutable type; strings and
numbers can always be keys.  Tuples can be used as keys if they contain
only strings, numbers, or tuples; if a tuple contains any mutable object
either directly or indirectly, it cannot be used as a key.  You can’t
use lists as keys, since lists can be modified in place using index
assignments, slice assignments, or methods like ‘append()’ and
‘extend()’.

  It is best to think of a dictionary as an unordered set of _key:
value_ pairs, with the requirement that the keys are unique (within one
dictionary).  A pair of braces creates an empty dictionary: ‘{}’.
Placing a comma-separated list of key:value pairs within the braces adds
initial key:value pairs to the dictionary; this is also the way
dictionaries are written on output.

  The main operations on a dictionary are storing a value with some key
and extracting the value given the key.  It is also possible to delete a
key:value pair with ‘del’.  If you store using a key that is already in
use, the old value associated with that key is forgotten.  It is an
error to extract a value using a non-existent key.

  The ‘keys()’ method of a dictionary object returns a list of all the
keys used in the dictionary, in arbitrary order (if you want it sorted,
just apply the *note sorted(): 223. function to it).  To check whether a
single key is in the dictionary, use the *note in: 428. keyword.

  Here is a small example using a dictionary:

     >>> tel = {'jack': 4098, 'sape': 4139}
     >>> tel['guido'] = 4127
     >>> tel
     {'sape': 4139, 'guido': 4127, 'jack': 4098}
     >>> tel['jack']
     4098
     >>> del tel['sape']
     >>> tel['irv'] = 4127
     >>> tel
     {'guido': 4127, 'irv': 4127, 'jack': 4098}
     >>> tel.keys()
     ['guido', 'irv', 'jack']
     >>> 'guido' in tel
     True

  The *note dict(): 305. constructor builds dictionaries directly from
sequences of key-value pairs:

     >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
     {'sape': 4139, 'jack': 4098, 'guido': 4127}

  In addition, dict comprehensions can be used to create dictionaries
from arbitrary key and value expressions:

     >>> {x: x**2 for x in (2, 4, 6)}
     {2: 4, 4: 16, 6: 36}

  When the keys are simple strings, it is sometimes easier to specify
pairs using keyword arguments:

     >>> dict(sape=4139, guido=4127, jack=4098)
     {'sape': 4139, 'jack': 4098, 'guido': 4127}


File: python.info,  Node: Looping Techniques,  Next: More on Conditions,  Prev: Dictionaries,  Up: Data Structures

2.5.6 Looping Techniques
------------------------

When looping through a sequence, the position index and corresponding
value can be retrieved at the same time using the *note enumerate():
427. function.

     >>> for i, v in enumerate(['tic', 'tac', 'toe']):
     ...     print i, v
     ...
     0 tic
     1 tac
     2 toe

  To loop over two or more sequences at the same time, the entries can
be paired with the *note zip(): 405. function.

     >>> questions = ['name', 'quest', 'favorite color']
     >>> answers = ['lancelot', 'the holy grail', 'blue']
     >>> for q, a in zip(questions, answers):
     ...     print 'What is your {0}?  It is {1}.'.format(q, a)
     ...
     What is your name?  It is lancelot.
     What is your quest?  It is the holy grail.
     What is your favorite color?  It is blue.

  To loop over a sequence in reverse, first specify the sequence in a
forward direction and then call the *note reversed(): 3f8. function.

     >>> for i in reversed(xrange(1,10,2)):
     ...     print i
     ...
     9
     7
     5
     3
     1

  To loop over a sequence in sorted order, use the *note sorted(): 223.
function which returns a new sorted list while leaving the source
unaltered.

     >>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
     >>> for f in sorted(set(basket)):
     ...     print f
     ...
     apple
     banana
     orange
     pear

  When looping through dictionaries, the key and corresponding value can
be retrieved at the same time using the ‘iteritems()’ method.

     >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
     >>> for k, v in knights.iteritems():
     ...     print k, v
     ...
     gallahad the pure
     robin the brave

  To change a sequence you are iterating over while inside the loop (for
example to duplicate certain items), it is recommended that you first
make a copy.  Looping over a sequence does not implicitly make a copy.
The slice notation makes this especially convenient:

     >>> words = ['cat', 'window', 'defenestrate']
     >>> for w in words[:]:  # Loop over a slice copy of the entire list.
     ...     if len(w) > 6:
     ...         words.insert(0, w)
     ...
     >>> words
     ['defenestrate', 'cat', 'window', 'defenestrate']


File: python.info,  Node: More on Conditions,  Next: Comparing Sequences and Other Types,  Prev: Looping Techniques,  Up: Data Structures

2.5.7 More on Conditions
------------------------

The conditions used in ‘while’ and ‘if’ statements can contain any
operators, not just comparisons.

  The comparison operators ‘in’ and ‘not in’ check whether a value
occurs (does not occur) in a sequence.  The operators ‘is’ and ‘is not’
compare whether two objects are really the same object; this only
matters for mutable objects like lists.  All comparison operators have
the same priority, which is lower than that of all numerical operators.

  Comparisons can be chained.  For example, ‘a < b == c’ tests whether
‘a’ is less than ‘b’ and moreover ‘b’ equals ‘c’.

  Comparisons may be combined using the Boolean operators ‘and’ and
‘or’, and the outcome of a comparison (or of any other Boolean
expression) may be negated with ‘not’.  These have lower priorities than
comparison operators; between them, ‘not’ has the highest priority and
‘or’ the lowest, so that ‘A and not B or C’ is equivalent to ‘(A and
(not B)) or C’.  As always, parentheses can be used to express the
desired composition.

  The Boolean operators ‘and’ and ‘or’ are so-called _short-circuit_
operators: their arguments are evaluated from left to right, and
evaluation stops as soon as the outcome is determined.  For example, if
‘A’ and ‘C’ are true but ‘B’ is false, ‘A and B and C’ does not evaluate
the expression ‘C’.  When used as a general value and not as a Boolean,
the return value of a short-circuit operator is the last evaluated
argument.

  It is possible to assign the result of a comparison or other Boolean
expression to a variable.  For example,

     >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
     >>> non_null = string1 or string2 or string3
     >>> non_null
     'Trondheim'

  Note that in Python, unlike C, assignment cannot occur inside
expressions.  C programmers may grumble about this, but it avoids a
common class of problems encountered in C programs: typing ‘=’ in an
expression when ‘==’ was intended.


File: python.info,  Node: Comparing Sequences and Other Types,  Prev: More on Conditions,  Up: Data Structures

2.5.8 Comparing Sequences and Other Types
-----------------------------------------

Sequence objects may be compared to other objects with the same sequence
type.  The comparison uses _lexicographical_ ordering: first the first
two items are compared, and if they differ this determines the outcome
of the comparison; if they are equal, the next two items are compared,
and so on, until either sequence is exhausted.  If two items to be
compared are themselves sequences of the same type, the lexicographical
comparison is carried out recursively.  If all items of two sequences
compare equal, the sequences are considered equal.  If one sequence is
an initial sub-sequence of the other, the shorter sequence is the
smaller (lesser) one.  Lexicographical ordering for strings uses the
ASCII ordering for individual characters.  Some examples of comparisons
between sequences of the same type:

     (1, 2, 3)              < (1, 2, 4)
     [1, 2, 3]              < [1, 2, 4]
     'ABC' < 'C' < 'Pascal' < 'Python'
     (1, 2, 3, 4)           < (1, 2, 4)
     (1, 2)                 < (1, 2, -1)
     (1, 2, 3)             == (1.0, 2.0, 3.0)
     (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

  Note that comparing objects of different types is legal.  The outcome
is deterministic but arbitrary: the types are ordered by their name.
Thus, a list is always smaller than a string, a string is always smaller
than a tuple, etc.  (1) Mixed numeric types are compared according to
their numeric value, so 0 equals 0.0, etc.

   ---------- Footnotes ----------

   (1) The rules for comparing objects of different types should not be
relied upon; they may change in a future version of the language.


File: python.info,  Node: Modules,  Next: Input and Output,  Prev: Data Structures,  Up: The Python Tutorial

2.6 Modules
===========

If you quit from the Python interpreter and enter it again, the
definitions you have made (functions and variables) are lost.
Therefore, if you want to write a somewhat longer program, you are
better off using a text editor to prepare the input for the interpreter
and running it with that file as input instead.  This is known as
creating a _script_.  As your program gets longer, you may want to split
it into several files for easier maintenance.  You may also want to use
a handy function that you’ve written in several programs without copying
its definition into each program.

  To support this, Python has a way to put definitions in a file and use
them in a script or in an interactive instance of the interpreter.  Such
a file is called a _module_; definitions from a module can be _imported_
into other modules or into the _main_ module (the collection of
variables that you have access to in a script executed at the top level
and in calculator mode).

  A module is a file containing Python definitions and statements.  The
file name is the module name with the suffix ‘.py’ appended.  Within a
module, the module’s name (as a string) is available as the value of the
global variable ‘__name__’.  For instance, use your favorite text editor
to create a file called ‘fibo.py’ in the current directory with the
following contents:

     # Fibonacci numbers module

     def fib(n):    # write Fibonacci series up to n
         a, b = 0, 1
         while b < n:
             print b,
             a, b = b, a+b

     def fib2(n): # return Fibonacci series up to n
         result = []
         a, b = 0, 1
         while b < n:
             result.append(b)
             a, b = b, a+b
         return result

  Now enter the Python interpreter and import this module with the
following command:

     >>> import fibo

  This does not enter the names of the functions defined in ‘fibo’
directly in the current symbol table; it only enters the module name
‘fibo’ there.  Using the module name you can access the functions:

     >>> fibo.fib(1000)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
     >>> fibo.fib2(100)
     [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
     >>> fibo.__name__
     'fibo'

  If you intend to use a function often you can assign it to a local
name:

     >>> fib = fibo.fib
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

* Menu:

* More on Modules:: 
* Standard Modules:: 
* The dir() Function: The dir Function. 
* Packages:: 

More on Modules

* Executing modules as scripts:: 
* The Module Search Path:: 
* "Compiled" Python files:: 

Packages

* Importing * From a Package:: 
* Intra-package References:: 
* Packages in Multiple Directories:: 


File: python.info,  Node: More on Modules,  Next: Standard Modules,  Up: Modules

2.6.1 More on Modules
---------------------

A module can contain executable statements as well as function
definitions.  These statements are intended to initialize the module.
They are executed only the _first_ time the module name is encountered
in an import statement.  (1) (They are also run if the file is executed
as a script.)

  Each module has its own private symbol table, which is used as the
global symbol table by all functions defined in the module.  Thus, the
author of a module can use global variables in the module without
worrying about accidental clashes with a user’s global variables.  On
the other hand, if you know what you are doing you can touch a module’s
global variables with the same notation used to refer to its functions,
‘modname.itemname’.

  Modules can import other modules.  It is customary but not required to
place all *note import: 1f4. statements at the beginning of a module (or
script, for that matter).  The imported module names are placed in the
importing module’s global symbol table.

  There is a variant of the *note import: 1f4. statement that imports
names from a module directly into the importing module’s symbol table.
For example:

     >>> from fibo import fib, fib2
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

  This does not introduce the module name from which the imports are
taken in the local symbol table (so in the example, ‘fibo’ is not
defined).

  There is even a variant to import all names that a module defines:

     >>> from fibo import *
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

  This imports all names except those beginning with an underscore
(‘_’).

  Note that in general the practice of importing ‘*’ from a module or
package is frowned upon, since it often causes poorly readable code.
However, it is okay to use it to save typing in interactive sessions.

     Note: For efficiency reasons, each module is only imported once per
     interpreter session.  Therefore, if you change your modules, you
     must restart the interpreter – or, if it’s just one module you want
     to test interactively, use *note reload(): 57a, e.g.
     ‘reload(modulename)’.

* Menu:

* Executing modules as scripts:: 
* The Module Search Path:: 
* "Compiled" Python files:: 

   ---------- Footnotes ----------

   (1) In fact function definitions are also ’statements’ that are
’executed’; the execution of a module-level function definition enters
the function name in the module’s global symbol table.


File: python.info,  Node: Executing modules as scripts,  Next: The Module Search Path,  Up: More on Modules

2.6.1.1 Executing modules as scripts
....................................

When you run a Python module with

     python fibo.py <arguments>

  the code in the module will be executed, just as if you imported it,
but with the ‘__name__’ set to ‘"__main__"’.  That means that by adding
this code at the end of your module:

     if __name__ == "__main__":
         import sys
         fib(int(sys.argv[1]))

  you can make the file usable as a script as well as an importable
module, because the code that parses the command line only runs if the
module is executed as the "main" file:

     $ python fibo.py 50
     1 1 2 3 5 8 13 21 34

  If the module is imported, the code is not run:

     >>> import fibo
     >>>

  This is often used either to provide a convenient user interface to a
module, or for testing purposes (running the module as a script executes
a test suite).


File: python.info,  Node: The Module Search Path,  Next: "Compiled" Python files,  Prev: Executing modules as scripts,  Up: More on Modules

2.6.1.2 The Module Search Path
..............................

When a module named ‘spam’ is imported, the interpreter first searches
for a built-in module with that name.  If not found, it then searches
for a file named ‘spam.py’ in a list of directories given by the
variable *note sys.path: 57f.  *note sys.path: 57f. is initialized from
these locations:

   * the directory containing the input script (or the current
     directory).

   * *note PYTHONPATH: 580. (a list of directory names, with the same
     syntax as the shell variable ‘PATH’).

   * the installation-dependent default.

  After initialization, Python programs can modify *note sys.path: 57f.
The directory containing the script being run is placed at the beginning
of the search path, ahead of the standard library path.  This means that
scripts in that directory will be loaded instead of modules of the same
name in the library directory.  This is an error unless the replacement
is intended.  See section *note Standard Modules: 581. for more
information.


File: python.info,  Node: "Compiled" Python files,  Prev: The Module Search Path,  Up: More on Modules

2.6.1.3 "Compiled" Python files
...............................

As an important speed-up of the start-up time for short programs that
use a lot of standard modules, if a file called ‘spam.pyc’ exists in the
directory where ‘spam.py’ is found, this is assumed to contain an
already-"byte-compiled" version of the module ‘spam’.  The modification
time of the version of ‘spam.py’ used to create ‘spam.pyc’ is recorded
in ‘spam.pyc’, and the ‘.pyc’ file is ignored if these don’t match.

  Normally, you don’t need to do anything to create the ‘spam.pyc’ file.
Whenever ‘spam.py’ is successfully compiled, an attempt is made to write
the compiled version to ‘spam.pyc’.  It is not an error if this attempt
fails; if for any reason the file is not written completely, the
resulting ‘spam.pyc’ file will be recognized as invalid and thus ignored
later.  The contents of the ‘spam.pyc’ file are platform independent, so
a Python module directory can be shared by machines of different
architectures.

  Some tips for experts:

   * When the Python interpreter is invoked with the *note -O: 453.
     flag, optimized code is generated and stored in ‘.pyo’ files.  The
     optimizer currently doesn’t help much; it only removes *note
     assert: 452. statements.  When *note -O: 453. is used, _all_ *note
     bytecode: 583. is optimized; ‘.pyc’ files are ignored and ‘.py’
     files are compiled to optimized bytecode.

   * Passing two *note -O: 453. flags to the Python interpreter (*note
     -OO: 584.) will cause the bytecode compiler to perform
     optimizations that could in some rare cases result in
     malfunctioning programs.  Currently only ‘__doc__’ strings are
     removed from the bytecode, resulting in more compact ‘.pyo’ files.
     Since some programs may rely on having these available, you should
     only use this option if you know what you’re doing.

   * A program doesn’t run any faster when it is read from a ‘.pyc’ or
     ‘.pyo’ file than when it is read from a ‘.py’ file; the only thing
     that’s faster about ‘.pyc’ or ‘.pyo’ files is the speed with which
     they are loaded.

   * When a script is run by giving its name on the command line, the
     bytecode for the script is never written to a ‘.pyc’ or ‘.pyo’
     file.  Thus, the startup time of a script may be reduced by moving
     most of its code to a module and having a small bootstrap script
     that imports that module.  It is also possible to name a ‘.pyc’ or
     ‘.pyo’ file directly on the command line.

   * It is possible to have a file called ‘spam.pyc’ (or ‘spam.pyo’ when
     *note -O: 453. is used) without a file ‘spam.py’ for the same
     module.  This can be used to distribute a library of Python code in
     a form that is moderately hard to reverse engineer.

   * The module *note compileall: 69. can create ‘.pyc’ files (or ‘.pyo’
     files when *note -O: 453. is used) for all modules in a directory.


File: python.info,  Node: Standard Modules,  Next: The dir Function,  Prev: More on Modules,  Up: Modules

2.6.2 Standard Modules
----------------------

Python comes with a library of standard modules, described in a separate
document, the Python Library Reference ("Library Reference" hereafter).
Some modules are built into the interpreter; these provide access to
operations that are not part of the core of the language but are
nevertheless built in, either for efficiency or to provide access to
operating system primitives such as system calls.  The set of such
modules is a configuration option which also depends on the underlying
platform.  For example, the ‘winreg’ module is only provided on Windows
systems.  One particular module deserves some attention: *note sys: 16d,
which is built into every Python interpreter.  The variables ‘sys.ps1’
and ‘sys.ps2’ define the strings used as primary and secondary prompts:

     >>> import sys
     >>> sys.ps1
     '>>> '
     >>> sys.ps2
     '... '
     >>> sys.ps1 = 'C> '
     C> print 'Yuck!'
     Yuck!
     C>

  These two variables are only defined if the interpreter is in
interactive mode.

  The variable ‘sys.path’ is a list of strings that determines the
interpreter’s search path for modules.  It is initialized to a default
path taken from the environment variable *note PYTHONPATH: 580, or from
a built-in default if *note PYTHONPATH: 580. is not set.  You can modify
it using standard list operations:

     >>> import sys
     >>> sys.path.append('/ufs/guido/lib/python')


File: python.info,  Node: The dir Function,  Next: Packages,  Prev: Standard Modules,  Up: Modules

2.6.3 The ‘dir()’ Function
--------------------------

The built-in function *note dir(): 33a. is used to find out which names
a module defines.  It returns a sorted list of strings:

     >>> import fibo, sys
     >>> dir(fibo)
     ['__name__', 'fib', 'fib2']
     >>> dir(sys)  # doctest: +NORMALIZE_WHITESPACE
     ['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__',
      '__stderr__', '__stdin__', '__stdout__', '_clear_type_cache',
      '_current_frames', '_getframe', '_mercurial', 'api_version', 'argv',
      'builtin_module_names', 'byteorder', 'call_tracing', 'callstats',
      'copyright', 'displayhook', 'dont_write_bytecode', 'exc_clear', 'exc_info',
      'exc_traceback', 'exc_type', 'exc_value', 'excepthook', 'exec_prefix',
      'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
      'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
      'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
      'getrefcount', 'getsizeof', 'gettotalrefcount', 'gettrace', 'hexversion',
      'long_info', 'maxint', 'maxsize', 'maxunicode', 'meta_path', 'modules',
      'path', 'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
      'py3kwarning', 'setcheckinterval', 'setdlopenflags', 'setprofile',
      'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout', 'subversion',
      'version', 'version_info', 'warnoptions']

  Without arguments, *note dir(): 33a. lists the names you have defined
currently:

     >>> a = [1, 2, 3, 4, 5]
     >>> import fibo
     >>> fib = fibo.fib
     >>> dir()
     ['__builtins__', '__name__', '__package__', 'a', 'fib', 'fibo', 'sys']

  Note that it lists all types of names: variables, modules, functions,
etc.

  *note dir(): 33a. does not list the names of built-in functions and
variables.  If you want a list of those, they are defined in the
standard module *note __builtin__: 0.:

     >>> import __builtin__
     >>> dir(__builtin__)  # doctest: +NORMALIZE_WHITESPACE
     ['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
      'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError',
      'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError',
      'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning',
      'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
      'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
      'NotImplementedError', 'OSError', 'OverflowError',
      'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError',
      'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError',
      'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True',
      'TypeError', 'UnboundLocalError', 'UnicodeDecodeError',
      'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError',
      'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning',
      'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__',
      '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring',
      'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr',
      'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright',
      'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval',
      'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset',
      'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input',
      'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license',
      'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next',
      'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit',
      'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round',
      'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super',
      'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']


File: python.info,  Node: Packages,  Prev: The dir Function,  Up: Modules

2.6.4 Packages
--------------

Packages are a way of structuring Python’s module namespace by using
"dotted module names".  For example, the module name ‘A.B’ designates a
submodule named ‘B’ in a package named ‘A’.  Just like the use of
modules saves the authors of different modules from having to worry
about each other’s global variable names, the use of dotted module names
saves the authors of multi-module packages like NumPy or the Python
Imaging Library from having to worry about each other’s module names.

  Suppose you want to design a collection of modules (a "package") for
the uniform handling of sound files and sound data.  There are many
different sound file formats (usually recognized by their extension, for
example: ‘.wav’, ‘.aiff’, ‘.au’), so you may need to create and maintain
a growing collection of modules for the conversion between the various
file formats.  There are also many different operations you might want
to perform on sound data (such as mixing, adding echo, applying an
equalizer function, creating an artificial stereo effect), so in
addition you will be writing a never-ending stream of modules to perform
these operations.  Here’s a possible structure for your package
(expressed in terms of a hierarchical filesystem):

     sound/                          Top-level package
           __init__.py               Initialize the sound package
           formats/                  Subpackage for file format conversions
                   __init__.py
                   wavread.py
                   wavwrite.py
                   aiffread.py
                   aiffwrite.py
                   auread.py
                   auwrite.py
                   ...
           effects/                  Subpackage for sound effects
                   __init__.py
                   echo.py
                   surround.py
                   reverse.py
                   ...
           filters/                  Subpackage for filters
                   __init__.py
                   equalizer.py
                   vocoder.py
                   karaoke.py
                   ...

  When importing the package, Python searches through the directories on
‘sys.path’ looking for the package subdirectory.

  The ‘__init__.py’ files are required to make Python treat the
directories as containing packages; this is done to prevent directories
with a common name, such as ‘string’, from unintentionally hiding valid
modules that occur later on the module search path.  In the simplest
case, ‘__init__.py’ can just be an empty file, but it can also execute
initialization code for the package or set the ‘__all__’ variable,
described later.

  Users of the package can import individual modules from the package,
for example:

     import sound.effects.echo

  This loads the submodule ‘sound.effects.echo’.  It must be referenced
with its full name.

     sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)

  An alternative way of importing the submodule is:

     from sound.effects import echo

  This also loads the submodule ‘echo’, and makes it available without
its package prefix, so it can be used as follows:

     echo.echofilter(input, output, delay=0.7, atten=4)

  Yet another variation is to import the desired function or variable
directly:

     from sound.effects.echo import echofilter

  Again, this loads the submodule ‘echo’, but this makes its function
‘echofilter()’ directly available:

     echofilter(input, output, delay=0.7, atten=4)

  Note that when using ‘from package import item’, the item can be
either a submodule (or subpackage) of the package, or some other name
defined in the package, like a function, class or variable.  The
‘import’ statement first tests whether the item is defined in the
package; if not, it assumes it is a module and attempts to load it.  If
it fails to find it, an *note ImportError: 370. exception is raised.

  Contrarily, when using syntax like ‘import item.subitem.subsubitem’,
each item except for the last must be a package; the last item can be a
module or a package but can’t be a class or function or variable defined
in the previous item.

* Menu:

* Importing * From a Package:: 
* Intra-package References:: 
* Packages in Multiple Directories:: 


File: python.info,  Node: Importing * From a Package,  Next: Intra-package References,  Up: Packages

2.6.4.1 Importing * From a Package
..................................

Now what happens when the user writes ‘from sound.effects import *’?
Ideally, one would hope that this somehow goes out to the filesystem,
finds which submodules are present in the package, and imports them all.
This could take a long time and importing sub-modules might have
unwanted side-effects that should only happen when the sub-module is
explicitly imported.

  The only solution is for the package author to provide an explicit
index of the package.  The *note import: 1f4. statement uses the
following convention: if a package’s ‘__init__.py’ code defines a list
named ‘__all__’, it is taken to be the list of module names that should
be imported when ‘from package import *’ is encountered.  It is up to
the package author to keep this list up-to-date when a new version of
the package is released.  Package authors may also decide not to support
it, if they don’t see a use for importing * from their package.  For
example, the file ‘sound/effects/__init__.py’ could contain the
following code:

     __all__ = ["echo", "surround", "reverse"]

  This would mean that ‘from sound.effects import *’ would import the
three named submodules of the ‘sound’ package.

  If ‘__all__’ is not defined, the statement ‘from sound.effects import
*’ does _not_ import all submodules from the package ‘sound.effects’
into the current namespace; it only ensures that the package
‘sound.effects’ has been imported (possibly running any initialization
code in ‘__init__.py’) and then imports whatever names are defined in
the package.  This includes any names defined (and submodules explicitly
loaded) by ‘__init__.py’.  It also includes any submodules of the
package that were explicitly loaded by previous *note import: 1f4.
statements.  Consider this code:

     import sound.effects.echo
     import sound.effects.surround
     from sound.effects import *

  In this example, the ‘echo’ and ‘surround’ modules are imported in the
current namespace because they are defined in the ‘sound.effects’
package when the ‘from...import’ statement is executed.  (This also
works when ‘__all__’ is defined.)

  Although certain modules are designed to export only names that follow
certain patterns when you use ‘import *’, it is still considered bad
practise in production code.

  Remember, there is nothing wrong with using ‘from Package import
specific_submodule’!  In fact, this is the recommended notation unless
the importing module needs to use submodules with the same name from
different packages.


File: python.info,  Node: Intra-package References,  Next: Packages in Multiple Directories,  Prev: Importing * From a Package,  Up: Packages

2.6.4.2 Intra-package References
................................

The submodules often need to refer to each other.  For example, the
‘surround’ module might use the ‘echo’ module.  In fact, such references
are so common that the *note import: 1f4. statement first looks in the
containing package before looking in the standard module search path.
Thus, the ‘surround’ module can simply use ‘import echo’ or ‘from echo
import echofilter’.  If the imported module is not found in the current
package (the package of which the current module is a submodule), the
*note import: 1f4. statement looks for a top-level module with the given
name.

  When packages are structured into subpackages (as with the ‘sound’
package in the example), you can use absolute imports to refer to
submodules of siblings packages.  For example, if the module
‘sound.filters.vocoder’ needs to use the ‘echo’ module in the
‘sound.effects’ package, it can use ‘from sound.effects import echo’.

  Starting with Python 2.5, in addition to the implicit relative imports
described above, you can write explicit relative imports with the ‘from
module import name’ form of import statement.  These explicit relative
imports use leading dots to indicate the current and parent packages
involved in the relative import.  From the ‘surround’ module for
example, you might use:

     from . import echo
     from .. import formats
     from ..filters import equalizer

  Note that both explicit and implicit relative imports are based on the
name of the current module.  Since the name of the main module is always
‘"__main__"’, modules intended for use as the main module of a Python
application should always use absolute imports.


File: python.info,  Node: Packages in Multiple Directories,  Prev: Intra-package References,  Up: Packages

2.6.4.3 Packages in Multiple Directories
........................................

Packages support one more special attribute, ‘__path__’.  This is
initialized to be a list containing the name of the directory holding
the package’s ‘__init__.py’ before the code in that file is executed.
This variable can be modified; doing so affects future searches for
modules and subpackages contained in the package.

  While this feature is not often needed, it can be used to extend the
set of modules found in a package.


File: python.info,  Node: Input and Output,  Next: Errors and Exceptions,  Prev: Modules,  Up: The Python Tutorial

2.7 Input and Output
====================

There are several ways to present the output of a program; data can be
printed in a human-readable form, or written to a file for future use.
This chapter will discuss some of the possibilities.

* Menu:

* Fancier Output Formatting:: 
* Reading and Writing Files:: 

Fancier Output Formatting

* Old string formatting:: 

Reading and Writing Files

* Methods of File Objects:: 
* Saving structured data with json:: 


File: python.info,  Node: Fancier Output Formatting,  Next: Reading and Writing Files,  Up: Input and Output

2.7.1 Fancier Output Formatting
-------------------------------

So far we’ve encountered two ways of writing values: _expression
statements_ and the *note print: 4e0. statement.  (A third way is using
the ‘write()’ method of file objects; the standard output file can be
referenced as ‘sys.stdout’.  See the Library Reference for more
information on this.)

  Often you’ll want more control over the formatting of your output than
simply printing space-separated values.  There are two ways to format
your output; the first way is to do all the string handling yourself;
using string slicing and concatenation operations you can create any
layout you can imagine.  The string types have some methods that perform
useful operations for padding strings to a given column width; these
will be discussed shortly.  The second way is to use the *note
str.format(): 1d2. method.

  The *note string: 163. module contains a *note Template: 593. class
which offers yet another way to substitute values into strings.

  One question remains, of course: how do you convert values to strings?
Luckily, Python has ways to convert any value to a string: pass it to
the *note repr(): 145. or *note str(): 1ea. functions.

  The *note str(): 1ea. function is meant to return representations of
values which are fairly human-readable, while *note repr(): 145. is
meant to generate representations which can be read by the interpreter
(or will force a *note SyntaxError: 498. if there is no equivalent
syntax).  For objects which don’t have a particular representation for
human consumption, *note str(): 1ea. will return the same value as *note
repr(): 145.  Many values, such as numbers or structures like lists and
dictionaries, have the same representation using either function.
Strings and floating point numbers, in particular, have two distinct
representations.

  Some examples:

     >>> s = 'Hello, world.'
     >>> str(s)
     'Hello, world.'
     >>> repr(s)
     "'Hello, world.'"
     >>> str(1.0/7.0)
     '0.142857142857'
     >>> repr(1.0/7.0)
     '0.14285714285714285'
     >>> x = 10 * 3.25
     >>> y = 200 * 200
     >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
     >>> print s
     The value of x is 32.5, and y is 40000...
     >>> # The repr() of a string adds string quotes and backslashes:
     ... hello = 'hello, world\n'
     >>> hellos = repr(hello)
     >>> print hellos
     'hello, world\n'
     >>> # The argument to repr() may be any Python object:
     ... repr((x, y, ('spam', 'eggs')))
     "(32.5, 40000, ('spam', 'eggs'))"

  Here are two ways to write a table of squares and cubes:

     >>> for x in range(1, 11):
     ...     print repr(x).rjust(2), repr(x*x).rjust(3),
     ...     # Note trailing comma on previous line
     ...     print repr(x*x*x).rjust(4)
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000

     >>> for x in range(1,11):
     ...     print '{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x)
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000

  (Note that in the first example, one space between each column was
added by the way *note print: 4e0. works: it always adds spaces between
its arguments.)

  This example demonstrates the *note str.rjust(): 594. method of string
objects, which right-justifies a string in a field of a given width by
padding it with spaces on the left.  There are similar methods *note
str.ljust(): 595. and *note str.center(): 596.  These methods do not
write anything, they just return a new string.  If the input string is
too long, they don’t truncate it, but return it unchanged; this will
mess up your column lay-out but that’s usually better than the
alternative, which would be lying about a value.  (If you really want
truncation you can always add a slice operation, as in
‘x.ljust(n)[:n]’.)

  There is another method, *note str.zfill(): 597, which pads a numeric
string on the left with zeros.  It understands about plus and minus
signs:

     >>> '12'.zfill(5)
     '00012'
     >>> '-3.14'.zfill(7)
     '-003.14'
     >>> '3.14159265359'.zfill(5)
     '3.14159265359'

  Basic usage of the *note str.format(): 1d2. method looks like this:

     >>> print 'We are the {} who say "{}!"'.format('knights', 'Ni')
     We are the knights who say "Ni!"

  The brackets and characters within them (called format fields) are
replaced with the objects passed into the *note str.format(): 1d2.
method.  A number in the brackets refers to the position of the object
passed into the *note str.format(): 1d2. method.

     >>> print '{0} and {1}'.format('spam', 'eggs')
     spam and eggs
     >>> print '{1} and {0}'.format('spam', 'eggs')
     eggs and spam

  If keyword arguments are used in the *note str.format(): 1d2. method,
their values are referred to by using the name of the argument.

     >>> print 'This {food} is {adjective}.'.format(
     ...       food='spam', adjective='absolutely horrible')
     This spam is absolutely horrible.

  Positional and keyword arguments can be arbitrarily combined:

     >>> print 'The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
     ...                                                    other='Georg')
     The story of Bill, Manfred, and Georg.

  ‘'!s'’ (apply *note str(): 1ea.) and ‘'!r'’ (apply *note repr(): 145.)
can be used to convert the value before it is formatted.

     >>> import math
     >>> print 'The value of PI is approximately {}.'.format(math.pi)
     The value of PI is approximately 3.14159265359.
     >>> print 'The value of PI is approximately {!r}.'.format(math.pi)
     The value of PI is approximately 3.141592653589793.

  An optional ‘':'’ and format specifier can follow the field name.
This allows greater control over how the value is formatted.  The
following example rounds Pi to three places after the decimal.

     >>> import math
     >>> print 'The value of PI is approximately {0:.3f}.'.format(math.pi)
     The value of PI is approximately 3.142.

  Passing an integer after the ‘':'’ will cause that field to be a
minimum number of characters wide.  This is useful for making tables
pretty.

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
     >>> for name, phone in table.items():
     ...     print '{0:10} ==> {1:10d}'.format(name, phone)
     ...
     Jack       ==>       4098
     Dcab       ==>       7678
     Sjoerd     ==>       4127

  If you have a really long format string that you don’t want to split
up, it would be nice if you could reference the variables to be
formatted by name instead of by position.  This can be done by simply
passing the dict and using square brackets ‘'[]'’ to access the keys

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
     >>> print ('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
     ...        'Dcab: {0[Dcab]:d}'.format(table))
     Jack: 4098; Sjoerd: 4127; Dcab: 8637678

  This could also be done by passing the table as keyword arguments with
the ’**’ notation.

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
     >>> print 'Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table)
     Jack: 4098; Sjoerd: 4127; Dcab: 8637678

  This is particularly useful in combination with the built-in function
*note vars(): 598, which returns a dictionary containing all local
variables.

  For a complete overview of string formatting with *note str.format():
1d2, see *note Format String Syntax: 308.

* Menu:

* Old string formatting:: 


File: python.info,  Node: Old string formatting,  Up: Fancier Output Formatting

2.7.1.1 Old string formatting
.............................

The ‘%’ operator can also be used for string formatting.  It interprets
the left argument much like a ‘sprintf()’-style format string to be
applied to the right argument, and returns the string resulting from
this formatting operation.  For example:

     >>> import math
     >>> print 'The value of PI is approximately %5.3f.' % math.pi
     The value of PI is approximately 3.142.

  More information can be found in the *note String Formatting
Operations: 524. section.


File: python.info,  Node: Reading and Writing Files,  Prev: Fancier Output Formatting,  Up: Input and Output

2.7.2 Reading and Writing Files
-------------------------------

*note open(): 2d6. returns a file object, and is most commonly used with
two arguments: ‘open(filename, mode)’.

     >>> f = open('workfile', 'w')
     >>> print f
     <open file 'workfile', mode 'w' at 80a0960>

  The first argument is a string containing the filename.  The second
argument is another string containing a few characters describing the
way in which the file will be used.  _mode_ can be ‘'r'’ when the file
will only be read, ‘'w'’ for only writing (an existing file with the
same name will be erased), and ‘'a'’ opens the file for appending; any
data written to the file is automatically added to the end.  ‘'r+'’
opens the file for both reading and writing.  The _mode_ argument is
optional; ‘'r'’ will be assumed if it’s omitted.

  On Windows, ‘'b'’ appended to the mode opens the file in binary mode,
so there are also modes like ‘'rb'’, ‘'wb'’, and ‘'r+b'’.  Python on
Windows makes a distinction between text and binary files; the
end-of-line characters in text files are automatically altered slightly
when data is read or written.  This behind-the-scenes modification to
file data is fine for ASCII text files, but it’ll corrupt binary data
like that in ‘JPEG’ or ‘EXE’ files.  Be very careful to use binary mode
when reading and writing such files.  On Unix, it doesn’t hurt to append
a ‘'b'’ to the mode, so you can use it platform-independently for all
binary files.

* Menu:

* Methods of File Objects:: 
* Saving structured data with json:: 


File: python.info,  Node: Methods of File Objects,  Next: Saving structured data with json,  Up: Reading and Writing Files

2.7.2.1 Methods of File Objects
...............................

The rest of the examples in this section will assume that a file object
called ‘f’ has already been created.

  To read a file’s contents, call ‘f.read(size)’, which reads some
quantity of data and returns it as a string.  _size_ is an optional
numeric argument.  When _size_ is omitted or negative, the entire
contents of the file will be read and returned; it’s your problem if the
file is twice as large as your machine’s memory.  Otherwise, at most
_size_ bytes are read and returned.  If the end of the file has been
reached, ‘f.read()’ will return an empty string (‘""’).

     >>> f.read()
     'This is the entire file.\n'
     >>> f.read()
     ''

  ‘f.readline()’ reads a single line from the file; a newline character
(‘\n’) is left at the end of the string, and is only omitted on the last
line of the file if the file doesn’t end in a newline.  This makes the
return value unambiguous; if ‘f.readline()’ returns an empty string, the
end of the file has been reached, while a blank line is represented by
‘'\n'’, a string containing only a single newline.

     >>> f.readline()
     'This is the first line of the file.\n'
     >>> f.readline()
     'Second line of the file\n'
     >>> f.readline()
     ''

  For reading lines from a file, you can loop over the file object.
This is memory efficient, fast, and leads to simple code:

     >>> for line in f:
             print line,

     This is the first line of the file.
     Second line of the file

  If you want to read all the lines of a file in a list you can also use
‘list(f)’ or ‘f.readlines()’.

  ‘f.write(string)’ writes the contents of _string_ to the file,
returning ‘None’.

     >>> f.write('This is a test\n')

  To write something other than a string, it needs to be converted to a
string first:

     >>> value = ('the answer', 42)
     >>> s = str(value)
     >>> f.write(s)

  ‘f.tell()’ returns an integer giving the file object’s current
position in the file, measured in bytes from the beginning of the file.
To change the file object’s position, use ‘f.seek(offset, from_what)’.
The position is computed from adding _offset_ to a reference point; the
reference point is selected by the _from_what_ argument.  A _from_what_
value of 0 measures from the beginning of the file, 1 uses the current
file position, and 2 uses the end of the file as the reference point.
_from_what_ can be omitted and defaults to 0, using the beginning of the
file as the reference point.

     >>> f = open('workfile', 'r+')
     >>> f.write('0123456789abcdef')
     >>> f.seek(5)     # Go to the 6th byte in the file
     >>> f.read(1)
     '5'
     >>> f.seek(-3, 2) # Go to the 3rd byte before the end
     >>> f.read(1)
     'd'

  When you’re done with a file, call ‘f.close()’ to close it and free up
any system resources taken up by the open file.  After calling
‘f.close()’, attempts to use the file object will automatically fail.

     >>> f.close()
     >>> f.read()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: I/O operation on closed file

  It is good practice to use the *note with: 1c0. keyword when dealing
with file objects.  This has the advantage that the file is properly
closed after its suite finishes, even if an exception is raised on the
way.  It is also much shorter than writing equivalent *note try:
395.-*note finally: 396. blocks:

     >>> with open('workfile', 'r') as f:
     ...     read_data = f.read()
     >>> f.closed
     True

  File objects have some additional methods, such as *note isatty():
59e. and *note truncate(): 59f. which are less frequently used; consult
the Library Reference for a complete guide to file objects.


File: python.info,  Node: Saving structured data with json,  Prev: Methods of File Objects,  Up: Reading and Writing Files

2.7.2.2 Saving structured data with ‘json’
..........................................

Strings can easily be written to and read from a file.  Numbers take a
bit more effort, since the ‘read()’ method only returns strings, which
will have to be passed to a function like *note int(): 1f2, which takes
a string like ‘'123'’ and returns its numeric value 123.  When you want
to save more complex data types like nested lists and dictionaries,
parsing and serializing by hand becomes complicated.

  Rather than having users constantly writing and debugging code to save
complicated data types to files, Python allows you to use the popular
data interchange format called JSON (JavaScript Object Notation)(1).
The standard module called *note json: fc. can take Python data
hierarchies, and convert them to string representations; this process is
called _serializing_.  Reconstructing the data from the string
representation is called _deserializing_.  Between serializing and
deserializing, the string representing the object may have been stored
in a file or data, or sent over a network connection to some distant
machine.

     Note: The JSON format is commonly used by modern applications to
     allow for data exchange.  Many programmers are already familiar
     with it, which makes it a good choice for interoperability.

  If you have an object ‘x’, you can view its JSON string representation
with a simple line of code:

     >>> json.dumps([1, 'simple', 'list'])
     '[1, "simple", "list"]'

  Another variant of the *note dumps(): 5a2. function, called *note
dump(): 5a3, simply serializes the object to a file.  So if ‘f’ is a
*note file object: 5a4. opened for writing, we can do this:

     json.dump(x, f)

  To decode the object again, if ‘f’ is a *note file object: 5a4. which
has been opened for reading:

     x = json.load(f)

  This simple serialization technique can handle lists and dictionaries,
but serializing arbitrary class instances in JSON requires a bit of
extra effort.  The reference for the *note json: fc. module contains an
explanation of this.

See also
........

*note pickle: 12d. - the pickle module

  Contrary to *note JSON: 5a0, _pickle_ is a protocol which allows the
serialization of arbitrarily complex Python objects.  As such, it is
specific to Python and cannot be used to communicate with applications
written in other languages.  It is also insecure by default:
deserializing pickle data coming from an untrusted source can execute
arbitrary code, if the data was crafted by a skilled attacker.

   ---------- Footnotes ----------

   (1) http://json.org


File: python.info,  Node: Errors and Exceptions,  Next: Classes,  Prev: Input and Output,  Up: The Python Tutorial

2.8 Errors and Exceptions
=========================

Until now error messages haven’t been more than mentioned, but if you
have tried out the examples you have probably seen some.  There are (at
least) two distinguishable kinds of errors: _syntax errors_ and
_exceptions_.

* Menu:

* Syntax Errors:: 
* Exceptions:: 
* Handling Exceptions:: 
* Raising Exceptions:: 
* User-defined Exceptions:: 
* Defining Clean-up Actions:: 
* Predefined Clean-up Actions:: 


File: python.info,  Node: Syntax Errors,  Next: Exceptions,  Up: Errors and Exceptions

2.8.1 Syntax Errors
-------------------

Syntax errors, also known as parsing errors, are perhaps the most common
kind of complaint you get while you are still learning Python:

     >>> while True print 'Hello world'
       File "<stdin>", line 1, in ?
         while True print 'Hello world'
                        ^
     SyntaxError: invalid syntax

  The parser repeats the offending line and displays a little ’arrow’
pointing at the earliest point in the line where the error was detected.
The error is caused by (or at least detected at) the token _preceding_
the arrow: in the example, the error is detected at the keyword *note
print: 4e0, since a colon (‘':'’) is missing before it.  File name and
line number are printed so you know where to look in case the input came
from a script.


File: python.info,  Node: Exceptions,  Next: Handling Exceptions,  Prev: Syntax Errors,  Up: Errors and Exceptions

2.8.2 Exceptions
----------------

Even if a statement or expression is syntactically correct, it may cause
an error when an attempt is made to execute it.  Errors detected during
execution are called _exceptions_ and are not unconditionally fatal: you
will soon learn how to handle them in Python programs.  Most exceptions
are not handled by programs, however, and result in error messages as
shown here:

     >>> 10 * (1/0)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ZeroDivisionError: integer division or modulo by zero
     >>> 4 + spam*3
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: name 'spam' is not defined
     >>> '2' + 2
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: cannot concatenate 'str' and 'int' objects

  The last line of the error message indicates what happened.
Exceptions come in different types, and the type is printed as part of
the message: the types in the example are *note ZeroDivisionError: 5ac,
*note NameError: 3a3. and *note TypeError: 218.  The string printed as
the exception type is the name of the built-in exception that occurred.
This is true for all built-in exceptions, but need not be true for
user-defined exceptions (although it is a useful convention).  Standard
exception names are built-in identifiers (not reserved keywords).

  The rest of the line provides detail based on the type of exception
and what caused it.

  The preceding part of the error message shows the context where the
exception happened, in the form of a stack traceback.  In general it
contains a stack traceback listing source lines; however, it will not
display lines read from standard input.

  *note Built-in Exceptions: 5ad. lists the built-in exceptions and
their meanings.


File: python.info,  Node: Handling Exceptions,  Next: Raising Exceptions,  Prev: Exceptions,  Up: Errors and Exceptions

2.8.3 Handling Exceptions
-------------------------

It is possible to write programs that handle selected exceptions.  Look
at the following example, which asks the user for input until a valid
integer has been entered, but allows the user to interrupt the program
(using ‘Control-C’ or whatever the operating system supports); note that
a user-generated interruption is signalled by raising the *note
KeyboardInterrupt: 251. exception.

     >>> while True:
     ...     try:
     ...         x = int(raw_input("Please enter a number: "))
     ...         break
     ...     except ValueError:
     ...         print "Oops!  That was no valid number.  Try again..."
     ...

  The *note try: 395. statement works as follows.

   * First, the _try clause_ (the statement(s) between the *note try:
     395. and *note except: 397. keywords) is executed.

   * If no exception occurs, the _except clause_ is skipped and
     execution of the *note try: 395. statement is finished.

   * If an exception occurs during execution of the try clause, the rest
     of the clause is skipped.  Then if its type matches the exception
     named after the *note except: 397. keyword, the except clause is
     executed, and then execution continues after the *note try: 395.
     statement.

   * If an exception occurs which does not match the exception named in
     the except clause, it is passed on to outer *note try: 395.
     statements; if no handler is found, it is an _unhandled exception_
     and execution stops with a message as shown above.

  A *note try: 395. statement may have more than one except clause, to
specify handlers for different exceptions.  At most one handler will be
executed.  Handlers only handle exceptions that occur in the
corresponding try clause, not in other handlers of the same *note try:
395. statement.  An except clause may name multiple exceptions as a
parenthesized tuple, for example:

     ... except (RuntimeError, TypeError, NameError):
     ...     pass

  Note that the parentheses around this tuple are required, because
‘except ValueError, e:’ was the syntax used for what is normally written
as ‘except ValueError as e:’ in modern Python (described below).  The
old syntax is still supported for backwards compatibility.  This means
‘except RuntimeError, TypeError’ is not equivalent to ‘except
(RuntimeError, TypeError):’ but to ‘except RuntimeError as TypeError:’
which is not what you want.

  The last except clause may omit the exception name(s), to serve as a
wildcard.  Use this with extreme caution, since it is easy to mask a
real programming error in this way!  It can also be used to print an
error message and then re-raise the exception (allowing a caller to
handle the exception as well):

     import sys

     try:
         f = open('myfile.txt')
         s = f.readline()
         i = int(s.strip())
     except IOError as e:
         print "I/O error({0}): {1}".format(e.errno, e.strerror)
     except ValueError:
         print "Could not convert data to an integer."
     except:
         print "Unexpected error:", sys.exc_info()[0]
         raise

  The *note try: 395. ...  *note except: 397. statement has an optional
_else clause_, which, when present, must follow all except clauses.  It
is useful for code that must be executed if the try clause does not
raise an exception.  For example:

     for arg in sys.argv[1:]:
         try:
             f = open(arg, 'r')
         except IOError:
             print 'cannot open', arg
         else:
             print arg, 'has', len(f.readlines()), 'lines'
             f.close()

  The use of the *note else: 532. clause is better than adding
additional code to the *note try: 395. clause because it avoids
accidentally catching an exception that wasn’t raised by the code being
protected by the *note try: 395. ...  *note except: 397. statement.

  When an exception occurs, it may have an associated value, also known
as the exception’s _argument_.  The presence and type of the argument
depend on the exception type.

  The except clause may specify a variable after the exception name (or
tuple).  The variable is bound to an exception instance with the
arguments stored in ‘instance.args’.  For convenience, the exception
instance defines *note __str__(): 496. so the arguments can be printed
directly without having to reference ‘.args’.

  One may also instantiate an exception first before raising it and add
any attributes to it as desired.

     >>> try:
     ...    raise Exception('spam', 'eggs')
     ... except Exception as inst:
     ...    print type(inst)     # the exception instance
     ...    print inst.args      # arguments stored in .args
     ...    print inst           # __str__ allows args to printed directly
     ...    x, y = inst.args
     ...    print 'x =', x
     ...    print 'y =', y
     ...
     <type 'exceptions.Exception'>
     ('spam', 'eggs')
     ('spam', 'eggs')
     x = spam
     y = eggs

  If an exception has an argument, it is printed as the last part
(’detail’) of the message for unhandled exceptions.

  Exception handlers don’t just handle exceptions if they occur
immediately in the try clause, but also if they occur inside functions
that are called (even indirectly) in the try clause.  For example:

     >>> def this_fails():
     ...     x = 1/0
     ...
     >>> try:
     ...     this_fails()
     ... except ZeroDivisionError as detail:
     ...     print 'Handling run-time error:', detail
     ...
     Handling run-time error: integer division or modulo by zero


File: python.info,  Node: Raising Exceptions,  Next: User-defined Exceptions,  Prev: Handling Exceptions,  Up: Errors and Exceptions

2.8.4 Raising Exceptions
------------------------

The *note raise: 5b1. statement allows the programmer to force a
specified exception to occur.  For example:

     >>> raise NameError('HiThere')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: HiThere

  The sole argument to *note raise: 5b1. indicates the exception to be
raised.  This must be either an exception instance or an exception class
(a class that derives from ‘Exception’).

  If you need to determine whether an exception was raised but don’t
intend to handle it, a simpler form of the *note raise: 5b1. statement
allows you to re-raise the exception:

     >>> try:
     ...     raise NameError('HiThere')
     ... except NameError:
     ...     print 'An exception flew by!'
     ...     raise
     ...
     An exception flew by!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     NameError: HiThere


File: python.info,  Node: User-defined Exceptions,  Next: Defining Clean-up Actions,  Prev: Raising Exceptions,  Up: Errors and Exceptions

2.8.5 User-defined Exceptions
-----------------------------

Programs may name their own exceptions by creating a new exception class
(see *note Classes: 544. for more about Python classes).  Exceptions
should typically be derived from the *note Exception: 339. class, either
directly or indirectly.  For example:

     >>> class MyError(Exception):
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __str__(self):
     ...         return repr(self.value)
     ...
     >>> try:
     ...     raise MyError(2*2)
     ... except MyError as e:
     ...     print 'My exception occurred, value:', e.value
     ...
     My exception occurred, value: 4
     >>> raise MyError('oops!')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     __main__.MyError: 'oops!'

  In this example, the default *note __init__(): 37c. of ‘Exception’ has
been overridden.  The new behavior simply creates the _value_ attribute.
This replaces the default behavior of creating the _args_ attribute.

  Exception classes can be defined which do anything any other class can
do, but are usually kept simple, often only offering a number of
attributes that allow information about the error to be extracted by
handlers for the exception.  When creating a module that can raise
several distinct errors, a common practice is to create a base class for
exceptions defined by that module, and subclass that to create specific
exception classes for different error conditions:

     class Error(Exception):
         """Base class for exceptions in this module."""
         pass

     class InputError(Error):
         """Exception raised for errors in the input.

         Attributes:
             expr -- input expression in which the error occurred
             msg  -- explanation of the error
         """

         def __init__(self, expr, msg):
             self.expr = expr
             self.msg = msg

     class TransitionError(Error):
         """Raised when an operation attempts a state transition that's not
         allowed.

         Attributes:
             prev -- state at beginning of transition
             next -- attempted new state
             msg  -- explanation of why the specific transition is not allowed
         """

         def __init__(self, prev, next, msg):
             self.prev = prev
             self.next = next
             self.msg = msg

  Most exceptions are defined with names that end in "Error," similar to
the naming of the standard exceptions.

  Many standard modules define their own exceptions to report errors
that may occur in functions they define.  More information on classes is
presented in chapter *note Classes: 544.


File: python.info,  Node: Defining Clean-up Actions,  Next: Predefined Clean-up Actions,  Prev: User-defined Exceptions,  Up: Errors and Exceptions

2.8.6 Defining Clean-up Actions
-------------------------------

The *note try: 395. statement has another optional clause which is
intended to define clean-up actions that must be executed under all
circumstances.  For example:

     >>> try:
     ...     raise KeyboardInterrupt
     ... finally:
     ...     print 'Goodbye, world!'
     ...
     Goodbye, world!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     KeyboardInterrupt

  A _finally clause_ is always executed before leaving the *note try:
395. statement, whether an exception has occurred or not.  When an
exception has occurred in the *note try: 395. clause and has not been
handled by an *note except: 397. clause (or it has occurred in a *note
except: 397. or *note else: 532. clause), it is re-raised after the
*note finally: 396. clause has been executed.  The *note finally: 396.
clause is also executed "on the way out" when any other clause of the
*note try: 395. statement is left via a *note break: 53a, *note
continue: 53c. or *note return: 2f4. statement.  A more complicated
example (having *note except: 397. and *note finally: 396. clauses in
the same *note try: 395. statement works as of Python 2.5):

     >>> def divide(x, y):
     ...     try:
     ...         result = x / y
     ...     except ZeroDivisionError:
     ...         print "division by zero!"
     ...     else:
     ...         print "result is", result
     ...     finally:
     ...         print "executing finally clause"
     ...
     >>> divide(2, 1)
     result is 2
     executing finally clause
     >>> divide(2, 0)
     division by zero!
     executing finally clause
     >>> divide("2", "1")
     executing finally clause
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "<stdin>", line 3, in divide
     TypeError: unsupported operand type(s) for /: 'str' and 'str'

  As you can see, the *note finally: 396. clause is executed in any
event.  The *note TypeError: 218. raised by dividing two strings is not
handled by the *note except: 397. clause and therefore re-raised after
the *note finally: 396. clause has been executed.

  In real world applications, the *note finally: 396. clause is useful
for releasing external resources (such as files or network connections),
regardless of whether the use of the resource was successful.


File: python.info,  Node: Predefined Clean-up Actions,  Prev: Defining Clean-up Actions,  Up: Errors and Exceptions

2.8.7 Predefined Clean-up Actions
---------------------------------

Some objects define standard clean-up actions to be undertaken when the
object is no longer needed, regardless of whether or not the operation
using the object succeeded or failed.  Look at the following example,
which tries to open a file and print its contents to the screen.

     for line in open("myfile.txt"):
         print line,

  The problem with this code is that it leaves the file open for an
indeterminate amount of time after the code has finished executing.
This is not an issue in simple scripts, but can be a problem for larger
applications.  The *note with: 1c0. statement allows objects like files
to be used in a way that ensures they are always cleaned up promptly and
correctly.

     with open("myfile.txt") as f:
         for line in f:
             print line,

  After the statement is executed, the file _f_ is always closed, even
if a problem was encountered while processing the lines.  Other objects
which provide predefined clean-up actions will indicate this in their
documentation.


File: python.info,  Node: Classes,  Next: Brief Tour of the Standard Library,  Prev: Errors and Exceptions,  Up: The Python Tutorial

2.9 Classes
===========

Compared with other programming languages, Python’s class mechanism adds
classes with a minimum of new syntax and semantics.  It is a mixture of
the class mechanisms found in C++ and Modula-3.  Python classes provide
all the standard features of Object Oriented Programming: the class
inheritance mechanism allows multiple base classes, a derived class can
override any methods of its base class or classes, and a method can call
the method of a base class with the same name.  Objects can contain
arbitrary amounts and kinds of data.  As is true for modules, classes
partake of the dynamic nature of Python: they are created at runtime,
and can be modified further after creation.

  In C++ terminology, normally class members (including the data
members) are _public_ (except see below *note Private Variables and
Class-local References: 5ba.), and all member functions are _virtual_.
As in Modula-3, there are no shorthands for referencing the object’s
members from its methods: the method function is declared with an
explicit first argument representing the object, which is provided
implicitly by the call.  As in Smalltalk, classes themselves are
objects.  This provides semantics for importing and renaming.  Unlike
C++ and Modula-3, built-in types can be used as base classes for
extension by the user.  Also, like in C++, most built-in operators with
special syntax (arithmetic operators, subscripting etc.)  can be
redefined for class instances.

  (Lacking universally accepted terminology to talk about classes, I
will make occasional use of Smalltalk and C++ terms.  I would use
Modula-3 terms, since its object-oriented semantics are closer to those
of Python than C++, but I expect that few readers have heard of it.)

* Menu:

* A Word About Names and Objects:: 
* Python Scopes and Namespaces:: 
* A First Look at Classes:: 
* Random Remarks:: 
* Inheritance:: 
* Private Variables and Class-local References:: 
* Odds and Ends:: 
* Exceptions Are Classes Too:: 
* Iterators:: 
* Generators:: 
* Generator Expressions:: 


File: python.info,  Node: A Word About Names and Objects,  Next: Python Scopes and Namespaces,  Up: Classes

2.9.1 A Word About Names and Objects
------------------------------------

Objects have individuality, and multiple names (in multiple scopes) can
be bound to the same object.  This is known as aliasing in other
languages.  This is usually not appreciated on a first glance at Python,
and can be safely ignored when dealing with immutable basic types
(numbers, strings, tuples).  However, aliasing has a possibly surprising
effect on the semantics of Python code involving mutable objects such as
lists, dictionaries, and most other types.  This is usually used to the
benefit of the program, since aliases behave like pointers in some
respects.  For example, passing an object is cheap since only a pointer
is passed by the implementation; and if a function modifies an object
passed as an argument, the caller will see the change — this eliminates
the need for two different argument passing mechanisms as in Pascal.


File: python.info,  Node: Python Scopes and Namespaces,  Next: A First Look at Classes,  Prev: A Word About Names and Objects,  Up: Classes

2.9.2 Python Scopes and Namespaces
----------------------------------

Before introducing classes, I first have to tell you something about
Python’s scope rules.  Class definitions play some neat tricks with
namespaces, and you need to know how scopes and namespaces work to fully
understand what’s going on.  Incidentally, knowledge about this subject
is useful for any advanced Python programmer.

  Let’s begin with some definitions.

  A _namespace_ is a mapping from names to objects.  Most namespaces are
currently implemented as Python dictionaries, but that’s normally not
noticeable in any way (except for performance), and it may change in the
future.  Examples of namespaces are: the set of built-in names
(containing functions such as *note abs(): 5bf, and built-in exception
names); the global names in a module; and the local names in a function
invocation.  In a sense the set of attributes of an object also form a
namespace.  The important thing to know about namespaces is that there
is absolutely no relation between names in different namespaces; for
instance, two different modules may both define a function ‘maximize’
without confusion — users of the modules must prefix it with the module
name.

  By the way, I use the word _attribute_ for any name following a dot —
for example, in the expression ‘z.real’, ‘real’ is an attribute of the
object ‘z’.  Strictly speaking, references to names in modules are
attribute references: in the expression ‘modname.funcname’, ‘modname’ is
a module object and ‘funcname’ is an attribute of it.  In this case
there happens to be a straightforward mapping between the module’s
attributes and the global names defined in the module: they share the
same namespace!  (1)

  Attributes may be read-only or writable.  In the latter case,
assignment to attributes is possible.  Module attributes are writable:
you can write ‘modname.the_answer = 42’.  Writable attributes may also
be deleted with the *note del: 568. statement.  For example, ‘del
modname.the_answer’ will remove the attribute ‘the_answer’ from the
object named by ‘modname’.

  Namespaces are created at different moments and have different
lifetimes.  The namespace containing the built-in names is created when
the Python interpreter starts up, and is never deleted.  The global
namespace for a module is created when the module definition is read in;
normally, module namespaces also last until the interpreter quits.  The
statements executed by the top-level invocation of the interpreter,
either read from a script file or interactively, are considered part of
a module called *note __main__: 2, so they have their own global
namespace.  (The built-in names actually also live in a module; this is
called *note __builtin__: 0.)

  The local namespace for a function is created when the function is
called, and deleted when the function returns or raises an exception
that is not handled within the function.  (Actually, forgetting would be
a better way to describe what actually happens.)  Of course, recursive
invocations each have their own local namespace.

  A _scope_ is a textual region of a Python program where a namespace is
directly accessible.  "Directly accessible" here means that an
unqualified reference to a name attempts to find the name in the
namespace.

  Although scopes are determined statically, they are used dynamically.
At any time during execution, there are at least three nested scopes
whose namespaces are directly accessible:

   * the innermost scope, which is searched first, contains the local
     names

   * the scopes of any enclosing functions, which are searched starting
     with the nearest enclosing scope, contains non-local, but also
     non-global names

   * the next-to-last scope contains the current module’s global names

   * the outermost scope (searched last) is the namespace containing
     built-in names

  If a name is declared global, then all references and assignments go
directly to the middle scope containing the module’s global names.
Otherwise, all variables found outside of the innermost scope are
read-only (an attempt to write to such a variable will simply create a
_new_ local variable in the innermost scope, leaving the identically
named outer variable unchanged).

  Usually, the local scope references the local names of the (textually)
current function.  Outside functions, the local scope references the
same namespace as the global scope: the module’s namespace.  Class
definitions place yet another namespace in the local scope.

  It is important to realize that scopes are determined textually: the
global scope of a function defined in a module is that module’s
namespace, no matter from where or by what alias the function is called.
On the other hand, the actual search for names is done dynamically, at
run time — however, the language definition is evolving towards static
name resolution, at "compile" time, so don’t rely on dynamic name
resolution!  (In fact, local variables are already determined
statically.)

  A special quirk of Python is that – if no *note global: 543. statement
is in effect – assignments to names always go into the innermost scope.
Assignments do not copy data — they just bind names to objects.  The
same is true for deletions: the statement ‘del x’ removes the binding of
‘x’ from the namespace referenced by the local scope.  In fact, all
operations that introduce new names use the local scope: in particular,
*note import: 1f4. statements and function definitions bind the module
or function name in the local scope.  (The *note global: 543. statement
can be used to indicate that particular variables live in the global
scope.)

   ---------- Footnotes ----------

   (1) Except for one thing.  Module objects have a secret read-only
attribute called ‘__dict__’ which returns the dictionary used to
implement the module’s namespace; the name ‘__dict__’ is an attribute
but not a global name.  Obviously, using this violates the abstraction
of namespace implementation, and should be restricted to things like
post-mortem debuggers.


File: python.info,  Node: A First Look at Classes,  Next: Random Remarks,  Prev: Python Scopes and Namespaces,  Up: Classes

2.9.3 A First Look at Classes
-----------------------------

Classes introduce a little bit of new syntax, three new object types,
and some new semantics.

* Menu:

* Class Definition Syntax:: 
* Class Objects:: 
* Instance Objects:: 
* Method Objects:: 
* Class and Instance Variables:: 


File: python.info,  Node: Class Definition Syntax,  Next: Class Objects,  Up: A First Look at Classes

2.9.3.1 Class Definition Syntax
...............................

The simplest form of class definition looks like this:

     class ClassName:
         <statement-1>
         .
         .
         .
         <statement-N>

  Class definitions, like function definitions (*note def: 3f4.
statements) must be executed before they have any effect.  (You could
conceivably place a class definition in a branch of an *note if: 42c.
statement, or inside a function.)

  In practice, the statements inside a class definition will usually be
function definitions, but other statements are allowed, and sometimes
useful — we’ll come back to this later.  The function definitions inside
a class normally have a peculiar form of argument list, dictated by the
calling conventions for methods — again, this is explained later.

  When a class definition is entered, a new namespace is created, and
used as the local scope — thus, all assignments to local variables go
into this new namespace.  In particular, function definitions bind the
name of the new function here.

  When a class definition is left normally (via the end), a _class
object_ is created.  This is basically a wrapper around the contents of
the namespace created by the class definition; we’ll learn more about
class objects in the next section.  The original local scope (the one in
effect just before the class definition was entered) is reinstated, and
the class object is bound here to the class name given in the class
definition header (‘ClassName’ in the example).


File: python.info,  Node: Class Objects,  Next: Instance Objects,  Prev: Class Definition Syntax,  Up: A First Look at Classes

2.9.3.2 Class Objects
.....................

Class objects support two kinds of operations: attribute references and
instantiation.

  _Attribute references_ use the standard syntax used for all attribute
references in Python: ‘obj.name’.  Valid attribute names are all the
names that were in the class’s namespace when the class object was
created.  So, if the class definition looked like this:

     class MyClass:
         """A simple example class"""
         i = 12345
         def f(self):
             return 'hello world'

  then ‘MyClass.i’ and ‘MyClass.f’ are valid attribute references,
returning an integer and a function object, respectively.  Class
attributes can also be assigned to, so you can change the value of
‘MyClass.i’ by assignment.  ‘__doc__’ is also a valid attribute,
returning the docstring belonging to the class: ‘"A simple example
class"’.

  Class _instantiation_ uses function notation.  Just pretend that the
class object is a parameterless function that returns a new instance of
the class.  For example (assuming the above class):

     x = MyClass()

  creates a new _instance_ of the class and assigns this object to the
local variable ‘x’.

  The instantiation operation ("calling" a class object) creates an
empty object.  Many classes like to create objects with instances
customized to a specific initial state.  Therefore a class may define a
special method named *note __init__(): 37c, like this:

     def __init__(self):
         self.data = []

  When a class defines an *note __init__(): 37c. method, class
instantiation automatically invokes *note __init__(): 37c. for the
newly-created class instance.  So in this example, a new, initialized
instance can be obtained by:

     x = MyClass()

  Of course, the *note __init__(): 37c. method may have arguments for
greater flexibility.  In that case, arguments given to the class
instantiation operator are passed on to *note __init__(): 37c.  For
example,

     >>> class Complex:
     ...     def __init__(self, realpart, imagpart):
     ...         self.r = realpart
     ...         self.i = imagpart
     ...
     >>> x = Complex(3.0, -4.5)
     >>> x.r, x.i
     (3.0, -4.5)


File: python.info,  Node: Instance Objects,  Next: Method Objects,  Prev: Class Objects,  Up: A First Look at Classes

2.9.3.3 Instance Objects
........................

Now what can we do with instance objects?  The only operations
understood by instance objects are attribute references.  There are two
kinds of valid attribute names, data attributes and methods.

  _data attributes_ correspond to "instance variables" in Smalltalk, and
to "data members" in C++.  Data attributes need not be declared; like
local variables, they spring into existence when they are first assigned
to.  For example, if ‘x’ is the instance of ‘MyClass’ created above, the
following piece of code will print the value ‘16’, without leaving a
trace:

     x.counter = 1
     while x.counter < 10:
         x.counter = x.counter * 2
     print x.counter
     del x.counter

  The other kind of instance attribute reference is a _method_.  A
method is a function that "belongs to" an object.  (In Python, the term
method is not unique to class instances: other object types can have
methods as well.  For example, list objects have methods called append,
insert, remove, sort, and so on.  However, in the following discussion,
we’ll use the term method exclusively to mean methods of class instance
objects, unless explicitly stated otherwise.)

  Valid method names of an instance object depend on its class.  By
definition, all attributes of a class that are function objects define
corresponding methods of its instances.  So in our example, ‘x.f’ is a
valid method reference, since ‘MyClass.f’ is a function, but ‘x.i’ is
not, since ‘MyClass.i’ is not.  But ‘x.f’ is not the same thing as
‘MyClass.f’ — it is a _method object_, not a function object.


File: python.info,  Node: Method Objects,  Next: Class and Instance Variables,  Prev: Instance Objects,  Up: A First Look at Classes

2.9.3.4 Method Objects
......................

Usually, a method is called right after it is bound:

     x.f()

  In the ‘MyClass’ example, this will return the string ‘'hello world'’.
However, it is not necessary to call a method right away: ‘x.f’ is a
method object, and can be stored away and called at a later time.  For
example:

     xf = x.f
     while True:
         print xf()

  will continue to print ‘hello world’ until the end of time.

  What exactly happens when a method is called?  You may have noticed
that ‘x.f()’ was called without an argument above, even though the
function definition for ‘f()’ specified an argument.  What happened to
the argument?  Surely Python raises an exception when a function that
requires an argument is called without any — even if the argument isn’t
actually used...

  Actually, you may have guessed the answer: the special thing about
methods is that the object is passed as the first argument of the
function.  In our example, the call ‘x.f()’ is exactly equivalent to
‘MyClass.f(x)’.  In general, calling a method with a list of _n_
arguments is equivalent to calling the corresponding function with an
argument list that is created by inserting the method’s object before
the first argument.

  If you still don’t understand how methods work, a look at the
implementation can perhaps clarify matters.  When an instance attribute
is referenced that isn’t a data attribute, its class is searched.  If
the name denotes a valid class attribute that is a function object, a
method object is created by packing (pointers to) the instance object
and the function object just found together in an abstract object: this
is the method object.  When the method object is called with an argument
list, a new argument list is constructed from the instance object and
the argument list, and the function object is called with this new
argument list.


File: python.info,  Node: Class and Instance Variables,  Prev: Method Objects,  Up: A First Look at Classes

2.9.3.5 Class and Instance Variables
....................................

Generally speaking, instance variables are for data unique to each
instance and class variables are for attributes and methods shared by
all instances of the class:

     class Dog:

         kind = 'canine'         # class variable shared by all instances

         def __init__(self, name):
             self.name = name    # instance variable unique to each instance

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.kind                  # shared by all dogs
     'canine'
     >>> e.kind                  # shared by all dogs
     'canine'
     >>> d.name                  # unique to d
     'Fido'
     >>> e.name                  # unique to e
     'Buddy'

  As discussed in *note A Word About Names and Objects: 5bc, shared data
can have possibly surprising effects with involving *note mutable: 56b.
objects such as lists and dictionaries.  For example, the _tricks_ list
in the following code should not be used as a class variable because
just a single list would be shared by all _Dog_ instances:

     class Dog:

         tricks = []             # mistaken use of a class variable

         def __init__(self, name):
             self.name = name

         def add_trick(self, trick):
             self.tricks.append(trick)

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.add_trick('roll over')
     >>> e.add_trick('play dead')
     >>> d.tricks                # unexpectedly shared by all dogs
     ['roll over', 'play dead']

  Correct design of the class should use an instance variable instead:

     class Dog:

         def __init__(self, name):
             self.name = name
             self.tricks = []    # creates a new empty list for each dog

         def add_trick(self, trick):
             self.tricks.append(trick)

     >>> d = Dog('Fido')
     >>> e = Dog('Buddy')
     >>> d.add_trick('roll over')
     >>> e.add_trick('play dead')
     >>> d.tricks
     ['roll over']
     >>> e.tricks
     ['play dead']


File: python.info,  Node: Random Remarks,  Next: Inheritance,  Prev: A First Look at Classes,  Up: Classes

2.9.4 Random Remarks
--------------------

Data attributes override method attributes with the same name; to avoid
accidental name conflicts, which may cause hard-to-find bugs in large
programs, it is wise to use some kind of convention that minimizes the
chance of conflicts.  Possible conventions include capitalizing method
names, prefixing data attribute names with a small unique string
(perhaps just an underscore), or using verbs for methods and nouns for
data attributes.

  Data attributes may be referenced by methods as well as by ordinary
users ("clients") of an object.  In other words, classes are not usable
to implement pure abstract data types.  In fact, nothing in Python makes
it possible to enforce data hiding — it is all based upon convention.
(On the other hand, the Python implementation, written in C, can
completely hide implementation details and control access to an object
if necessary; this can be used by extensions to Python written in C.)

  Clients should use data attributes with care — clients may mess up
invariants maintained by the methods by stamping on their data
attributes.  Note that clients may add data attributes of their own to
an instance object without affecting the validity of the methods, as
long as name conflicts are avoided — again, a naming convention can save
a lot of headaches here.

  There is no shorthand for referencing data attributes (or other
methods!)  from within methods.  I find that this actually increases the
readability of methods: there is no chance of confusing local variables
and instance variables when glancing through a method.

  Often, the first argument of a method is called ‘self’.  This is
nothing more than a convention: the name ‘self’ has absolutely no
special meaning to Python.  Note, however, that by not following the
convention your code may be less readable to other Python programmers,
and it is also conceivable that a _class browser_ program might be
written that relies upon such a convention.

  Any function object that is a class attribute defines a method for
instances of that class.  It is not necessary that the function
definition is textually enclosed in the class definition: assigning a
function object to a local variable in the class is also ok.  For
example:

     # Function defined outside the class
     def f1(self, x, y):
         return min(x, x+y)

     class C:
         f = f1
         def g(self):
             return 'hello world'
         h = g

  Now ‘f’, ‘g’ and ‘h’ are all attributes of class ‘C’ that refer to
function objects, and consequently they are all methods of instances of
‘C’ — ‘h’ being exactly equivalent to ‘g’.  Note that this practice
usually only serves to confuse the reader of a program.

  Methods may call other methods by using method attributes of the
‘self’ argument:

     class Bag:
         def __init__(self):
             self.data = []
         def add(self, x):
             self.data.append(x)
         def addtwice(self, x):
             self.add(x)
             self.add(x)

  Methods may reference global names in the same way as ordinary
functions.  The global scope associated with a method is the module
containing its definition.  (A class is never used as a global scope.)
While one rarely encounters a good reason for using global data in a
method, there are many legitimate uses of the global scope: for one
thing, functions and modules imported into the global scope can be used
by methods, as well as functions and classes defined in it.  Usually,
the class containing the method is itself defined in this global scope,
and in the next section we’ll find some good reasons why a method would
want to reference its own class.

  Each value is an object, and therefore has a _class_ (also called its
_type_).  It is stored as ‘object.__class__’.


File: python.info,  Node: Inheritance,  Next: Private Variables and Class-local References,  Prev: Random Remarks,  Up: Classes

2.9.5 Inheritance
-----------------

Of course, a language feature would not be worthy of the name "class"
without supporting inheritance.  The syntax for a derived class
definition looks like this:

     class DerivedClassName(BaseClassName):
         <statement-1>
         .
         .
         .
         <statement-N>

  The name ‘BaseClassName’ must be defined in a scope containing the
derived class definition.  In place of a base class name, other
arbitrary expressions are also allowed.  This can be useful, for
example, when the base class is defined in another module:

     class DerivedClassName(modname.BaseClassName):

  Execution of a derived class definition proceeds the same as for a
base class.  When the class object is constructed, the base class is
remembered.  This is used for resolving attribute references: if a
requested attribute is not found in the class, the search proceeds to
look in the base class.  This rule is applied recursively if the base
class itself is derived from some other class.

  There’s nothing special about instantiation of derived classes:
‘DerivedClassName()’ creates a new instance of the class.  Method
references are resolved as follows: the corresponding class attribute is
searched, descending down the chain of base classes if necessary, and
the method reference is valid if this yields a function object.

  Derived classes may override methods of their base classes.  Because
methods have no special privileges when calling other methods of the
same object, a method of a base class that calls another method defined
in the same base class may end up calling a method of a derived class
that overrides it.  (For C++ programmers: all methods in Python are
effectively ‘virtual’.)

  An overriding method in a derived class may in fact want to extend
rather than simply replace the base class method of the same name.
There is a simple way to call the base class method directly: just call
‘BaseClassName.methodname(self, arguments)’.  This is occasionally
useful to clients as well.  (Note that this only works if the base class
is accessible as ‘BaseClassName’ in the global scope.)

  Python has two built-in functions that work with inheritance:

   * Use *note isinstance(): 31e. to check an instance’s type:
     ‘isinstance(obj, int)’ will be ‘True’ only if ‘obj.__class__’ is
     *note int: 1f2. or some class derived from *note int: 1f2.

   * Use *note issubclass(): 31f. to check class inheritance:
     ‘issubclass(bool, int)’ is ‘True’ since *note bool: 43c. is a
     subclass of *note int: 1f2.  However, ‘issubclass(unicode, str)’ is
     ‘False’ since *note unicode: 1f5. is not a subclass of *note str:
     1ea. (they only share a common ancestor, *note basestring: 458.).

* Menu:

* Multiple Inheritance:: 


File: python.info,  Node: Multiple Inheritance,  Up: Inheritance

2.9.5.1 Multiple Inheritance
............................

Python supports a limited form of multiple inheritance as well.  A class
definition with multiple base classes looks like this:

     class DerivedClassName(Base1, Base2, Base3):
         <statement-1>
         .
         .
         .
         <statement-N>

  For old-style classes, the only rule is depth-first, left-to-right.
Thus, if an attribute is not found in ‘DerivedClassName’, it is searched
in ‘Base1’, then (recursively) in the base classes of ‘Base1’, and only
if it is not found there, it is searched in ‘Base2’, and so on.

  (To some people breadth first — searching ‘Base2’ and ‘Base3’ before
the base classes of ‘Base1’ — looks more natural.  However, this would
require you to know whether a particular attribute of ‘Base1’ is
actually defined in ‘Base1’ or in one of its base classes before you can
figure out the consequences of a name conflict with an attribute of
‘Base2’.  The depth-first rule makes no differences between direct and
inherited attributes of ‘Base1’.)

  For *note new-style class: 5d1.es, the method resolution order changes
dynamically to support cooperative calls to *note super(): 37d.  This
approach is known in some other multiple-inheritance languages as
call-next-method and is more powerful than the super call found in
single-inheritance languages.

  With new-style classes, dynamic ordering is necessary because all
cases of multiple inheritance exhibit one or more diamond relationships
(where at least one of the parent classes can be accessed through
multiple paths from the bottommost class).  For example, all new-style
classes inherit from *note object: 1f1, so any case of multiple
inheritance provides more than one path to reach *note object: 1f1.  To
keep the base classes from being accessed more than once, the dynamic
algorithm linearizes the search order in a way that preserves the
left-to-right ordering specified in each class, that calls each parent
only once, and that is monotonic (meaning that a class can be subclassed
without affecting the precedence order of its parents).  Taken together,
these properties make it possible to design reliable and extensible
classes with multiple inheritance.  For more detail, see
‘http://www.python.org/download/releases/2.3/mro/’.


File: python.info,  Node: Private Variables and Class-local References,  Next: Odds and Ends,  Prev: Inheritance,  Up: Classes

2.9.6 Private Variables and Class-local References
--------------------------------------------------

"Private" instance variables that cannot be accessed except from inside
an object don’t exist in Python.  However, there is a convention that is
followed by most Python code: a name prefixed with an underscore (e.g.
‘_spam’) should be treated as a non-public part of the API (whether it
is a function, a method or a data member).  It should be considered an
implementation detail and subject to change without notice.

  Since there is a valid use-case for class-private members (namely to
avoid name clashes of names with names defined by subclasses), there is
limited support for such a mechanism, called _name mangling_.  Any
identifier of the form ‘__spam’ (at least two leading underscores, at
most one trailing underscore) is textually replaced with
‘_classname__spam’, where ‘classname’ is the current class name with
leading underscore(s) stripped.  This mangling is done without regard to
the syntactic position of the identifier, as long as it occurs within
the definition of a class.

  Name mangling is helpful for letting subclasses override methods
without breaking intraclass method calls.  For example:

     class Mapping:
         def __init__(self, iterable):
             self.items_list = []
             self.__update(iterable)

         def update(self, iterable):
             for item in iterable:
                 self.items_list.append(item)

         __update = update   # private copy of original update() method

     class MappingSubclass(Mapping):

         def update(self, keys, values):
             # provides new signature for update()
             # but does not break __init__()
             for item in zip(keys, values):
                 self.items_list.append(item)

  Note that the mangling rules are designed mostly to avoid accidents;
it still is possible to access or modify a variable that is considered
private.  This can even be useful in special circumstances, such as in
the debugger.

  Notice that code passed to ‘exec’, ‘eval()’ or ‘execfile()’ does not
consider the classname of the invoking class to be the current class;
this is similar to the effect of the ‘global’ statement, the effect of
which is likewise restricted to code that is byte-compiled together.
The same restriction applies to ‘getattr()’, ‘setattr()’ and
‘delattr()’, as well as when referencing ‘__dict__’ directly.


File: python.info,  Node: Odds and Ends,  Next: Exceptions Are Classes Too,  Prev: Private Variables and Class-local References,  Up: Classes

2.9.7 Odds and Ends
-------------------

Sometimes it is useful to have a data type similar to the Pascal
"record" or C "struct", bundling together a few named data items.  An
empty class definition will do nicely:

     class Employee:
         pass

     john = Employee() # Create an empty employee record

     # Fill the fields of the record
     john.name = 'John Doe'
     john.dept = 'computer lab'
     john.salary = 1000

  A piece of Python code that expects a particular abstract data type
can often be passed a class that emulates the methods of that data type
instead.  For instance, if you have a function that formats some data
from a file object, you can define a class with methods ‘read()’ and
‘readline()’ that get the data from a string buffer instead, and pass it
as an argument.

  Instance method objects have attributes, too: ‘m.im_self’ is the
instance object with the method ‘m()’, and ‘m.im_func’ is the function
object corresponding to the method.


File: python.info,  Node: Exceptions Are Classes Too,  Next: Iterators,  Prev: Odds and Ends,  Up: Classes

2.9.8 Exceptions Are Classes Too
--------------------------------

User-defined exceptions are identified by classes as well.  Using this
mechanism it is possible to create extensible hierarchies of exceptions.

  There are two new valid (semantic) forms for the *note raise: 5b1.
statement:

     raise Class, instance

     raise instance

  In the first form, ‘instance’ must be an instance of ‘Class’ or of a
class derived from it.  The second form is a shorthand for:

     raise instance.__class__, instance

  A class in an *note except: 397. clause is compatible with an
exception if it is the same class or a base class thereof (but not the
other way around — an except clause listing a derived class is not
compatible with a base class).  For example, the following code will
print B, C, D in that order:

     class B:
         pass
     class C(B):
         pass
     class D(C):
         pass

     for c in [B, C, D]:
         try:
             raise c()
         except D:
             print "D"
         except C:
             print "C"
         except B:
             print "B"

  Note that if the except clauses were reversed (with ‘except B’ first),
it would have printed B, B, B — the first matching except clause is
triggered.

  When an error message is printed for an unhandled exception, the
exception’s class name is printed, then a colon and a space, and finally
the instance converted to a string using the built-in function *note
str(): 1ea.


File: python.info,  Node: Iterators,  Next: Generators,  Prev: Exceptions Are Classes Too,  Up: Classes

2.9.9 Iterators
---------------

By now you have probably noticed that most container objects can be
looped over using a *note for: 2f0. statement:

     for element in [1, 2, 3]:
         print element
     for element in (1, 2, 3):
         print element
     for key in {'one':1, 'two':2}:
         print key
     for char in "123":
         print char
     for line in open("myfile.txt"):
         print line,

  This style of access is clear, concise, and convenient.  The use of
iterators pervades and unifies Python.  Behind the scenes, the *note
for: 2f0. statement calls *note iter(): 320. on the container object.
The function returns an iterator object that defines the method *note
next(): 5d9. which accesses elements in the container one at a time.
When there are no more elements, *note next(): 5d9. raises a *note
StopIteration: 333. exception which tells the *note for: 2f0. loop to
terminate.  This example shows how it all works:

     >>> s = 'abc'
     >>> it = iter(s)
     >>> it
     <iterator object at 0x00A1DB50>
     >>> it.next()
     'a'
     >>> it.next()
     'b'
     >>> it.next()
     'c'
     >>> it.next()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
         it.next()
     StopIteration

  Having seen the mechanics behind the iterator protocol, it is easy to
add iterator behavior to your classes.  Define an *note __iter__(): 321.
method which returns an object with a *note next(): 399. method.  If the
class defines *note next(): 399, then *note __iter__(): 321. can just
return ‘self’:

     class Reverse:
         """Iterator for looping over a sequence backwards."""
         def __init__(self, data):
             self.data = data
             self.index = len(data)
         def __iter__(self):
             return self
         def next(self):
             if self.index == 0:
                 raise StopIteration
             self.index = self.index - 1
             return self.data[self.index]

     >>> rev = Reverse('spam')
     >>> iter(rev)
     <__main__.Reverse object at 0x00A1DB50>
     >>> for char in rev:
     ...     print char
     ...
     m
     a
     p
     s


File: python.info,  Node: Generators,  Next: Generator Expressions,  Prev: Iterators,  Up: Classes

2.9.10 Generators
-----------------

*note Generator: 5dc.s are a simple and powerful tool for creating
iterators.  They are written like regular functions but use the *note
yield: 2f7. statement whenever they want to return data.  Each time
*note next(): 399. is called, the generator resumes where it left-off
(it remembers all the data values and which statement was last
executed).  An example shows that generators can be trivially easy to
create:

     def reverse(data):
         for index in range(len(data)-1, -1, -1):
             yield data[index]

     >>> for char in reverse('golf'):
     ...     print char
     ...
     f
     l
     o
     g

  Anything that can be done with generators can also be done with class
based iterators as described in the previous section.  What makes
generators so compact is that the *note __iter__(): 321. and *note
next(): 399. methods are created automatically.

  Another key feature is that the local variables and execution state
are automatically saved between calls.  This made the function easier to
write and much more clear than an approach using instance variables like
‘self.index’ and ‘self.data’.

  In addition to automatic method creation and saving program state,
when generators terminate, they automatically raise *note StopIteration:
333.  In combination, these features make it easy to create iterators
with no more effort than writing a regular function.


File: python.info,  Node: Generator Expressions,  Prev: Generators,  Up: Classes

2.9.11 Generator Expressions
----------------------------

Some simple generators can be coded succinctly as expressions using a
syntax similar to list comprehensions but with parentheses instead of
brackets.  These expressions are designed for situations where the
generator is used right away by an enclosing function.  Generator
expressions are more compact but less versatile than full generator
definitions and tend to be more memory friendly than equivalent list
comprehensions.

  Examples:

     >>> sum(i*i for i in range(10))                 # sum of squares
     285

     >>> xvec = [10, 20, 30]
     >>> yvec = [7, 5, 3]
     >>> sum(x*y for x,y in zip(xvec, yvec))         # dot product
     260

     >>> from math import pi, sin
     >>> sine_table = dict((x, sin(x*pi/180)) for x in range(0, 91))

     >>> unique_words = set(word  for line in page  for word in line.split())

     >>> valedictorian = max((student.gpa, student.name) for student in graduates)

     >>> data = 'golf'
     >>> list(data[i] for i in range(len(data)-1,-1,-1))
     ['f', 'l', 'o', 'g']


File: python.info,  Node: Brief Tour of the Standard Library,  Next: Brief Tour of the Standard Library -- Part II,  Prev: Classes,  Up: The Python Tutorial

2.10 Brief Tour of the Standard Library
=======================================

* Menu:

* Operating System Interface:: 
* File Wildcards:: 
* Command Line Arguments:: 
* Error Output Redirection and Program Termination:: 
* String Pattern Matching:: 
* Mathematics:: 
* Internet Access:: 
* Dates and Times:: 
* Data Compression:: 
* Performance Measurement:: 
* Quality Control:: 
* Batteries Included:: 


File: python.info,  Node: Operating System Interface,  Next: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.1 Operating System Interface
---------------------------------

The *note os: 128. module provides dozens of functions for interacting
with the operating system:

     >>> import os
     >>> os.getcwd()      # Return the current working directory
     'C:\\Python26'
     >>> os.chdir('/server/accesslogs')   # Change current working directory
     >>> os.system('mkdir today')   # Run the command mkdir in the system shell
     0

  Be sure to use the ‘import os’ style instead of ‘from os import *’.
This will keep *note os.open(): 5e4. from shadowing the built-in *note
open(): 2d6. function which operates much differently.

  The built-in *note dir(): 33a. and *note help(): 49a. functions are
useful as interactive aids for working with large modules like *note os:
128.:

     >>> import os
     >>> dir(os)
     <returns a list of all module functions>
     >>> help(os)
     <returns an extensive manual page created from the module's docstrings>

  For daily file and directory management tasks, the *note shutil: 154.
module provides a higher level interface that is easier to use:

     >>> import shutil
     >>> shutil.copyfile('data.db', 'archive.db')
     >>> shutil.move('/build/executables', 'installdir')


File: python.info,  Node: File Wildcards,  Next: Command Line Arguments,  Prev: Operating System Interface,  Up: Brief Tour of the Standard Library

2.10.2 File Wildcards
---------------------

The *note glob: e3. module provides a function for making file lists
from directory wildcard searches:

     >>> import glob
     >>> glob.glob('*.py')
     ['primes.py', 'random.py', 'quote.py']


File: python.info,  Node: Command Line Arguments,  Next: Error Output Redirection and Program Termination,  Prev: File Wildcards,  Up: Brief Tour of the Standard Library

2.10.3 Command Line Arguments
-----------------------------

Common utility scripts often need to process command line arguments.
These arguments are stored in the *note sys: 16d. module’s _argv_
attribute as a list.  For instance the following output results from
running ‘python demo.py one two three’ at the command line:

     >>> import sys
     >>> print sys.argv
     ['demo.py', 'one', 'two', 'three']

  The *note getopt: de. module processes _sys.argv_ using the
conventions of the Unix *note getopt(): de. function.  More powerful and
flexible command line processing is provided by the *note argparse: d.
module.


File: python.info,  Node: Error Output Redirection and Program Termination,  Next: String Pattern Matching,  Prev: Command Line Arguments,  Up: Brief Tour of the Standard Library

2.10.4 Error Output Redirection and Program Termination
-------------------------------------------------------

The *note sys: 16d. module also has attributes for _stdin_, _stdout_,
and _stderr_.  The latter is useful for emitting warnings and error
messages to make them visible even when _stdout_ has been redirected:

     >>> sys.stderr.write('Warning, log file not found starting a new one\n')
     Warning, log file not found starting a new one

  The most direct way to terminate a script is to use ‘sys.exit()’.


File: python.info,  Node: String Pattern Matching,  Next: Mathematics,  Prev: Error Output Redirection and Program Termination,  Up: Brief Tour of the Standard Library

2.10.5 String Pattern Matching
------------------------------

The *note re: 143. module provides regular expression tools for advanced
string processing.  For complex matching and manipulation, regular
expressions offer succinct, optimized solutions:

     >>> import re
     >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
     ['foot', 'fell', 'fastest']
     >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
     'cat in the hat'

  When only simple capabilities are needed, string methods are preferred
because they are easier to read and debug:

     >>> 'tea for too'.replace('too', 'two')
     'tea for two'


File: python.info,  Node: Mathematics,  Next: Internet Access,  Prev: String Pattern Matching,  Up: Brief Tour of the Standard Library

2.10.6 Mathematics
------------------

The *note math: 10c. module gives access to the underlying C library
functions for floating point math:

     >>> import math
     >>> math.cos(math.pi / 4.0)
     0.70710678118654757
     >>> math.log(1024, 2)
     10.0

  The *note random: 142. module provides tools for making random
selections:

     >>> import random
     >>> random.choice(['apple', 'pear', 'banana'])
     'apple'
     >>> random.sample(xrange(100), 10)   # sampling without replacement
     [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
     >>> random.random()    # random float
     0.17970987693706186
     >>> random.randrange(6)    # random integer chosen from range(6)
     4


File: python.info,  Node: Internet Access,  Next: Dates and Times,  Prev: Mathematics,  Up: Brief Tour of the Standard Library

2.10.7 Internet Access
----------------------

There are a number of modules for accessing the internet and processing
internet protocols.  Two of the simplest are *note urllib2: 189. for
retrieving data from URLs and *note smtplib: 15a. for sending mail:

     >>> import urllib2
     >>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
     ...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time
     ...         print line

     <BR>Nov. 25, 09:43:32 PM EST

     >>> import smtplib
     >>> server = smtplib.SMTP('localhost')
     >>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
     ... """To: jcaesar@example.org
     ... From: soothsayer@example.org
     ...
     ... Beware the Ides of March.
     ... """)
     >>> server.quit()

  (Note that the second example needs a mailserver running on
localhost.)


File: python.info,  Node: Dates and Times,  Next: Data Compression,  Prev: Internet Access,  Up: Brief Tour of the Standard Library

2.10.8 Dates and Times
----------------------

The *note datetime: 7d. module supplies classes for manipulating dates
and times in both simple and complex ways.  While date and time
arithmetic is supported, the focus of the implementation is on efficient
member extraction for output formatting and manipulation.  The module
also supports objects that are timezone aware.

     >>> # dates are easily constructed and formatted
     >>> from datetime import date
     >>> now = date.today()
     >>> now
     datetime.date(2003, 12, 2)
     >>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
     '12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'

     >>> # dates support calendar arithmetic
     >>> birthday = date(1964, 7, 31)
     >>> age = now - birthday
     >>> age.days
     14368


File: python.info,  Node: Data Compression,  Next: Performance Measurement,  Prev: Dates and Times,  Up: Brief Tour of the Standard Library

2.10.9 Data Compression
-----------------------

Common data archiving and compression formats are directly supported by
modules including: *note zlib: 1ad, *note gzip: e5, *note bz2: 1e, *note
zipfile: 1ab. and *note tarfile: 171.

     >>> import zlib
     >>> s = 'witch which has which witches wrist watch'
     >>> len(s)
     41
     >>> t = zlib.compress(s)
     >>> len(t)
     37
     >>> zlib.decompress(t)
     'witch which has which witches wrist watch'
     >>> zlib.crc32(s)
     226805979


File: python.info,  Node: Performance Measurement,  Next: Quality Control,  Prev: Data Compression,  Up: Brief Tour of the Standard Library

2.10.10 Performance Measurement
-------------------------------

Some Python users develop a deep interest in knowing the relative
performance of different approaches to the same problem.  Python
provides a measurement tool that answers those questions immediately.

  For example, it may be tempting to use the tuple packing and unpacking
feature instead of the traditional approach to swapping arguments.  The
*note timeit: 17b. module quickly demonstrates a modest performance
advantage:

     >>> from timeit import Timer
     >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
     0.57535828626024577
     >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
     0.54962537085770791

  In contrast to *note timeit: 17b.’s fine level of granularity, the
*note profile: 139. and *note pstats: 13a. modules provide tools for
identifying time critical sections in larger blocks of code.


File: python.info,  Node: Quality Control,  Next: Batteries Included,  Prev: Performance Measurement,  Up: Brief Tour of the Standard Library

2.10.11 Quality Control
-----------------------

One approach for developing high quality software is to write tests for
each function as it is developed and to run those tests frequently
during the development process.

  The *note doctest: b5. module provides a tool for scanning a module
and validating tests embedded in a program’s docstrings.  Test
construction is as simple as cutting-and-pasting a typical call along
with its results into the docstring.  This improves the documentation by
providing the user with an example and it allows the doctest module to
make sure the code remains true to the documentation:

     def average(values):
         """Computes the arithmetic mean of a list of numbers.

         >>> print average([20, 30, 70])
         40.0
         """
         return sum(values, 0.0) / len(values)

     import doctest
     doctest.testmod()   # automatically validate the embedded tests

  The *note unittest: 187. module is not as effortless as the *note
doctest: b5. module, but it allows a more comprehensive set of tests to
be maintained in a separate file:

     import unittest

     class TestStatisticalFunctions(unittest.TestCase):

         def test_average(self):
             self.assertEqual(average([20, 30, 70]), 40.0)
             self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
             with self.assertRaises(ZeroDivisionError):
                 average([])
             with self.assertRaises(TypeError):
                 average(20, 30, 70)

     unittest.main() # Calling from the command line invokes all tests


File: python.info,  Node: Batteries Included,  Prev: Quality Control,  Up: Brief Tour of the Standard Library

2.10.12 Batteries Included
--------------------------

Python has a "batteries included" philosophy.  This is best seen through
the sophisticated and robust capabilities of its larger packages.  For
example:

   * The *note xmlrpclib: 1aa. and *note SimpleXMLRPCServer: 157.
     modules make implementing remote procedure calls into an almost
     trivial task.  Despite the modules names, no direct knowledge or
     handling of XML is needed.

   * The *note email: bb. package is a library for managing email
     messages, including MIME and other RFC 2822-based message
     documents.  Unlike *note smtplib: 15a. and *note poplib: 135. which
     actually send and receive messages, the email package has a
     complete toolset for building or decoding complex message
     structures (including attachments) and for implementing internet
     encoding and header protocols.

   * The *note xml.dom: 1a1. and *note xml.sax: 1a6. packages provide
     robust support for parsing this popular data interchange format.
     Likewise, the *note csv: 77. module supports direct reads and
     writes in a common database format.  Together, these modules and
     packages greatly simplify data interchange between Python
     applications and other tools.

   * Internationalization is supported by a number of modules including
     *note gettext: e0, *note locale: 100, and the *note codecs: 63.
     package.


File: python.info,  Node: Brief Tour of the Standard Library -- Part II,  Next: What Now?,  Prev: Brief Tour of the Standard Library,  Up: The Python Tutorial

2.11 Brief Tour of the Standard Library – Part II
=================================================

This second tour covers more advanced modules that support professional
programming needs.  These modules rarely occur in small scripts.

* Menu:

* Output Formatting:: 
* Templating:: 
* Working with Binary Data Record Layouts:: 
* Multi-threading:: 
* Logging:: 
* Weak References:: 
* Tools for Working with Lists:: 
* Decimal Floating Point Arithmetic:: 


File: python.info,  Node: Output Formatting,  Next: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.1 Output Formatting
------------------------

The *note repr: 145. module provides a version of *note repr(): 145.
customized for abbreviated displays of large or deeply nested
containers:

     >>> import repr
     >>> repr.repr(set('supercalifragilisticexpialidocious'))
     "set(['a', 'c', 'd', 'e', 'f', 'g', ...])"

  The *note pprint: 138. module offers more sophisticated control over
printing both built-in and user defined objects in a way that is
readable by the interpreter.  When the result is longer than one line,
the "pretty printer" adds line breaks and indentation to more clearly
reveal data structure:

     >>> import pprint
     >>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
     ...     'yellow'], 'blue']]]
     ...
     >>> pprint.pprint(t, width=30)
     [[[['black', 'cyan'],
        'white',
        ['green', 'red']],
       [['magenta', 'yellow'],
        'blue']]]

  The *note textwrap: 177. module formats paragraphs of text to fit a
given screen width:

     >>> import textwrap
     >>> doc = """The wrap() method is just like fill() except that it returns
     ... a list of strings instead of one big string with newlines to separate
     ... the wrapped lines."""
     ...
     >>> print textwrap.fill(doc, width=40)
     The wrap() method is just like fill()
     except that it returns a list of strings
     instead of one big string with newlines
     to separate the wrapped lines.

  The *note locale: 100. module accesses a database of culture specific
data formats.  The grouping attribute of locale’s format function
provides a direct way of formatting numbers with group separators:

     >>> import locale
     >>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
     'English_United States.1252'
     >>> conv = locale.localeconv()          # get a mapping of conventions
     >>> x = 1234567.8
     >>> locale.format("%d", x, grouping=True)
     '1,234,567'
     >>> locale.format_string("%s%.*f", (conv['currency_symbol'],
     ...                      conv['frac_digits'], x), grouping=True)
     '$1,234,567.80'


File: python.info,  Node: Templating,  Next: Working with Binary Data Record Layouts,  Prev: Output Formatting,  Up: Brief Tour of the Standard Library -- Part II

2.11.2 Templating
-----------------

The *note string: 163. module includes a versatile *note Template: 593.
class with a simplified syntax suitable for editing by end-users.  This
allows users to customize their applications without having to alter the
application.

  The format uses placeholder names formed by ‘$’ with valid Python
identifiers (alphanumeric characters and underscores).  Surrounding the
placeholder with braces allows it to be followed by more alphanumeric
letters with no intervening spaces.  Writing ‘$$’ creates a single
escaped ‘$’:

     >>> from string import Template
     >>> t = Template('${village}folk send $$10 to $cause.')
     >>> t.substitute(village='Nottingham', cause='the ditch fund')
     'Nottinghamfolk send $10 to the ditch fund.'

  The *note substitute(): 602. method raises a *note KeyError: 205. when
a placeholder is not supplied in a dictionary or a keyword argument.
For mail-merge style applications, user supplied data may be incomplete
and the *note safe_substitute(): 603. method may be more appropriate —
it will leave placeholders unchanged if data is missing:

     >>> t = Template('Return the $item to $owner.')
     >>> d = dict(item='unladen swallow')
     >>> t.substitute(d)
     Traceback (most recent call last):
       ...
     KeyError: 'owner'
     >>> t.safe_substitute(d)
     'Return the unladen swallow to $owner.'

  Template subclasses can specify a custom delimiter.  For example, a
batch renaming utility for a photo browser may elect to use percent
signs for placeholders such as the current date, image sequence number,
or file format:

     >>> import time, os.path
     >>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
     >>> class BatchRename(Template):
     ...     delimiter = '%'
     >>> fmt = raw_input('Enter rename style (%d-date %n-seqnum %f-format):  ')
     Enter rename style (%d-date %n-seqnum %f-format):  Ashley_%n%f

     >>> t = BatchRename(fmt)
     >>> date = time.strftime('%d%b%y')
     >>> for i, filename in enumerate(photofiles):
     ...     base, ext = os.path.splitext(filename)
     ...     newname = t.substitute(d=date, n=i, f=ext)
     ...     print '{0} --> {1}'.format(filename, newname)

     img_1074.jpg --> Ashley_0.jpg
     img_1076.jpg --> Ashley_1.jpg
     img_1077.jpg --> Ashley_2.jpg

  Another application for templating is separating program logic from
the details of multiple output formats.  This makes it possible to
substitute custom templates for XML files, plain text reports, and HTML
web reports.


File: python.info,  Node: Working with Binary Data Record Layouts,  Next: Multi-threading,  Prev: Templating,  Up: Brief Tour of the Standard Library -- Part II

2.11.3 Working with Binary Data Record Layouts
----------------------------------------------

The *note struct: 166. module provides *note pack(): 25e. and *note
unpack(): 606. functions for working with variable length binary record
formats.  The following example shows how to loop through header
information in a ZIP file without using the *note zipfile: 1ab. module.
Pack codes ‘"H"’ and ‘"I"’ represent two and four byte unsigned numbers
respectively.  The ‘"<"’ indicates that they are standard size and in
little-endian byte order:

     import struct

     data = open('myfile.zip', 'rb').read()
     start = 0
     for i in range(3):                      # show the first 3 file headers
         start += 14
         fields = struct.unpack('<IIIHH', data[start:start+16])
         crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

         start += 16
         filename = data[start:start+filenamesize]
         start += filenamesize
         extra = data[start:start+extra_size]
         print filename, hex(crc32), comp_size, uncomp_size

         start += extra_size + comp_size     # skip to the next header


File: python.info,  Node: Multi-threading,  Next: Logging,  Prev: Working with Binary Data Record Layouts,  Up: Brief Tour of the Standard Library -- Part II

2.11.4 Multi-threading
----------------------

Threading is a technique for decoupling tasks which are not sequentially
dependent.  Threads can be used to improve the responsiveness of
applications that accept user input while other tasks run in the
background.  A related use case is running I/O in parallel with
computations in another thread.

  The following code shows how the high level *note threading: 179.
module can run tasks in background while the main program continues to
run:

     import threading, zipfile

     class AsyncZip(threading.Thread):
         def __init__(self, infile, outfile):
             threading.Thread.__init__(self)
             self.infile = infile
             self.outfile = outfile
         def run(self):
             f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
             f.write(self.infile)
             f.close()
             print 'Finished background zip of: ', self.infile

     background = AsyncZip('mydata.txt', 'myarchive.zip')
     background.start()
     print 'The main program continues to run in foreground.'

     background.join()    # Wait for the background task to finish
     print 'Main program waited until background was done.'

  The principal challenge of multi-threaded applications is coordinating
threads that share data or other resources.  To that end, the threading
module provides a number of synchronization primitives including locks,
events, condition variables, and semaphores.

  While those tools are powerful, minor design errors can result in
problems that are difficult to reproduce.  So, the preferred approach to
task coordination is to concentrate all access to a resource in a single
thread and then use the *note Queue: 140. module to feed that thread
with requests from other threads.  Applications using *note Queue.Queue:
609. objects for inter-thread communication and coordination are easier
to design, more readable, and more reliable.


File: python.info,  Node: Logging,  Next: Weak References,  Prev: Multi-threading,  Up: Brief Tour of the Standard Library -- Part II

2.11.5 Logging
--------------

The *note logging: 101. module offers a full featured and flexible
logging system.  At its simplest, log messages are sent to a file or to
‘sys.stderr’:

     import logging
     logging.debug('Debugging information')
     logging.info('Informational message')
     logging.warning('Warning:config file %s not found', 'server.conf')
     logging.error('Error occurred')
     logging.critical('Critical error -- shutting down')

  This produces the following output:

     WARNING:root:Warning:config file server.conf not found
     ERROR:root:Error occurred
     CRITICAL:root:Critical error -- shutting down

  By default, informational and debugging messages are suppressed and
the output is sent to standard error.  Other output options include
routing messages through email, datagrams, sockets, or to an HTTP
Server.  New filters can select different routing based on message
priority: ‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, and ‘CRITICAL’.

  The logging system can be configured directly from Python or can be
loaded from a user editable configuration file for customized logging
without altering the application.


File: python.info,  Node: Weak References,  Next: Tools for Working with Lists,  Prev: Logging,  Up: Brief Tour of the Standard Library -- Part II

2.11.6 Weak References
----------------------

Python does automatic memory management (reference counting for most
objects and *note garbage collection: 60e. to eliminate cycles).  The
memory is freed shortly after the last reference to it has been
eliminated.

  This approach works fine for most applications but occasionally there
is a need to track objects only as long as they are being used by
something else.  Unfortunately, just tracking them creates a reference
that makes them permanent.  The *note weakref: 195. module provides
tools for tracking objects without creating a reference.  When the
object is no longer needed, it is automatically removed from a weakref
table and a callback is triggered for weakref objects.  Typical
applications include caching objects that are expensive to create:

     >>> import weakref, gc
     >>> class A:
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __repr__(self):
     ...         return str(self.value)
     ...
     >>> a = A(10)                   # create a reference
     >>> d = weakref.WeakValueDictionary()
     >>> d['primary'] = a            # does not create a reference
     >>> d['primary']                # fetch the object if it is still alive
     10
     >>> del a                       # remove the one reference
     >>> gc.collect()                # run garbage collection right away
     0
     >>> d['primary']                # entry was automatically removed
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
         d['primary']                # entry was automatically removed
       File "C:/python26/lib/weakref.py", line 46, in __getitem__
         o = self.data[key]()
     KeyError: 'primary'


File: python.info,  Node: Tools for Working with Lists,  Next: Decimal Floating Point Arithmetic,  Prev: Weak References,  Up: Brief Tour of the Standard Library -- Part II

2.11.7 Tools for Working with Lists
-----------------------------------

Many data structure needs can be met with the built-in list type.
However, sometimes there is a need for alternative implementations with
different performance trade-offs.

  The *note array: e. module provides an *note array(): 611. object that
is like a list that stores only homogeneous data and stores it more
compactly.  The following example shows an array of numbers stored as
two byte unsigned binary numbers (typecode ‘"H"’) rather than the usual
16 bytes per entry for regular lists of Python int objects:

     >>> from array import array
     >>> a = array('H', [4000, 10, 700, 22222])
     >>> sum(a)
     26932
     >>> a[1:3]
     array('H', [10, 700])

  The *note collections: 65. module provides a *note deque(): 209.
object that is like a list with faster appends and pops from the left
side but slower lookups in the middle.  These objects are well suited
for implementing queues and breadth first tree searches:

     >>> from collections import deque
     >>> d = deque(["task1", "task2", "task3"])
     >>> d.append("task4")
     >>> print "Handling", d.popleft()
     Handling task1

     unsearched = deque([starting_node])
     def breadth_first_search(unsearched):
         node = unsearched.popleft()
         for m in gen_moves(node):
             if is_goal(m):
                 return m
             unsearched.append(m)

  In addition to alternative list implementations, the library also
offers other tools such as the *note bisect: 1b. module with functions
for manipulating sorted lists:

     >>> import bisect
     >>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
     >>> bisect.insort(scores, (300, 'ruby'))
     >>> scores
     [(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]

  The *note heapq: e7. module provides functions for implementing heaps
based on regular lists.  The lowest valued entry is always kept at
position zero.  This is useful for applications which repeatedly access
the smallest element but do not want to run a full list sort:

     >>> from heapq import heapify, heappop, heappush
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> heapify(data)                      # rearrange the list into heap order
     >>> heappush(data, -5)                 # add a new entry
     >>> [heappop(data) for i in range(3)]  # fetch the three smallest entries
     [-5, 0, 1]


File: python.info,  Node: Decimal Floating Point Arithmetic,  Prev: Tools for Working with Lists,  Up: Brief Tour of the Standard Library -- Part II

2.11.8 Decimal Floating Point Arithmetic
----------------------------------------

The *note decimal: 80. module offers a *note Decimal: 1b4. datatype for
decimal floating point arithmetic.  Compared to the built-in *note
float: 1eb. implementation of binary floating point, the class is
especially helpful for

   * financial applications and other uses which require exact decimal
     representation,

   * control over precision,

   * control over rounding to meet legal or regulatory requirements,

   * tracking of significant decimal places, or

   * applications where the user expects the results to match
     calculations done by hand.

  For example, calculating a 5% tax on a 70 cent phone charge gives
different results in decimal floating point and binary floating point.
The difference becomes significant if the results are rounded to the
nearest cent:

     >>> from decimal import *
     >>> x = Decimal('0.70') * Decimal('1.05')
     >>> x
     Decimal('0.7350')
     >>> x.quantize(Decimal('0.01'))  # round to nearest cent
     Decimal('0.74')
     >>> round(.70 * 1.05, 2)         # same calculation with floats
     0.73

  The *note Decimal: 1b4. result keeps a trailing zero, automatically
inferring four place significance from multiplicands with two place
significance.  Decimal reproduces mathematics as done by hand and avoids
issues that can arise when binary floating point cannot exactly
represent decimal quantities.

  Exact representation enables the *note Decimal: 1b4. class to perform
modulo calculations and equality tests that are unsuitable for binary
floating point:

     >>> Decimal('1.00') % Decimal('.10')
     Decimal('0.00')
     >>> 1.00 % 0.10
     0.09999999999999995

     >>> sum([Decimal('0.1')]*10) == Decimal('1.0')
     True
     >>> sum([0.1]*10) == 1.0
     False

  The *note decimal: 80. module provides arithmetic with as much
precision as needed:

     >>> getcontext().prec = 36
     >>> Decimal(1) / Decimal(7)
     Decimal('0.142857142857142857142857142857142857')


File: python.info,  Node: What Now?,  Next: Interactive Input Editing and History Substitution,  Prev: Brief Tour of the Standard Library -- Part II,  Up: The Python Tutorial

2.12 What Now?
==============

Reading this tutorial has probably reinforced your interest in using
Python — you should be eager to apply Python to solving your real-world
problems.  Where should you go to learn more?

  This tutorial is part of Python’s documentation set.  Some other
documents in the set are:

   * *note The Python Standard Library: 4f8.:

     You should browse through this manual, which gives complete (though
     terse) reference material about types, functions, and the modules
     in the standard library.  The standard Python distribution includes
     a _lot_ of additional code.  There are modules to read Unix
     mailboxes, retrieve documents via HTTP, generate random numbers,
     parse command-line options, write CGI programs, compress data, and
     many other tasks.  Skimming through the Library Reference will give
     you an idea of what’s available.

   * *note Installing Python Modules: 617. explains how to install
     external modules written by other Python users.

   * *note The Python Language Reference: 4f9.: A detailed explanation
     of Python’s syntax and semantics.  It’s heavy reading, but is
     useful as a complete guide to the language itself.

  More Python resources:

   * ‘http://www.python.org’: The major Python Web site.  It contains
     code, documentation, and pointers to Python-related pages around
     the Web.  This Web site is mirrored in various places around the
     world, such as Europe, Japan, and Australia; a mirror may be faster
     than the main site, depending on your geographical location.

   * ‘http://docs.python.org’: Fast access to Python’s documentation.

   * ‘http://pypi.python.org’: The Python Package Index, previously also
     nicknamed the Cheese Shop, is an index of user-created Python
     modules that are available for download.  Once you begin releasing
     code, you can register it here so that others can find it.

   * ‘http://aspn.activestate.com/ASPN/Python/Cookbook/’: The Python
     Cookbook is a sizable collection of code examples, larger modules,
     and useful scripts.  Particularly notable contributions are
     collected in a book also titled Python Cookbook (O’Reilly &
     Associates, ISBN 0-596-00797-3.)

  For Python-related questions and problem reports, you can post to the
newsgroup ‘comp.lang.python’, or send them to the mailing list at
<python-list@python.org>.  The newsgroup and mailing list are gatewayed,
so messages posted to one will automatically be forwarded to the other.
There are around 120 postings a day (with peaks up to several hundred),
asking (and answering) questions, suggesting new features, and
announcing new modules.  Before posting, be sure to check the list of
*note Frequently Asked Questions: 618. (also called the FAQ). Mailing
list archives are available at ‘http://mail.python.org/pipermail/’.  The
FAQ answers many of the questions that come up again and again, and may
already contain the solution for your problem.


File: python.info,  Node: Interactive Input Editing and History Substitution,  Next: Floating Point Arithmetic Issues and Limitations,  Prev: What Now?,  Up: The Python Tutorial

2.13 Interactive Input Editing and History Substitution
=======================================================

Some versions of the Python interpreter support editing of the current
input line and history substitution, similar to facilities found in the
Korn shell and the GNU Bash shell.  This is implemented using the GNU
Readline(1) library, which supports Emacs-style and vi-style editing.
This library has its own documentation which I won’t duplicate here;
however, the basics are easily explained.  The interactive editing and
history described here are optionally available in the Unix and Cygwin
versions of the interpreter.

  This chapter does _not_ document the editing facilities of Mark
Hammond’s PythonWin package or the Tk-based environment, IDLE,
distributed with Python.  The command line history recall which operates
within DOS boxes on NT and some other DOS and Windows flavors is yet
another beast.

* Menu:

* Line Editing:: 
* History Substitution:: 
* Key Bindings:: 
* Alternatives to the Interactive Interpreter:: 

   ---------- Footnotes ----------

   (1) http://tiswww.case.edu/php/chet/readline/rltop.html


File: python.info,  Node: Line Editing,  Next: History Substitution,  Up: Interactive Input Editing and History Substitution

2.13.1 Line Editing
-------------------

If supported, input line editing is active whenever the interpreter
prints a primary or secondary prompt.  The current line can be edited
using the conventional Emacs control characters.  The most important of
these are: ‘C-A’ (Control-A) moves the cursor to the beginning of the
line, ‘C-E’ to the end, ‘C-B’ moves it one position to the left, ‘C-F’
to the right.  Backspace erases the character to the left of the cursor,
‘C-D’ the character to its right.  ‘C-K’ kills (erases) the rest of the
line to the right of the cursor, ‘C-Y’ yanks back the last killed
string.  ‘C-underscore’ undoes the last change you made; it can be
repeated for cumulative effect.


File: python.info,  Node: History Substitution,  Next: Key Bindings,  Prev: Line Editing,  Up: Interactive Input Editing and History Substitution

2.13.2 History Substitution
---------------------------

History substitution works as follows.  All non-empty input lines issued
are saved in a history buffer, and when a new prompt is given you are
positioned on a new line at the bottom of this buffer.  ‘C-P’ moves one
line up (back) in the history buffer, ‘C-N’ moves one down.  Any line in
the history buffer can be edited; an asterisk appears in front of the
prompt to mark a line as modified.  Pressing the ‘Return’ key passes the
current line to the interpreter.  ‘C-R’ starts an incremental reverse
search; ‘C-S’ starts a forward search.


File: python.info,  Node: Key Bindings,  Next: Alternatives to the Interactive Interpreter,  Prev: History Substitution,  Up: Interactive Input Editing and History Substitution

2.13.3 Key Bindings
-------------------

The key bindings and some other parameters of the Readline library can
be customized by placing commands in an initialization file called
‘~/.inputrc’.  Key bindings have the form

     key-name: function-name

  or

     "string": function-name

  and options can be set with

     set option-name value

  For example:

     # I prefer vi-style editing:
     set editing-mode vi

     # Edit using a single line:
     set horizontal-scroll-mode On

     # Rebind some keys:
     Meta-h: backward-kill-word
     "\C-u": universal-argument
     "\C-x\C-r": re-read-init-file

  Note that the default binding for ‘Tab’ in Python is to insert a ‘Tab’
character instead of Readline’s default filename completion function.
If you insist, you can override this by putting

     Tab: complete

  in your ‘~/.inputrc’.  (Of course, this makes it harder to type
indented continuation lines if you’re accustomed to using ‘Tab’ for that
purpose.)

  Automatic completion of variable and module names is optionally
available.  To enable it in the interpreter’s interactive mode, add the
following to your startup file: (1)

     import rlcompleter, readline
     readline.parse_and_bind('tab: complete')

  This binds the ‘Tab’ key to the completion function, so hitting the
‘Tab’ key twice suggests completions; it looks at Python statement
names, the current local variables, and the available module names.  For
dotted expressions such as ‘string.a’, it will evaluate the expression
up to the final ‘'.'’ and then suggest completions from the attributes
of the resulting object.  Note that this may execute application-defined
code if an object with a *note __getattr__(): 331. method is part of the
expression.

  A more capable startup file might look like this example.  Note that
this deletes the names it creates once they are no longer needed; this
is done since the startup file is executed in the same namespace as the
interactive commands, and removing the names avoids creating side
effects in the interactive environment.  You may find it convenient to
keep some of the imported modules, such as *note os: 128, which turn out
to be needed in most sessions with the interpreter.

     # Add auto-completion and a stored history file of commands to your Python
     # interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
     # bound to the Esc key by default (you can change it - see readline docs).
     #
     # Store the file in ~/.pystartup, and set an environment variable to point
     # to it:  "export PYTHONSTARTUP=~/.pystartup" in bash.

     import atexit
     import os
     import readline
     import rlcompleter

     historyPath = os.path.expanduser("~/.pyhistory")

     def save_history(historyPath=historyPath):
         import readline
         readline.write_history_file(historyPath)

     if os.path.exists(historyPath):
         readline.read_history_file(historyPath)

     atexit.register(save_history)
     del os, atexit, readline, rlcompleter, save_history, historyPath

   ---------- Footnotes ----------

   (1) Python will execute the contents of a file identified by the
*note PYTHONSTARTUP: 514. environment variable when you start an
interactive interpreter.  To customize Python even for non-interactive
mode, see *note The Customization Modules: 516.


File: python.info,  Node: Alternatives to the Interactive Interpreter,  Prev: Key Bindings,  Up: Interactive Input Editing and History Substitution

2.13.4 Alternatives to the Interactive Interpreter
--------------------------------------------------

This facility is an enormous step forward compared to earlier versions
of the interpreter; however, some wishes are left: It would be nice if
the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next).  The completion mechanism
might use the interpreter’s symbol table.  A command to check (or even
suggest) matching parentheses, quotes, etc., would also be useful.

  One alternative enhanced interactive interpreter that has been around
for quite some time is IPython(1), which features tab completion, object
exploration and advanced history management.  It can also be thoroughly
customized and embedded into other applications.  Another similar
enhanced interactive environment is bpython(2).

   ---------- Footnotes ----------

   (1) http://ipython.scipy.org/

   (2) http://www.bpython-interpreter.org/


File: python.info,  Node: Floating Point Arithmetic Issues and Limitations,  Prev: Interactive Input Editing and History Substitution,  Up: The Python Tutorial

2.14 Floating Point Arithmetic: Issues and Limitations
======================================================

Floating-point numbers are represented in computer hardware as base 2
(binary) fractions.  For example, the decimal fraction

     0.125

  has value 1/10 + 2/100 + 5/1000, and in the same way the binary
fraction

     0.001

  has value 0/2 + 0/4 + 1/8.  These two fractions have identical values,
the only real difference being that the first is written in base 10
fractional notation, and the second in base 2.

  Unfortunately, most decimal fractions cannot be represented exactly as
binary fractions.  A consequence is that, in general, the decimal
floating-point numbers you enter are only approximated by the binary
floating-point numbers actually stored in the machine.

  The problem is easier to understand at first in base 10.  Consider the
fraction 1/3.  You can approximate that as a base 10 fraction:

     0.3

  or, better,

     0.33

  or, better,

     0.333

  and so on.  No matter how many digits you’re willing to write down,
the result will never be exactly 1/3, but will be an increasingly better
approximation of 1/3.

  In the same way, no matter how many base 2 digits you’re willing to
use, the decimal value 0.1 cannot be represented exactly as a base 2
fraction.  In base 2, 1/10 is the infinitely repeating fraction

     0.0001100110011001100110011001100110011001100110011...

  Stop at any finite number of bits, and you get an approximation.

  On a typical machine running Python, there are 53 bits of precision
available for a Python float, so the value stored internally when you
enter the decimal number ‘0.1’ is the binary fraction

     0.00011001100110011001100110011001100110011001100110011010

  which is close to, but not exactly equal to, 1/10.

  It’s easy to forget that the stored value is an approximation to the
original decimal fraction, because of the way that floats are displayed
at the interpreter prompt.  Python only prints a decimal approximation
to the true decimal value of the binary approximation stored by the
machine.  If Python were to print the true decimal value of the binary
approximation stored for 0.1, it would have to display

     >>> 0.1
     0.1000000000000000055511151231257827021181583404541015625

  That is more digits than most people find useful, so Python keeps the
number of digits manageable by displaying a rounded value instead

     >>> 0.1
     0.1

  It’s important to realize that this is, in a real sense, an illusion:
the value in the machine is not exactly 1/10, you’re simply rounding the
_display_ of the true machine value.  This fact becomes apparent as soon
as you try to do arithmetic with these values

     >>> 0.1 + 0.2
     0.30000000000000004

  Note that this is in the very nature of binary floating-point: this is
not a bug in Python, and it is not a bug in your code either.  You’ll
see the same kind of thing in all languages that support your hardware’s
floating-point arithmetic (although some languages may not _display_ the
difference by default, or in all output modes).

  Other surprises follow from this one.  For example, if you try to
round the value 2.675 to two decimal places, you get this

     >>> round(2.675, 2)
     2.67

  The documentation for the built-in *note round(): 1c5. function says
that it rounds to the nearest value, rounding ties away from zero.
Since the decimal fraction 2.675 is exactly halfway between 2.67 and
2.68, you might expect the result here to be (a binary approximation to)
2.68.  It’s not, because when the decimal string ‘2.675’ is converted to
a binary floating-point number, it’s again replaced with a binary
approximation, whose exact value is

     2.67499999999999982236431605997495353221893310546875

  Since this approximation is slightly closer to 2.67 than to 2.68, it’s
rounded down.

  If you’re in a situation where you care which way your decimal
halfway-cases are rounded, you should consider using the *note decimal:
80. module.  Incidentally, the *note decimal: 80. module also provides a
nice way to "see" the exact value that’s stored in any particular Python
float

     >>> from decimal import Decimal
     >>> Decimal(2.675)
     Decimal('2.67499999999999982236431605997495353221893310546875')

  Another consequence is that since 0.1 is not exactly 1/10, summing ten
values of 0.1 may not yield exactly 1.0, either:

     >>> sum = 0.0
     >>> for i in range(10):
     ...     sum += 0.1
     ...
     >>> sum
     0.9999999999999999

  Binary floating-point arithmetic holds many surprises like this.  The
problem with "0.1" is explained in precise detail below, in the
"Representation Error" section.  See The Perils of Floating Point(1) for
a more complete account of other common surprises.

  As that says near the end, "there are no easy answers."  Still, don’t
be unduly wary of floating-point!  The errors in Python float operations
are inherited from the floating-point hardware, and on most machines are
on the order of no more than 1 part in 2**53 per operation.  That’s more
than adequate for most tasks, but you do need to keep in mind that it’s
not decimal arithmetic, and that every float operation can suffer a new
rounding error.

  While pathological cases do exist, for most casual use of
floating-point arithmetic you’ll see the result you expect in the end if
you simply round the display of your final results to the number of
decimal digits you expect.  For fine control over how a float is
displayed see the *note str.format(): 1d2. method’s format specifiers in
*note Format String Syntax: 308.

* Menu:

* Representation Error:: 

   ---------- Footnotes ----------

   (1) http://www.lahey.com/float.htm


File: python.info,  Node: Representation Error,  Up: Floating Point Arithmetic Issues and Limitations

2.14.1 Representation Error
---------------------------

This section explains the "0.1" example in detail, and shows how you can
perform an exact analysis of cases like this yourself.  Basic
familiarity with binary floating-point representation is assumed.

  _Representation error_ refers to the fact that some (most, actually)
decimal fractions cannot be represented exactly as binary (base 2)
fractions.  This is the chief reason why Python (or Perl, C, C++, Java,
Fortran, and many others) often won’t display the exact decimal number
you expect:

     >>> 0.1 + 0.2
     0.30000000000000004

  Why is that?  1/10 and 2/10 are not exactly representable as a binary
fraction.  Almost all machines today (July 2010) use IEEE-754 floating
point arithmetic, and almost all platforms map Python floats to IEEE-754
"double precision".  754 doubles contain 53 bits of precision, so on
input the computer strives to convert 0.1 to the closest fraction it can
of the form _J_/2**_N_ where _J_ is an integer containing exactly 53
bits.  Rewriting

     1 / 10 ~= J / (2**N)

  as

     J ~= 2**N / 10

  and recalling that _J_ has exactly 53 bits (is ‘>= 2**52’ but ‘<
2**53’), the best value for _N_ is 56:

     >>> 2**52
     4503599627370496
     >>> 2**53
     9007199254740992
     >>> 2**56/10
     7205759403792793

  That is, 56 is the only value for _N_ that leaves _J_ with exactly 53
bits.  The best possible value for _J_ is then that quotient rounded:

     >>> q, r = divmod(2**56, 10)
     >>> r
     6

  Since the remainder is more than half of 10, the best approximation is
obtained by rounding up:

     >>> q+1
     7205759403792794

  Therefore the best possible approximation to 1/10 in 754 double
precision is that over 2**56, or

     7205759403792794 / 72057594037927936

  Note that since we rounded up, this is actually a little bit larger
than 1/10; if we had not rounded up, the quotient would have been a
little bit smaller than 1/10.  But in no case can it be _exactly_ 1/10!

  So the computer never "sees" 1/10: what it sees is the exact fraction
given above, the best 754 double approximation it can get:

     >>> .1 * 2**56
     7205759403792794.0

  If we multiply that fraction by 10**30, we can see the (truncated)
value of its 30 most significant decimal digits:

     >>> 7205759403792794 * 10**30 // 2**56
     100000000000000005551115123125L

  meaning that the exact number stored in the computer is approximately
equal to the decimal value 0.100000000000000005551115123125.  In
versions prior to Python 2.7 and Python 3.1, Python rounded this value
to 17 significant digits, giving ’0.10000000000000001’.  In current
versions, Python displays a value based on the shortest decimal fraction
that rounds correctly back to the true binary value, resulting simply in
’0.1’.


File: python.info,  Node: Python Setup and Usage,  Next: The Python Language Reference,  Prev: The Python Tutorial,  Up: Top

3 Python Setup and Usage
************************

This part of the documentation is devoted to general information on the
setup of the Python environment on different platform, the invocation of
the interpreter and things that make working with Python easier.

* Menu:

* Command line and environment:: 
* Using Python on Unix platforms:: 
* Using Python on Windows:: 
* Using Python on a Macintosh:: 

Command line and environment

* Command line:: 
* Environment variables:: 

Command line

* Interface options:: 
* Generic options:: 
* Miscellaneous options:: 
* Options you shouldn't use:: 

Environment variables

* Debug-mode variables:: 

Using Python on Unix platforms

* Getting and installing the latest version of Python:: 
* Building Python:: 
* Python-related paths and files:: 
* Miscellaneous:: 
* Editors:: 

Getting and installing the latest version of Python

* On Linux:: 
* On FreeBSD and OpenBSD:: 
* On OpenSolaris:: 

Using Python on Windows

* Installing Python:: 
* Alternative bundles:: 
* Configuring Python:: 
* Additional modules:: 
* Compiling Python on Windows:: 
* Other resources:: 

Configuring Python

* Excursus; Setting environment variables: Excursus Setting environment variables. 
* Finding the Python executable:: 
* Finding modules:: 
* Executing scripts:: 

Additional modules

* PyWin32:: 
* Py2exe:: 
* WConio:: 

Using Python on a Macintosh

* Getting and Installing MacPython:: 
* The IDE:: 
* Installing Additional Python Packages:: 
* GUI Programming on the Mac:: 
* Distributing Python Applications on the Mac:: 
* Other Resources:: 

Getting and Installing MacPython

* How to run a Python script:: 
* Running scripts with a GUI:: 
* Configuration:: 


File: python.info,  Node: Command line and environment,  Next: Using Python on Unix platforms,  Up: Python Setup and Usage

3.1 Command line and environment
================================

The CPython interpreter scans the command line and the environment for
various settings.

*CPython implementation detail:* Other implementations’ command line
schemes may differ.  See *note Alternate Implementations: 62f. for
further resources.

* Menu:

* Command line:: 
* Environment variables:: 

Command line

* Interface options:: 
* Generic options:: 
* Miscellaneous options:: 
* Options you shouldn't use:: 

Environment variables

* Debug-mode variables:: 


File: python.info,  Node: Command line,  Next: Environment variables,  Up: Command line and environment

3.1.1 Command line
------------------

When invoking Python, you may specify any of these options:

     python [-BdEiOQsRStuUvVWxX3?] [-c command | -m module-name | script | - ] [args]

  The most common use case is, of course, a simple invocation of a
script:

     python myscript.py

* Menu:

* Interface options:: 
* Generic options:: 
* Miscellaneous options:: 
* Options you shouldn't use:: 


File: python.info,  Node: Interface options,  Next: Generic options,  Up: Command line

3.1.1.1 Interface options
.........................

The interpreter interface resembles that of the UNIX shell, but provides
some additional methods of invocation:

   * When called with standard input connected to a tty device, it
     prompts for commands and executes them until an EOF (an end-of-file
     character, you can produce that with _Ctrl-D_ on UNIX or _Ctrl-Z,
     Enter_ on Windows) is read.

   * When called with a file name argument or with a file as standard
     input, it reads and executes a script from that file.

   * When called with a directory name argument, it reads and executes
     an appropriately named script from that directory.

   * When called with ‘-c command’, it executes the Python statement(s)
     given as _command_.  Here _command_ may contain multiple statements
     separated by newlines.  Leading whitespace is significant in Python
     statements!

   * When called with ‘-m module-name’, the given module is located on
     the Python module path and executed as a script.

  In non-interactive mode, the entire input is parsed before it is
executed.

  An interface option terminates the list of options consumed by the
interpreter, all consecutive arguments will end up in *note sys.argv:
634. – note that the first element, subscript zero (‘sys.argv[0]’), is a
string reflecting the program’s source.

 -- Program Option: -c <command>

     Execute the Python code in _command_.  _command_ can be one or more
     statements separated by newlines, with significant leading
     whitespace as in normal module code.

     If this option is given, the first element of *note sys.argv: 634.
     will be ‘"-c"’ and the current directory will be added to the start
     of *note sys.path: 57f. (allowing modules in that directory to be
     imported as top level modules).

 -- Program Option: -m <module-name>

     Search *note sys.path: 57f. for the named module and execute its
     contents as the *note __main__: 2. module.

     Since the argument is a _module_ name, you must not give a file
     extension (‘.py’).  The ‘module-name’ should be a valid Python
     module name, but the implementation may not always enforce this
     (e.g.  it may allow you to use a name that includes a hyphen).

     Package names are also permitted.  When a package name is supplied
     instead of a normal module, the interpreter will execute
     ‘<pkg>.__main__’ as the main module.  This behaviour is
     deliberately similar to the handling of directories and zipfiles
     that are passed to the interpreter as the script argument.

          Note: This option cannot be used with built-in modules and
          extension modules written in C, since they do not have Python
          module files.  However, it can still be used for precompiled
          modules, even if the original source file is not available.

     If this option is given, the first element of *note sys.argv: 634.
     will be the full path to the module file.  As with the *note -c:
     27b. option, the current directory will be added to the start of
     *note sys.path: 57f.

     Many standard library modules contain code that is invoked on their
     execution as a script.  An example is the *note timeit: 17b.
     module:

          python -mtimeit -s 'setup here' 'benchmarked code here'
          python -mtimeit -h # for details

     See also
.............

     *note runpy.run_module(): 635. Equivalent functionality directly
     available to Python code

     PEP 338(1) – Executing modules as scripts

     New in version 2.4.

     Changed in version 2.5: The named module can now be located inside
     a package.

     Changed in version 2.7: Supply the package name to run a ‘__main__’
     submodule.  sys.argv[0] is now set to ‘"-m"’ while searching for
     the module (it was previously incorrectly set to ‘"-c"’)

 -- Describe: -

     Read commands from standard input (*note sys.stdin: 636.).  If
     standard input is a terminal, *note -i: 476. is implied.

     If this option is given, the first element of *note sys.argv: 634.
     will be ‘"-"’ and the current directory will be added to the start
     of *note sys.path: 57f.

 -- Describe: <script>

     Execute the Python code contained in _script_, which must be a
     filesystem path (absolute or relative) referring to either a Python
     file, a directory containing a ‘__main__.py’ file, or a zipfile
     containing a ‘__main__.py’ file.

     If this option is given, the first element of *note sys.argv: 634.
     will be the script name as given on the command line.

     If the script name refers directly to a Python file, the directory
     containing that file is added to the start of *note sys.path: 57f,
     and the file is executed as the *note __main__: 2. module.

     If the script name refers to a directory or zipfile, the script
     name is added to the start of *note sys.path: 57f. and the
     ‘__main__.py’ file in that location is executed as the *note
     __main__: 2. module.

     Changed in version 2.5: Directories and zipfiles containing a
     ‘__main__.py’ file at the top level are now considered valid Python
     scripts.

  If no interface option is given, *note -i: 476. is implied,
‘sys.argv[0]’ is an empty string (‘""’) and the current directory will
be added to the start of *note sys.path: 57f.

See also
........

*note Invoking the Interpreter: 503.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0338


File: python.info,  Node: Generic options,  Next: Miscellaneous options,  Prev: Interface options,  Up: Command line

3.1.1.2 Generic options
.......................

 -- Program Option: -?
 -- Program Option: -h
 -- Program Option: --help

     Print a short description of all command line options.

     Changed in version 2.5: The ‘--help’ variant.

 -- Program Option: -V
 -- Program Option: --version

     Print the Python version number and exit.  Example output could be:

          Python 2.5.1

     Changed in version 2.5: The ‘--version’ variant.


File: python.info,  Node: Miscellaneous options,  Next: Options you shouldn't use,  Prev: Generic options,  Up: Command line

3.1.1.3 Miscellaneous options
.............................

 -- Program Option: -B

     If given, Python won’t try to write ‘.pyc’ or ‘.pyo’ files on the
     import of source modules.  See also *note PYTHONDONTWRITEBYTECODE:
     344.

     New in version 2.6.

 -- Program Option: -d

     Turn on parser debugging output (for wizards only, depending on
     compilation options).  See also *note PYTHONDEBUG: 63b.

 -- Program Option: -E

     Ignore all ‘PYTHON*’ environment variables, e.g.  *note PYTHONPATH:
     580. and *note PYTHONHOME: 63d, that might be set.

     New in version 2.2.

 -- Program Option: -i

     When a script is passed as first argument or the *note -c: 27b.
     option is used, enter interactive mode after executing the script
     or the command, even when *note sys.stdin: 636. does not appear to
     be a terminal.  The *note PYTHONSTARTUP: 514. file is not read.

     This can be useful to inspect global variables or a stack trace
     when a script raises an exception.  See also *note PYTHONINSPECT:
     475.

 -- Program Option: -O

     Turn on basic optimizations.  This changes the filename extension
     for compiled (*note bytecode: 583.) files from ‘.pyc’ to ‘.pyo’.
     See also *note PYTHONOPTIMIZE: 63e.

 -- Program Option: -OO

     Discard docstrings in addition to the *note -O: 453. optimizations.

 -- Program Option: -Q <arg>

     Division control.  The argument must be one of the following:

     ‘old’

          division of int/int and long/long return an int or long
          (_default_)

     ‘new’

          new division semantics, i.e.  division of int/int and
          long/long returns a float

     ‘warn’

          old division semantics with a warning for int/int and
          long/long

     ‘warnall’

          old division semantics with a warning for all uses of the
          division operator

     See also
.............

     ‘Tools/scripts/fixdiv.py’ for a use of ‘warnall’

     PEP 238(1) – Changing the division operator

 -- Program Option: -R

     Turn on hash randomization, so that the *note __hash__(): 335.
     values of str, bytes and datetime objects are "salted" with an
     unpredictable random value.  Although they remain constant within
     an individual Python process, they are not predictable between
     repeated invocations of Python.

     This is intended to provide protection against a denial-of-service
     caused by carefully-chosen inputs that exploit the worst case
     performance of a dict construction, O(n^2) complexity.  See
     ‘http://www.ocert.org/advisories/ocert-2011-003.html’ for details.

     Changing hash values affects the order in which keys are retrieved
     from a dict.  Although Python has never made guarantees about this
     ordering (and it typically varies between 32-bit and 64-bit
     builds), enough real-world code implicitly relies on this
     non-guaranteed behavior that the randomization is disabled by
     default.

     See also *note PYTHONHASHSEED: 63f.

     New in version 2.6.8.

 -- Program Option: -s

     Don’t add the *note user site-packages directory: 640. to *note
     sys.path: 57f.

     New in version 2.6.

     See also
.............

     PEP 370(2) – Per user site-packages directory

 -- Program Option: -S

     Disable the import of the module *note site: 158. and the
     site-dependent manipulations of *note sys.path: 57f. that it
     entails.

 -- Program Option: -t

     Issue a warning when a source file mixes tabs and spaces for
     indentation in a way that makes it depend on the worth of a tab
     expressed in spaces.  Issue an error when the option is given twice
     (‘-tt’).

 -- Program Option: -u

     Force stdin, stdout and stderr to be totally unbuffered.  On
     systems where it matters, also put stdin, stdout and stderr in
     binary mode.

     Note that there is internal buffering in *note file.readlines():
     642. and *note File Objects: 643. (‘for line in sys.stdin’) which
     is not influenced by this option.  To work around this, you will
     want to use *note file.readline(): 644. inside a ‘while 1:’ loop.

     See also *note PYTHONUNBUFFERED: 645.

 -- Program Option: -v

     Print a message each time a module is initialized, showing the
     place (filename or built-in module) from which it is loaded.  When
     given twice (‘-vv’), print a message for each file that is checked
     for when searching for a module.  Also provides information on
     module cleanup at exit.  See also *note PYTHONVERBOSE: 646.

 -- Program Option: -W arg

     Warning control.  Python’s warning machinery by default prints
     warning messages to *note sys.stderr: 647.  A typical warning
     message has the following form:

          file:line: category: message

     By default, each warning is printed once for each source line where
     it occurs.  This option controls how often warnings are printed.

     Multiple *note -W: 1bd. options may be given; when a warning
     matches more than one option, the action for the last matching
     option is performed.  Invalid *note -W: 1bd. options are ignored
     (though, a warning message is printed about invalid options when
     the first warning is issued).

     Starting from Python 2.7, *note DeprecationWarning: 1bc. and its
     descendants are ignored by default.  The ‘-Wd’ option can be used
     to re-enable them.

     Warnings can also be controlled from within a Python program using
     the *note warnings: 193. module.

     The simplest form of argument is one of the following action
     strings (or a unique abbreviation) by themselves:

     ‘ignore’

          Ignore all warnings.

     ‘default’

          Explicitly request the default behavior (printing each warning
          once per source line).

     ‘all’

          Print a warning each time it occurs (this may generate many
          messages if a warning is triggered repeatedly for the same
          source line, such as inside a loop).

     ‘module’

          Print each warning only the first time it occurs in each
          module.

     ‘once’

          Print each warning only the first time it occurs in the
          program.

     ‘error’

          Raise an exception instead of printing a warning message.

     The full form of argument is:

          action:message:category:module:line

     Here, _action_ is as explained above but only applies to messages
     that match the remaining fields.  Empty fields match all values;
     trailing empty fields may be omitted.  The _message_ field matches
     the start of the warning message printed; this match is
     case-insensitive.  The _category_ field matches the warning
     category.  This must be a class name; the match tests whether the
     actual warning category of the message is a subclass of the
     specified warning category.  The full class name must be given.
     The _module_ field matches the (fully-qualified) module name; this
     match is case-sensitive.  The _line_ field matches the line number,
     where zero matches all line numbers and is thus equivalent to an
     omitted line number.

     See also
.............

     *note warnings: 193. – the warnings module

     PEP 230(3) – Warning framework

     *note PYTHONWARNINGS: 1be.

 -- Program Option: -x

     Skip the first line of the source, allowing use of non-Unix forms
     of ‘#!cmd’.  This is intended for a DOS specific hack only.

          Note: The line numbers in error messages will be off by one.

 -- Program Option: -3

     Warn about Python 3.x possible incompatibilities by emitting a
     *note DeprecationWarning: 1bc. for features that are removed or
     significantly changed in Python 3.

     New in version 2.6.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0238

   (2) http://www.python.org/dev/peps/pep-0370

   (3) http://www.python.org/dev/peps/pep-0230


File: python.info,  Node: Options you shouldn't use,  Prev: Miscellaneous options,  Up: Command line

3.1.1.4 Options you shouldn’t use
.................................

 -- Program Option: -J

     Reserved for use by Jython(1).

 -- Program Option: -U

     Turns all string literals into unicodes globally.  Do not be
     tempted to use this option as it will probably break your world.
     It also produces ‘.pyc’ files with a different magic number than
     normal.  Instead, you can enable unicode literals on a per-module
     basis by using:

          from __future__ import unicode_literals

     at the top of the file.  See *note __future__: 1. for details.

 -- Program Option: -X

     Reserved for alternative implementations of Python to use for their
     own purposes.

   ---------- Footnotes ----------

   (1) http://jython.org


File: python.info,  Node: Environment variables,  Prev: Command line,  Up: Command line and environment

3.1.2 Environment variables
---------------------------

These environment variables influence Python’s behavior, they are
processed before the command-line switches other than -E. It is
customary that command-line switches override environmental variables
where there is a conflict.

 -- Environment Variable: PYTHONHOME

     Change the location of the standard Python libraries.  By default,
     the libraries are searched in ‘_prefix_/lib/python_version_’ and
     ‘_exec_prefix_/lib/python_version_’, where ‘_prefix_’ and
     ‘_exec_prefix_’ are installation-dependent directories, both
     defaulting to ‘/usr/local’.

     When *note PYTHONHOME: 63d. is set to a single directory, its value
     replaces both ‘_prefix_’ and ‘_exec_prefix_’.  To specify different
     values for these, set *note PYTHONHOME: 63d. to
     ‘_prefix_:_exec_prefix_’.

 -- Environment Variable: PYTHONPATH

     Augment the default search path for module files.  The format is
     the same as the shell’s ‘PATH’: one or more directory pathnames
     separated by *note os.pathsep: 64d. (e.g.  colons on Unix or
     semicolons on Windows).  Non-existent directories are silently
     ignored.

     In addition to normal directories, individual *note PYTHONPATH:
     580. entries may refer to zipfiles containing pure Python modules
     (in either source or compiled form).  Extension modules cannot be
     imported from zipfiles.

     The default search path is installation dependent, but generally
     begins with ‘_prefix_/lib/python_version_’ (see *note PYTHONHOME:
     63d. above).  It is _always_ appended to *note PYTHONPATH: 580.

     An additional directory will be inserted in the search path in
     front of *note PYTHONPATH: 580. as described above under *note
     Interface options: 633.  The search path can be manipulated from
     within a Python program as the variable *note sys.path: 57f.

 -- Environment Variable: PYTHONSTARTUP

     If this is the name of a readable file, the Python commands in that
     file are executed before the first prompt is displayed in
     interactive mode.  The file is executed in the same namespace where
     interactive commands are executed so that objects defined or
     imported in it can be used without qualification in the interactive
     session.  You can also change the prompts *note sys.ps1: 64e. and
     *note sys.ps2: 64f. in this file.

 -- Environment Variable: PYTHONY2K

     Set this to a non-empty string to cause the *note time: 17a. module
     to require dates specified as strings to include 4-digit years,
     otherwise 2-digit years are converted based on rules described in
     the *note time: 17a. module documentation.

 -- Environment Variable: PYTHONOPTIMIZE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -O: 453. option.  If set to an integer, it is equivalent
     to specifying *note -O: 453. multiple times.

 -- Environment Variable: PYTHONDEBUG

     If this is set to a non-empty string it is equivalent to specifying
     the *note -d: 63a. option.  If set to an integer, it is equivalent
     to specifying *note -d: 63a. multiple times.

 -- Environment Variable: PYTHONINSPECT

     If this is set to a non-empty string it is equivalent to specifying
     the *note -i: 476. option.

     This variable can also be modified by Python code using *note
     os.environ: 651. to force inspect mode on program termination.

 -- Environment Variable: PYTHONUNBUFFERED

     If this is set to a non-empty string it is equivalent to specifying
     the *note -u: 477. option.

 -- Environment Variable: PYTHONVERBOSE

     If this is set to a non-empty string it is equivalent to specifying
     the *note -v: 3b3. option.  If set to an integer, it is equivalent
     to specifying *note -v: 3b3. multiple times.

 -- Environment Variable: PYTHONCASEOK

     If this is set, Python ignores case in *note import: 1f4.
     statements.  This only works on Windows, OS X, OS/2, and RiscOS.

 -- Environment Variable: PYTHONDONTWRITEBYTECODE

     If this is set, Python won’t try to write ‘.pyc’ or ‘.pyo’ files on
     the import of source modules.  This is equivalent to specifying the
     *note -B: 343. option.

     New in version 2.6.

 -- Environment Variable: PYTHONHASHSEED

     If this variable is set to ‘random’, the effect is the same as
     specifying the *note -R: 2d7. option: a random value is used to
     seed the hashes of str, bytes and datetime objects.

     If *note PYTHONHASHSEED: 63f. is set to an integer value, it is
     used as a fixed seed for generating the hash() of the types covered
     by the hash randomization.

     Its purpose is to allow repeatable hashing, such as for selftests
     for the interpreter itself, or to allow a cluster of python
     processes to share hash values.

     The integer must be a decimal number in the range [0,4294967295].
     Specifying the value 0 will lead to the same hash values as when
     hash randomization is disabled.

     New in version 2.6.8.

 -- Environment Variable: PYTHONIOENCODING

     Overrides the encoding used for stdin/stdout/stderr, in the syntax
     ‘encodingname:errorhandler’.  The ‘:errorhandler’ part is optional
     and has the same meaning as in *note str.encode(): 652.

     New in version 2.6.

 -- Environment Variable: PYTHONNOUSERSITE

     If this is set, Python won’t add the *note user site-packages
     directory: 640. to *note sys.path: 57f.

     New in version 2.6.

     See also
.............

     PEP 370(1) – Per user site-packages directory

 -- Environment Variable: PYTHONUSERBASE

     Defines the *note user base directory: 653, which is used to
     compute the path of the *note user site-packages directory: 640.
     and *note Distutils installation paths: 654. for ‘python setup.py
     install --user’.

     New in version 2.6.

     See also
.............

     PEP 370(2) – Per user site-packages directory

 -- Environment Variable: PYTHONEXECUTABLE

     If this environment variable is set, ‘sys.argv[0]’ will be set to
     its value instead of the value got through the C runtime.  Only
     works on Mac OS X.

 -- Environment Variable: PYTHONWARNINGS

     This is equivalent to the *note -W: 1bd. option.  If set to a comma
     separated string, it is equivalent to specifying *note -W: 1bd.
     multiple times.

* Menu:

* Debug-mode variables:: 

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0370

   (2) http://www.python.org/dev/peps/pep-0370


File: python.info,  Node: Debug-mode variables,  Up: Environment variables

3.1.2.1 Debug-mode variables
............................

Setting these variables only has an effect in a debug build of Python,
that is, if Python was configured with the ‘--with-pydebug’ build
option.

 -- Environment Variable: PYTHONTHREADDEBUG

     If set, Python will print threading debug info.

     Changed in version 2.6: Previously, this variable was called
     ‘THREADDEBUG’.

 -- Environment Variable: PYTHONDUMPREFS

     If set, Python will dump objects and reference counts still alive
     after shutting down the interpreter.

 -- Environment Variable: PYTHONMALLOCSTATS

     If set, Python will print memory allocation statistics every time a
     new object arena is created, and on shutdown.


File: python.info,  Node: Using Python on Unix platforms,  Next: Using Python on Windows,  Prev: Command line and environment,  Up: Python Setup and Usage

3.2 Using Python on Unix platforms
==================================

* Menu:

* Getting and installing the latest version of Python:: 
* Building Python:: 
* Python-related paths and files:: 
* Miscellaneous:: 
* Editors:: 

Getting and installing the latest version of Python

* On Linux:: 
* On FreeBSD and OpenBSD:: 
* On OpenSolaris:: 


File: python.info,  Node: Getting and installing the latest version of Python,  Next: Building Python,  Up: Using Python on Unix platforms

3.2.1 Getting and installing the latest version of Python
---------------------------------------------------------

* Menu:

* On Linux:: 
* On FreeBSD and OpenBSD:: 
* On OpenSolaris:: 


File: python.info,  Node: On Linux,  Next: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.1 On Linux
................

Python comes preinstalled on most Linux distributions, and is available
as a package on all others.  However there are certain features you
might want to use that are not available on your distro’s package.  You
can easily compile the latest version of Python from source.

  In the event that Python doesn’t come preinstalled and isn’t in the
repositories as well, you can easily make packages for your own distro.
Have a look at the following links:

See also
........

‘http://www.debian.org/doc/manuals/maint-guide/first.en.html’

     for Debian users

‘http://en.opensuse.org/Portal:Packaging’

     for OpenSuse users

‘http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-creating-rpms.html’

     for Fedora users

‘http://www.slackbook.org/html/package-management-making-packages.html’

     for Slackware users


File: python.info,  Node: On FreeBSD and OpenBSD,  Next: On OpenSolaris,  Prev: On Linux,  Up: Getting and installing the latest version of Python

3.2.1.2 On FreeBSD and OpenBSD
..............................

   * FreeBSD users, to add the package use:

          pkg_add -r python

   * OpenBSD users use:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/<insert your architecture here>/python-<version>.tgz

     For example i386 users get the 2.5.1 version of Python using:

          pkg_add ftp://ftp.openbsd.org/pub/OpenBSD/4.2/packages/i386/python-2.5.1p2.tgz


File: python.info,  Node: On OpenSolaris,  Prev: On FreeBSD and OpenBSD,  Up: Getting and installing the latest version of Python

3.2.1.3 On OpenSolaris
......................

To install the newest Python versions on OpenSolaris, install
blastwave(1) and type ‘pkg_get -i python’ at the prompt.

   ---------- Footnotes ----------

   (1) http://www.blastwave.org/howto.html


File: python.info,  Node: Building Python,  Next: Python-related paths and files,  Prev: Getting and installing the latest version of Python,  Up: Using Python on Unix platforms

3.2.2 Building Python
---------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh clone(2).  (If you want to contribute patches, you
will need a clone.)

  The build process consists in the usual

     ./configure
     make
     make install

  invocations.  Configuration options and caveats for specific Unix
platforms are extensively documented in the README(3) file in the root
of the Python source tree.

     Warning: ‘make install’ can overwrite or masquerade the ‘python’
     binary.  ‘make altinstall’ is therefore recommended instead of
     ‘make install’ since it only installs
     ‘_exec_prefix_/bin/python_version_’.

   ---------- Footnotes ----------

   (1) http://python.org/download/source/

   (2) http://docs.python.org/devguide/setup#getting-the-source-code

   (3) http://hg.python.org/cpython/file/2.7/README


File: python.info,  Node: Python-related paths and files,  Next: Miscellaneous,  Prev: Building Python,  Up: Using Python on Unix platforms

3.2.3 Python-related paths and files
------------------------------------

These are subject to difference depending on local installation
conventions; ‘prefix’ (‘${prefix}’) and ‘exec_prefix’ (‘${exec_prefix}’)
are installation-dependent and should be interpreted as for GNU
software; they may be the same.

  For example, on most Linux systems, the default for both is ‘/usr’.

File/directory                                      Meaning
                                                    
---------------------------------------------------------------------------------------------------
                                                    
‘_exec_prefix_/bin/python’                          Recommended location of the interpreter.
                                                    
                                                    
‘_prefix_/lib/python_version_’,                     Recommended locations of the directories
‘_exec_prefix_/lib/python_version_’                 containing the standard modules.
                                                    
                                                    
‘_prefix_/include/python_version_’,                 Recommended locations of the directories
‘_exec_prefix_/include/python_version_’             containing the include files needed for
                                                    developing Python extensions and embedding
                                                    the interpreter.
                                                    
                                                    
‘~/.pythonrc.py’                                    User-specific initialization file loaded by
                                                    the user module; not used by default or by
                                                    most applications.
                                                    


File: python.info,  Node: Miscellaneous,  Next: Editors,  Prev: Python-related paths and files,  Up: Using Python on Unix platforms

3.2.4 Miscellaneous
-------------------

To easily use Python scripts on Unix, you need to make them executable,
e.g.  with

     $ chmod +x script

  and put an appropriate Shebang line at the top of the script.  A good
choice is usually

     #!/usr/bin/env python

  which searches for the Python interpreter in the whole ‘PATH’.
However, some Unices may not have the *env* command, so you may need to
hardcode ‘/usr/bin/python’ as the interpreter path.

  To use shell commands in your Python scripts, look at the *note
subprocess: 167. module.


File: python.info,  Node: Editors,  Prev: Miscellaneous,  Up: Using Python on Unix platforms

3.2.5 Editors
-------------

Vim and Emacs are excellent editors which support Python very well.  For
more information on how to code in Python in these editors, look at:

   * ‘http://www.vim.org/scripts/script.php?script_id=790’

   * ‘http://sourceforge.net/projects/python-mode’

  Geany is an excellent IDE with support for a lot of languages.  For
more information, read: ‘http://www.geany.org/’

  Komodo edit is another extremely good IDE. It also has support for a
lot of languages.  For more information, read:
‘http://www.activestate.com/store/productdetail.aspx?prdGuid=20f4ed15-6684-4118-a78b-d37ff4058c5f’


File: python.info,  Node: Using Python on Windows,  Next: Using Python on a Macintosh,  Prev: Using Python on Unix platforms,  Up: Python Setup and Usage

3.3 Using Python on Windows
===========================

This document aims to give an overview of Windows-specific behaviour you
should know about when using Python on Microsoft Windows.

* Menu:

* Installing Python:: 
* Alternative bundles:: 
* Configuring Python:: 
* Additional modules:: 
* Compiling Python on Windows:: 
* Other resources:: 


File: python.info,  Node: Installing Python,  Next: Alternative bundles,  Up: Using Python on Windows

3.3.1 Installing Python
-----------------------

Unlike most Unix systems and services, Windows does not require Python
natively and thus does not pre-install a version of Python.  However,
the CPython team has compiled Windows installers (MSI packages) with
every release(1) for many years.

  With ongoing development of Python, some platforms that used to be
supported earlier are no longer supported (due to the lack of users or
developers).  Check PEP 11(2) for details on all unsupported platforms.

   * DOS and Windows 3.x are deprecated since Python 2.0 and code
     specific to these systems was removed in Python 2.1.

   * Up to 2.5, Python was still compatible with Windows 95, 98 and ME
     (but already raised a deprecation warning on installation).  For
     Python 2.6 (and all following releases), this support was dropped
     and new releases are just expected to work on the Windows NT
     family.

   * Windows CE(3) is still supported.

   * The Cygwin(4) installer offers to install the Python interpreter(5)
     as well; it is located under "Interpreters."  (cf.  Cygwin package
     source(6), Maintainer releases(7))

  See Python for Windows (and DOS)(8) for detailed information about
platforms with precompiled installers.

See also
........

Python on XP(9)

     "7 Minutes to "Hello World!""  by Richard Dooling, 2006

Installing on Windows(10)

     in "Dive into Python: Python from novice to pro(11)" by Mark
     Pilgrim, 2004, ISBN 1-59059-356-1

For Windows users(12)

     in "Installing Python" in "A Byte of Python(13)" by Swaroop C H,
     2003

   ---------- Footnotes ----------

   (1) http://www.python.org/download/releases/

   (2) http://www.python.org/dev/peps/pep-0011

   (3) http://pythonce.sourceforge.net/

   (4) http://cygwin.com/

   (5) http://cygwin.com/packages/python

   (6) 
ftp://ftp.uni-erlangen.de/pub/pc/gnuwin32/cygwin/mirrors/cygnus/release/python

   (7) http://www.tishler.net/jason/software/python/

   (8) http://www.python.org/download/windows/

   (9) 
http://www.richarddooling.com/index.php/2006/03/14/python-on-xp-7-minutes-to-hello-world/

   (10) http://diveintopython.net/installing_python/windows.html

   (11) http://diveintopython.net/index.html

   (12) 
http://swaroopch.com/text/Byte_of_Python:Installing_Python#For_Windows_users

   (13) http://www.byteofpython.info


File: python.info,  Node: Alternative bundles,  Next: Configuring Python,  Prev: Installing Python,  Up: Using Python on Windows

3.3.2 Alternative bundles
-------------------------

Besides the standard CPython distribution, there are modified packages
including additional functionality.  The following is a list of popular
versions and their key features:

ActivePython(1)

     Installer with multi-platform compatibility, documentation, PyWin32

Enthought Python Distribution(2)

     Popular modules (such as PyWin32) with their respective
     documentation, tool suite for building extensible Python
     applications

  Notice that these packages are likely to install _older_ versions of
Python.

   ---------- Footnotes ----------

   (1) http://www.activestate.com/Products/activepython/

   (2) http://www.enthought.com/products/epd.php


File: python.info,  Node: Configuring Python,  Next: Additional modules,  Prev: Alternative bundles,  Up: Using Python on Windows

3.3.3 Configuring Python
------------------------

In order to run Python flawlessly, you might have to change certain
environment settings in Windows.

* Menu:

* Excursus; Setting environment variables: Excursus Setting environment variables. 
* Finding the Python executable:: 
* Finding modules:: 
* Executing scripts:: 


File: python.info,  Node: Excursus Setting environment variables,  Next: Finding the Python executable,  Up: Configuring Python

3.3.3.1 Excursus: Setting environment variables
...............................................

Windows has a built-in dialog for changing environment variables
(following guide applies to XP classical view): Right-click the icon for
your machine (usually located on your Desktop and called "My Computer")
and choose _Properties_ there.  Then, open the _Advanced_ tab and click
the _Environment Variables_ button.

  In short, your path is:

     _My Computer ‣ Properties ‣ Advanced ‣ Environment Variables_

  In this dialog, you can add or modify User and System variables.  To
change System variables, you need non-restricted access to your machine
(i.e.  Administrator rights).

  Another way of adding variables to your environment is using the *set*
command:

     set PYTHONPATH=%PYTHONPATH%;C:\My_python_lib

  To make this setting permanent, you could add the corresponding
command line to your ‘autoexec.bat’.  *msconfig* is a graphical
interface to this file.

  Viewing environment variables can also be done more straight-forward:
The command prompt will expand strings wrapped into percent signs
automatically:

     echo %PATH%

  Consult *set /?*  for details on this behaviour.

See also
........

‘http://support.microsoft.com/kb/100843’

     Environment variables in Windows NT

‘http://support.microsoft.com/kb/310519’

     How To Manage Environment Variables in Windows XP

‘http://www.chem.gla.ac.uk/~louis/software/faq/q1.html’

     Setting Environment variables, Louis J. Farrugia


File: python.info,  Node: Finding the Python executable,  Next: Finding modules,  Prev: Excursus Setting environment variables,  Up: Configuring Python

3.3.3.2 Finding the Python executable
.....................................

Besides using the automatically created start menu entry for the Python
interpreter, you might want to start Python in the DOS prompt.  To make
this work, you need to set your ‘%PATH%’ environment variable to include
the directory of your Python distribution, delimited by a semicolon from
other entries.  An example variable could look like this (assuming the
first two entries are Windows’ default):

     C:\WINDOWS\system32;C:\WINDOWS;C:\Python25

  Typing *python* on your command prompt will now fire up the Python
interpreter.  Thus, you can also execute your scripts with command line
options, see *note Command line: 631. documentation.


File: python.info,  Node: Finding modules,  Next: Executing scripts,  Prev: Finding the Python executable,  Up: Configuring Python

3.3.3.3 Finding modules
.......................

Python usually stores its library (and thereby your site-packages
folder) in the installation directory.  So, if you had installed Python
to ‘C:\Python\’, the default library would reside in ‘C:\Python\Lib\’
and third-party modules should be stored in
‘C:\Python\Lib\site-packages\’.

  This is how *note sys.path: 57f. is populated on Windows:

   * An empty entry is added at the start, which corresponds to the
     current directory.

   * If the environment variable *note PYTHONPATH: 580. exists, as
     described in *note Environment variables: 64b, its entries are
     added next.  Note that on Windows, paths in this variable must be
     separated by semicolons, to distinguish them from the colon used in
     drive identifiers (‘C:\’ etc.).

   * Additional "application paths" can be added in the registry as
     subkeys of ‘\SOFTWARE\Python\PythonCore\_version_\PythonPath’ under
     both the ‘HKEY_CURRENT_USER’ and ‘HKEY_LOCAL_MACHINE’ hives.
     Subkeys which have semicolon-delimited path strings as their
     default value will cause each path to be added to *note sys.path:
     57f.  (Note that all known installers only use HKLM, so HKCU is
     typically empty.)

   * If the environment variable *note PYTHONHOME: 63d. is set, it is
     assumed as "Python Home".  Otherwise, the path of the main Python
     executable is used to locate a "landmark file" (‘Lib\os.py’) to
     deduce the "Python Home".  If a Python home is found, the relevant
     sub-directories added to *note sys.path: 57f. (‘Lib’, ‘plat-win’,
     etc) are based on that folder.  Otherwise, the core Python path is
     constructed from the PythonPath stored in the registry.

   * If the Python Home cannot be located, no *note PYTHONPATH: 580. is
     specified in the environment, and no registry entries can be found,
     a default path with relative entries is used (e.g.
     ‘.\Lib;.\plat-win’, etc).

  The end result of all this is:

   * When running ‘python.exe’, or any other .exe in the main Python
     directory (either an installed version, or directly from the
     PCbuild directory), the core path is deduced, and the core paths in
     the registry are ignored.  Other "application paths" in the
     registry are always read.

   * When Python is hosted in another .exe (different directory,
     embedded via COM, etc), the "Python Home" will not be deduced, so
     the core path from the registry is used.  Other "application paths"
     in the registry are always read.

   * If Python can’t find its home and there is no registry (eg, frozen
     .exe, some very strange installation setup) you get a path with
     some default, but relative, paths.


File: python.info,  Node: Executing scripts,  Prev: Finding modules,  Up: Configuring Python

3.3.3.4 Executing scripts
.........................

Python scripts (files with the extension ‘.py’) will be executed by
*python.exe* by default.  This executable opens a terminal, which stays
open even if the program uses a GUI. If you do not want this to happen,
use the extension ‘.pyw’ which will cause the script to be executed by
*pythonw.exe* by default (both executables are located in the top-level
of your Python installation directory).  This suppresses the terminal
window on startup.

  You can also make all ‘.py’ scripts execute with *pythonw.exe*,
setting this through the usual facilities, for example (might require
administrative rights):

  1. Launch a command prompt.

  2. Associate the correct file group with ‘.py’ scripts:

          assoc .py=Python.File

  3. Redirect all Python files to the new executable:

          ftype Python.File=C:\Path\to\pythonw.exe "%1" %*


File: python.info,  Node: Additional modules,  Next: Compiling Python on Windows,  Prev: Configuring Python,  Up: Using Python on Windows

3.3.4 Additional modules
------------------------

Even though Python aims to be portable among all platforms, there are
features that are unique to Windows.  A couple of modules, both in the
standard library and external, and snippets exist to use these features.

  The Windows-specific standard modules are documented in *note MS
Windows Specific Services: 671.

* Menu:

* PyWin32:: 
* Py2exe:: 
* WConio:: 


File: python.info,  Node: PyWin32,  Next: Py2exe,  Up: Additional modules

3.3.4.1 PyWin32
...............

The PyWin32(1) module by Mark Hammond is a collection of modules for
advanced Windows-specific support.  This includes utilities for:

   * Component Object Model(2) (COM)

   * Win32 API calls

   * Registry

   * Event log

   * Microsoft Foundation Classes(3) (MFC) user interfaces

  PythonWin(4) is a sample MFC application shipped with PyWin32.  It is
an embeddable IDE with a built-in debugger.

See also
........

Win32 How Do I...?(5)

     by Tim Golden

Python and COM(6)

     by David and Paul Boddie

   ---------- Footnotes ----------

   (1) http://python.net/crew/mhammond/win32/

   (2) http://www.microsoft.com/com/

   (3) http://msdn.microsoft.com/en-us/library/fe1cf721%28VS.80%29.aspx

   (4) 
http://web.archive.org/web/20060524042422/http://www.python.org/windows/pythonwin/

   (5) http://timgolden.me.uk/python/win32_how_do_i.html

   (6) http://www.boddie.org.uk/python/COM.html


File: python.info,  Node: Py2exe,  Next: WConio,  Prev: PyWin32,  Up: Additional modules

3.3.4.2 Py2exe
..............

Py2exe(1) is a *note distutils: 85. extension (see *note Extending
Distutils: 674.) which wraps Python scripts into executable Windows
programs (‘_*_.exe’ files).  When you have done this, you can distribute
your application without requiring your users to install Python.

   ---------- Footnotes ----------

   (1) http://www.py2exe.org/


File: python.info,  Node: WConio,  Prev: Py2exe,  Up: Additional modules

3.3.4.3 WConio
..............

Since Python’s advanced terminal handling layer, *note curses: 79, is
restricted to Unix-like systems, there is a library exclusive to Windows
as well: Windows Console I/O for Python.

  WConio(1) is a wrapper for Turbo-C’s ‘CONIO.H’, used to create text
user interfaces.

   ---------- Footnotes ----------

   (1) http://newcenturycomputers.net/projects/wconio.html


File: python.info,  Node: Compiling Python on Windows,  Next: Other resources,  Prev: Additional modules,  Up: Using Python on Windows

3.3.5 Compiling Python on Windows
---------------------------------

If you want to compile CPython yourself, first thing you should do is
get the source(1).  You can download either the latest release’s source
or just grab a fresh checkout(2).

  For Microsoft Visual C++, which is the compiler with which official
Python releases are built, the source tree contains solutions/project
files.  View the ‘readme.txt’ in their respective directories:

Directory                MSVC version       Visual Studio version
                                            
------------------------------------------------------------------------
                                            
‘PC/VC6/’                6.0                97
                                            
                                            
‘PC/VS7.1/’              7.1                2003
                                            
                                            
‘PC/VS8.0/’              8.0                2005
                                            
                                            
‘PCbuild/’               9.0                2008
                                            

  Note that not all of these build directories are fully supported.
Read the release notes to see which compiler version the official
releases for your version are built with.

  Check ‘PC/readme.txt’ for general information on the build process.

  For extension modules, consult *note Building C and C++ Extensions on
Windows: 677.

See also
........

Python + Windows + distutils + SWIG + gcc MinGW(3)

     or "Creating Python extensions in C/C++ with SWIG and compiling
     them with MinGW gcc under Windows" or "Installing Python extension
     with distutils and without Microsoft Visual C++" by Sébastien
     Sauvage, 2003

MingW – Python extensions(4)

     by Trent Apted et al, 2007

   ---------- Footnotes ----------

   (1) http://python.org/download/source/

   (2) http://docs.python.org/devguide/setup#checking-out-the-code

   (3) http://sebsauvage.net/python/mingw.html

   (4) http://oldwiki.mingw.org/index.php/Python%20extensions


File: python.info,  Node: Other resources,  Prev: Compiling Python on Windows,  Up: Using Python on Windows

3.3.6 Other resources
---------------------

See also
........

Python Programming On Win32(1)

     "Help for Windows Programmers" by Mark Hammond and Andy Robinson,
     O’Reilly Media, 2000, ISBN 1-56592-621-8

A Python for Windows Tutorial(2)

     by Amanda Birmingham, 2004

   ---------- Footnotes ----------

   (1) http://www.oreilly.com/catalog/pythonwin32/

   (2) http://www.imladris.com/Scripts/PythonForWindows.html


File: python.info,  Node: Using Python on a Macintosh,  Prev: Using Python on Windows,  Up: Python Setup and Usage

3.4 Using Python on a Macintosh
===============================

     Author: Bob Savage <<bobsavage@mac.com>>

  Python on a Macintosh running Mac OS X is in principle very similar to
Python on any other Unix platform, but there are a number of additional
features such as the IDE and the Package Manager that are worth pointing
out.

  The Mac-specific modules are documented in *note Mac OS X specific
services: 67c.

  Python on Mac OS 9 or earlier can be quite different from Python on
Unix or Windows, but is beyond the scope of this manual, as that
platform is no longer supported, starting with Python 2.4.  See
‘http://www.cwi.nl/~jack/macpython’ for installers for the latest 2.3
release for Mac OS 9 and related documentation.

* Menu:

* Getting and Installing MacPython:: 
* The IDE:: 
* Installing Additional Python Packages:: 
* GUI Programming on the Mac:: 
* Distributing Python Applications on the Mac:: 
* Other Resources:: 

Getting and Installing MacPython

* How to run a Python script:: 
* Running scripts with a GUI:: 
* Configuration:: 


File: python.info,  Node: Getting and Installing MacPython,  Next: The IDE,  Up: Using Python on a Macintosh

3.4.1 Getting and Installing MacPython
--------------------------------------

Mac OS X 10.8 comes with Python 2.7 pre-installed by Apple.  If you
wish, you are invited to install the most recent version of Python from
the Python website (‘http://www.python.org’).  A current "universal
binary" build of Python, which runs natively on the Mac’s new Intel and
legacy PPC CPU’s, is available there.

  What you get after installing is a number of things:

   * A ‘MacPython 2.7’ folder in your ‘Applications’ folder.  In here
     you find IDLE, the development environment that is a standard part
     of official Python distributions; PythonLauncher, which handles
     double-clicking Python scripts from the Finder; and the "Build
     Applet" tool, which allows you to package Python scripts as
     standalone applications on your system.

   * A framework ‘/Library/Frameworks/Python.framework’, which includes
     the Python executable and libraries.  The installer adds this
     location to your shell path.  To uninstall MacPython, you can
     simply remove these three things.  A symlink to the Python
     executable is placed in /usr/local/bin/.

  The Apple-provided build of Python is installed in
‘/System/Library/Frameworks/Python.framework’ and ‘/usr/bin/python’,
respectively.  You should never modify or delete these, as they are
Apple-controlled and are used by Apple- or third-party software.
Remember that if you choose to install a newer Python version from
python.org, you will have two different but functional Python
installations on your computer, so it will be important that your paths
and usages are consistent with what you want to do.

  IDLE includes a help menu that allows you to access Python
documentation.  If you are completely new to Python you should start
reading the tutorial introduction in that document.

  If you are familiar with Python on other Unix platforms you should
read the section on running Python scripts from the Unix shell.

* Menu:

* How to run a Python script:: 
* Running scripts with a GUI:: 
* Configuration:: 


File: python.info,  Node: How to run a Python script,  Next: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.1 How to run a Python script
..................................

Your best way to get started with Python on Mac OS X is through the IDLE
integrated development environment, see section *note The IDE: 680. and
use the Help menu when the IDE is running.

  If you want to run Python scripts from the Terminal window command
line or from the Finder you first need an editor to create your script.
Mac OS X comes with a number of standard Unix command line editors,
*vim* and *emacs* among them.  If you want a more Mac-like editor,
*BBEdit* or *TextWrangler* from Bare Bones Software (see
‘http://www.barebones.com/products/bbedit/index.shtml’) are good
choices, as is *TextMate* (see ‘http://macromates.com/’).  Other editors
include *Gvim* (‘http://macvim.org’) and *Aquamacs*
(‘http://aquamacs.org/’).

  To run your script from the Terminal window you must make sure that
‘/usr/local/bin’ is in your shell search path.

  To run your script from the Finder you have two options:

   * Drag it to *PythonLauncher*

   * Select *PythonLauncher* as the default application to open your
     script (or any .py script) through the finder Info window and
     double-click it.  *PythonLauncher* has various preferences to
     control how your script is launched.  Option-dragging allows you to
     change these for one invocation, or use its Preferences menu to
     change things globally.


File: python.info,  Node: Running scripts with a GUI,  Next: Configuration,  Prev: How to run a Python script,  Up: Getting and Installing MacPython

3.4.1.2 Running scripts with a GUI
..................................

With older versions of Python, there is one Mac OS X quirk that you need
to be aware of: programs that talk to the Aqua window manager (in other
words, anything that has a GUI) need to be run in a special way.  Use
*pythonw* instead of *python* to start such scripts.

  With Python 2.7, you can use either *python* or *pythonw*.


File: python.info,  Node: Configuration,  Prev: Running scripts with a GUI,  Up: Getting and Installing MacPython

3.4.1.3 Configuration
.....................

Python on OS X honors all standard Unix environment variables such as
*note PYTHONPATH: 580, but setting these variables for programs started
from the Finder is non-standard as the Finder does not read your
‘.profile’ or ‘.cshrc’ at startup.  You need to create a file ‘~
/.MacOSX/environment.plist’.  See Apple’s Technical Document QA1067 for
details.

  For more information on installation Python packages in MacPython, see
section *note Installing Additional Python Packages: 684.


File: python.info,  Node: The IDE,  Next: Installing Additional Python Packages,  Prev: Getting and Installing MacPython,  Up: Using Python on a Macintosh

3.4.2 The IDE
-------------

MacPython ships with the standard IDLE development environment.  A good
introduction to using IDLE can be found at
‘http://hkn.eecs.berkeley.edu/~dyoo/python/idle_intro/index.html’.


File: python.info,  Node: Installing Additional Python Packages,  Next: GUI Programming on the Mac,  Prev: The IDE,  Up: Using Python on a Macintosh

3.4.3 Installing Additional Python Packages
-------------------------------------------

There are several methods to install additional Python packages:

   * Packages can be installed via the standard Python distutils mode
     (‘python setup.py install’).

   * Many packages can also be installed via the *setuptools* extension
     or *pip* wrapper, see ‘http://www.pip-installer.org/’.


File: python.info,  Node: GUI Programming on the Mac,  Next: Distributing Python Applications on the Mac,  Prev: Installing Additional Python Packages,  Up: Using Python on a Macintosh

3.4.4 GUI Programming on the Mac
--------------------------------

There are several options for building GUI applications on the Mac with
Python.

  _PyObjC_ is a Python binding to Apple’s Objective-C/Cocoa framework,
which is the foundation of most modern Mac development.  Information on
PyObjC is available from ‘http://pyobjc.sourceforge.net’.

  The standard Python GUI toolkit is *note Tkinter: 17d, based on the
cross-platform Tk toolkit (‘http://www.tcl.tk’).  An Aqua-native version
of Tk is bundled with OS X by Apple, and the latest version can be
downloaded and installed from ‘http://www.activestate.com’; it can also
be built from source.

  _wxPython_ is another popular cross-platform GUI toolkit that runs
natively on Mac OS X. Packages and documentation are available from
‘http://www.wxpython.org’.

  _PyQt_ is another popular cross-platform GUI toolkit that runs
natively on Mac OS X. More information can be found at
‘http://www.riverbankcomputing.co.uk/software/pyqt/intro’.


File: python.info,  Node: Distributing Python Applications on the Mac,  Next: Other Resources,  Prev: GUI Programming on the Mac,  Up: Using Python on a Macintosh

3.4.5 Distributing Python Applications on the Mac
-------------------------------------------------

The "Build Applet" tool that is placed in the MacPython 2.7 folder is
fine for packaging small Python scripts on your own machine to run as a
standard Mac application.  This tool, however, is not robust enough to
distribute Python applications to other users.

  The standard tool for deploying standalone Python applications on the
Mac is *py2app*.  More information on installing and using py2app can be
found at ‘http://undefined.org/python/#py2app’.


File: python.info,  Node: Other Resources,  Prev: Distributing Python Applications on the Mac,  Up: Using Python on a Macintosh

3.4.6 Other Resources
---------------------

The MacPython mailing list is an excellent support resource for Python
users and developers on the Mac:

  ‘http://www.python.org/community/sigs/current/pythonmac-sig/’

  Another useful resource is the MacPython wiki:

  ‘http://wiki.python.org/moin/MacPython’


File: python.info,  Node: The Python Language Reference,  Next: The Python Standard Library,  Prev: Python Setup and Usage,  Up: Top

4 The Python Language Reference
*******************************

This reference manual describes the syntax and "core semantics" of the
language.  It is terse, but attempts to be exact and complete.  The
semantics of non-essential built-in object types and of the built-in
functions and modules are described in *note The Python Standard
Library: 4f8.  For an informal introduction to the language, see *note
The Python Tutorial: 4f7.  For C or C++ programmers, two additional
manuals exist: *note Extending and Embedding the Python Interpreter:
4fa. describes the high-level picture of how to write a Python extension
module, and the *note Python/C API Reference Manual: 4fb. describes the
interfaces available to C/C++ programmers in detail.

* Menu:

* Introduction: Introduction<4>. 
* Lexical analysis:: 
* Data model:: 
* Execution model:: 
* Expressions:: 
* Simple statements:: 
* Compound statements:: 
* Top-level components:: 
* Full Grammar specification:: 

Introduction

* Alternate Implementations:: 
* Notation:: 

Lexical analysis

* Line structure:: 
* Other tokens:: 
* Identifiers and keywords:: 
* Literals:: 
* Operators:: 
* Delimiters:: 

Line structure

* Logical lines:: 
* Physical lines:: 
* Comments:: 
* Encoding declarations:: 
* Explicit line joining:: 
* Implicit line joining:: 
* Blank lines:: 
* Indentation:: 
* Whitespace between tokens:: 

Identifiers and keywords

* Keywords:: 
* Reserved classes of identifiers:: 

Literals

* String literals:: 
* String literal concatenation:: 
* Numeric literals:: 
* Integer and long integer literals:: 
* Floating point literals:: 
* Imaginary literals:: 

Data model

* Objects, values and types: Objects values and types. 
* The standard type hierarchy:: 
* New-style and classic classes:: 
* Special method names:: 

Special method names

* Basic customization:: 
* Customizing attribute access:: 
* Customizing class creation:: 
* Customizing instance and subclass checks:: 
* Emulating callable objects:: 
* Emulating container types:: 
* Additional methods for emulation of sequence types:: 
* Emulating numeric types:: 
* Coercion rules:: 
* With Statement Context Managers:: 
* Special method lookup for old-style classes:: 
* Special method lookup for new-style classes:: 

Customizing attribute access

* More attribute access for new-style classes:: 
* Implementing Descriptors:: 
* Invoking Descriptors:: 
* __slots__:: 

Execution model

* Naming and binding:: 
* Exceptions: Exceptions<2>. 

Naming and binding

* Interaction with dynamic features:: 

Expressions

* Arithmetic conversions:: 
* Atoms:: 
* Primaries:: 
* The power operator:: 
* Unary arithmetic and bitwise operations:: 
* Binary arithmetic operations:: 
* Shifting operations:: 
* Binary bitwise operations:: 
* Comparisons:: 
* Boolean operations:: 
* Conditional Expressions:: 
* Lambdas:: 
* Expression lists:: 
* Evaluation order:: 
* Operator precedence:: 

Atoms

* Identifiers (Names): Identifiers Names. 
* Literals: Literals<2>. 
* Parenthesized forms:: 
* List displays:: 
* Displays for sets and dictionaries:: 
* Generator expressions:: 
* Dictionary displays:: 
* Set displays:: 
* String conversions:: 
* Yield expressions:: 

Yield expressions

* Generator-iterator methods:: 

Primaries

* Attribute references:: 
* Subscriptions:: 
* Slicings:: 
* Calls:: 

Simple statements

* Expression statements:: 
* Assignment statements:: 
* The assert statement:: 
* The pass statement:: 
* The del statement: The del statement<2>. 
* The print statement:: 
* The return statement:: 
* The yield statement:: 
* The raise statement:: 
* The break statement:: 
* The continue statement:: 
* The import statement:: 
* The global statement:: 
* The exec statement:: 

Assignment statements

* Augmented assignment statements:: 

The import statement

* Future statements:: 

Compound statements

* The if statement:: 
* The while statement:: 
* The for statement:: 
* The try statement:: 
* The with statement:: 
* Function definitions:: 
* Class definitions:: 

Top-level components

* Complete Python programs:: 
* File input:: 
* Interactive input:: 
* Expression input:: 


File: python.info,  Node: Introduction<4>,  Next: Lexical analysis,  Up: The Python Language Reference

4.1 Introduction
================

This reference manual describes the Python programming language.  It is
not intended as a tutorial.

  While I am trying to be as precise as possible, I chose to use English
rather than formal specifications for everything except syntax and
lexical analysis.  This should make the document more understandable to
the average reader, but will leave room for ambiguities.  Consequently,
if you were coming from Mars and tried to re-implement Python from this
document alone, you might have to guess things and in fact you would
probably end up implementing quite a different language.  On the other
hand, if you are using Python and wonder what the precise rules about a
particular area of the language are, you should definitely be able to
find them here.  If you would like to see a more formal definition of
the language, maybe you could volunteer your time — or invent a cloning
machine :-).

  It is dangerous to add too many implementation details to a language
reference document — the implementation may change, and other
implementations of the same language may work differently.  On the other
hand, there is currently only one Python implementation in widespread
use (although alternate implementations exist), and its particular
quirks are sometimes worth being mentioned, especially where the
implementation imposes additional limitations.  Therefore, you’ll find
short "implementation notes" sprinkled throughout the text.

  Every Python implementation comes with a number of built-in and
standard modules.  These are documented in *note The Python Standard
Library: 4f8.  A few built-in modules are mentioned when they interact
in a significant way with the language definition.

* Menu:

* Alternate Implementations:: 
* Notation:: 


File: python.info,  Node: Alternate Implementations,  Next: Notation,  Up: Introduction<4>

4.1.1 Alternate Implementations
-------------------------------

Though there is one Python implementation which is by far the most
popular, there are some alternate implementations which are of
particular interest to different audiences.

  Known implementations include:

CPython

     This is the original and most-maintained implementation of Python,
     written in C. New language features generally appear here first.

Jython

     Python implemented in Java.  This implementation can be used as a
     scripting language for Java applications, or can be used to create
     applications using the Java class libraries.  It is also often used
     to create tests for Java libraries.  More information can be found
     at the Jython website(1).

Python for .NET

     This implementation actually uses the CPython implementation, but
     is a managed .NET application and makes .NET libraries available.
     It was created by Brian Lloyd.  For more information, see the
     Python for .NET home page(2).

IronPython

     An alternate Python for .NET. Unlike Python.NET, this is a complete
     Python implementation that generates IL, and compiles Python code
     directly to .NET assemblies.  It was created by Jim Hugunin, the
     original creator of Jython.  For more information, see the
     IronPython website(3).

PyPy

     An implementation of Python written completely in Python.  It
     supports several advanced features not found in other
     implementations like stackless support and a Just in Time compiler.
     One of the goals of the project is to encourage experimentation
     with the language itself by making it easier to modify the
     interpreter (since it is written in Python).  Additional
     information is available on the PyPy project’s home page(4).

  Each of these implementations varies in some way from the language as
documented in this manual, or introduces specific information beyond
what’s covered in the standard Python documentation.  Please refer to
the implementation-specific documentation to determine what else you
need to know about the specific implementation you’re using.

   ---------- Footnotes ----------

   (1) http://www.jython.org/

   (2) http://pythonnet.sourceforge.net

   (3) http://www.ironpython.net/

   (4) http://pypy.org/


File: python.info,  Node: Notation,  Prev: Alternate Implementations,  Up: Introduction<4>

4.1.2 Notation
--------------

The descriptions of lexical analysis and syntax use a modified BNF
grammar notation.  This uses the following style of definition:

     name      ::= lc_letter (lc_letter | "_")*
     lc_letter ::= "a"..."z"


  The first line says that a ‘name’ is an ‘lc_letter’ followed by a
sequence of zero or more ‘lc_letter’s and underscores.  An ‘lc_letter’
in turn is any of the single characters ‘'a'’ through ‘'z'’.  (This rule
is actually adhered to for the names defined in lexical and grammar
rules in this document.)

  Each rule begins with a name (which is the name defined by the rule)
and ‘::=’.  A vertical bar (‘|’) is used to separate alternatives; it is
the least binding operator in this notation.  A star (‘*’) means zero or
more repetitions of the preceding item; likewise, a plus (‘+’) means one
or more repetitions, and a phrase enclosed in square brackets (‘[ ]’)
means zero or one occurrences (in other words, the enclosed phrase is
optional).  The ‘*’ and ‘+’ operators bind as tightly as possible;
parentheses are used for grouping.  Literal strings are enclosed in
quotes.  White space is only meaningful to separate tokens.  Rules are
normally contained on a single line; rules with many alternatives may be
formatted alternatively with each line after the first beginning with a
vertical bar.

  In lexical definitions (as the example above), two more conventions
are used: Two literal characters separated by three dots mean a choice
of any single character in the given (inclusive) range of ASCII
characters.  A phrase between angular brackets (‘<...>’) gives an
informal description of the symbol defined; e.g., this could be used to
describe the notion of ’control character’ if needed.

  Even though the notation used is almost the same, there is a big
difference between the meaning of lexical and syntactic definitions: a
lexical definition operates on the individual characters of the input
source, while a syntax definition operates on the stream of tokens
generated by the lexical analysis.  All uses of BNF in the next chapter
("Lexical Analysis") are lexical definitions; uses in subsequent
chapters are syntactic definitions.


File: python.info,  Node: Lexical analysis,  Next: Data model,  Prev: Introduction<4>,  Up: The Python Language Reference

4.2 Lexical analysis
====================

A Python program is read by a _parser_.  Input to the parser is a stream
of _tokens_, generated by the _lexical analyzer_.  This chapter
describes how the lexical analyzer breaks a file into tokens.

  Python uses the 7-bit ASCII character set for program text.

  New in version 2.3: An encoding declaration can be used to indicate
that string literals and comments use an encoding different from ASCII.

  For compatibility with older versions, Python only warns if it finds
8-bit characters; those warnings should be corrected by either declaring
an explicit encoding, or using escape sequences if those bytes are
binary data, instead of characters.

  The run-time character set depends on the I/O devices connected to the
program but is generally a superset of ASCII.

  *Future compatibility note:* It may be tempting to assume that the
character set for 8-bit characters is ISO Latin-1 (an ASCII superset
that covers most western languages that use the Latin alphabet), but it
is possible that in the future Unicode text editors will become common.
These generally use the UTF-8 encoding, which is also an ASCII superset,
but with very different use for the characters with ordinals 128-255.
While there is no consensus on this subject yet, it is unwise to assume
either Latin-1 or UTF-8, even though the current implementation appears
to favor Latin-1.  This applies both to the source character set and the
run-time character set.

* Menu:

* Line structure:: 
* Other tokens:: 
* Identifiers and keywords:: 
* Literals:: 
* Operators:: 
* Delimiters:: 

Line structure

* Logical lines:: 
* Physical lines:: 
* Comments:: 
* Encoding declarations:: 
* Explicit line joining:: 
* Implicit line joining:: 
* Blank lines:: 
* Indentation:: 
* Whitespace between tokens:: 

Identifiers and keywords

* Keywords:: 
* Reserved classes of identifiers:: 

Literals

* String literals:: 
* String literal concatenation:: 
* Numeric literals:: 
* Integer and long integer literals:: 
* Floating point literals:: 
* Imaginary literals:: 


File: python.info,  Node: Line structure,  Next: Other tokens,  Up: Lexical analysis

4.2.1 Line structure
--------------------

A Python program is divided into a number of _logical lines_.

* Menu:

* Logical lines:: 
* Physical lines:: 
* Comments:: 
* Encoding declarations:: 
* Explicit line joining:: 
* Implicit line joining:: 
* Blank lines:: 
* Indentation:: 
* Whitespace between tokens:: 


File: python.info,  Node: Logical lines,  Next: Physical lines,  Up: Line structure

4.2.1.1 Logical lines
.....................

The end of a logical line is represented by the token NEWLINE.
Statements cannot cross logical line boundaries except where NEWLINE is
allowed by the syntax (e.g., between statements in compound statements).
A logical line is constructed from one or more _physical lines_ by
following the explicit or implicit _line joining_ rules.


File: python.info,  Node: Physical lines,  Next: Comments,  Prev: Logical lines,  Up: Line structure

4.2.1.2 Physical lines
......................

A physical line is a sequence of characters terminated by an end-of-line
sequence.  In source files, any of the standard platform line
termination sequences can be used - the Unix form using ASCII LF
(linefeed), the Windows form using the ASCII sequence CR LF (return
followed by linefeed), or the old Macintosh form using the ASCII CR
(return) character.  All of these forms can be used equally, regardless
of platform.

  When embedding Python, source code strings should be passed to Python
APIs using the standard C conventions for newline characters (the ‘\n’
character, representing ASCII LF, is the line terminator).

