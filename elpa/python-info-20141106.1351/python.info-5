This is python.info, produced by makeinfo version 5.2 from python.texi.

     Python 2.7.8, November 06, 2014

     Georg Brandl

     Copyright © 1990-2014, Python Software Foundation

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Python: (python.info). The Python Programming Language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: python.info,  Node: Comments,  Next: Encoding declarations,  Prev: Physical lines,  Up: Line structure

4.2.1.3 Comments
................

A comment starts with a hash character (‘#’) that is not part of a
string literal, and ends at the end of the physical line.  A comment
signifies the end of the logical line unless the implicit line joining
rules are invoked.  Comments are ignored by the syntax; they are not
tokens.


File: python.info,  Node: Encoding declarations,  Next: Explicit line joining,  Prev: Comments,  Up: Line structure

4.2.1.4 Encoding declarations
.............................

If a comment in the first or second line of the Python script matches
the regular expression ‘coding[=:]\s*([-\w.]+)’, this comment is
processed as an encoding declaration; the first group of this expression
names the encoding of the source code file.  The recommended forms of
this expression are

     # -*- coding: <encoding-name> -*-

  which is recognized also by GNU Emacs, and

     # vim:fileencoding=<encoding-name>

  which is recognized by Bram Moolenaar’s VIM. In addition, if the first
bytes of the file are the UTF-8 byte-order mark (‘'\xef\xbb\xbf'’), the
declared file encoding is UTF-8 (this is supported, among others, by
Microsoft’s *notepad*).

  If an encoding is declared, the encoding name must be recognized by
Python.  The encoding is used for all lexical analysis, in particular to
find the end of a string, and to interpret the contents of Unicode
literals.  String literals are converted to Unicode for syntactical
analysis, then converted back to their original encoding before
interpretation starts.  The encoding declaration must appear on a line
of its own.


File: python.info,  Node: Explicit line joining,  Next: Implicit line joining,  Prev: Encoding declarations,  Up: Line structure

4.2.1.5 Explicit line joining
.............................

Two or more physical lines may be joined into logical lines using
backslash characters (‘\’), as follows: when a physical line ends in a
backslash that is not part of a string literal or comment, it is joined
with the following forming a single logical line, deleting the backslash
and the following end-of-line character.  For example:

     if 1900 < year < 2100 and 1 <= month <= 12 \
        and 1 <= day <= 31 and 0 <= hour < 24 \
        and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
             return 1

  A line ending in a backslash cannot carry a comment.  A backslash does
not continue a comment.  A backslash does not continue a token except
for string literals (i.e., tokens other than string literals cannot be
split across physical lines using a backslash).  A backslash is illegal
elsewhere on a line outside a string literal.


File: python.info,  Node: Implicit line joining,  Next: Blank lines,  Prev: Explicit line joining,  Up: Line structure

4.2.1.6 Implicit line joining
.............................

Expressions in parentheses, square brackets or curly braces can be split
over more than one physical line without using backslashes.  For
example:

     month_names = ['Januari', 'Februari', 'Maart',      # These are the
                    'April',   'Mei',      'Juni',       # Dutch names
                    'Juli',    'Augustus', 'September',  # for the months
                    'Oktober', 'November', 'December']   # of the year

  Implicitly continued lines can carry comments.  The indentation of the
continuation lines is not important.  Blank continuation lines are
allowed.  There is no NEWLINE token between implicit continuation lines.
Implicitly continued lines can also occur within triple-quoted strings
(see below); in that case they cannot carry comments.


File: python.info,  Node: Blank lines,  Next: Indentation,  Prev: Implicit line joining,  Up: Line structure

4.2.1.7 Blank lines
...................

A logical line that contains only spaces, tabs, formfeeds and possibly a
comment, is ignored (i.e., no NEWLINE token is generated).  During
interactive input of statements, handling of a blank line may differ
depending on the implementation of the read-eval-print loop.  In the
standard implementation, an entirely blank logical line (i.e.  one
containing not even whitespace or a comment) terminates a multi-line
statement.


File: python.info,  Node: Indentation,  Next: Whitespace between tokens,  Prev: Blank lines,  Up: Line structure

4.2.1.8 Indentation
...................

Leading whitespace (spaces and tabs) at the beginning of a logical line
is used to compute the indentation level of the line, which in turn is
used to determine the grouping of statements.

  First, tabs are replaced (from left to right) by one to eight spaces
such that the total number of characters up to and including the
replacement is a multiple of eight (this is intended to be the same rule
as used by Unix).  The total number of spaces preceding the first
non-blank character then determines the line’s indentation.  Indentation
cannot be split over multiple physical lines using backslashes; the
whitespace up to the first backslash determines the indentation.

  *Cross-platform compatibility note:* because of the nature of text
editors on non-UNIX platforms, it is unwise to use a mixture of spaces
and tabs for the indentation in a single source file.  It should also be
noted that different platforms may explicitly limit the maximum
indentation level.

  A formfeed character may be present at the start of the line; it will
be ignored for the indentation calculations above.  Formfeed characters
occurring elsewhere in the leading whitespace have an undefined effect
(for instance, they may reset the space count to zero).

  The indentation levels of consecutive lines are used to generate
INDENT and DEDENT tokens, using a stack, as follows.

  Before the first line of the file is read, a single zero is pushed on
the stack; this will never be popped off again.  The numbers pushed on
the stack will always be strictly increasing from bottom to top.  At the
beginning of each logical line, the line’s indentation level is compared
to the top of the stack.  If it is equal, nothing happens.  If it is
larger, it is pushed on the stack, and one INDENT token is generated.
If it is smaller, it _must_ be one of the numbers occurring on the
stack; all numbers on the stack that are larger are popped off, and for
each number popped off a DEDENT token is generated.  At the end of the
file, a DEDENT token is generated for each number remaining on the stack
that is larger than zero.

  Here is an example of a correctly (though confusingly) indented piece
of Python code:

     def perm(l):
             # Compute the list of all permutations of l
         if len(l) <= 1:
                       return [l]
         r = []
         for i in range(len(l)):
                  s = l[:i] + l[i+1:]
                  p = perm(s)
                  for x in p:
                   r.append(l[i:i+1] + x)
         return r

  The following example shows various indentation errors:

      def perm(l):                       # error: first line indented
     for i in range(len(l)):             # error: not indented
         s = l[:i] + l[i+1:]
             p = perm(l[:i] + l[i+1:])   # error: unexpected indent
             for x in p:
                     r.append(l[i:i+1] + x)
                 return r                # error: inconsistent dedent

  (Actually, the first three errors are detected by the parser; only the
last error is found by the lexical analyzer — the indentation of ‘return
r’ does not match a level popped off the stack.)


File: python.info,  Node: Whitespace between tokens,  Prev: Indentation,  Up: Line structure

4.2.1.9 Whitespace between tokens
.................................

Except at the beginning of a logical line or in string literals, the
whitespace characters space, tab and formfeed can be used
interchangeably to separate tokens.  Whitespace is needed between two
tokens only if their concatenation could otherwise be interpreted as a
different token (e.g., ab is one token, but a b is two tokens).


File: python.info,  Node: Other tokens,  Next: Identifiers and keywords,  Prev: Line structure,  Up: Lexical analysis

4.2.2 Other tokens
------------------

Besides NEWLINE, INDENT and DEDENT, the following categories of tokens
exist: _identifiers_, _keywords_, _literals_, _operators_, and
_delimiters_.  Whitespace characters (other than line terminators,
discussed earlier) are not tokens, but serve to delimit tokens.  Where
ambiguity exists, a token comprises the longest possible string that
forms a legal token, when read from left to right.


File: python.info,  Node: Identifiers and keywords,  Next: Literals,  Prev: Other tokens,  Up: Lexical analysis

4.2.3 Identifiers and keywords
------------------------------

Identifiers (also referred to as _names_) are described by the following
lexical definitions:

     identifier ::= (letter|"_") (letter | digit | "_")*
     letter     ::= lowercase | uppercase
     lowercase  ::= "a"..."z"
     uppercase  ::= "A"..."Z"
     digit      ::= "0"..."9"


  Identifiers are unlimited in length.  Case is significant.

* Menu:

* Keywords:: 
* Reserved classes of identifiers:: 


File: python.info,  Node: Keywords,  Next: Reserved classes of identifiers,  Up: Identifiers and keywords

4.2.3.1 Keywords
................

The following identifiers are used as reserved words, or _keywords_ of
the language, and cannot be used as ordinary identifiers.  They must be
spelled exactly as written here:

     and       del       from      not       while
     as        elif      global    or        with
     assert    else      if        pass      yield
     break     except    import    print
     class     exec      in        raise
     continue  finally   is        return
     def       for       lambda    try

  Changed in version 2.4: *note None: 39a. became a constant and is now
recognized by the compiler as a name for the built-in object *note None:
39a.  Although it is not a keyword, you cannot assign a different object
to it.

  Changed in version 2.5: Using *note as: 2f8. and *note with: 1c0. as
identifiers triggers a warning.  To use them as keywords, enable the
‘with_statement’ future feature .

  Changed in version 2.6: *note as: 2f8. and *note with: 1c0. are full
keywords.


File: python.info,  Node: Reserved classes of identifiers,  Prev: Keywords,  Up: Identifiers and keywords

4.2.3.2 Reserved classes of identifiers
.......................................

Certain classes of identifiers (besides keywords) have special meanings.
These classes are identified by the patterns of leading and trailing
underscore characters:

‘_*’

     Not imported by ‘from module import *’.  The special identifier ‘_’
     is used in the interactive interpreter to store the result of the
     last evaluation; it is stored in the *note __builtin__: 0. module.
     When not in interactive mode, ‘_’ has no special meaning and is not
     defined.  See section *note The import statement: 1f4.

          Note: The name ‘_’ is often used in conjunction with
          internationalization; refer to the documentation for the *note
          gettext: e0. module for more information on this convention.

‘__*__’

     System-defined names.  These names are defined by the interpreter
     and its implementation (including the standard library).  Current
     system names are discussed in the *note Special method names: 6b8.
     section and elsewhere.  More will likely be defined in future
     versions of Python.  _Any_ use of ‘__*__’ names, in any context,
     that does not follow explicitly documented use, is subject to
     breakage without warning.

‘__*’

     Class-private names.  Names in this category, when used within the
     context of a class definition, are re-written to use a mangled form
     to help avoid name clashes between "private" attributes of base and
     derived classes.  See section *note Identifiers (Names): 6b9.


File: python.info,  Node: Literals,  Next: Operators,  Prev: Identifiers and keywords,  Up: Lexical analysis

4.2.4 Literals
--------------

Literals are notations for constant values of some built-in types.

* Menu:

* String literals:: 
* String literal concatenation:: 
* Numeric literals:: 
* Integer and long integer literals:: 
* Floating point literals:: 
* Imaginary literals:: 


File: python.info,  Node: String literals,  Next: String literal concatenation,  Up: Literals

4.2.4.1 String literals
.......................

String literals are described by the following lexical definitions:

     stringliteral   ::= [stringprefix](shortstring | longstring)
     stringprefix    ::= "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"
                         | "b" | "B" | "br" | "Br" | "bR" | "BR"
     shortstring     ::= "'" shortstringitem* "'" | '"' shortstringitem* '"'
     longstring      ::= "'''" longstringitem* "'''"
                         | '"""' longstringitem* '"""'
     shortstringitem ::= shortstringchar | escapeseq
     longstringitem  ::= longstringchar | escapeseq
     shortstringchar ::= <any source character except "\" or newline or the quote>
     longstringchar  ::= <any source character except "\">
     escapeseq       ::= "\" <any ASCII character>


  One syntactic restriction not indicated by these productions is that
whitespace is not allowed between the *note stringprefix: 6bf. and the
rest of the string literal.  The source character set is defined by the
encoding declaration; it is ASCII if no encoding declaration is given in
the source file; see section *note Encoding declarations: 6a0.

  In plain English: String literals can be enclosed in matching single
quotes (‘'’) or double quotes (‘"’).  They can also be enclosed in
matching groups of three single or double quotes (these are generally
referred to as _triple-quoted strings_).  The backslash (‘\’) character
is used to escape characters that otherwise have a special meaning, such
as newline, backslash itself, or the quote character.  String literals
may optionally be prefixed with a letter ‘'r'’ or ‘'R'’; such strings
are called _raw strings_ and use different rules for interpreting
backslash escape sequences.  A prefix of ‘'u'’ or ‘'U'’ makes the string
a Unicode string.  Unicode strings use the Unicode character set as
defined by the Unicode Consortium and ISO 10646.  Some additional escape
sequences, described below, are available in Unicode strings.  A prefix
of ‘'b'’ or ‘'B'’ is ignored in Python 2; it indicates that the literal
should become a bytes literal in Python 3 (e.g.  when code is
automatically converted with 2to3).  A ‘'u'’ or ‘'b'’ prefix may be
followed by an ‘'r'’ prefix.

  In triple-quoted strings, unescaped newlines and quotes are allowed
(and are retained), except that three unescaped quotes in a row
terminate the string.  (A "quote" is the character used to open the
string, i.e.  either ‘'’ or ‘"’.)

  Unless an ‘'r'’ or ‘'R'’ prefix is present, escape sequences in
strings are interpreted according to rules similar to those used by
Standard C. The recognized escape sequences are:

Escape Sequence       Meaning                               Notes
                                                            
------------------------------------------------------------------------
                                                            
‘\newline’            Ignored
                      
                                                            
‘\\’                  Backslash (‘\’)
                      
                                                            
‘\'’                  Single quote (‘'’)
                      
                                                            
‘\"’                  Double quote (‘"’)
                      
                                                            
‘\a’                  ASCII Bell (BEL)
                      
                                                            
‘\b’                  ASCII Backspace (BS)
                      
                                                            
‘\f’                  ASCII Formfeed (FF)
                      
                                                            
‘\n’                  ASCII Linefeed (LF)
                      
                                                            
‘\N{name}’            Character named _name_ in the
                      Unicode database (Unicode only)
                      
                                                            
‘\r’                  ASCII Carriage Return (CR)
                      
                                                            
‘\t’                  ASCII Horizontal Tab (TAB)
                      
                                                            
‘\uxxxx’              Character with 16-bit hex value       (1)
                      _xxxx_ (Unicode only)                 
                      
                                                            
‘\Uxxxxxxxx’          Character with 32-bit hex value       (2)
                      _xxxxxxxx_ (Unicode only)             
                      
                                                            
‘\v’                  ASCII Vertical Tab (VT)
                      
                                                            
‘\ooo’                Character with octal value _ooo_      (3,5)
                                                            
                                                            
‘\xhh’                Character with hex value _hh_         (4,5)
                                                            

  Notes:

  1. Individual code units which form parts of a surrogate pair can be
     encoded using this escape sequence.

  2. Any Unicode character can be encoded this way, but characters
     outside the Basic Multilingual Plane (BMP) will be encoded using a
     surrogate pair if Python is compiled to use 16-bit code units (the
     default).

  3. As in Standard C, up to three octal digits are accepted.

  4. Unlike in Standard C, exactly two hex digits are required.

  5. In a string literal, hexadecimal and octal escapes denote the byte
     with the given value; it is not necessary that the byte encodes a
     character in the source character set.  In a Unicode literal, these
     escapes denote a Unicode character with the given value.

  Unlike Standard C, all unrecognized escape sequences are left in the
string unchanged, i.e., _the backslash is left in the string_.  (This
behavior is useful when debugging: if an escape sequence is mistyped,
the resulting output is more easily recognized as broken.)  It is also
important to note that the escape sequences marked as "(Unicode only)"
in the table above fall into the category of unrecognized escapes for
non-Unicode string literals.

  When an ‘'r'’ or ‘'R'’ prefix is present, a character following a
backslash is included in the string without change, and _all backslashes
are left in the string_.  For example, the string literal ‘r"\n"’
consists of two characters: a backslash and a lowercase ‘'n'’.  String
quotes can be escaped with a backslash, but the backslash remains in the
string; for example, ‘r"\""’ is a valid string literal consisting of two
characters: a backslash and a double quote; ‘r"\"’ is not a valid string
literal (even a raw string cannot end in an odd number of backslashes).
Specifically, _a raw string cannot end in a single backslash_ (since the
backslash would escape the following quote character).  Note also that a
single backslash followed by a newline is interpreted as those two
characters as part of the string, _not_ as a line continuation.

  When an ‘'r'’ or ‘'R'’ prefix is used in conjunction with a ‘'u'’ or
‘'U'’ prefix, then the ‘\uXXXX’ and ‘\UXXXXXXXX’ escape sequences are
processed while _all other backslashes are left in the string_.  For
example, the string literal ‘ur"\u0062\n"’ consists of three Unicode
characters: ’LATIN SMALL LETTER B’, ’REVERSE SOLIDUS’, and ’LATIN SMALL
LETTER N’.  Backslashes can be escaped with a preceding backslash;
however, both remain in the string.  As a result, ‘\uXXXX’ escape
sequences are only recognized when there are an odd number of
backslashes.


File: python.info,  Node: String literal concatenation,  Next: Numeric literals,  Prev: String literals,  Up: Literals

4.2.4.2 String literal concatenation
....................................

Multiple adjacent string literals (delimited by whitespace), possibly
using different quoting conventions, are allowed, and their meaning is
the same as their concatenation.  Thus, ‘"hello" 'world'’ is equivalent
to ‘"helloworld"’.  This feature can be used to reduce the number of
backslashes needed, to split long strings conveniently across long
lines, or even to add comments to parts of strings, for example:

     re.compile("[A-Za-z_]"       # letter or underscore
                "[A-Za-z0-9_]*"   # letter, digit or underscore
               )

  Note that this feature is defined at the syntactical level, but
implemented at compile time.  The ’+’ operator must be used to
concatenate string expressions at run time.  Also note that literal
concatenation can use different quoting styles for each component (even
mixing raw strings and triple quoted strings).


File: python.info,  Node: Numeric literals,  Next: Integer and long integer literals,  Prev: String literal concatenation,  Up: Literals

4.2.4.3 Numeric literals
........................

There are four types of numeric literals: plain integers, long integers,
floating point numbers, and imaginary numbers.  There are no complex
literals (complex numbers can be formed by adding a real number and an
imaginary number).

  Note that numeric literals do not include a sign; a phrase like ‘-1’
is actually an expression composed of the unary operator ’‘-’’ and the
literal ‘1’.


File: python.info,  Node: Integer and long integer literals,  Next: Floating point literals,  Prev: Numeric literals,  Up: Literals

4.2.4.4 Integer and long integer literals
.........................................

Integer and long integer literals are described by the following lexical
definitions:

     longinteger    ::= integer ("l" | "L")
     integer        ::= decimalinteger | octinteger | hexinteger | bininteger
     decimalinteger ::= nonzerodigit digit* | "0"
     octinteger     ::= "0" ("o" | "O") octdigit+ | "0" octdigit+
     hexinteger     ::= "0" ("x" | "X") hexdigit+
     bininteger     ::= "0" ("b" | "B") bindigit+
     nonzerodigit   ::= "1"..."9"
     octdigit       ::= "0"..."7"
     bindigit       ::= "0" | "1"
     hexdigit       ::= digit | "a"..."f" | "A"..."F"


  Although both lower case ‘'l'’ and upper case ‘'L'’ are allowed as
suffix for long integers, it is strongly recommended to always use
‘'L'’, since the letter ‘'l'’ looks too much like the digit ‘'1'’.

  Plain integer literals that are above the largest representable plain
integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted as
if they were long integers instead.  (1) There is no limit for long
integer literals apart from what can be stored in available memory.

  Some examples of plain integer literals (first row) and long integer
literals (second and third rows):

     7     2147483647                        0177
     3L    79228162514264337593543950336L    0377L   0x100000000L
           79228162514264337593543950336             0xdeadbeef

   ---------- Footnotes ----------

   (1) In versions of Python prior to 2.4, octal and hexadecimal
literals in the range just above the largest representable plain integer
but below the largest unsigned 32-bit number (on a machine using 32-bit
arithmetic), 4294967296, were taken as the negative plain integer
obtained by subtracting 4294967296 from their unsigned value.


File: python.info,  Node: Floating point literals,  Next: Imaginary literals,  Prev: Integer and long integer literals,  Up: Literals

4.2.4.5 Floating point literals
...............................

Floating point literals are described by the following lexical
definitions:

     floatnumber   ::= pointfloat | exponentfloat
     pointfloat    ::= [intpart] fraction | intpart "."
     exponentfloat ::= (intpart | pointfloat) exponent
     intpart       ::= digit+
     fraction      ::= "." digit+
     exponent      ::= ("e" | "E") ["+" | "-"] digit+


  Note that the integer and exponent parts of floating point numbers can
look like octal integers, but are interpreted using radix 10.  For
example, ‘077e010’ is legal, and denotes the same number as ‘77e10’.
The allowed range of floating point literals is
implementation-dependent.  Some examples of floating point literals:

     3.14    10.    .001    1e100    3.14e-10    0e0

  Note that numeric literals do not include a sign; a phrase like ‘-1’
is actually an expression composed of the unary operator ‘-’ and the
literal ‘1’.


File: python.info,  Node: Imaginary literals,  Prev: Floating point literals,  Up: Literals

4.2.4.6 Imaginary literals
..........................

Imaginary literals are described by the following lexical definitions:

     imagnumber ::= (floatnumber | intpart) ("j" | "J")


  An imaginary literal yields a complex number with a real part of 0.0.
Complex numbers are represented as a pair of floating point numbers and
have the same restrictions on their range.  To create a complex number
with a nonzero real part, add a floating point number to it, e.g.,
‘(3+4j)’.  Some examples of imaginary literals:

     3.14j   10.j    10j     .001j   1e100j  3.14e-10j


File: python.info,  Node: Operators,  Next: Delimiters,  Prev: Literals,  Up: Lexical analysis

4.2.5 Operators
---------------

The following tokens are operators:

     +       -       *       **      /       //      %
     <<      >>      &       |       ^       ~
     <       >       <=      >=      ==      !=      <>

  The comparison operators ‘<>’ and ‘!=’ are alternate spellings of the
same operator.  ‘!=’ is the preferred spelling; ‘<>’ is obsolescent.


File: python.info,  Node: Delimiters,  Prev: Operators,  Up: Lexical analysis

4.2.6 Delimiters
----------------

The following tokens serve as delimiters in the grammar:

     (       )       [       ]       {       }      @
     ,       :       .       `       =       ;
     +=      -=      *=      /=      //=     %=
     &=      |=      ^=      >>=     <<=     **=

  The period can also occur in floating-point and imaginary literals.  A
sequence of three periods has a special meaning as an ellipsis in
slices.  The second half of the list, the augmented assignment
operators, serve lexically as delimiters, but also perform an operation.

  The following printing ASCII characters have special meaning as part
of other tokens or are otherwise significant to the lexical analyzer:

     '       "       #       \

  The following printing ASCII characters are not used in Python.  Their
occurrence outside string literals and comments is an unconditional
error:

     $       ?


File: python.info,  Node: Data model,  Next: Execution model,  Prev: Lexical analysis,  Up: The Python Language Reference

4.3 Data model
==============

* Menu:

* Objects, values and types: Objects values and types. 
* The standard type hierarchy:: 
* New-style and classic classes:: 
* Special method names:: 


File: python.info,  Node: Objects values and types,  Next: The standard type hierarchy,  Up: Data model

4.3.1 Objects, values and types
-------------------------------

_Objects_ are Python’s abstraction for data.  All data in a Python
program is represented by objects or by relations between objects.  (In
a sense, and in conformance to Von Neumann’s model of a "stored program
computer," code is also represented by objects.)

  Every object has an identity, a type and a value.  An object’s
_identity_ never changes once it has been created; you may think of it
as the object’s address in memory.  The ’*note is: 6eb.’ operator
compares the identity of two objects; the *note id(): 3b2. function
returns an integer representing its identity (currently implemented as
its address).  An object’s _type_ is also unchangeable.  (1) An object’s
type determines the operations that the object supports (e.g., "does it
have a length?")  and also defines the possible values for objects of
that type.  The *note type(): 490. function returns an object’s type
(which is an object itself).  The _value_ of some objects can change.
Objects whose value can change are said to be _mutable_; objects whose
value is unchangeable once they are created are called _immutable_.
(The value of an immutable container object that contains a reference to
a mutable object can change when the latter’s value is changed; however
the container is still considered immutable, because the collection of
objects it contains cannot be changed.  So, immutability is not strictly
the same as having an unchangeable value, it is more subtle.)  An
object’s mutability is determined by its type; for instance, numbers,
strings and tuples are immutable, while dictionaries and lists are
mutable.

  Objects are never explicitly destroyed; however, when they become
unreachable they may be garbage-collected.  An implementation is allowed
to postpone garbage collection or omit it altogether — it is a matter of
implementation quality how garbage collection is implemented, as long as
no objects are collected that are still reachable.

*CPython implementation detail:* CPython currently uses a
reference-counting scheme with (optional) delayed detection of
cyclically linked garbage, which collects most objects as soon as they
become unreachable, but is not guaranteed to collect garbage containing
circular references.  See the documentation of the *note gc: db. module
for information on controlling the collection of cyclic garbage.  Other
implementations act differently and CPython may change.  Do not depend
on immediate finalization of objects when they become unreachable (ex:
always close files).

  Note that the use of the implementation’s tracing or debugging
facilities may keep objects alive that would normally be collectable.
Also note that catching an exception with a ’*note try: 395...*note
except: 397.’ statement may keep objects alive.

  Some objects contain references to "external" resources such as open
files or windows.  It is understood that these resources are freed when
the object is garbage-collected, but since garbage collection is not
guaranteed to happen, such objects also provide an explicit way to
release the external resource, usually a ‘close()’ method.  Programs are
strongly recommended to explicitly close such objects.  The ’*note try:
395...*note finally: 396.’ statement provides a convenient way to do
this.

  Some objects contain references to other objects; these are called
_containers_.  Examples of containers are tuples, lists and
dictionaries.  The references are part of a container’s value.  In most
cases, when we talk about the value of a container, we imply the values,
not the identities of the contained objects; however, when we talk about
the mutability of a container, only the identities of the immediately
contained objects are implied.  So, if an immutable container (like a
tuple) contains a reference to a mutable object, its value changes if
that mutable object is changed.

  Types affect almost all aspects of object behavior.  Even the
importance of object identity is affected in some sense: for immutable
types, operations that compute new values may actually return a
reference to any existing object with the same type and value, while for
mutable objects this is not allowed.  E.g., after ‘a = 1; b = 1’, ‘a’
and ‘b’ may or may not refer to the same object with the value one,
depending on the implementation, but after ‘c = []; d = []’, ‘c’ and ‘d’
are guaranteed to refer to two different, unique, newly created empty
lists.  (Note that ‘c = d = []’ assigns the same object to both ‘c’ and
‘d’.)

   ---------- Footnotes ----------

   (1) It _is_ possible in some cases to change an object’s type, under
certain controlled conditions.  It generally isn’t a good idea though,
since it can lead to some very strange behaviour if it is handled
incorrectly.


File: python.info,  Node: The standard type hierarchy,  Next: New-style and classic classes,  Prev: Objects values and types,  Up: Data model

4.3.2 The standard type hierarchy
---------------------------------

Below is a list of the types that are built into Python.  Extension
modules (written in C, Java, or other languages, depending on the
implementation) can define additional types.  Future versions of Python
may add types to the type hierarchy (e.g., rational numbers, efficiently
stored arrays of integers, etc.).

  Some of the type descriptions below contain a paragraph listing
’special attributes.’ These are attributes that provide access to the
implementation and are not intended for general use.  Their definition
may change in the future.

None

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the built-in name ‘None’.
     It is used to signify the absence of a value in many situations,
     e.g., it is returned from functions that don’t explicitly return
     anything.  Its truth value is false.

NotImplemented

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the built-in name
     ‘NotImplemented’.  Numeric methods and rich comparison methods may
     return this value if they do not implement the operation for the
     operands provided.  (The interpreter will then try the reflected
     operation, or some other fallback, depending on the operator.)  Its
     truth value is true.

Ellipsis

     This type has a single value.  There is a single object with this
     value.  This object is accessed through the built-in name
     ‘Ellipsis’.  It is used to indicate the presence of the ‘...’
     syntax in a slice.  Its truth value is true.

*note numbers.Number: 6ee.

     These are created by numeric literals and returned as results by
     arithmetic operators and arithmetic built-in functions.  Numeric
     objects are immutable; once created their value never changes.
     Python numbers are of course strongly related to mathematical
     numbers, but subject to the limitations of numerical representation
     in computers.

     Python distinguishes between integers, floating point numbers, and
     complex numbers:

     *note numbers.Integral: 6ef.

          These represent elements from the mathematical set of integers
          (positive and negative).

          There are three types of integers:

          Plain integers

               These represent numbers in the range -2147483648 through
               2147483647.  (The range may be larger on machines with a
               larger natural word size, but not smaller.)  When the
               result of an operation would fall outside this range, the
               result is normally returned as a long integer (in some
               cases, the exception *note OverflowError: 2db. is raised
               instead).  For the purpose of shift and mask operations,
               integers are assumed to have a binary, 2’s complement
               notation using 32 or more bits, and hiding no bits from
               the user (i.e., all 4294967296 different bit patterns
               correspond to different values).

          Long integers

               These represent numbers in an unlimited range, subject to
               available (virtual) memory only.  For the purpose of
               shift and mask operations, a binary representation is
               assumed, and negative numbers are represented in a
               variant of 2’s complement which gives the illusion of an
               infinite string of sign bits extending to the left.

          Booleans

               These represent the truth values False and True.  The two
               objects representing the values ‘False’ and ‘True’ are
               the only Boolean objects.  The Boolean type is a subtype
               of plain integers, and Boolean values behave like the
               values 0 and 1, respectively, in almost all contexts, the
               exception being that when converted to a string, the
               strings ‘"False"’ or ‘"True"’ are returned, respectively.

          The rules for integer representation are intended to give the
          most meaningful interpretation of shift and mask operations
          involving negative integers and the least surprises when
          switching between the plain and long integer domains.  Any
          operation, if it yields a result in the plain integer domain,
          will yield the same result in the long integer domain or when
          using mixed operands.  The switch between domains is
          transparent to the programmer.

     *note numbers.Real: 6f0. (*note float: 1eb.)

          These represent machine-level double precision floating point
          numbers.  You are at the mercy of the underlying machine
          architecture (and C or Java implementation) for the accepted
          range and handling of overflow.  Python does not support
          single-precision floating point numbers; the savings in
          processor and memory usage that are usually the reason for
          using these is dwarfed by the overhead of using objects in
          Python, so there is no reason to complicate the language with
          two kinds of floating point numbers.

     *note numbers.Complex: 6f1.

          These represent complex numbers as a pair of machine-level
          double precision floating point numbers.  The same caveats
          apply as for floating point numbers.  The real and imaginary
          parts of a complex number ‘z’ can be retrieved through the
          read-only attributes ‘z.real’ and ‘z.imag’.

Sequences

     These represent finite ordered sets indexed by non-negative
     numbers.  The built-in function *note len(): 520. returns the
     number of items of a sequence.  When the length of a sequence is
     _n_, the index set contains the numbers 0, 1, ..., _n_-1.  Item _i_
     of sequence _a_ is selected by ‘a[i]’.

     Sequences also support slicing: ‘a[i:j]’ selects all items with
     index _k_ such that _i_ ‘<=’ _k_ ‘<’ _j_.  When used as an
     expression, a slice is a sequence of the same type.  This implies
     that the index set is renumbered so that it starts at 0.

     Some sequences also support "extended slicing" with a third "step"
     parameter: ‘a[i:j:k]’ selects all items of _a_ with index _x_ where
     ‘x = i + n*k’, _n_ ‘>=’ ‘0’ and _i_ ‘<=’ _x_ ‘<’ _j_.

     Sequences are distinguished according to their mutability:

     Immutable sequences

          An object of an immutable sequence type cannot change once it
          is created.  (If the object contains references to other
          objects, these other objects may be mutable and may be
          changed; however, the collection of objects directly
          referenced by an immutable object cannot change.)

          The following types are immutable sequences:

          Strings

               The items of a string are characters.  There is no
               separate character type; a character is represented by a
               string of one item.  Characters represent (at least)
               8-bit bytes.  The built-in functions *note chr(): 6f2.
               and *note ord(): 6f3. convert between characters and
               nonnegative integers representing the byte values.  Bytes
               with the values 0-127 usually represent the corresponding
               ASCII values, but the interpretation of values is up to
               the program.  The string data type is also used to
               represent arrays of bytes, e.g., to hold data read from a
               file.

               (On systems whose native character set is not ASCII,
               strings may use EBCDIC in their internal representation,
               provided the functions *note chr(): 6f2. and *note ord():
               6f3. implement a mapping between ASCII and EBCDIC, and
               string comparison preserves the ASCII order.  Or perhaps
               someone can propose a better rule?)

          Unicode

               The items of a Unicode object are Unicode code units.  A
               Unicode code unit is represented by a Unicode object of
               one item and can hold either a 16-bit or 32-bit value
               representing a Unicode ordinal (the maximum value for the
               ordinal is given in ‘sys.maxunicode’, and depends on how
               Python is configured at compile time).  Surrogate pairs
               may be present in the Unicode object, and will be
               reported as two separate items.  The built-in functions
               *note unichr(): 495. and *note ord(): 6f3. convert
               between code units and nonnegative integers representing
               the Unicode ordinals as defined in the Unicode Standard
               3.0.  Conversion from and to other encodings are possible
               through the Unicode method ‘encode()’ and the built-in
               function *note unicode(): 1f5.

          Tuples

               The items of a tuple are arbitrary Python objects.
               Tuples of two or more items are formed by comma-separated
               lists of expressions.  A tuple of one item (a
               ’singleton’) can be formed by affixing a comma to an
               expression (an expression by itself does not create a
               tuple, since parentheses must be usable for grouping of
               expressions).  An empty tuple can be formed by an empty
               pair of parentheses.

     Mutable sequences

          Mutable sequences can be changed after they are created.  The
          subscription and slicing notations can be used as the target
          of assignment and *note del: 568. (delete) statements.

          There are currently two intrinsic mutable sequence types:

          Lists

               The items of a list are arbitrary Python objects.  Lists
               are formed by placing a comma-separated list of
               expressions in square brackets.  (Note that there are no
               special cases needed to form lists of length 0 or 1.)

          Byte Arrays

               A bytearray object is a mutable array.  They are created
               by the built-in *note bytearray(): 1f7. constructor.
               Aside from being mutable (and hence unhashable), byte
               arrays otherwise provide the same interface and
               functionality as immutable bytes objects.

          The extension module *note array: e. provides an additional
          example of a mutable sequence type.

Set types

     These represent unordered, finite sets of unique, immutable
     objects.  As such, they cannot be indexed by any subscript.
     However, they can be iterated over, and the built-in function *note
     len(): 520. returns the number of items in a set.  Common uses for
     sets are fast membership testing, removing duplicates from a
     sequence, and computing mathematical operations such as
     intersection, union, difference, and symmetric difference.

     For set elements, the same immutability rules apply as for
     dictionary keys.  Note that numeric types obey the normal rules for
     numeric comparison: if two numbers compare equal (e.g., ‘1’ and
     ‘1.0’), only one of them can be contained in a set.

     There are currently two intrinsic set types:

     Sets

          These represent a mutable set.  They are created by the
          built-in *note set(): 36a. constructor and can be modified
          afterwards by several methods, such as *note add(): 6f4.

     Frozen sets

          These represent an immutable set.  They are created by the
          built-in *note frozenset(): 36b. constructor.  As a frozenset
          is immutable and *note hashable: 6f5, it can be used again as
          an element of another set, or as a dictionary key.

Mappings

     These represent finite sets of objects indexed by arbitrary index
     sets.  The subscript notation ‘a[k]’ selects the item indexed by
     ‘k’ from the mapping ‘a’; this can be used in expressions and as
     the target of assignments or *note del: 568. statements.  The
     built-in function *note len(): 520. returns the number of items in
     a mapping.

     There is currently a single intrinsic mapping type:

     Dictionaries

          These represent finite sets of objects indexed by nearly
          arbitrary values.  The only types of values not acceptable as
          keys are values containing lists or dictionaries or other
          mutable types that are compared by value rather than by object
          identity, the reason being that the efficient implementation
          of dictionaries requires a key’s hash value to remain
          constant.  Numeric types used for keys obey the normal rules
          for numeric comparison: if two numbers compare equal (e.g.,
          ‘1’ and ‘1.0’) then they can be used interchangeably to index
          the same dictionary entry.

          Dictionaries are mutable; they can be created by the ‘{...}’
          notation (see section *note Dictionary displays: 6f6.).

          The extension modules *note dbm: 7f, *note gdbm: dc, and *note
          bsddb: 1c. provide additional examples of mapping types.

Callable types

     These are the types to which the function call operation (see
     section *note Calls: 6f7.) can be applied:

     User-defined functions

          A user-defined function object is created by a function
          definition (see section *note Function definitions: 6f8.).  It
          should be called with an argument list containing the same
          number of items as the function’s formal parameter list.

          Special attributes:

          Attribute                   Meaning
                                      
          --------------------------------------------------------------------------------
                                                                          
          ‘__doc__’ ‘func_doc’        The function’s documentation        Writable
                                      string, or ‘None’ if unavailable.   
                                      
                                                                          
          ‘__name__’ ‘func_name’      The function’s name.                Writable
                                                                          
                                                                          
          ‘__module__’                The name of the module the          Writable
                                      function was defined in, or         
                                      ‘None’ if unavailable.
                                      
                                                                          
          ‘__defaults__’              A tuple containing default          Writable
          ‘func_defaults’             argument values for those           
                                      arguments that have defaults, or
                                      ‘None’ if no arguments have a
                                      default value.
                                      
                                                                          
          ‘__code__’ ‘func_code’      The code object representing the    Writable
                                      compiled function body.             
                                      
                                                                          
          ‘__globals__’               A reference to the dictionary       Read-only
          ‘func_globals’              that holds the function’s global    
                                      variables — the global namespace
                                      of the module in which the
                                      function was defined.
                                      
                                                                          
          ‘__dict__’ ‘func_dict’      The namespace supporting            Writable
                                      arbitrary function attributes.      
                                      
                                                                          
          ‘__closure__’               ‘None’ or a tuple of cells that     Read-only
          ‘func_closure’              contain bindings for the            
                                      function’s free variables.
                                      

          Most of the attributes labelled "Writable" check the type of
          the assigned value.

          Changed in version 2.4: ‘func_name’ is now writable.

          Changed in version 2.6: The double-underscore attributes
          ‘__closure__’, ‘__code__’, ‘__defaults__’, and ‘__globals__’
          were introduced as aliases for the corresponding ‘func_*’
          attributes for forwards compatibility with Python 3.

          Function objects also support getting and setting arbitrary
          attributes, which can be used, for example, to attach metadata
          to functions.  Regular attribute dot-notation is used to get
          and set such attributes.  _Note that the current
          implementation only supports function attributes on
          user-defined functions.  Function attributes on built-in
          functions may be supported in the future._

          Additional information about a function’s definition can be
          retrieved from its code object; see the description of
          internal types below.

     User-defined methods

          A user-defined method object combines a class, a class
          instance (or ‘None’) and any callable object (normally a
          user-defined function).

          Special read-only attributes: ‘im_self’ is the class instance
          object, ‘im_func’ is the function object; ‘im_class’ is the
          class of ‘im_self’ for bound methods or the class that asked
          for the method for unbound methods; ‘__doc__’ is the method’s
          documentation (same as ‘im_func.__doc__’); ‘__name__’ is the
          method name (same as ‘im_func.__name__’); ‘__module__’ is the
          name of the module the method was defined in, or ‘None’ if
          unavailable.

          Changed in version 2.2: ‘im_self’ used to refer to the class
          that defined the method.

          Changed in version 2.6: For Python 3 forward-compatibility,
          ‘im_func’ is also available as ‘__func__’, and ‘im_self’ as
          ‘__self__’.

          Methods also support accessing (but not setting) the arbitrary
          function attributes on the underlying function object.

          User-defined method objects may be created when getting an
          attribute of a class (perhaps via an instance of that class),
          if that attribute is a user-defined function object, an
          unbound user-defined method object, or a class method object.
          When the attribute is a user-defined method object, a new
          method object is only created if the class from which it is
          being retrieved is the same as, or a derived class of, the
          class stored in the original method object; otherwise, the
          original method object is used as it is.

          When a user-defined method object is created by retrieving a
          user-defined function object from a class, its ‘im_self’
          attribute is ‘None’ and the method object is said to be
          unbound.  When one is created by retrieving a user-defined
          function object from a class via one of its instances, its
          ‘im_self’ attribute is the instance, and the method object is
          said to be bound.  In either case, the new method’s ‘im_class’
          attribute is the class from which the retrieval takes place,
          and its ‘im_func’ attribute is the original function object.

          When a user-defined method object is created by retrieving
          another method object from a class or instance, the behaviour
          is the same as for a function object, except that the
          ‘im_func’ attribute of the new instance is not the original
          method object but its ‘im_func’ attribute.

          When a user-defined method object is created by retrieving a
          class method object from a class or instance, its ‘im_self’
          attribute is the class itself, and its ‘im_func’ attribute is
          the function object underlying the class method.

          When an unbound user-defined method object is called, the
          underlying function (‘im_func’) is called, with the
          restriction that the first argument must be an instance of the
          proper class (‘im_class’) or of a derived class thereof.

          When a bound user-defined method object is called, the
          underlying function (‘im_func’) is called, inserting the class
          instance (‘im_self’) in front of the argument list.  For
          instance, when ‘C’ is a class which contains a definition for
          a function ‘f()’, and ‘x’ is an instance of ‘C’, calling
          ‘x.f(1)’ is equivalent to calling ‘C.f(x, 1)’.

          When a user-defined method object is derived from a class
          method object, the "class instance" stored in ‘im_self’ will
          actually be the class itself, so that calling either ‘x.f(1)’
          or ‘C.f(1)’ is equivalent to calling ‘f(C,1)’ where ‘f’ is the
          underlying function.

          Note that the transformation from function object to (unbound
          or bound) method object happens each time the attribute is
          retrieved from the class or instance.  In some cases, a
          fruitful optimization is to assign the attribute to a local
          variable and call that local variable.  Also notice that this
          transformation only happens for user-defined functions; other
          callable objects (and all non-callable objects) are retrieved
          without transformation.  It is also important to note that
          user-defined functions which are attributes of a class
          instance are not converted to bound methods; this _only_
          happens when the function is an attribute of the class.

     Generator functions

          A function or method which uses the *note yield: 2f7.
          statement (see section *note The yield statement: 2f7.) is
          called a _generator function_.  Such a function, when called,
          always returns an iterator object which can be used to execute
          the body of the function: calling the iterator’s *note next():
          5d9. method will cause the function to execute until it
          provides a value using the *note yield: 2f7. statement.  When
          the function executes a *note return: 2f4. statement or falls
          off the end, a *note StopIteration: 333. exception is raised
          and the iterator will have reached the end of the set of
          values to be returned.

     Built-in functions

          A built-in function object is a wrapper around a C function.
          Examples of built-in functions are *note len(): 520. and *note
          math.sin(): 45e. (*note math: 10c. is a standard built-in
          module).  The number and type of the arguments are determined
          by the C function.  Special read-only attributes: ‘__doc__’ is
          the function’s documentation string, or ‘None’ if unavailable;
          ‘__name__’ is the function’s name; ‘__self__’ is set to ‘None’
          (but see the next item); ‘__module__’ is the name of the
          module the function was defined in or ‘None’ if unavailable.

     Built-in methods

          This is really a different disguise of a built-in function,
          this time containing an object passed to the C function as an
          implicit extra argument.  An example of a built-in method is
          ‘alist.append()’, assuming _alist_ is a list object.  In this
          case, the special read-only attribute ‘__self__’ is set to the
          object denoted by _alist_.

     Class Types

          Class types, or "new-style classes," are callable.  These
          objects normally act as factories for new instances of
          themselves, but variations are possible for class types that
          override *note __new__(): 6f9.  The arguments of the call are
          passed to *note __new__(): 6f9. and, in the typical case, to
          *note __init__(): 37c. to initialize the new instance.

     Classic Classes

          Class objects are described below.  When a class object is
          called, a new class instance (also described below) is created
          and returned.  This implies a call to the class’s *note
          __init__(): 37c. method if it has one.  Any arguments are
          passed on to the *note __init__(): 37c. method.  If there is
          no *note __init__(): 37c. method, the class must be called
          without arguments.

     Class instances

          Class instances are described below.  Class instances are
          callable only when the class has a *note __call__(): 6fa.
          method; ‘x(arguments)’ is a shorthand for
          ‘x.__call__(arguments)’.

Modules

     Modules are imported by the *note import: 1f4. statement (see
     section *note The import statement: 1f4.).  A module object has a
     namespace implemented by a dictionary object (this is the
     dictionary referenced by the func_globals attribute of functions
     defined in the module).  Attribute references are translated to
     lookups in this dictionary, e.g., ‘m.x’ is equivalent to
     ‘m.__dict__["x"]’.  A module object does not contain the code
     object used to initialize the module (since it isn’t needed once
     the initialization is done).

     Attribute assignment updates the module’s namespace dictionary,
     e.g., ‘m.x = 1’ is equivalent to ‘m.__dict__["x"] = 1’.

     Special read-only attribute: ‘__dict__’ is the module’s namespace
     as a dictionary object.

     *CPython implementation detail:* Because of the way CPython clears
     module dictionaries, the module dictionary will be cleared when the
     module falls out of scope even if the dictionary still has live
     references.  To avoid this, copy the dictionary or keep the module
     around while using its dictionary directly.

     Predefined (writable) attributes: ‘__name__’ is the module’s name;
     ‘__doc__’ is the module’s documentation string, or ‘None’ if
     unavailable; ‘__file__’ is the pathname of the file from which the
     module was loaded, if it was loaded from a file.  The ‘__file__’
     attribute is not present for C modules that are statically linked
     into the interpreter; for extension modules loaded dynamically from
     a shared library, it is the pathname of the shared library file.

Classes

     Both class types (new-style classes) and class objects
     (old-style/classic classes) are typically created by class
     definitions (see section *note Class definitions: 33d.).  A class
     has a namespace implemented by a dictionary object.  Class
     attribute references are translated to lookups in this dictionary,
     e.g., ‘C.x’ is translated to ‘C.__dict__["x"]’ (although for
     new-style classes in particular there are a number of hooks which
     allow for other means of locating attributes).  When the attribute
     name is not found there, the attribute search continues in the base
     classes.  For old-style classes, the search is depth-first,
     left-to-right in the order of occurrence in the base class list.
     New-style classes use the more complex C3 method resolution order
     which behaves correctly even in the presence of ’diamond’
     inheritance structures where there are multiple inheritance paths
     leading back to a common ancestor.  Additional details on the C3
     MRO used by new-style classes can be found in the documentation
     accompanying the 2.3 release at
     ‘http://www.python.org/download/releases/2.3/mro/’.

     When a class attribute reference (for class ‘C’, say) would yield a
     user-defined function object or an unbound user-defined method
     object whose associated class is either ‘C’ or one of its base
     classes, it is transformed into an unbound user-defined method
     object whose ‘im_class’ attribute is ‘C’.  When it would yield a
     class method object, it is transformed into a bound user-defined
     method object whose ‘im_self’ attribute is ‘C’.  When it would
     yield a static method object, it is transformed into the object
     wrapped by the static method object.  See section *note
     Implementing Descriptors: 6fb. for another way in which attributes
     retrieved from a class may differ from those actually contained in
     its ‘__dict__’ (note that only new-style classes support
     descriptors).

     Class attribute assignments update the class’s dictionary, never
     the dictionary of a base class.

     A class object can be called (see above) to yield a class instance
     (see below).

     Special attributes: ‘__name__’ is the class name; ‘__module__’ is
     the module name in which the class was defined; ‘__dict__’ is the
     dictionary containing the class’s namespace; *note __bases__: 6fc.
     is a tuple (possibly empty or a singleton) containing the base
     classes, in the order of their occurrence in the base class list;
     ‘__doc__’ is the class’s documentation string, or None if
     undefined.

Class instances

     A class instance is created by calling a class object (see above).
     A class instance has a namespace implemented as a dictionary which
     is the first place in which attribute references are searched.
     When an attribute is not found there, and the instance’s class has
     an attribute by that name, the search continues with the class
     attributes.  If a class attribute is found that is a user-defined
     function object or an unbound user-defined method object whose
     associated class is the class (call it ‘C’) of the instance for
     which the attribute reference was initiated or one of its bases, it
     is transformed into a bound user-defined method object whose
     ‘im_class’ attribute is ‘C’ and whose ‘im_self’ attribute is the
     instance.  Static method and class method objects are also
     transformed, as if they had been retrieved from class ‘C’; see
     above under "Classes".  See section *note Implementing Descriptors:
     6fb. for another way in which attributes of a class retrieved via
     its instances may differ from the objects actually stored in the
     class’s ‘__dict__’.  If no class attribute is found, and the
     object’s class has a *note __getattr__(): 331. method, that is
     called to satisfy the lookup.

     Attribute assignments and deletions update the instance’s
     dictionary, never a class’s dictionary.  If the class has a *note
     __setattr__(): 488. or *note __delattr__(): 6fd. method, this is
     called instead of updating the instance dictionary directly.

     Class instances can pretend to be numbers, sequences, or mappings
     if they have methods with certain special names.  See section *note
     Special method names: 6b8.

     Special attributes: *note __dict__: 6fe. is the attribute
     dictionary; *note __class__: 6ff. is the instance’s class.

Files

     A file object represents an open file.  File objects are created by
     the *note open(): 2d6. built-in function, and also by *note
     os.popen(): 700, *note os.fdopen(): 701, and the ‘makefile()’
     method of socket objects (and perhaps by other functions or methods
     provided by extension modules).  The objects ‘sys.stdin’,
     ‘sys.stdout’ and ‘sys.stderr’ are initialized to file objects
     corresponding to the interpreter’s standard input, output and error
     streams.  See *note File Objects: 643. for complete documentation
     of file objects.

Internal types

     A few types used internally by the interpreter are exposed to the
     user.  Their definitions may change with future versions of the
     interpreter, but they are mentioned here for completeness.

     Code objects

          Code objects represent _byte-compiled_ executable Python code,
          or *note bytecode: 583.  The difference between a code object
          and a function object is that the function object contains an
          explicit reference to the function’s globals (the module in
          which it was defined), while a code object contains no
          context; also the default argument values are stored in the
          function object, not in the code object (because they
          represent values calculated at run-time).  Unlike function
          objects, code objects are immutable and contain no references
          (directly or indirectly) to mutable objects.

          Special read-only attributes: ‘co_name’ gives the function
          name; ‘co_argcount’ is the number of positional arguments
          (including arguments with default values); ‘co_nlocals’ is the
          number of local variables used by the function (including
          arguments); ‘co_varnames’ is a tuple containing the names of
          the local variables (starting with the argument names);
          ‘co_cellvars’ is a tuple containing the names of local
          variables that are referenced by nested functions;
          ‘co_freevars’ is a tuple containing the names of free
          variables; ‘co_code’ is a string representing the sequence of
          bytecode instructions; ‘co_consts’ is a tuple containing the
          literals used by the bytecode; ‘co_names’ is a tuple
          containing the names used by the bytecode; ‘co_filename’ is
          the filename from which the code was compiled;
          ‘co_firstlineno’ is the first line number of the function;
          ‘co_lnotab’ is a string encoding the mapping from bytecode
          offsets to line numbers (for details see the source code of
          the interpreter); ‘co_stacksize’ is the required stack size
          (including local variables); ‘co_flags’ is an integer encoding
          a number of flags for the interpreter.

          The following flag bits are defined for ‘co_flags’: bit ‘0x04’
          is set if the function uses the ‘*arguments’ syntax to accept
          an arbitrary number of positional arguments; bit ‘0x08’ is set
          if the function uses the ‘**keywords’ syntax to accept
          arbitrary keyword arguments; bit ‘0x20’ is set if the function
          is a generator.

          Future feature declarations (‘from __future__ import
          division’) also use bits in ‘co_flags’ to indicate whether a
          code object was compiled with a particular feature enabled:
          bit ‘0x2000’ is set if the function was compiled with future
          division enabled; bits ‘0x10’ and ‘0x1000’ were used in
          earlier versions of Python.

          Other bits in ‘co_flags’ are reserved for internal use.

          If a code object represents a function, the first item in
          ‘co_consts’ is the documentation string of the function, or
          ‘None’ if undefined.

     Frame objects

          Frame objects represent execution frames.  They may occur in
          traceback objects (see below).

          Special read-only attributes: ‘f_back’ is to the previous
          stack frame (towards the caller), or ‘None’ if this is the
          bottom stack frame; ‘f_code’ is the code object being executed
          in this frame; ‘f_locals’ is the dictionary used to look up
          local variables; ‘f_globals’ is used for global variables;
          ‘f_builtins’ is used for built-in (intrinsic) names;
          ‘f_restricted’ is a flag indicating whether the function is
          executing in restricted execution mode; ‘f_lasti’ gives the
          precise instruction (this is an index into the bytecode string
          of the code object).

          Special writable attributes: ‘f_trace’, if not ‘None’, is a
          function called at the start of each source code line (this is
          used by the debugger); ‘f_exc_type’, ‘f_exc_value’,
          ‘f_exc_traceback’ represent the last exception raised in the
          parent frame provided another exception was ever raised in the
          current frame (in all other cases they are None); ‘f_lineno’
          is the current line number of the frame — writing to this from
          within a trace function jumps to the given line (only for the
          bottom-most frame).  A debugger can implement a Jump command
          (aka Set Next Statement) by writing to f_lineno.

     Traceback objects

          Traceback objects represent a stack trace of an exception.  A
          traceback object is created when an exception occurs.  When
          the search for an exception handler unwinds the execution
          stack, at each unwound level a traceback object is inserted in
          front of the current traceback.  When an exception handler is
          entered, the stack trace is made available to the program.
          (See section *note The try statement: 395.)  It is accessible
          as ‘sys.exc_traceback’, and also as the third item of the
          tuple returned by ‘sys.exc_info()’.  The latter is the
          preferred interface, since it works correctly when the program
          is using multiple threads.  When the program contains no
          suitable handler, the stack trace is written (nicely
          formatted) to the standard error stream; if the interpreter is
          interactive, it is also made available to the user as
          ‘sys.last_traceback’.

          Special read-only attributes: ‘tb_next’ is the next level in
          the stack trace (towards the frame where the exception
          occurred), or ‘None’ if there is no next level; ‘tb_frame’
          points to the execution frame of the current level;
          ‘tb_lineno’ gives the line number where the exception
          occurred; ‘tb_lasti’ indicates the precise instruction.  The
          line number and last instruction in the traceback may differ
          from the line number of its frame object if the exception
          occurred in a *note try: 395. statement with no matching
          except clause or with a finally clause.

     Slice objects

          Slice objects are used to represent slices when _extended
          slice syntax_ is used.  This is a slice using two colons, or
          multiple slices or ellipses separated by commas, e.g.,
          ‘a[i:j:step]’, ‘a[i:j, k:l]’, or ‘a[..., i:j]’.  They are also
          created by the built-in *note slice(): 450. function.

          Special read-only attributes: ‘start’ is the lower bound;
          ‘stop’ is the upper bound; ‘step’ is the step value; each is
          ‘None’ if omitted.  These attributes can have any type.

          Slice objects support one method:

           -- Method: slice.indices (self, length)

               This method takes a single integer argument _length_ and
               computes information about the extended slice that the
               slice object would describe if applied to a sequence of
               _length_ items.  It returns a tuple of three integers;
               respectively these are the _start_ and _stop_ indices and
               the _step_ or stride length of the slice.  Missing or
               out-of-bounds indices are handled in a manner consistent
               with regular slices.

               New in version 2.3.

     Static method objects

          Static method objects provide a way of defeating the
          transformation of function objects to method objects described
          above.  A static method object is a wrapper around any other
          object, usually a user-defined method object.  When a static
          method object is retrieved from a class or a class instance,
          the object actually returned is the wrapped object, which is
          not subject to any further transformation.  Static method
          objects are not themselves callable, although the objects they
          wrap usually are.  Static method objects are created by the
          built-in *note staticmethod(): 3f5. constructor.

     Class method objects

          A class method object, like a static method object, is a
          wrapper around another object that alters the way in which
          that object is retrieved from classes and class instances.
          The behaviour of class method objects upon such retrieval is
          described above, under "User-defined methods".  Class method
          objects are created by the built-in *note classmethod(): 3f6.
          constructor.


File: python.info,  Node: New-style and classic classes,  Next: Special method names,  Prev: The standard type hierarchy,  Up: Data model

4.3.3 New-style and classic classes
-----------------------------------

Classes and instances come in two flavors: old-style (or classic) and
new-style.

  Up to Python 2.1, old-style classes were the only flavour available to
the user.  The concept of (old-style) class is unrelated to the concept
of type: if _x_ is an instance of an old-style class, then ‘x.__class__’
designates the class of _x_, but ‘type(x)’ is always ‘<type
'instance'>’.  This reflects the fact that all old-style instances,
independently of their class, are implemented with a single built-in
type, called ‘instance’.

  New-style classes were introduced in Python 2.2 to unify classes and
types.  A new-style class is neither more nor less than a user-defined
type.  If _x_ is an instance of a new-style class, then ‘type(x)’ is
typically the same as ‘x.__class__’ (although this is not guaranteed - a
new-style class instance is permitted to override the value returned for
‘x.__class__’).

  The major motivation for introducing new-style classes is to provide a
unified object model with a full meta-model.  It also has a number of
practical benefits, like the ability to subclass most built-in types, or
the introduction of "descriptors", which enable computed properties.

  For compatibility reasons, classes are still old-style by default.
New-style classes are created by specifying another new-style class
(i.e.  a type) as a parent class, or the "top-level type" *note object:
1f1. if no other parent is needed.  The behaviour of new-style classes
differs from that of old-style classes in a number of important details
in addition to what *note type(): 490. returns.  Some of these changes
are fundamental to the new object model, like the way special methods
are invoked.  Others are "fixes" that could not be implemented before
for compatibility concerns, like the method resolution order in case of
multiple inheritance.

  While this manual aims to provide comprehensive coverage of Python’s
class mechanics, it may still be lacking in some areas when it comes to
its coverage of new-style classes.  Please see
‘http://www.python.org/doc/newstyle/’ for sources of additional
information.

  Old-style classes are removed in Python 3, leaving only the semantics
of new-style classes.


File: python.info,  Node: Special method names,  Prev: New-style and classic classes,  Up: Data model

4.3.4 Special method names
--------------------------

A class can implement certain operations that are invoked by special
syntax (such as arithmetic operations or subscripting and slicing) by
defining methods with special names.  This is Python’s approach to
_operator overloading_, allowing classes to define their own behavior
with respect to language operators.  For instance, if a class defines a
method named *note __getitem__(): 44f, and ‘x’ is an instance of this
class, then ‘x[i]’ is roughly equivalent to ‘x.__getitem__(i)’ for
old-style classes and ‘type(x).__getitem__(x, i)’ for new-style classes.
Except where mentioned, attempts to execute an operation raise an
exception when no appropriate method is defined (typically *note
AttributeError: 1f8. or *note TypeError: 218.).

  When implementing a class that emulates any built-in type, it is
important that the emulation only be implemented to the degree that it
makes sense for the object being modelled.  For example, some sequences
may work well with retrieval of individual elements, but extracting a
slice may not make sense.  (One example of this is the ‘NodeList’
interface in the W3C’s Document Object Model.)

* Menu:

* Basic customization:: 
* Customizing attribute access:: 
* Customizing class creation:: 
* Customizing instance and subclass checks:: 
* Emulating callable objects:: 
* Emulating container types:: 
* Additional methods for emulation of sequence types:: 
* Emulating numeric types:: 
* Coercion rules:: 
* With Statement Context Managers:: 
* Special method lookup for old-style classes:: 
* Special method lookup for new-style classes:: 


File: python.info,  Node: Basic customization,  Next: Customizing attribute access,  Up: Special method names

4.3.4.1 Basic customization
...........................

 -- Method: object.__new__ (cls[, ...])

     Called to create a new instance of class _cls_.  *note __new__():
     6f9. is a static method (special-cased so you need not declare it
     as such) that takes the class of which an instance was requested as
     its first argument.  The remaining arguments are those passed to
     the object constructor expression (the call to the class).  The
     return value of *note __new__(): 6f9. should be the new object
     instance (usually an instance of _cls_).

     Typical implementations create a new instance of the class by
     invoking the superclass’s *note __new__(): 6f9. method using
     ‘super(currentclass, cls).__new__(cls[, ...])’ with appropriate
     arguments and then modifying the newly-created instance as
     necessary before returning it.

     If *note __new__(): 6f9. returns an instance of _cls_, then the new
     instance’s *note __init__(): 37c. method will be invoked like
     ‘__init__(self[, ...])’, where _self_ is the new instance and the
     remaining arguments are the same as were passed to *note __new__():
     6f9.

     If *note __new__(): 6f9. does not return an instance of _cls_, then
     the new instance’s *note __init__(): 37c. method will not be
     invoked.

     *note __new__(): 6f9. is intended mainly to allow subclasses of
     immutable types (like int, str, or tuple) to customize instance
     creation.  It is also commonly overridden in custom metaclasses in
     order to customize class creation.

 -- Method: object.__init__ (self[, ...])

     Called when the instance is created.  The arguments are those
     passed to the class constructor expression.  If a base class has an
     *note __init__(): 37c. method, the derived class’s *note
     __init__(): 37c. method, if any, must explicitly call it to ensure
     proper initialization of the base class part of the instance; for
     example: ‘BaseClass.__init__(self, [args...])’.  As a special
     constraint on constructors, no value may be returned; doing so will
     cause a *note TypeError: 218. to be raised at runtime.

 -- Method: object.__del__ (self)

     Called when the instance is about to be destroyed.  This is also
     called a destructor.  If a base class has a *note __del__(): 709.
     method, the derived class’s *note __del__(): 709. method, if any,
     must explicitly call it to ensure proper deletion of the base class
     part of the instance.  Note that it is possible (though not
     recommended!)  for the *note __del__(): 709. method to postpone
     destruction of the instance by creating a new reference to it.  It
     may then be called at a later time when this new reference is
     deleted.  It is not guaranteed that *note __del__(): 709. methods
     are called for objects that still exist when the interpreter exits.

          Note: ‘del x’ doesn’t directly call ‘x.__del__()’ — the former
          decrements the reference count for ‘x’ by one, and the latter
          is only called when ‘x’’s reference count reaches zero.  Some
          common situations that may prevent the reference count of an
          object from going to zero include: circular references between
          objects (e.g., a doubly-linked list or a tree data structure
          with parent and child pointers); a reference to the object on
          the stack frame of a function that caught an exception (the
          traceback stored in ‘sys.exc_traceback’ keeps the stack frame
          alive); or a reference to the object on the stack frame that
          raised an unhandled exception in interactive mode (the
          traceback stored in ‘sys.last_traceback’ keeps the stack frame
          alive).  The first situation can only be remedied by
          explicitly breaking the cycles; the latter two situations can
          be resolved by storing ‘None’ in ‘sys.exc_traceback’ or
          ‘sys.last_traceback’.  Circular references which are garbage
          are detected when the option cycle detector is enabled (it’s
          on by default), but can only be cleaned up if there are no
          Python-level *note __del__(): 709. methods involved.  Refer to
          the documentation for the *note gc: db. module for more
          information about how *note __del__(): 709. methods are
          handled by the cycle detector, particularly the description of
          the ‘garbage’ value.

          Warning: Due to the precarious circumstances under which *note
          __del__(): 709. methods are invoked, exceptions that occur
          during their execution are ignored, and a warning is printed
          to ‘sys.stderr’ instead.  Also, when *note __del__(): 709. is
          invoked in response to a module being deleted (e.g., when
          execution of the program is done), other globals referenced by
          the *note __del__(): 709. method may already have been deleted
          or in the process of being torn down (e.g.  the import
          machinery shutting down).  For this reason, *note __del__():
          709. methods should do the absolute minimum needed to maintain
          external invariants.  Starting with version 1.5, Python
          guarantees that globals whose name begins with a single
          underscore are deleted from their module before other globals
          are deleted; if no other references to such globals exist,
          this may help in assuring that imported modules are still
          available at the time when the *note __del__(): 709. method is
          called.

     See also the *note -R: 2d7. command-line option.

 -- Method: object.__repr__ (self)

     Called by the *note repr(): 145. built-in function and by string
     conversions (reverse quotes) to compute the "official" string
     representation of an object.  If at all possible, this should look
     like a valid Python expression that could be used to recreate an
     object with the same value (given an appropriate environment).  If
     this is not possible, a string of the form ‘<...some useful
     description...>’ should be returned.  The return value must be a
     string object.  If a class defines *note __repr__(): 486. but not
     *note __str__(): 496, then *note __repr__(): 486. is also used when
     an "informal" string representation of instances of that class is
     required.

     This is typically used for debugging, so it is important that the
     representation is information-rich and unambiguous.

 -- Method: object.__str__ (self)

     Called by the *note str(): 1ea. built-in function and by the *note
     print: 4e0. statement to compute the "informal" string
     representation of an object.  This differs from *note __repr__():
     486. in that it does not have to be a valid Python expression: a
     more convenient or concise representation may be used instead.  The
     return value must be a string object.

 -- Method: object.__lt__ (self, other)
 -- Method: object.__le__ (self, other)
 -- Method: object.__eq__ (self, other)
 -- Method: object.__ne__ (self, other)
 -- Method: object.__gt__ (self, other)
 -- Method: object.__ge__ (self, other)

     New in version 2.1.

     These are the so-called "rich comparison" methods, and are called
     for comparison operators in preference to *note __cmp__(): 221.
     below.  The correspondence between operator symbols and method
     names is as follows: ‘x<y’ calls ‘x.__lt__(y)’, ‘x<=y’ calls
     ‘x.__le__(y)’, ‘x==y’ calls ‘x.__eq__(y)’, ‘x!=y’ and ‘x<>y’ call
     ‘x.__ne__(y)’, ‘x>y’ calls ‘x.__gt__(y)’, and ‘x>=y’ calls
     ‘x.__ge__(y)’.

     A rich comparison method may return the singleton ‘NotImplemented’
     if it does not implement the operation for a given pair of
     arguments.  By convention, ‘False’ and ‘True’ are returned for a
     successful comparison.  However, these methods can return any
     value, so if the comparison operator is used in a Boolean context
     (e.g., in the condition of an ‘if’ statement), Python will call
     *note bool(): 43c. on the value to determine if the result is true
     or false.

     There are no implied relationships among the comparison operators.
     The truth of ‘x==y’ does not imply that ‘x!=y’ is false.
     Accordingly, when defining *note __eq__(): 21c, one should also
     define *note __ne__(): 4bd. so that the operators will behave as
     expected.  See the paragraph on *note __hash__(): 335. for some
     important notes on creating *note hashable: 6f5. objects which
     support custom comparison operations and are usable as dictionary
     keys.

     There are no swapped-argument versions of these methods (to be used
     when the left argument does not support the operation but the right
     argument does); rather, *note __lt__(): 21d. and *note __gt__():
     21f. are each other’s reflection, *note __le__(): 21e. and *note
     __ge__(): 220. are each other’s reflection, and *note __eq__():
     21c. and *note __ne__(): 4bd. are their own reflection.

     Arguments to rich comparison methods are never coerced.

     To automatically generate ordering operations from a single root
     operation, see *note functools.total_ordering(): 21b.

 -- Method: object.__cmp__ (self, other)

     Called by comparison operations if rich comparison (see above) is
     not defined.  Should return a negative integer if ‘self < other’,
     zero if ‘self == other’, a positive integer if ‘self > other’.  If
     no *note __cmp__(): 221, *note __eq__(): 21c. or *note __ne__():
     4bd. operation is defined, class instances are compared by object
     identity ("address").  See also the description of *note
     __hash__(): 335. for some important notes on creating *note
     hashable: 6f5. objects which support custom comparison operations
     and are usable as dictionary keys.  (Note: the restriction that
     exceptions are not propagated by *note __cmp__(): 221. has been
     removed since Python 1.5.)

 -- Method: object.__rcmp__ (self, other)

     Changed in version 2.1: No longer supported.

 -- Method: object.__hash__ (self)

     Called by built-in function *note hash(): 70b. and for operations
     on members of hashed collections including *note set: 36a, *note
     frozenset: 36b, and *note dict: 305.  *note __hash__(): 335. should
     return an integer.  The only required property is that objects
     which compare equal have the same hash value; it is advised to
     somehow mix together (e.g.  using exclusive or) the hash values for
     the components of the object that also play a part in comparison of
     objects.

     If a class does not define a *note __cmp__(): 221. or *note
     __eq__(): 21c. method it should not define a *note __hash__(): 335.
     operation either; if it defines *note __cmp__(): 221. or *note
     __eq__(): 21c. but not *note __hash__(): 335, its instances will
     not be usable in hashed collections.  If a class defines mutable
     objects and implements a *note __cmp__(): 221. or *note __eq__():
     21c. method, it should not implement *note __hash__(): 335, since
     hashable collection implementations require that a object’s hash
     value is immutable (if the object’s hash value changes, it will be
     in the wrong hash bucket).

     User-defined classes have *note __cmp__(): 221. and *note
     __hash__(): 335. methods by default; with them, all objects compare
     unequal (except with themselves) and ‘x.__hash__()’ returns a
     result derived from ‘id(x)’.

     Classes which inherit a *note __hash__(): 335. method from a parent
     class but change the meaning of *note __cmp__(): 221. or *note
     __eq__(): 21c. such that the hash value returned is no longer
     appropriate (e.g.  by switching to a value-based concept of
     equality instead of the default identity based equality) can
     explicitly flag themselves as being unhashable by setting ‘__hash__
     = None’ in the class definition.  Doing so means that not only will
     instances of the class raise an appropriate *note TypeError: 218.
     when a program attempts to retrieve their hash value, but they will
     also be correctly identified as unhashable when checking
     ‘isinstance(obj, collections.Hashable)’ (unlike classes which
     define their own *note __hash__(): 335. to explicitly raise *note
     TypeError: 218.).

     Changed in version 2.5: *note __hash__(): 335. may now also return
     a long integer object; the 32-bit integer is then derived from the
     hash of that object.

     Changed in version 2.6: *note __hash__: 335. may now be set to
     *note None: 39a. to explicitly flag instances of a class as
     unhashable.

 -- Method: object.__nonzero__ (self)

     Called to implement truth value testing and the built-in operation
     ‘bool()’; should return ‘False’ or ‘True’, or their integer
     equivalents ‘0’ or ‘1’.  When this method is not defined, *note
     __len__(): 40a. is called, if it is defined, and the object is
     considered true if its result is nonzero.  If a class defines
     neither *note __len__(): 40a. nor *note __nonzero__(): 70c, all its
     instances are considered true.

 -- Method: object.__unicode__ (self)

     Called to implement *note unicode(): 1f5. built-in; should return a
     Unicode object.  When this method is not defined, string conversion
     is attempted, and the result of string conversion is converted to
     Unicode using the system default encoding.


File: python.info,  Node: Customizing attribute access,  Next: Customizing class creation,  Prev: Basic customization,  Up: Special method names

4.3.4.2 Customizing attribute access
....................................

The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of ‘x.name’) for
class instances.

 -- Method: object.__getattr__ (self, name)

     Called when an attribute lookup has not found the attribute in the
     usual places (i.e.  it is not an instance attribute nor is it found
     in the class tree for ‘self’).  ‘name’ is the attribute name.  This
     method should return the (computed) attribute value or raise an
     *note AttributeError: 1f8. exception.

     Note that if the attribute is found through the normal mechanism,
     *note __getattr__(): 331. is not called.  (This is an intentional
     asymmetry between *note __getattr__(): 331. and *note
     __setattr__(): 488.)  This is done both for efficiency reasons and
     because otherwise *note __getattr__(): 331. would have no way to
     access other attributes of the instance.  Note that at least for
     instance variables, you can fake total control by not inserting any
     values in the instance attribute dictionary (but instead inserting
     them in another object).  See the *note __getattribute__(): 33b.
     method below for a way to actually get total control in new-style
     classes.

 -- Method: object.__setattr__ (self, name, value)

     Called when an attribute assignment is attempted.  This is called
     instead of the normal mechanism (i.e.  store the value in the
     instance dictionary).  _name_ is the attribute name, _value_ is the
     value to be assigned to it.

     If *note __setattr__(): 488. wants to assign to an instance
     attribute, it should not simply execute ‘self.name = value’ — this
     would cause a recursive call to itself.  Instead, it should insert
     the value in the dictionary of instance attributes, e.g.,
     ‘self.__dict__[name] = value’.  For new-style classes, rather than
     accessing the instance dictionary, it should call the base class
     method with the same name, for example, ‘object.__setattr__(self,
     name, value)’.

 -- Method: object.__delattr__ (self, name)

     Like *note __setattr__(): 488. but for attribute deletion instead
     of assignment.  This should only be implemented if ‘del obj.name’
     is meaningful for the object.

* Menu:

* More attribute access for new-style classes:: 
* Implementing Descriptors:: 
* Invoking Descriptors:: 
* __slots__:: 


File: python.info,  Node: More attribute access for new-style classes,  Next: Implementing Descriptors,  Up: Customizing attribute access

4.3.4.3 More attribute access for new-style classes
...................................................

The following methods only apply to new-style classes.

 -- Method: object.__getattribute__ (self, name)

     Called unconditionally to implement attribute accesses for
     instances of the class.  If the class also defines *note
     __getattr__(): 331, the latter will not be called unless *note
     __getattribute__(): 33b. either calls it explicitly or raises an
     *note AttributeError: 1f8.  This method should return the
     (computed) attribute value or raise an *note AttributeError: 1f8.
     exception.  In order to avoid infinite recursion in this method,
     its implementation should always call the base class method with
     the same name to access any attributes it needs, for example,
     ‘object.__getattribute__(self, name)’.

          Note: This method may still be bypassed when looking up
          special methods as the result of implicit invocation via
          language syntax or built-in functions.  See *note Special
          method lookup for new-style classes: 711.


File: python.info,  Node: Implementing Descriptors,  Next: Invoking Descriptors,  Prev: More attribute access for new-style classes,  Up: Customizing attribute access

4.3.4.4 Implementing Descriptors
................................

The following methods only apply when an instance of the class
containing the method (a so-called _descriptor_ class) appears in an
_owner_ class (the descriptor must be in either the owner’s class
dictionary or in the class dictionary for one of its parents).  In the
examples below, "the attribute" refers to the attribute whose name is
the key of the property in the owner class’ ‘__dict__’.

 -- Method: object.__get__ (self, instance, owner)

     Called to get the attribute of the owner class (class attribute
     access) or of an instance of that class (instance attribute
     access).  _owner_ is always the owner class, while _instance_ is
     the instance that the attribute was accessed through, or ‘None’
     when the attribute is accessed through the _owner_.  This method
     should return the (computed) attribute value or raise an *note
     AttributeError: 1f8. exception.

 -- Method: object.__set__ (self, instance, value)

     Called to set the attribute on an instance _instance_ of the owner
     class to a new value, _value_.

 -- Method: object.__delete__ (self, instance)

     Called to delete the attribute on an instance _instance_ of the
     owner class.


File: python.info,  Node: Invoking Descriptors,  Next: __slots__,  Prev: Implementing Descriptors,  Up: Customizing attribute access

4.3.4.5 Invoking Descriptors
............................

In general, a descriptor is an object attribute with "binding behavior",
one whose attribute access has been overridden by methods in the
descriptor protocol: *note __get__(): 713, *note __set__(): 714, and
*note __delete__(): 715.  If any of those methods are defined for an
object, it is said to be a descriptor.

  The default behavior for attribute access is to get, set, or delete
the attribute from an object’s dictionary.  For instance, ‘a.x’ has a
lookup chain starting with ‘a.__dict__['x']’, then
‘type(a).__dict__['x']’, and continuing through the base classes of
‘type(a)’ excluding metaclasses.

  However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.  Note that descriptors are only invoked for new
style objects or classes (ones that subclass *note object(): 1f1. or
*note type(): 490.).

  The starting point for descriptor invocation is a binding, ‘a.x’.  How
the arguments are assembled depends on ‘a’:

Direct Call

     The simplest and least common call is when user code directly
     invokes a descriptor method: ‘x.__get__(a)’.

Instance Binding

     If binding to a new-style object instance, ‘a.x’ is transformed
     into the call: ‘type(a).__dict__['x'].__get__(a, type(a))’.

Class Binding

     If binding to a new-style class, ‘A.x’ is transformed into the
     call: ‘A.__dict__['x'].__get__(None, A)’.

Super Binding

     If ‘a’ is an instance of *note super: 37d, then the binding
     ‘super(B, obj).m()’ searches ‘obj.__class__.__mro__’ for the base
     class ‘A’ immediately preceding ‘B’ and then invokes the descriptor
     with the call: ‘A.__dict__['m'].__get__(obj, obj.__class__)’.

  For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  A descriptor can define
any combination of *note __get__(): 713, *note __set__(): 714. and *note
__delete__(): 715.  If it does not define *note __get__(): 713, then
accessing the attribute will return the descriptor object itself unless
there is a value in the object’s instance dictionary.  If the descriptor
defines *note __set__(): 714. and/or *note __delete__(): 715, it is a
data descriptor; if it defines neither, it is a non-data descriptor.
Normally, data descriptors define both *note __get__(): 713. and *note
__set__(): 714, while non-data descriptors have just the *note
__get__(): 713. method.  Data descriptors with *note __set__(): 714. and
*note __get__(): 713. defined always override a redefinition in an
instance dictionary.  In contrast, non-data descriptors can be
overridden by instances.

  Python methods (including *note staticmethod(): 3f5. and *note
classmethod(): 3f6.) are implemented as non-data descriptors.
Accordingly, instances can redefine and override methods.  This allows
individual instances to acquire behaviors that differ from other
instances of the same class.

  The *note property(): 487. function is implemented as a data
descriptor.  Accordingly, instances cannot override the behavior of a
property.


File: python.info,  Node: __slots__,  Prev: Invoking Descriptors,  Up: Customizing attribute access

4.3.4.6 __slots__
.................

By default, instances of both old and new-style classes have a
dictionary for attribute storage.  This wastes space for objects having
very few instance variables.  The space consumption can become acute
when creating large numbers of instances.

  The default can be overridden by defining ___slots___ in a new-style
class definition.  The ___slots___ declaration takes a sequence of
instance variables and reserves just enough space in each instance to
hold a value for each variable.  Space is saved because ___dict___ is
not created for each instance.

 -- Data: __slots__

     This class variable can be assigned a string, iterable, or sequence
     of strings with variable names used by instances.  If defined in a
     new-style class, ___slots___ reserves space for the declared
     variables and prevents the automatic creation of ___dict___ and
     ___weakref___ for each instance.

     New in version 2.2.

  Notes on using ___slots___

   * When inheriting from a class without ___slots___, the ___dict___
     attribute of that class will always be accessible, so a ___slots___
     definition in the subclass is meaningless.

   * Without a ___dict___ variable, instances cannot be assigned new
     variables not listed in the ___slots___ definition.  Attempts to
     assign to an unlisted variable name raises *note AttributeError:
     1f8.  If dynamic assignment of new variables is desired, then add
     ‘'__dict__'’ to the sequence of strings in the ___slots___
     declaration.

     Changed in version 2.3: Previously, adding ‘'__dict__'’ to the
     ___slots___ declaration would not enable the assignment of new
     attributes not specifically listed in the sequence of instance
     variable names.

   * Without a ___weakref___ variable for each instance, classes
     defining ___slots___ do not support weak references to its
     instances.  If weak reference support is needed, then add
     ‘'__weakref__'’ to the sequence of strings in the ___slots___
     declaration.

     Changed in version 2.3: Previously, adding ‘'__weakref__'’ to the
     ___slots___ declaration would not enable support for weak
     references.

   * ___slots___ are implemented at the class level by creating
     descriptors (*note Implementing Descriptors: 6fb.) for each
     variable name.  As a result, class attributes cannot be used to set
     default values for instance variables defined by ___slots___;
     otherwise, the class attribute would overwrite the descriptor
     assignment.

   * The action of a ___slots___ declaration is limited to the class
     where it is defined.  As a result, subclasses will have a
     ___dict___ unless they also define ___slots___ (which must only
     contain names of any _additional_ slots).

   * If a class defines a slot also defined in a base class, the
     instance variable defined by the base class slot is inaccessible
     (except by retrieving its descriptor directly from the base class).
     This renders the meaning of the program undefined.  In the future,
     a check may be added to prevent this.

   * Nonempty ___slots___ does not work for classes derived from
     "variable-length" built-in types such as *note long: 1f3, *note
     str: 1ea. and *note tuple: 408.

   * Any non-string iterable may be assigned to ___slots___.  Mappings
     may also be used; however, in the future, special meaning may be
     assigned to the values corresponding to each key.

   * ___class___ assignment works only if both classes have the same
     ___slots___.

     Changed in version 2.6: Previously, ___class___ assignment raised
     an error if either new or old class had ___slots___.


File: python.info,  Node: Customizing class creation,  Next: Customizing instance and subclass checks,  Prev: Customizing attribute access,  Up: Special method names

4.3.4.7 Customizing class creation
..................................

By default, new-style classes are constructed using *note type(): 490.
A class definition is read into a separate namespace and the value of
class name is bound to the result of ‘type(name, bases, dict)’.

  When the class definition is read, if ___metaclass___ is defined then
the callable assigned to it will be called instead of *note type(): 490.
This allows classes or functions to be written which monitor or alter
the class creation process:

   * Modifying the class dictionary prior to the class being created.

   * Returning an instance of another class – essentially performing the
     role of a factory function.

  These steps will have to be performed in the metaclass’s *note
__new__(): 6f9. method – ‘type.__new__()’ can then be called from this
method to create a class with different properties.  This example adds a
new element to the class dictionary before creating the class:

     class metacls(type):
         def __new__(mcs, name, bases, dict):
             dict['foo'] = 'metacls was here'
             return type.__new__(mcs, name, bases, dict)

  You can of course also override other class methods (or add new
methods); for example defining a custom *note __call__(): 6fa. method in
the metaclass allows custom behavior when the class is called, e.g.  not
always creating a new instance.

 -- Data: __metaclass__

     This variable can be any callable accepting arguments for ‘name’,
     ‘bases’, and ‘dict’.  Upon class creation, the callable is used
     instead of the built-in *note type(): 490.

     New in version 2.2.

  The appropriate metaclass is determined by the following precedence
rules:

   * If ‘dict['__metaclass__']’ exists, it is used.

   * Otherwise, if there is at least one base class, its metaclass is
     used (this looks for a ___class___ attribute first and if not
     found, uses its type).

   * Otherwise, if a global variable named __metaclass__ exists, it is
     used.

   * Otherwise, the old-style, classic metaclass (types.ClassType) is
     used.

  The potential uses for metaclasses are boundless.  Some ideas that
have been explored including logging, interface checking, automatic
delegation, automatic property creation, proxies, frameworks, and
automatic resource locking/synchronization.


File: python.info,  Node: Customizing instance and subclass checks,  Next: Emulating callable objects,  Prev: Customizing class creation,  Up: Special method names

4.3.4.8 Customizing instance and subclass checks
................................................

New in version 2.6.

  The following methods are used to override the default behavior of the
*note isinstance(): 31e. and *note issubclass(): 31f. built-in
functions.

  In particular, the metaclass *note abc.ABCMeta: 71d. implements these
methods in order to allow the addition of Abstract Base Classes (ABCs)
as "virtual base classes" to any class or type (including built-in
types), including other ABCs.

 -- Method: class.__instancecheck__ (self, instance)

     Return true if _instance_ should be considered a (direct or
     indirect) instance of _class_.  If defined, called to implement
     ‘isinstance(instance, class)’.

 -- Method: class.__subclasscheck__ (self, subclass)

     Return true if _subclass_ should be considered a (direct or
     indirect) subclass of _class_.  If defined, called to implement
     ‘issubclass(subclass, class)’.

  Note that these methods are looked up on the type (metaclass) of a
class.  They cannot be defined as class methods in the actual class.
This is consistent with the lookup of special methods that are called on
instances, only in this case the instance is itself a class.

See also
........

PEP 3119(1) - Introducing Abstract Base Classes

     Includes the specification for customizing *note isinstance(): 31e.
     and *note issubclass(): 31f. behavior through *note
     __instancecheck__(): 71e. and *note __subclasscheck__(): 71f, with
     motivation for this functionality in the context of adding Abstract
     Base Classes (see the *note abc: 4. module) to the language.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-3119


File: python.info,  Node: Emulating callable objects,  Next: Emulating container types,  Prev: Customizing instance and subclass checks,  Up: Special method names

4.3.4.9 Emulating callable objects
..................................

 -- Method: object.__call__ (self[, args...])

     Called when the instance is "called" as a function; if this method
     is defined, ‘x(arg1, arg2, ...)’ is a shorthand for
     ‘x.__call__(arg1, arg2, ...)’.


File: python.info,  Node: Emulating container types,  Next: Additional methods for emulation of sequence types,  Prev: Emulating callable objects,  Up: Special method names

4.3.4.10 Emulating container types
..................................

The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to emulate
a mapping; the difference is that for a sequence, the allowable keys
should be the integers _k_ for which ‘0 <= k < N’ where _N_ is the
length of the sequence, or slice objects, which define a range of items.
(For backwards compatibility, the method *note __getslice__(): 724. (see
below) can also be defined to handle simple, but not extended slices.)
It is also recommended that mappings provide the methods ‘keys()’,
‘values()’, ‘items()’, ‘has_key()’, ‘get()’, ‘clear()’, ‘setdefault()’,
‘iterkeys()’, ‘itervalues()’, ‘iteritems()’, ‘pop()’, ‘popitem()’,
‘copy()’, and ‘update()’ behaving similar to those for Python’s standard
dictionary objects.  The *note UserDict: 18c. module provides a
‘DictMixin’ class to help create those methods from a base set of *note
__getitem__(): 44f, *note __setitem__(): 465, *note __delitem__(): 466,
and ‘keys()’.  Mutable sequences should provide methods ‘append()’,
‘count()’, ‘index()’, ‘extend()’, ‘insert()’, ‘pop()’, ‘remove()’,
‘reverse()’ and ‘sort()’, like Python standard list objects.  Finally,
sequence types should implement addition (meaning concatenation) and
multiplication (meaning repetition) by defining the methods *note
__add__(): 725, *note __radd__(): 726, *note __iadd__(): 4d8, *note
__mul__(): 727, *note __rmul__(): 728. and *note __imul__(): 729.
described below; they should not define *note __coerce__(): 1ee. or
other numerical operators.  It is recommended that both mappings and
sequences implement the *note __contains__(): 322. method to allow
efficient use of the ‘in’ operator; for mappings, ‘in’ should be
equivalent of ‘has_key()’; for sequences, it should search through the
values.  It is further recommended that both mappings and sequences
implement the *note __iter__(): 321. method to allow efficient iteration
through the container; for mappings, *note __iter__(): 321. should be
the same as ‘iterkeys()’; for sequences, it should iterate through the
values.

 -- Method: object.__len__ (self)

     Called to implement the built-in function *note len(): 520.  Should
     return the length of the object, an integer ‘>=’ 0.  Also, an
     object that doesn’t define a *note __nonzero__(): 70c. method and
     whose *note __len__(): 40a. method returns zero is considered to be
     false in a Boolean context.

 -- Method: object.__getitem__ (self, key)

     Called to implement evaluation of ‘self[key]’.  For sequence types,
     the accepted keys should be integers and slice objects.  Note that
     the special interpretation of negative indexes (if the class wishes
     to emulate a sequence type) is up to the *note __getitem__(): 44f.
     method.  If _key_ is of an inappropriate type, *note TypeError:
     218. may be raised; if of a value outside the set of indexes for
     the sequence (after any special interpretation of negative values),
     *note IndexError: 4e1. should be raised.  For mapping types, if
     _key_ is missing (not in the container), *note KeyError: 205.
     should be raised.

          Note: *note for: 2f0. loops expect that an *note IndexError:
          4e1. will be raised for illegal indexes to allow proper
          detection of the end of the sequence.

 -- Method: object.__setitem__ (self, key, value)

     Called to implement assignment to ‘self[key]’.  Same note as for
     *note __getitem__(): 44f.  This should only be implemented for
     mappings if the objects support changes to the values for keys, or
     if new keys can be added, or for sequences if elements can be
     replaced.  The same exceptions should be raised for improper _key_
     values as for the *note __getitem__(): 44f. method.

 -- Method: object.__delitem__ (self, key)

     Called to implement deletion of ‘self[key]’.  Same note as for
     *note __getitem__(): 44f.  This should only be implemented for
     mappings if the objects support removal of keys, or for sequences
     if elements can be removed from the sequence.  The same exceptions
     should be raised for improper _key_ values as for the *note
     __getitem__(): 44f. method.

 -- Method: object.__iter__ (self)

     This method is called when an iterator is required for a container.
     This method should return a new iterator object that can iterate
     over all the objects in the container.  For mappings, it should
     iterate over the keys of the container, and should also be made
     available as the method ‘iterkeys()’.

     Iterator objects also need to implement this method; they are
     required to return themselves.  For more information on iterator
     objects, see *note Iterator Types: 72a.

 -- Method: object.__reversed__ (self)

     Called (if present) by the *note reversed(): 3f8. built-in to
     implement reverse iteration.  It should return a new iterator
     object that iterates over all the objects in the container in
     reverse order.

     If the *note __reversed__(): 72b. method is not provided, the *note
     reversed(): 3f8. built-in will fall back to using the sequence
     protocol (*note __len__(): 40a. and *note __getitem__(): 44f.).
     Objects that support the sequence protocol should only provide
     *note __reversed__(): 72b. if they can provide an implementation
     that is more efficient than the one provided by *note reversed():
     3f8.

     New in version 2.6.

  The membership test operators (*note in: 428. and *note not in: 72c.)
are normally implemented as an iteration through a sequence.  However,
container objects can supply the following special method with a more
efficient implementation, which also does not require the object be a
sequence.

 -- Method: object.__contains__ (self, item)

     Called to implement membership test operators.  Should return true
     if _item_ is in _self_, false otherwise.  For mapping objects, this
     should consider the keys of the mapping rather than the values or
     the key-item pairs.

     For objects that don’t define *note __contains__(): 322, the
     membership test first tries iteration via *note __iter__(): 321,
     then the old sequence iteration protocol via *note __getitem__():
     44f, see *note this section in the language reference: 72d.


File: python.info,  Node: Additional methods for emulation of sequence types,  Next: Emulating numeric types,  Prev: Emulating container types,  Up: Special method names

4.3.4.11 Additional methods for emulation of sequence types
...........................................................

The following optional methods can be defined to further emulate
sequence objects.  Immutable sequences methods should at most only
define *note __getslice__(): 724.; mutable sequences might define all
three methods.

 -- Method: object.__getslice__ (self, i, j)

     Deprecated since version 2.0: Support slice objects as parameters
     to the *note __getitem__(): 44f. method.  (However, built-in types
     in CPython currently still implement *note __getslice__(): 724.
     Therefore, you have to override it in derived classes when
     implementing slicing.)

     Called to implement evaluation of ‘self[i:j]’.  The returned object
     should be of the same type as _self_.  Note that missing _i_ or _j_
     in the slice expression are replaced by zero or ‘sys.maxint’,
     respectively.  If negative indexes are used in the slice, the
     length of the sequence is added to that index.  If the instance
     does not implement the *note __len__(): 40a. method, an *note
     AttributeError: 1f8. is raised.  No guarantee is made that indexes
     adjusted this way are not still negative.  Indexes which are
     greater than the length of the sequence are not modified.  If no
     *note __getslice__(): 724. is found, a slice object is created
     instead, and passed to *note __getitem__(): 44f. instead.

 -- Method: object.__setslice__ (self, i, j, sequence)

     Called to implement assignment to ‘self[i:j]’.  Same notes for _i_
     and _j_ as for *note __getslice__(): 724.

     This method is deprecated.  If no *note __setslice__(): 730. is
     found, or for extended slicing of the form ‘self[i:j:k]’, a slice
     object is created, and passed to *note __setitem__(): 465, instead
     of *note __setslice__(): 730. being called.

 -- Method: object.__delslice__ (self, i, j)

     Called to implement deletion of ‘self[i:j]’.  Same notes for _i_
     and _j_ as for *note __getslice__(): 724.  This method is
     deprecated.  If no *note __delslice__(): 731. is found, or for
     extended slicing of the form ‘self[i:j:k]’, a slice object is
     created, and passed to *note __delitem__(): 466, instead of *note
     __delslice__(): 731. being called.

  Notice that these methods are only invoked when a single slice with a
single colon is used, and the slice method is available.  For slice
operations involving extended slice notation, or in absence of the slice
methods, *note __getitem__(): 44f, *note __setitem__(): 465. or *note
__delitem__(): 466. is called with a slice object as argument.

  The following example demonstrate how to make your program or module
compatible with earlier versions of Python (assuming that methods *note
__getitem__(): 44f, *note __setitem__(): 465. and *note __delitem__():
466. support slice objects as arguments):

     class MyClass:
         ...
         def __getitem__(self, index):
             ...
         def __setitem__(self, index, value):
             ...
         def __delitem__(self, index):
             ...

         if sys.version_info < (2, 0):
             # They won't be defined if version is at least 2.0 final

             def __getslice__(self, i, j):
                 return self[max(0, i):max(0, j):]
             def __setslice__(self, i, j, seq):
                 self[max(0, i):max(0, j):] = seq
             def __delslice__(self, i, j):
                 del self[max(0, i):max(0, j):]
         ...

  Note the calls to *note max(): 225.; these are necessary because of
the handling of negative indices before the ‘__*slice__()’ methods are
called.  When negative indexes are used, the ‘__*item__()’ methods
receive them as provided, but the ‘__*slice__()’ methods get a "cooked"
form of the index values.  For each negative index value, the length of
the sequence is added to the index before calling the method (which may
still result in a negative index); this is the customary handling of
negative indexes by the built-in sequence types, and the ‘__*item__()’
methods are expected to do this as well.  However, since they should
already be doing that, negative indexes cannot be passed in; they must
be constrained to the bounds of the sequence before being passed to the
‘__*item__()’ methods.  Calling ‘max(0, i)’ conveniently returns the
proper value.


File: python.info,  Node: Emulating numeric types,  Next: Coercion rules,  Prev: Additional methods for emulation of sequence types,  Up: Special method names

4.3.4.12 Emulating numeric types
................................

The following methods can be defined to emulate numeric objects.
Methods corresponding to operations that are not supported by the
particular kind of number implemented (e.g., bitwise operations for
non-integral numbers) should be left undefined.

 -- Method: object.__add__ (self, other)
 -- Method: object.__sub__ (self, other)
 -- Method: object.__mul__ (self, other)
 -- Method: object.__floordiv__ (self, other)
 -- Method: object.__mod__ (self, other)
 -- Method: object.__divmod__ (self, other)
 -- Method: object.__pow__ (self, other[, modulo])
 -- Method: object.__lshift__ (self, other)
 -- Method: object.__rshift__ (self, other)
 -- Method: object.__and__ (self, other)
 -- Method: object.__xor__ (self, other)
 -- Method: object.__or__ (self, other)

     These methods are called to implement the binary arithmetic
     operations (‘+’, ‘-’, ‘*’, ‘//’, ‘%’, *note divmod(): 73d, *note
     pow(): 4b5, ‘**’, ‘<<’, ‘>>’, ‘&’, ‘^’, ‘|’).  For instance, to
     evaluate the expression ‘x + y’, where _x_ is an instance of a
     class that has an *note __add__(): 725. method, ‘x.__add__(y)’ is
     called.  The *note __divmod__(): 736. method should be the
     equivalent to using *note __floordiv__(): 493. and *note __mod__():
     735.; it should not be related to *note __truediv__(): 492.
     (described below).  Note that *note __pow__(): 737. should be
     defined to accept an optional third argument if the ternary version
     of the built-in *note pow(): 4b5. function is to be supported.

     If one of those methods does not support the operation with the
     supplied arguments, it should return ‘NotImplemented’.

 -- Method: object.__div__ (self, other)
 -- Method: object.__truediv__ (self, other)

     The division operator (‘/’) is implemented by these methods.  The
     *note __truediv__(): 492. method is used when ‘__future__.division’
     is in effect, otherwise *note __div__(): 73e. is used.  If only one
     of these two methods is defined, the object will not support
     division in the alternate context; *note TypeError: 218. will be
     raised instead.

 -- Method: object.__radd__ (self, other)
 -- Method: object.__rsub__ (self, other)
 -- Method: object.__rmul__ (self, other)
 -- Method: object.__rdiv__ (self, other)
 -- Method: object.__rtruediv__ (self, other)
 -- Method: object.__rfloordiv__ (self, other)
 -- Method: object.__rmod__ (self, other)
 -- Method: object.__rdivmod__ (self, other)
 -- Method: object.__rpow__ (self, other)
 -- Method: object.__rlshift__ (self, other)
 -- Method: object.__rrshift__ (self, other)
 -- Method: object.__rand__ (self, other)
 -- Method: object.__rxor__ (self, other)
 -- Method: object.__ror__ (self, other)

     These methods are called to implement the binary arithmetic
     operations (‘+’, ‘-’, ‘*’, ‘/’, ‘%’, *note divmod(): 73d, *note
     pow(): 4b5, ‘**’, ‘<<’, ‘>>’, ‘&’, ‘^’, ‘|’) with reflected
     (swapped) operands.  These functions are only called if the left
     operand does not support the corresponding operation and the
     operands are of different types.  (1) For instance, to evaluate the
     expression ‘x - y’, where _y_ is an instance of a class that has an
     *note __rsub__(): 73f. method, ‘y.__rsub__(x)’ is called if
     ‘x.__sub__(y)’ returns _NotImplemented_.

     Note that ternary *note pow(): 4b5. will not try calling *note
     __rpow__(): 745. (the coercion rules would become too complicated).

          Note: If the right operand’s type is a subclass of the left
          operand’s type and that subclass provides the reflected method
          for the operation, this method will be called before the left
          operand’s non-reflected method.  This behavior allows
          subclasses to override their ancestors’ operations.

 -- Method: object.__iadd__ (self, other)
 -- Method: object.__isub__ (self, other)
 -- Method: object.__imul__ (self, other)
 -- Method: object.__idiv__ (self, other)
 -- Method: object.__itruediv__ (self, other)
 -- Method: object.__ifloordiv__ (self, other)
 -- Method: object.__imod__ (self, other)
 -- Method: object.__ipow__ (self, other[, modulo])
 -- Method: object.__ilshift__ (self, other)
 -- Method: object.__irshift__ (self, other)
 -- Method: object.__iand__ (self, other)
 -- Method: object.__ixor__ (self, other)
 -- Method: object.__ior__ (self, other)

     These methods are called to implement the augmented arithmetic
     assignments (‘+=’, ‘-=’, ‘*=’, ‘/=’, ‘//=’, ‘%=’, ‘**=’, ‘<<=’,
     ‘>>=’, ‘&=’, ‘^=’, ‘|=’).  These methods should attempt to do the
     operation in-place (modifying _self_) and return the result (which
     could be, but does not have to be, _self_).  If a specific method
     is not defined, the augmented assignment falls back to the normal
     methods.  For instance, to execute the statement ‘x += y’, where
     _x_ is an instance of a class that has an *note __iadd__(): 4d8.
     method, ‘x.__iadd__(y)’ is called.  If _x_ is an instance of a
     class that does not define a *note __iadd__(): 4d8. method,
     ‘x.__add__(y)’ and ‘y.__radd__(x)’ are considered, as with the
     evaluation of ‘x + y’.

 -- Method: object.__neg__ (self)
 -- Method: object.__pos__ (self)
 -- Method: object.__abs__ (self)
 -- Method: object.__invert__ (self)

     Called to implement the unary arithmetic operations (‘-’, ‘+’,
     *note abs(): 5bf. and ‘~’).

 -- Method: object.__complex__ (self)
 -- Method: object.__int__ (self)
 -- Method: object.__long__ (self)
 -- Method: object.__float__ (self)

     Called to implement the built-in functions *note complex(): 1ec,
     *note int(): 1f2, *note long(): 1f3, and *note float(): 1eb.
     Should return a value of the appropriate type.

 -- Method: object.__oct__ (self)
 -- Method: object.__hex__ (self)

     Called to implement the built-in functions *note oct(): 325. and
     *note hex(): 334.  Should return a string value.

 -- Method: object.__index__ (self)

     Called to implement *note operator.index(): 75b.  Also called
     whenever Python needs an integer object (such as in slicing).  Must
     return an integer (int or long).

     New in version 2.5.

 -- Method: object.__coerce__ (self, other)

     Called to implement "mixed-mode" numeric arithmetic.  Should either
     return a 2-tuple containing _self_ and _other_ converted to a
     common numeric type, or ‘None’ if conversion is impossible.  When
     the common type would be the type of ‘other’, it is sufficient to
     return ‘None’, since the interpreter will also ask the other object
     to attempt a coercion (but sometimes, if the implementation of the
     other type cannot be changed, it is useful to do the conversion to
     the other type here).  A return value of ‘NotImplemented’ is
     equivalent to returning ‘None’.

   ---------- Footnotes ----------

   (1) For operands of the same type, it is assumed that if the
non-reflected method (such as *note __add__(): 725.) fails the operation
is not supported, which is why the reflected method is not called.


File: python.info,  Node: Coercion rules,  Next: With Statement Context Managers,  Prev: Emulating numeric types,  Up: Special method names

4.3.4.13 Coercion rules
.......................

This section used to document the rules for coercion.  As the language
has evolved, the coercion rules have become hard to document precisely;
documenting what one version of one particular implementation does is
undesirable.  Instead, here are some informal guidelines regarding
coercion.  In Python 3, coercion will not be supported.

   * If the left operand of a % operator is a string or Unicode object,
     no coercion takes place and the string formatting operation is
     invoked instead.

   * It is no longer recommended to define a coercion operation.
     Mixed-mode operations on types that don’t define coercion pass the
     original arguments to the operation.

   * New-style classes (those derived from *note object: 1f1.) never
     invoke the *note __coerce__(): 1ee. method in response to a binary
     operator; the only time *note __coerce__(): 1ee. is invoked is when
     the built-in function *note coerce(): 75e. is called.

   * For most intents and purposes, an operator that returns
     ‘NotImplemented’ is treated the same as one that is not implemented
     at all.

   * Below, ‘__op__()’ and ‘__rop__()’ are used to signify the generic
     method names corresponding to an operator; ‘__iop__()’ is used for
     the corresponding in-place operator.  For example, for the operator
     ’‘+’’, *note __add__(): 725. and *note __radd__(): 726. are used
     for the left and right variant of the binary operator, and *note
     __iadd__(): 4d8. for the in-place variant.

   * For objects _x_ and _y_, first ‘x.__op__(y)’ is tried.  If this is
     not implemented or returns ‘NotImplemented’, ‘y.__rop__(x)’ is
     tried.  If this is also not implemented or returns
     ‘NotImplemented’, a *note TypeError: 218. exception is raised.  But
     see the following exception:

   * Exception to the previous item: if the left operand is an instance
     of a built-in type or a new-style class, and the right operand is
     an instance of a proper subclass of that type or class and
     overrides the base’s ‘__rop__()’ method, the right operand’s
     ‘__rop__()’ method is tried _before_ the left operand’s ‘__op__()’
     method.

     This is done so that a subclass can completely override binary
     operators.  Otherwise, the left operand’s ‘__op__()’ method would
     always accept the right operand: when an instance of a given class
     is expected, an instance of a subclass of that class is always
     acceptable.

   * When either operand type defines a coercion, this coercion is
     called before that type’s ‘__op__()’ or ‘__rop__()’ method is
     called, but no sooner.  If the coercion returns an object of a
     different type for the operand whose coercion is invoked, part of
     the process is redone using the new object.

   * When an in-place operator (like ’‘+=’’) is used, if the left
     operand implements ‘__iop__()’, it is invoked without any coercion.
     When the operation falls back to ‘__op__()’ and/or ‘__rop__()’, the
     normal coercion rules apply.

   * In ‘x + y’, if _x_ is a sequence that implements sequence
     concatenation, sequence concatenation is invoked.

   * In ‘x * y’, if one operand is a sequence that implements sequence
     repetition, and the other is an integer (*note int: 1f2. or *note
     long: 1f3.), sequence repetition is invoked.

   * Rich comparisons (implemented by methods *note __eq__(): 21c. and
     so on) never use coercion.  Three-way comparison (implemented by
     *note __cmp__(): 221.) does use coercion under the same conditions
     as other binary operations use it.

   * In the current implementation, the built-in numeric types *note
     int: 1f2, *note long: 1f3, *note float: 1eb, and *note complex:
     1ec. do not use coercion.  All these types implement a *note
     __coerce__(): 1ee. method, for use by the built-in *note coerce():
     75e. function.

     Changed in version 2.7.


File: python.info,  Node: With Statement Context Managers,  Next: Special method lookup for old-style classes,  Prev: Coercion rules,  Up: Special method names

4.3.4.14 With Statement Context Managers
........................................

New in version 2.5.

  A _context manager_ is an object that defines the runtime context to
be established when executing a *note with: 1c0. statement.  The context
manager handles the entry into, and the exit from, the desired runtime
context for the execution of the block of code.  Context managers are
normally invoked using the *note with: 1c0. statement (described in
section *note The with statement: 1c0.), but can also be used by
directly invoking their methods.

  Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.

  For more information on context managers, see *note Context Manager
Types: 761.

 -- Method: object.__enter__ (self)

     Enter the runtime context related to this object.  The *note with:
     1c0. statement will bind this method’s return value to the
     target(s) specified in the *note as: 2f8. clause of the statement,
     if any.

 -- Method: object.__exit__ (self, exc_type, exc_value, traceback)

     Exit the runtime context related to this object.  The parameters
     describe the exception that caused the context to be exited.  If
     the context was exited without an exception, all three arguments
     will be *note None: 39a.

     If an exception is supplied, and the method wishes to suppress the
     exception (i.e., prevent it from being propagated), it should
     return a true value.  Otherwise, the exception will be processed
     normally upon exit from this method.

     Note that *note __exit__(): 200. methods should not reraise the
     passed-in exception; this is the caller’s responsibility.

See also
........

PEP 0343(1) - The "with" statement

     The specification, background, and examples for the Python *note
     with: 1c0. statement.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Special method lookup for old-style classes,  Next: Special method lookup for new-style classes,  Prev: With Statement Context Managers,  Up: Special method names

4.3.4.15 Special method lookup for old-style classes
....................................................

For old-style classes, special methods are always looked up in exactly
the same way as any other method or attribute.  This is the case
regardless of whether the method is being looked up explicitly as in
‘x.__getitem__(i)’ or implicitly as in ‘x[i]’.

  This behaviour means that special methods may exhibit different
behaviour for different instances of a single old-style class if the
appropriate special attributes are set differently:

     >>> class C:
     ...     pass
     ...
     >>> c1 = C()
     >>> c2 = C()
     >>> c1.__len__ = lambda: 5
     >>> c2.__len__ = lambda: 9
     >>> len(c1)
     5
     >>> len(c2)
     9


File: python.info,  Node: Special method lookup for new-style classes,  Prev: Special method lookup for old-style classes,  Up: Special method names

4.3.4.16 Special method lookup for new-style classes
....................................................

For new-style classes, implicit invocations of special methods are only
guaranteed to work correctly if defined on an object’s type, not in the
object’s instance dictionary.  That behaviour is the reason why the
following code raises an exception (unlike the equivalent example with
old-style classes):

     >>> class C(object):
     ...     pass
     ...
     >>> c = C()
     >>> c.__len__ = lambda: 5
     >>> len(c)
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: object of type 'C' has no len()

  The rationale behind this behaviour lies with a number of special
methods such as *note __hash__(): 335. and *note __repr__(): 486. that
are implemented by all objects, including type objects.  If the implicit
lookup of these methods used the conventional lookup process, they would
fail when invoked on the type object itself:

     >>> 1 .__hash__() == hash(1)
     True
     >>> int.__hash__() == hash(int)
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: descriptor '__hash__' of 'int' object needs an argument

  Incorrectly attempting to invoke an unbound method of a class in this
way is sometimes referred to as ’metaclass confusion’, and is avoided by
bypassing the instance when looking up special methods:

     >>> type(1).__hash__(1) == hash(1)
     True
     >>> type(int).__hash__(int) == hash(int)
     True

  In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
*note __getattribute__(): 33b. method even of the object’s metaclass:

     >>> class Meta(type):
     ...    def __getattribute__(*args):
     ...       print "Metaclass getattribute invoked"
     ...       return type.__getattribute__(*args)
     ...
     >>> class C(object):
     ...     __metaclass__ = Meta
     ...     def __len__(self):
     ...         return 10
     ...     def __getattribute__(*args):
     ...         print "Class getattribute invoked"
     ...         return object.__getattribute__(*args)
     ...
     >>> c = C()
     >>> c.__len__()                 # Explicit lookup via instance
     Class getattribute invoked
     10
     >>> type(c).__len__(c)          # Explicit lookup via type
     Metaclass getattribute invoked
     10
     >>> len(c)                      # Implicit lookup
     10

  Bypassing the *note __getattribute__(): 33b. machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of special
methods (the special method _must_ be set on the class object itself in
order to be consistently invoked by the interpreter).


File: python.info,  Node: Execution model,  Next: Expressions,  Prev: Data model,  Up: The Python Language Reference

4.4 Execution model
===================

* Menu:

* Naming and binding:: 
* Exceptions: Exceptions<2>. 

Naming and binding

* Interaction with dynamic features:: 


File: python.info,  Node: Naming and binding,  Next: Exceptions<2>,  Up: Execution model

4.4.1 Naming and binding
------------------------

_Names_ refer to objects.  Names are introduced by name binding
operations.  Each occurrence of a name in the program text refers to the
_binding_ of that name established in the innermost function block
containing the use.

  A _block_ is a piece of Python program text that is executed as a
unit.  The following are blocks: a module, a function body, and a class
definition.  Each command typed interactively is a block.  A script file
(a file given as standard input to the interpreter or specified on the
interpreter command line the first argument) is a code block.  A script
command (a command specified on the interpreter command line with the
’*-c*’ option) is a code block.  The file read by the built-in function
*note execfile(): 436. is a code block.  The string argument passed to
the built-in function *note eval(): 360. and to the *note exec: 404.
statement is a code block.  The expression read and evaluated by the
built-in function *note input(): 3bf. is a code block.

  A code block is executed in an _execution frame_.  A frame contains
some administrative information (used for debugging) and determines
where and how execution continues after the code block’s execution has
completed.

  A _scope_ defines the visibility of a name within a block.  If a local
variable is defined in a block, its scope includes that block.  If the
definition occurs in a function block, the scope extends to any blocks
contained within the defining one, unless a contained block introduces a
different binding for the name.  The scope of names defined in a class
block is limited to the class block; it does not extend to the code
blocks of methods – this includes generator expressions since they are
implemented using a function scope.  This means that the following will
fail:

     class A:
         a = 42
         b = list(a + i for i in range(10))

  When a name is used in a code block, it is resolved using the nearest
enclosing scope.  The set of all such scopes visible to a code block is
called the block’s _environment_.

  If a name is bound in a block, it is a local variable of that block.
If a name is bound at the module level, it is a global variable.  (The
variables of the module code block are local and global.)  If a variable
is used in a code block but not defined there, it is a _free variable_.

  When a name is not found at all, a *note NameError: 3a3. exception is
raised.  If the name refers to a local variable that has not been bound,
a *note UnboundLocalError: 4e2. exception is raised.  *note
UnboundLocalError: 4e2. is a subclass of *note NameError: 3a3.

  The following constructs bind names: formal parameters to functions,
*note import: 1f4. statements, class and function definitions (these
bind the class or function name in the defining block), and targets that
are identifiers if occurring in an assignment, *note for: 2f0. loop
header, in the second position of an *note except: 397. clause header or
after *note as: 2f8. in a *note with: 1c0. statement.  The *note import:
1f4. statement of the form ‘from ... import *’ binds all names defined
in the imported module, except those beginning with an underscore.  This
form may only be used at the module level.

  A target occurring in a *note del: 568. statement is also considered
bound for this purpose (though the actual semantics are to unbind the
name).  It is illegal to unbind a name that is referenced by an
enclosing scope; the compiler will report a *note SyntaxError: 498.

  Each assignment or import statement occurs within a block defined by a
class or function definition or at the module level (the top-level code
block).

  If a name binding operation occurs anywhere within a code block, all
uses of the name within the block are treated as references to the
current block.  This can lead to errors when a name is used within a
block before it is bound.  This rule is subtle.  Python lacks
declarations and allows name binding operations to occur anywhere within
a code block.  The local variables of a code block can be determined by
scanning the entire text of the block for name binding operations.

  If the global statement occurs within a block, all uses of the name
specified in the statement refer to the binding of that name in the
top-level namespace.  Names are resolved in the top-level namespace by
searching the global namespace, i.e.  the namespace of the module
containing the code block, and the builtins namespace, the namespace of
the module *note __builtin__: 0.  The global namespace is searched
first.  If the name is not found there, the builtins namespace is
searched.  The global statement must precede all uses of the name.

  The builtins namespace associated with the execution of a code block
is actually found by looking up the name ‘__builtins__’ in its global
namespace; this should be a dictionary or a module (in the latter case
the module’s dictionary is used).  By default, when in the *note
__main__: 2. module, ‘__builtins__’ is the built-in module *note
__builtin__: 0. (note: no ’s’); when in any other module, ‘__builtins__’
is an alias for the dictionary of the *note __builtin__: 0. module
itself.  ‘__builtins__’ can be set to a user-created dictionary to
create a weak form of restricted execution.

*CPython implementation detail:* Users should not touch ‘__builtins__’;
it is strictly an implementation detail.  Users wanting to override
values in the builtins namespace should *note import: 1f4. the *note
__builtin__: 0. (no ’s’) module and modify its attributes appropriately.

  The namespace for a module is automatically created the first time a
module is imported.  The main module for a script is always called *note
__main__: 2.

  The *note global: 543. statement has the same scope as a name binding
operation in the same block.  If the nearest enclosing scope for a free
variable contains a global statement, the free variable is treated as a
global.

  A class definition is an executable statement that may use and define
names.  These references follow the normal rules for name resolution.
The namespace of the class definition becomes the attribute dictionary
of the class.  Names defined at the class scope are not visible in
methods.

* Menu:

* Interaction with dynamic features:: 


File: python.info,  Node: Interaction with dynamic features,  Up: Naming and binding

4.4.1.1 Interaction with dynamic features
.........................................

There are several cases where Python statements are illegal when used in
conjunction with nested scopes that contain free variables.

  If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

  If the wild card form of import — ‘import *’ — is used in a function
and the function contains or is a nested block with free variables, the
compiler will raise a *note SyntaxError: 498.

  If *note exec: 404. is used in a function and the function contains or
is a nested block with free variables, the compiler will raise a *note
SyntaxError: 498. unless the exec explicitly specifies the local
namespace for the *note exec: 404.  (In other words, ‘exec obj’ would be
illegal, but ‘exec obj in ns’ would be legal.)

  The *note eval(): 360, *note execfile(): 436, and *note input(): 3bf.
functions and the *note exec: 404. statement do not have access to the
full environment for resolving names.  Names may be resolved in the
local and global namespaces of the caller.  Free variables are not
resolved in the nearest enclosing namespace, but in the global
namespace.  (1) The *note exec: 404. statement and the *note eval():
360. and *note execfile(): 436. functions have optional arguments to
override the global and local namespace.  If only one namespace is
specified, it is used for both.

   ---------- Footnotes ----------

   (1) This limitation occurs because the code that is executed by these
operations is not available at the time the module is compiled.


File: python.info,  Node: Exceptions<2>,  Prev: Naming and binding,  Up: Execution model

4.4.2 Exceptions
----------------

Exceptions are a means of breaking out of the normal flow of control of
a code block in order to handle errors or other exceptional conditions.
An exception is _raised_ at the point where the error is detected; it
may be _handled_ by the surrounding code block or by any code block that
directly or indirectly invoked the code block where the error occurred.

  The Python interpreter raises an exception when it detects a run-time
error (such as division by zero).  A Python program can also explicitly
raise an exception with the *note raise: 5b1. statement.  Exception
handlers are specified with the *note try: 395. ...  *note except: 397.
statement.  The *note finally: 396. clause of such a statement can be
used to specify cleanup code which does not handle the exception, but is
executed whether an exception occurred or not in the preceding code.

  Python uses the "termination" model of error handling: an exception
handler can find out what happened and continue execution at an outer
level, but it cannot repair the cause of the error and retry the failing
operation (except by re-entering the offending piece of code from the
top).

  When an exception is not handled at all, the interpreter terminates
execution of the program, or returns to its interactive main loop.  In
either case, it prints a stack backtrace, except when the exception is
*note SystemExit: 332.

  Exceptions are identified by class instances.  The *note except: 397.
clause is selected depending on the class of the instance: it must
reference the class of the instance or a base class thereof.  The
instance can be received by the handler and can carry additional
information about the exceptional condition.

  Exceptions can also be identified by strings, in which case the *note
except: 397. clause is selected by object identity.  An arbitrary value
can be raised along with the identifying string which can be passed to
the handler.

     Note: Messages to exceptions are not part of the Python API. Their
     contents may change from one version of Python to the next without
     warning and should not be relied on by code which will run under
     multiple versions of the interpreter.

  See also the description of the *note try: 395. statement in section
*note The try statement: 395. and *note raise: 5b1. statement in section
*note The raise statement: 5b1.


File: python.info,  Node: Expressions,  Next: Simple statements,  Prev: Execution model,  Up: The Python Language Reference

4.5 Expressions
===============

This chapter explains the meaning of the elements of expressions in
Python.

  *Syntax Notes:* In this and the following chapters, extended BNF
notation will be used to describe syntax, not lexical analysis.  When
(one alternative of) a syntax rule has the form

     name ::= othername


  and no semantics are given, the semantics of this form of ‘name’ are
the same as for ‘othername’.

* Menu:

* Arithmetic conversions:: 
* Atoms:: 
* Primaries:: 
* The power operator:: 
* Unary arithmetic and bitwise operations:: 
* Binary arithmetic operations:: 
* Shifting operations:: 
* Binary bitwise operations:: 
* Comparisons:: 
* Boolean operations:: 
* Conditional Expressions:: 
* Lambdas:: 
* Expression lists:: 
* Evaluation order:: 
* Operator precedence:: 


File: python.info,  Node: Arithmetic conversions,  Next: Atoms,  Up: Expressions

4.5.1 Arithmetic conversions
----------------------------

When a description of an arithmetic operator below uses the phrase "the
numeric arguments are converted to a common type," the arguments are
coerced using the coercion rules listed at *note Coercion rules: 75c.
If both arguments are standard numeric types, the following coercions
are applied:

   * If either argument is a complex number, the other is converted to
     complex;

   * otherwise, if either argument is a floating point number, the other
     is converted to floating point;

   * otherwise, if either argument is a long integer, the other is
     converted to long integer;

   * otherwise, both must be plain integers and no conversion is
     necessary.

  Some additional rules apply for certain operators (e.g., a string left
argument to the ’%’ operator).  Extensions can define their own
coercions.


File: python.info,  Node: Atoms,  Next: Primaries,  Prev: Arithmetic conversions,  Up: Expressions

4.5.2 Atoms
-----------

Atoms are the most basic elements of expressions.  The simplest atoms
are identifiers or literals.  Forms enclosed in reverse quotes or in
parentheses, brackets or braces are also categorized syntactically as
atoms.  The syntax for atoms is:

     atom      ::= identifier | literal | enclosure
     enclosure ::= parenth_form | list_display
                   | generator_expression | dict_display | set_display
                   | string_conversion | yield_atom


* Menu:

* Identifiers (Names): Identifiers Names. 
* Literals: Literals<2>. 
* Parenthesized forms:: 
* List displays:: 
* Displays for sets and dictionaries:: 
* Generator expressions:: 
* Dictionary displays:: 
* Set displays:: 
* String conversions:: 
* Yield expressions:: 


File: python.info,  Node: Identifiers Names,  Next: Literals<2>,  Up: Atoms

4.5.2.1 Identifiers (Names)
...........................

An identifier occurring as an atom is a name.  See section *note
Identifiers and keywords: 6ae. for lexical definition and section *note
Naming and binding: 768. for documentation of naming and binding.

  When the name is bound to an object, evaluation of the atom yields
that object.  When a name is not bound, an attempt to evaluate it raises
a *note NameError: 3a3. exception.

  *Private name mangling:* When an identifier that textually occurs in a
class definition begins with two or more underscore characters and does
not end in two or more underscores, it is considered a _private name_ of
that class.  Private names are transformed to a longer form before code
is generated for them.  The transformation inserts the class name, with
leading underscores removed and a single underscore inserted, in front
of the name.  For example, the identifier ‘__spam’ occurring in a class
named ‘Ham’ will be transformed to ‘_Ham__spam’.  This transformation is
independent of the syntactical context in which the identifier is used.
If the transformed name is extremely long (longer than 255 characters),
implementation defined truncation may happen.  If the class name
consists only of underscores, no transformation is done.


File: python.info,  Node: Literals<2>,  Next: Parenthesized forms,  Prev: Identifiers Names,  Up: Atoms

4.5.2.2 Literals
................

Python supports string literals and various numeric literals:

     literal ::= stringliteral | integer | longinteger
                 | floatnumber | imagnumber


  Evaluation of a literal yields an object of the given type (string,
integer, long integer, floating point number, complex number) with the
given value.  The value may be approximated in the case of floating
point and imaginary (complex) literals.  See section *note Literals:
6bb. for details.

  All literals correspond to immutable data types, and hence the
object’s identity is less important than its value.  Multiple
evaluations of literals with the same value (either the same occurrence
in the program text or a different occurrence) may obtain the same
object or a different object with the same value.


File: python.info,  Node: Parenthesized forms,  Next: List displays,  Prev: Literals<2>,  Up: Atoms

4.5.2.3 Parenthesized forms
...........................

A parenthesized form is an optional expression list enclosed in
parentheses:

     parenth_form ::= "(" [expression_list] ")"


  A parenthesized expression list yields whatever that expression list
yields: if the list contains at least one comma, it yields a tuple;
otherwise, it yields the single expression that makes up the expression
list.

  An empty pair of parentheses yields an empty tuple object.  Since
tuples are immutable, the rules for literals apply (i.e., two
occurrences of the empty tuple may or may not yield the same object).

  Note that tuples are not formed by the parentheses, but rather by use
of the comma operator.  The exception is the empty tuple, for which
parentheses _are_ required — allowing unparenthesized "nothing" in
expressions would cause ambiguities and allow common typos to pass
uncaught.


File: python.info,  Node: List displays,  Next: Displays for sets and dictionaries,  Prev: Parenthesized forms,  Up: Atoms

4.5.2.4 List displays
.....................

A list display is a possibly empty series of expressions enclosed in
square brackets:

     list_display        ::= "[" [expression_list | list_comprehension] "]"
     list_comprehension  ::= expression list_for
     list_for            ::= "for" target_list "in" old_expression_list [list_iter]
     old_expression_list ::= old_expression [("," old_expression)+ [","]]
     old_expression      ::= or_test | old_lambda_expr
     list_iter           ::= list_for | list_if
     list_if             ::= "if" old_expression [list_iter]


  A list display yields a new list object.  Its contents are specified
by providing either a list of expressions or a list comprehension.  When
a comma-separated list of expressions is supplied, its elements are
evaluated from left to right and placed into the list object in that
order.  When a list comprehension is supplied, it consists of a single
expression followed by at least one *note for: 2f0. clause and zero or
more *note for: 2f0. or *note if: 42c. clauses.  In this case, the
elements of the new list are those that would be produced by considering
each of the *note for: 2f0. or *note if: 42c. clauses a block, nesting
from left to right, and evaluating the expression to produce a list
element each time the innermost block is reached (1).

   ---------- Footnotes ----------

   (1) In Python 2.3 and later releases, a list comprehension "leaks"
the control variables of each ‘for’ it contains into the containing
scope.  However, this behavior is deprecated, and relying on it will not
work in Python 3.


File: python.info,  Node: Displays for sets and dictionaries,  Next: Generator expressions,  Prev: List displays,  Up: Atoms

4.5.2.5 Displays for sets and dictionaries
..........................................

For constructing a set or a dictionary Python provides special syntax
called "displays", each of them in two flavors:

   * either the container contents are listed explicitly, or

   * they are computed via a set of looping and filtering instructions,
     called a _comprehension_.

  Common syntax elements for comprehensions are:

     comprehension ::= expression comp_for
     comp_for      ::= "for" target_list "in" or_test [comp_iter]
     comp_iter     ::= comp_for | comp_if
     comp_if       ::= "if" expression_nocond [comp_iter]


  The comprehension consists of a single expression followed by at least
one *note for: 2f0. clause and zero or more *note for: 2f0. or *note if:
42c. clauses.  In this case, the elements of the new container are those
that would be produced by considering each of the *note for: 2f0. or
*note if: 42c. clauses a block, nesting from left to right, and
evaluating the expression to produce an element each time the innermost
block is reached.

  Note that the comprehension is executed in a separate scope, so names
assigned to in the target list don’t "leak" in the enclosing scope.


File: python.info,  Node: Generator expressions,  Next: Dictionary displays,  Prev: Displays for sets and dictionaries,  Up: Atoms

4.5.2.6 Generator expressions
.............................

A generator expression is a compact generator notation in parentheses:

     generator_expression ::= "(" expression comp_for ")"


  A generator expression yields a new generator object.  Its syntax is
the same as for comprehensions, except that it is enclosed in
parentheses instead of brackets or curly braces.

  Variables used in the generator expression are evaluated lazily when
the ‘__next__()’ method is called for generator object (in the same
fashion as normal generators).  However, the leftmost *note for: 2f0.
clause is immediately evaluated, so that an error produced by it can be
seen before any other possible error in the code that handles the
generator expression.  Subsequent *note for: 2f0. clauses cannot be
evaluated immediately since they may depend on the previous *note for:
2f0. loop.  For example: ‘(x*y for x in range(10) for y in bar(x))’.

  The parentheses can be omitted on calls with only one argument.  See
section *note Calls: 6f7. for the detail.


File: python.info,  Node: Dictionary displays,  Next: Set displays,  Prev: Generator expressions,  Up: Atoms

4.5.2.7 Dictionary displays
...........................

A dictionary display is a possibly empty series of key/datum pairs
enclosed in curly braces:

     dict_display       ::= "{" [key_datum_list | dict_comprehension] "}"
     key_datum_list     ::= key_datum ("," key_datum)* [","]
     key_datum          ::= expression ":" expression
     dict_comprehension ::= expression ":" expression comp_for


  A dictionary display yields a new dictionary object.

  If a comma-separated sequence of key/datum pairs is given, they are
evaluated from left to right to define the entries of the dictionary:
each key object is used as a key into the dictionary to store the
corresponding datum.  This means that you can specify the same key
multiple times in the key/datum list, and the final dictionary’s value
for that key will be the last one given.

  A dict comprehension, in contrast to list and set comprehensions,
needs two expressions separated with a colon followed by the usual "for"
and "if" clauses.  When the comprehension is run, the resulting key and
value elements are inserted in the new dictionary in the order they are
produced.

  Restrictions on the types of the key values are listed earlier in
section *note The standard type hierarchy: 6ed.  (To summarize, the key
type should be *note hashable: 6f5, which excludes all mutable objects.)
Clashes between duplicate keys are not detected; the last datum
(textually rightmost in the display) stored for a given key value
prevails.


File: python.info,  Node: Set displays,  Next: String conversions,  Prev: Dictionary displays,  Up: Atoms

4.5.2.8 Set displays
....................

A set display is denoted by curly braces and distinguishable from
dictionary displays by the lack of colons separating keys and values:

     set_display ::= "{" (expression_list | comprehension) "}"


  A set display yields a new mutable set object, the contents being
specified by either a sequence of expressions or a comprehension.  When
a comma-separated list of expressions is supplied, its elements are
evaluated from left to right and added to the set object.  When a
comprehension is supplied, the set is constructed from the elements
resulting from the comprehension.

  An empty set cannot be constructed with ‘{}’; this literal constructs
an empty dictionary.


File: python.info,  Node: String conversions,  Next: Yield expressions,  Prev: Set displays,  Up: Atoms

4.5.2.9 String conversions
..........................

A string conversion is an expression list enclosed in reverse (a.k.a.
backward) quotes:

     string_conversion ::= "`" expression_list "`"


  A string conversion evaluates the contained expression list and
converts the resulting object into a string according to rules specific
to its type.

  If the object is a string, a number, ‘None’, or a tuple, list or
dictionary containing only objects whose type is one of these, the
resulting string is a valid Python expression which can be passed to the
built-in function *note eval(): 360. to yield an expression with the
same value (or an approximation, if floating point numbers are
involved).

  (In particular, converting a string adds quotes around it and converts
"funny" characters to escape sequences that are safe to print.)

  Recursive objects (for example, lists or dictionaries that contain a
reference to themselves, directly or indirectly) use ‘...’ to indicate a
recursive reference, and the result cannot be passed to *note eval():
360. to get an equal value (*note SyntaxError: 498. will be raised
instead).

  The built-in function *note repr(): 145. performs exactly the same
conversion in its argument as enclosing it in parentheses and reverse
quotes does.  The built-in function *note str(): 1ea. performs a similar
but more user-friendly conversion.


File: python.info,  Node: Yield expressions,  Prev: String conversions,  Up: Atoms

4.5.2.10 Yield expressions
..........................

     yield_atom       ::= "(" yield_expression ")"
     yield_expression ::= "yield" [expression_list]


  New in version 2.5.

  The *note yield: 2f7. expression is only used when defining a
generator function, and can only be used in the body of a function
definition.  Using a *note yield: 2f7. expression in a function
definition is sufficient to cause that definition to create a generator
function instead of a normal function.

  When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of a generator
function.  The execution starts when one of the generator’s methods is
called.  At that time, the execution proceeds to the first *note yield:
2f7. expression, where it is suspended again, returning the value of
*note expression_list: 7a0. to generator’s caller.  By suspended we mean
that all local state is retained, including the current bindings of
local variables, the instruction pointer, and the internal evaluation
stack.  When the execution is resumed by calling one of the generator’s
methods, the function can proceed exactly as if the *note yield: 2f7.
expression was just another external call.  The value of the *note
yield: 2f7. expression after resuming depends on the method which
resumed the execution.

  All of this makes generator functions quite similar to coroutines;
they yield multiple times, they have more than one entry point and their
execution can be suspended.  The only difference is that a generator
function cannot control where should the execution continue after it
yields; the control is always transferred to the generator’s caller.

* Menu:

* Generator-iterator methods:: 


File: python.info,  Node: Generator-iterator methods,  Up: Yield expressions

4.5.2.11 Generator-iterator methods
...................................

This subsection describes the methods of a generator iterator.  They can
be used to control the execution of a generator function.

  Note that calling any of the generator methods below when the
generator is already executing raises a *note ValueError: 236.
exception.

 -- Class: generator

 -- Method: generator.next ()

     Starts the execution of a generator function or resumes it at the
     last executed *note yield: 2f7. expression.  When a generator
     function is resumed with a *note next(): 399. method, the current
     *note yield: 2f7. expression always evaluates to *note None: 39a.
     The execution then continues to the next *note yield: 2f7.
     expression, where the generator is suspended again, and the value
     of the *note expression_list: 7a0. is returned to *note next():
     399.’s caller.  If the generator exits without yielding another
     value, a *note StopIteration: 333. exception is raised.

 -- Class: .

 -- Method: generator.send (value)

     Resumes the execution and "sends" a value into the generator
     function.  The ‘value’ argument becomes the result of the current
     *note yield: 2f7. expression.  The *note send(): 7a4. method
     returns the next value yielded by the generator, or raises *note
     StopIteration: 333. if the generator exits without yielding another
     value.  When *note send(): 7a4. is called to start the generator,
     it must be called with *note None: 39a. as the argument, because
     there is no *note yield: 2f7. expression that could receive the
     value.

 -- Method: generator.throw (type[, value[, traceback]])

     Raises an exception of type ‘type’ at the point where generator was
     paused, and returns the next value yielded by the generator
     function.  If the generator exits without yielding another value, a
     *note StopIteration: 333. exception is raised.  If the generator
     function does not catch the passed-in exception, or raises a
     different exception, then that exception propagates to the caller.

 -- Method: generator.close ()

     Raises a *note GeneratorExit: 337. at the point where the generator
     function was paused.  If the generator function then raises *note
     StopIteration: 333. (by exiting normally, or due to already being
     closed) or *note GeneratorExit: 337. (by not catching the
     exception), close returns to its caller.  If the generator yields a
     value, a *note RuntimeError: 39b. is raised.  If the generator
     raises any other exception, it is propagated to the caller.  *note
     close(): 7a6. does nothing if the generator has already exited due
     to an exception or normal exit.

  Here is a simple example that demonstrates the behavior of generators
and generator functions:

     >>> def echo(value=None):
     ...     print "Execution starts when 'next()' is called for the first time."
     ...     try:
     ...         while True:
     ...             try:
     ...                 value = (yield value)
     ...             except Exception, e:
     ...                 value = e
     ...     finally:
     ...         print "Don't forget to clean up when 'close()' is called."
     ...
     >>> generator = echo(1)
     >>> print generator.next()
     Execution starts when 'next()' is called for the first time.
     1
     >>> print generator.next()
     None
     >>> print generator.send(2)
     2
     >>> generator.throw(TypeError, "spam")
     TypeError('spam',)
     >>> generator.close()
     Don't forget to clean up when 'close()' is called.

See also
........

PEP 0342(1) - Coroutines via Enhanced Generators

     The proposal to enhance the API and syntax of generators, making
     them usable as simple coroutines.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0342


File: python.info,  Node: Primaries,  Next: The power operator,  Prev: Atoms,  Up: Expressions

4.5.3 Primaries
---------------

Primaries represent the most tightly bound operations of the language.
Their syntax is:

     primary ::= atom | attributeref | subscription | slicing | call


* Menu:

* Attribute references:: 
* Subscriptions:: 
* Slicings:: 
* Calls:: 


File: python.info,  Node: Attribute references,  Next: Subscriptions,  Up: Primaries

4.5.3.1 Attribute references
............................

An attribute reference is a primary followed by a period and a name:

     attributeref ::= primary "." identifier


  The primary must evaluate to an object of a type that supports
attribute references, e.g., a module, list, or an instance.  This object
is then asked to produce the attribute whose name is the identifier.  If
this attribute is not available, the exception *note AttributeError:
1f8. is raised.  Otherwise, the type and value of the object produced is
determined by the object.  Multiple evaluations of the same attribute
reference may yield different objects.


File: python.info,  Node: Subscriptions,  Next: Slicings,  Prev: Attribute references,  Up: Primaries

4.5.3.2 Subscriptions
.....................

A subscription selects an item of a sequence (string, tuple or list) or
mapping (dictionary) object:

     subscription ::= primary "[" expression_list "]"


  The primary must evaluate to an object of a sequence or mapping type.

  If the primary is a mapping, the expression list must evaluate to an
object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that
key.  (The expression list is a tuple except if it has exactly one
item.)

  If the primary is a sequence, the expression (list) must evaluate to a
plain integer.  If this value is negative, the length of the sequence is
added to it (so that, e.g., ‘x[-1]’ selects the last item of ‘x’.)  The
resulting value must be a nonnegative integer less than the number of
items in the sequence, and the subscription selects the item whose index
is that value (counting from zero).

  A string’s items are characters.  A character is not a separate data
type but a string of exactly one character.


File: python.info,  Node: Slicings,  Next: Calls,  Prev: Subscriptions,  Up: Primaries

4.5.3.3 Slicings
................

A slicing selects a range of items in a sequence object (e.g., a string,
tuple or list).  Slicings may be used as expressions or as targets in
assignment or *note del: 568. statements.  The syntax for a slicing:

     slicing          ::= simple_slicing | extended_slicing
     simple_slicing   ::= primary "[" short_slice "]"
     extended_slicing ::= primary "[" slice_list "]"
     slice_list       ::= slice_item ("," slice_item)* [","]
     slice_item       ::= expression | proper_slice | ellipsis
     proper_slice     ::= short_slice | long_slice
     short_slice      ::= [lower_bound] ":" [upper_bound]
     long_slice       ::= short_slice ":" [stride]
     lower_bound      ::= expression
     upper_bound      ::= expression
     stride           ::= expression
     ellipsis         ::= "..."


  There is ambiguity in the formal syntax here: anything that looks like
an expression list also looks like a slice list, so any subscription can
be interpreted as a slicing.  Rather than further complicating the
syntax, this is disambiguated by defining that in this case the
interpretation as a subscription takes priority over the interpretation
as a slicing (this is the case if the slice list contains no proper
slice nor ellipses).  Similarly, when the slice list has exactly one
short slice and no trailing comma, the interpretation as a simple
slicing takes priority over that as an extended slicing.

  The semantics for a simple slicing are as follows.  The primary must
evaluate to a sequence object.  The lower and upper bound expressions,
if present, must evaluate to plain integers; defaults are zero and the
‘sys.maxint’, respectively.  If either bound is negative, the sequence’s
length is added to it.  The slicing now selects all items with index _k_
such that ‘i <= k < j’ where _i_ and _j_ are the specified lower and
upper bounds.  This may be an empty sequence.  It is not an error if _i_
or _j_ lie outside the range of valid indexes (such items don’t exist so
they aren’t selected).

  The semantics for an extended slicing are as follows.  The primary
must evaluate to a mapping object, and it is indexed with a key that is
constructed from the slice list, as follows.  If the slice list contains
at least one comma, the key is a tuple containing the conversion of the
slice items; otherwise, the conversion of the lone slice item is the
key.  The conversion of a slice item that is an expression is that
expression.  The conversion of an ellipsis slice item is the built-in
‘Ellipsis’ object.  The conversion of a proper slice is a slice object
(see section *note The standard type hierarchy: 6ed.) whose ‘start’,
‘stop’ and ‘step’ attributes are the values of the expressions given as
lower bound, upper bound and stride, respectively, substituting ‘None’
for missing expressions.


File: python.info,  Node: Calls,  Prev: Slicings,  Up: Primaries

4.5.3.4 Calls
.............

A call calls a callable object (e.g., a *note function: 7bf.) with a
possibly empty series of *note arguments: 7c0.:

     call                 ::= primary "(" [argument_list [","]
                              | expression genexpr_for] ")"
     argument_list        ::= positional_arguments ["," keyword_arguments]
                                ["," "*" expression] ["," keyword_arguments]
                                ["," "**" expression]
                              | keyword_arguments ["," "*" expression]
                                ["," "**" expression]
                              | "*" expression ["," "*" expression] ["," "**" expression]
                              | "**" expression
     positional_arguments ::= expression ("," expression)*
     keyword_arguments    ::= keyword_item ("," keyword_item)*
     keyword_item         ::= identifier "=" expression


  A trailing comma may be present after the positional and keyword
arguments but does not affect the semantics.

  The primary must evaluate to a callable object (user-defined
functions, built-in functions, methods of built-in objects, class
objects, methods of class instances, and certain class instances
themselves are callable; extensions may define additional callable
object types).  All argument expressions are evaluated before the call
is attempted.  Please refer to section *note Function definitions: 6f8.
for the syntax of formal *note parameter: 7c6. lists.

  If keyword arguments are present, they are first converted to
positional arguments, as follows.  First, a list of unfilled slots is
created for the formal parameters.  If there are N positional arguments,
they are placed in the first N slots.  Next, for each keyword argument,
the identifier is used to determine the corresponding slot (if the
identifier is the same as the first formal parameter name, the first
slot is used, and so on).  If the slot is already filled, a *note
TypeError: 218. exception is raised.  Otherwise, the value of the
argument is placed in the slot, filling it (even if the expression is
‘None’, it fills the slot).  When all arguments have been processed, the
slots that are still unfilled are filled with the corresponding default
value from the function definition.  (Default values are calculated,
once, when the function is defined; thus, a mutable object such as a
list or dictionary used as default value will be shared by all calls
that don’t specify an argument value for the corresponding slot; this
should usually be avoided.)  If there are any unfilled slots for which
no default value is specified, a *note TypeError: 218. exception is
raised.  Otherwise, the list of filled slots is used as the argument
list for the call.

*CPython implementation detail:* An implementation may provide built-in
functions whose positional parameters do not have names, even if they
are ’named’ for the purpose of documentation, and which therefore cannot
be supplied by keyword.  In CPython, this is the case for functions
implemented in C that use *note PyArg_ParseTuple(): 31b. to parse their
arguments.

  If there are more positional arguments than there are formal parameter
slots, a *note TypeError: 218. exception is raised, unless a formal
parameter using the syntax ‘*identifier’ is present; in this case, that
formal parameter receives a tuple containing the excess positional
arguments (or an empty tuple if there were no excess positional
arguments).

  If any keyword argument does not correspond to a formal parameter
name, a *note TypeError: 218. exception is raised, unless a formal
parameter using the syntax ‘**identifier’ is present; in this case, that
formal parameter receives a dictionary containing the excess keyword
arguments (using the keywords as keys and the argument values as
corresponding values), or a (new) empty dictionary if there were no
excess keyword arguments.

  If the syntax ‘*expression’ appears in the function call, ‘expression’
must evaluate to an iterable.  Elements from this iterable are treated
as if they were additional positional arguments; if there are positional
arguments _x1_, ..., _xN_, and ‘expression’ evaluates to a sequence
_y1_, ..., _yM_, this is equivalent to a call with M+N positional
arguments _x1_, ..., _xN_, _y1_, ..., _yM_.

  A consequence of this is that although the ‘*expression’ syntax may
appear _after_ some keyword arguments, it is processed _before_ the
keyword arguments (and the ‘**expression’ argument, if any – see below).
So:

     >>> def f(a, b):
     ...  print a, b
     ...
     >>> f(b=1, *(2,))
     2 1
     >>> f(a=1, *(2,))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: f() got multiple values for keyword argument 'a'
     >>> f(1, *(2,))
     1 2

  It is unusual for both keyword arguments and the ‘*expression’ syntax
to be used in the same call, so in practice this confusion does not
arise.

  If the syntax ‘**expression’ appears in the function call,
‘expression’ must evaluate to a mapping, the contents of which are
treated as additional keyword arguments.  In the case of a keyword
appearing in both ‘expression’ and as an explicit keyword argument, a
*note TypeError: 218. exception is raised.

  Formal parameters using the syntax ‘*identifier’ or ‘**identifier’
cannot be used as positional argument slots or as keyword argument
names.  Formal parameters using the syntax ‘(sublist)’ cannot be used as
keyword argument names; the outermost sublist corresponds to a single
unnamed argument slot, and the argument value is assigned to the sublist
using the usual tuple assignment rules after all other parameter
processing is done.

  A call always returns some value, possibly ‘None’, unless it raises an
exception.  How this value is computed depends on the type of the
callable object.

  If it is—

a user-defined function:

     The code block for the function is executed, passing it the
     argument list.  The first thing the code block will do is bind the
     formal parameters to the arguments; this is described in section
     *note Function definitions: 6f8.  When the code block executes a
     *note return: 2f4. statement, this specifies the return value of
     the function call.

a built-in function or method:

     The result is up to the interpreter; see *note Built-in Functions:
     7c7. for the descriptions of built-in functions and methods.

a class object:

     A new instance of that class is returned.

a class instance method:

     The corresponding user-defined function is called, with an argument
     list that is one longer than the argument list of the call: the
     instance becomes the first argument.

a class instance:

     The class must define a *note __call__(): 6fa. method; the effect
     is then the same as if that method was called.


File: python.info,  Node: The power operator,  Next: Unary arithmetic and bitwise operations,  Prev: Primaries,  Up: Expressions

4.5.4 The power operator
------------------------

The power operator binds more tightly than unary operators on its left;
it binds less tightly than unary operators on its right.  The syntax is:

     power ::= primary ["**" u_expr]


  Thus, in an unparenthesized sequence of power and unary operators, the
operators are evaluated from right to left (this does not constrain the
evaluation order for the operands): ‘-1**2’ results in ‘-1’.

  The power operator has the same semantics as the built-in *note pow():
4b5. function, when called with two arguments: it yields its left
argument raised to the power of its right argument.  The numeric
arguments are first converted to a common type.  The result type is that
of the arguments after coercion.

  With mixed operand types, the coercion rules for binary arithmetic
operators apply.  For int and long int operands, the result has the same
type as the operands (after coercion) unless the second argument is
negative; in that case, all arguments are converted to float and a float
result is delivered.  For example, ‘10**2’ returns ‘100’, but ‘10**-2’
returns ‘0.01’.  (This last feature was added in Python 2.2.  In Python
2.1 and before, if both arguments were of integer types and the second
argument was negative, an exception was raised).

  Raising ‘0.0’ to a negative power results in a *note
ZeroDivisionError: 5ac.  Raising a negative number to a fractional power
results in a *note ValueError: 236.


File: python.info,  Node: Unary arithmetic and bitwise operations,  Next: Binary arithmetic operations,  Prev: The power operator,  Up: Expressions

4.5.5 Unary arithmetic and bitwise operations
---------------------------------------------

All unary arithmetic and bitwise operations have the same priority:

     u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr


  The unary ‘-’ (minus) operator yields the negation of its numeric
argument.

  The unary ‘+’ (plus) operator yields its numeric argument unchanged.

  The unary ‘~’ (invert) operator yields the bitwise inversion of its
plain or long integer argument.  The bitwise inversion of ‘x’ is defined
as ‘-(x+1)’.  It only applies to integral numbers.

  In all three cases, if the argument does not have the proper type, a
*note TypeError: 218. exception is raised.


File: python.info,  Node: Binary arithmetic operations,  Next: Shifting operations,  Prev: Unary arithmetic and bitwise operations,  Up: Expressions

4.5.6 Binary arithmetic operations
----------------------------------

The binary arithmetic operations have the conventional priority levels.
Note that some of these operations also apply to certain non-numeric
types.  Apart from the power operator, there are only two levels, one
for multiplicative operators and one for additive operators:

     m_expr ::= u_expr | m_expr "*" u_expr | m_expr "//" u_expr | m_expr "/" u_expr
                | m_expr "%" u_expr
     a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr


  The ‘*’ (multiplication) operator yields the product of its arguments.
The arguments must either both be numbers, or one argument must be an
integer (plain or long) and the other must be a sequence.  In the former
case, the numbers are converted to a common type and then multiplied
together.  In the latter case, sequence repetition is performed; a
negative repetition factor yields an empty sequence.

  The ‘/’ (division) and ‘//’ (floor division) operators yield the
quotient of their arguments.  The numeric arguments are first converted
to a common type.  Plain or long integer division yields an integer of
the same type; the result is that of mathematical division with the
’floor’ function applied to the result.  Division by zero raises the
*note ZeroDivisionError: 5ac. exception.

  The ‘%’ (modulo) operator yields the remainder from the division of
the first argument by the second.  The numeric arguments are first
converted to a common type.  A zero right argument raises the *note
ZeroDivisionError: 5ac. exception.  The arguments may be floating point
numbers, e.g., ‘3.14%0.7’ equals ‘0.34’ (since ‘3.14’ equals ‘4*0.7 +
0.34’.)  The modulo operator always yields a result with the same sign
as its second operand (or zero); the absolute value of the result is
strictly smaller than the absolute value of the second operand (1).

  The integer division and modulo operators are connected by the
following identity: ‘x == (x/y)*y + (x%y)’.  Integer division and modulo
are also connected with the built-in function *note divmod(): 73d.:
‘divmod(x, y) == (x/y, x%y)’.  These identities don’t hold for floating
point numbers; there similar identities hold approximately where ‘x/y’
is replaced by ‘floor(x/y)’ or ‘floor(x/y) - 1’ (2).

  In addition to performing the modulo operation on numbers, the ‘%’
operator is also overloaded by string and unicode objects to perform
string formatting (also known as interpolation).  The syntax for string
formatting is described in the Python Library Reference, section *note
String Formatting Operations: 524.

  Deprecated since version 2.3: The floor division operator, the modulo
operator, and the *note divmod(): 73d. function are no longer defined
for complex numbers.  Instead, convert to a floating point number using
the *note abs(): 5bf. function if appropriate.

  The ‘+’ (addition) operator yields the sum of its arguments.  The
arguments must either both be numbers or both sequences of the same
type.  In the former case, the numbers are converted to a common type
and then added together.  In the latter case, the sequences are
concatenated.

  The ‘-’ (subtraction) operator yields the difference of its arguments.
The numeric arguments are first converted to a common type.

   ---------- Footnotes ----------

   (1) While ‘abs(x%y) < abs(y)’ is true mathematically, for floats it
may not be true numerically due to roundoff.  For example, and assuming
a platform on which a Python float is an IEEE 754 double-precision
number, in order that ‘-1e-100 % 1e100’ have the same sign as ‘1e100’,
the computed result is ‘-1e-100 + 1e100’, which is numerically exactly
equal to ‘1e100’.  The function *note math.fmod(): 7d2. returns a result
whose sign matches the sign of the first argument instead, and so
returns ‘-1e-100’ in this case.  Which approach is more appropriate
depends on the application.

   (2) If x is very close to an exact integer multiple of y, it’s
possible for ‘floor(x/y)’ to be one larger than ‘(x-x%y)/y’ due to
rounding.  In such cases, Python returns the latter result, in order to
preserve that ‘divmod(x,y)[0] * y + x % y’ be very close to ‘x’.


File: python.info,  Node: Shifting operations,  Next: Binary bitwise operations,  Prev: Binary arithmetic operations,  Up: Expressions

4.5.7 Shifting operations
-------------------------

The shifting operations have lower priority than the arithmetic
operations:

     shift_expr ::= a_expr | shift_expr ( "<<" | ">>" ) a_expr


  These operators accept plain or long integers as arguments.  The
arguments are converted to a common type.  They shift the first argument
to the left or right by the number of bits given by the second argument.

  A right shift by _n_ bits is defined as division by ‘pow(2, n)’.  A
left shift by _n_ bits is defined as multiplication with ‘pow(2, n)’.
Negative shift counts raise a *note ValueError: 236. exception.

     Note: In the current implementation, the right-hand operand is
     required to be at most *note sys.maxsize: 7d6.  If the right-hand
     operand is larger than *note sys.maxsize: 7d6. an *note
     OverflowError: 2db. exception is raised.


File: python.info,  Node: Binary bitwise operations,  Next: Comparisons,  Prev: Shifting operations,  Up: Expressions

4.5.8 Binary bitwise operations
-------------------------------

Each of the three bitwise operations has a different priority level:

     and_expr ::= shift_expr | and_expr "&" shift_expr
     xor_expr ::= and_expr | xor_expr "^" and_expr
     or_expr  ::= xor_expr | or_expr "|" xor_expr


  The ‘&’ operator yields the bitwise AND of its arguments, which must
be plain or long integers.  The arguments are converted to a common
type.

  The ‘^’ operator yields the bitwise XOR (exclusive OR) of its
arguments, which must be plain or long integers.  The arguments are
converted to a common type.

  The ‘|’ operator yields the bitwise (inclusive) OR of its arguments,
which must be plain or long integers.  The arguments are converted to a
common type.


File: python.info,  Node: Comparisons,  Next: Boolean operations,  Prev: Binary bitwise operations,  Up: Expressions

4.5.9 Comparisons
-----------------

Unlike C, all comparison operations in Python have the same priority,
which is lower than that of any arithmetic, shifting or bitwise
operation.  Also unlike C, expressions like ‘a < b < c’ have the
interpretation that is conventional in mathematics:

     comparison    ::= or_expr ( comp_operator or_expr )*
     comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="
                       | "is" ["not"] | ["not"] "in"


  Comparisons yield boolean values: ‘True’ or ‘False’.

  Comparisons can be chained arbitrarily, e.g., ‘x < y <= z’ is
equivalent to ‘x < y and y <= z’, except that ‘y’ is evaluated only once
(but in both cases ‘z’ is not evaluated at all when ‘x < y’ is found to
be false).

  Formally, if _a_, _b_, _c_, ..., _y_, _z_ are expressions and _op1_,
_op2_, ..., _opN_ are comparison operators, then ‘a op1 b op2 c ... y
opN z’ is equivalent to ‘a op1 b and b op2 c and ... y opN z’, except
that each expression is evaluated at most once.

  Note that ‘a op1 b op2 c’ doesn’t imply any kind of comparison between
_a_ and _c_, so that, e.g., ‘x < y > z’ is perfectly legal (though
perhaps not pretty).

  The forms ‘<>’ and ‘!=’ are equivalent; for consistency with C, ‘!=’
is preferred; where ‘!=’ is mentioned below ‘<>’ is also accepted.  The
‘<>’ spelling is considered obsolescent.

  The operators ‘<’, ‘>’, ‘==’, ‘>=’, ‘<=’, and ‘!=’ compare the values
of two objects.  The objects need not have the same type.  If both are
numbers, they are converted to a common type.  Otherwise, objects of
different types _always_ compare unequal, and are ordered consistently
but arbitrarily.  You can control comparison behavior of objects of
non-built-in types by defining a ‘__cmp__’ method or rich comparison
methods like ‘__gt__’, described in section *note Special method names:
6b8.

  (This unusual definition of comparison was used to simplify the
definition of operations like sorting and the *note in: 428. and *note
not in: 72c. operators.  In the future, the comparison rules for objects
of different types are likely to change.)

  Comparison of objects of the same type depends on the type:

   * Numbers are compared arithmetically.

   * Strings are compared lexicographically using the numeric
     equivalents (the result of the built-in function *note ord(): 6f3.)
     of their characters.  Unicode and 8-bit strings are fully
     interoperable in this behavior.  (1)

   * Tuples and lists are compared lexicographically using comparison of
     corresponding elements.  This means that to compare equal, each
     element must compare equal and the two sequences must be of the
     same type and have the same length.

     If not equal, the sequences are ordered the same as their first
     differing elements.  For example, ‘cmp([1,2,x], [1,2,y])’ returns
     the same as ‘cmp(x,y)’.  If the corresponding element does not
     exist, the shorter sequence is ordered first (for example, ‘[1,2] <
     [1,2,3]’).

   * Mappings (dictionaries) compare equal if and only if their sorted
     (key, value) lists compare equal.  (2) Outcomes other than equality
     are resolved consistently, but are not otherwise defined.  (3)

   * Most other objects of built-in types compare unequal unless they
     are the same object; the choice whether one object is considered
     smaller or larger than another one is made arbitrarily but
     consistently within one execution of a program.
  The operators *note in: 428. and *note not in: 72c. test for
collection membership.  ‘x in s’ evaluates to true if _x_ is a member of
the collection _s_, and false otherwise.  ‘x not in s’ returns the
negation of ‘x in s’.  The collection membership test has traditionally
been bound to sequences; an object is a member of a collection if the
collection is a sequence and contains an element equal to that object.
However, it make sense for many other object types to support membership
tests without being a sequence.  In particular, dictionaries (for keys)
and sets support membership testing.

  For the list and tuple types, ‘x in y’ is true if and only if there
exists an index _i_ such that ‘x == y[i]’ is true.

  For the Unicode and string types, ‘x in y’ is true if and only if _x_
is a substring of _y_.  An equivalent test is ‘y.find(x) != -1’.  Note,
_x_ and _y_ need not be the same type; consequently, ‘u'ab' in 'abc'’
will return ‘True’.  Empty strings are always considered to be a
substring of any other string, so ‘"" in "abc"’ will return ‘True’.

  Changed in version 2.3: Previously, _x_ was required to be a string of
length ‘1’.

  For user-defined classes which define the *note __contains__(): 322.
method, ‘x in y’ is true if and only if ‘y.__contains__(x)’ is true.

  For user-defined classes which do not define *note __contains__():
322. but do define *note __iter__(): 321, ‘x in y’ is true if some value
‘z’ with ‘x == z’ is produced while iterating over ‘y’.  If an exception
is raised during the iteration, it is as if *note in: 428. raised that
exception.

  Lastly, the old-style iteration protocol is tried: if a class defines
*note __getitem__(): 44f, ‘x in y’ is true if and only if there is a
non-negative integer index _i_ such that ‘x == y[i]’, and all lower
integer indices do not raise *note IndexError: 4e1. exception.  (If any
other exception is raised, it is as if *note in: 428. raised that
exception).

  The operator *note not in: 72c. is defined to have the inverse true
value of *note in: 428.

  The operators *note is: 6eb. and *note is not: 7dd. test for object
identity: ‘x is y’ is true if and only if _x_ and _y_ are the same
object.  ‘x is not y’ yields the inverse truth value.  (4)

   ---------- Footnotes ----------

   (1) While comparisons between unicode strings make sense at the byte
level, they may be counter-intuitive to users.  For example, the strings
‘u"\u00C7"’ and ‘u"\u0043\u0327"’ compare differently, even though they
both represent the same unicode character (LATIN CAPITAL LETTER C WITH
CEDILLA). To compare strings in a human recognizable way, compare using
*note unicodedata.normalize(): 7e1.

   (2) The implementation computes this efficiently, without
constructing lists or sorting.

   (3) Earlier versions of Python used lexicographic comparison of the
sorted (key, value) lists, but this was very expensive for the common
case of comparing for equality.  An even earlier version of Python
compared dictionaries by identity only, but this caused surprises
because people expected to be able to test a dictionary for emptiness by
comparing it to ‘{}’.

   (4) Due to automatic garbage-collection, free lists, and the dynamic
nature of descriptors, you may notice seemingly unusual behaviour in
certain uses of the *note is: 6eb. operator, like those involving
comparisons between instance methods, or constants.  Check their
documentation for more info.


File: python.info,  Node: Boolean operations,  Next: Conditional Expressions,  Prev: Comparisons,  Up: Expressions

4.5.10 Boolean operations
-------------------------

     or_test  ::= and_test | or_test "or" and_test
     and_test ::= not_test | and_test "and" not_test
     not_test ::= comparison | "not" not_test


  In the context of Boolean operations, and also when expressions are
used by control flow statements, the following values are interpreted as
false: ‘False’, ‘None’, numeric zero of all types, and empty strings and
containers (including strings, tuples, lists, dictionaries, sets and
frozensets).  All other values are interpreted as true.  (See the *note
__nonzero__(): 70c. special method for a way to change this.)

  The operator *note not: 7e5. yields ‘True’ if its argument is false,
‘False’ otherwise.

  The expression ‘x and y’ first evaluates _x_; if _x_ is false, its
value is returned; otherwise, _y_ is evaluated and the resulting value
is returned.

  The expression ‘x or y’ first evaluates _x_; if _x_ is true, its value
is returned; otherwise, _y_ is evaluated and the resulting value is
returned.

  (Note that neither *note and: 7e3. nor *note or: 7e4. restrict the
value and type they return to ‘False’ and ‘True’, but rather return the
last evaluated argument.  This is sometimes useful, e.g., if ‘s’ is a
string that should be replaced by a default value if it is empty, the
expression ‘s or 'foo'’ yields the desired value.  Because *note not:
7e5. has to invent a value anyway, it does not bother to return a value
of the same type as its argument, so e.g., ‘not 'foo'’ yields ‘False’,
not ‘''’.)


File: python.info,  Node: Conditional Expressions,  Next: Lambdas,  Prev: Boolean operations,  Up: Expressions

4.5.11 Conditional Expressions
------------------------------

New in version 2.5.

     conditional_expression ::= or_test ["if" or_test "else" expression]
     expression             ::= conditional_expression | lambda_expr


  Conditional expressions (sometimes called a "ternary operator") have
the lowest priority of all Python operations.

  The expression ‘x if C else y’ first evaluates the condition, _C_
(_not_ _x_); if _C_ is true, _x_ is evaluated and its value is returned;
otherwise, _y_ is evaluated and its value is returned.

  See PEP 308(1) for more details about conditional expressions.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0308


File: python.info,  Node: Lambdas,  Next: Expression lists,  Prev: Conditional Expressions,  Up: Expressions

4.5.12 Lambdas
--------------

     lambda_expr     ::= "lambda" [parameter_list]: expression
     old_lambda_expr ::= "lambda" [parameter_list]: old_expression


  Lambda expressions (sometimes called lambda forms) have the same
syntactic position as expressions.  They are a shorthand to create
anonymous functions; the expression ‘lambda arguments: expression’
yields a function object.  The unnamed object behaves like a function
object defined with

     def name(arguments):
         return expression

  See section *note Function definitions: 6f8. for the syntax of
parameter lists.  Note that functions created with lambda expressions
cannot contain statements.


File: python.info,  Node: Expression lists,  Next: Evaluation order,  Prev: Lambdas,  Up: Expressions

4.5.13 Expression lists
-----------------------

     expression_list ::= expression ( "," expression )* [","]


  An expression list containing at least one comma yields a tuple.  The
length of the tuple is the number of expressions in the list.  The
expressions are evaluated from left to right.

  The trailing comma is required only to create a single tuple (a.k.a.
a _singleton_); it is optional in all other cases.  A single expression
without a trailing comma doesn’t create a tuple, but rather yields the
value of that expression.  (To create an empty tuple, use an empty pair
of parentheses: ‘()’.)


File: python.info,  Node: Evaluation order,  Next: Operator precedence,  Prev: Expression lists,  Up: Expressions

4.5.14 Evaluation order
-----------------------

Python evaluates expressions from left to right.  Notice that while
evaluating an assignment, the right-hand side is evaluated before the
left-hand side.

  In the following lines, expressions will be evaluated in the
arithmetic order of their suffixes:

     expr1, expr2, expr3, expr4
     (expr1, expr2, expr3, expr4)
     {expr1: expr2, expr3: expr4}
     expr1 + expr2 * (expr3 - expr4)
     expr1(expr2, expr3, *expr4, **expr5)
     expr3, expr4 = expr1, expr2


File: python.info,  Node: Operator precedence,  Prev: Evaluation order,  Up: Expressions

4.5.15 Operator precedence
--------------------------

The following table summarizes the operator precedences in Python, from
lowest precedence (least binding) to highest precedence (most binding).
Operators in the same box have the same precedence.  Unless the syntax
is explicitly given, operators are binary.  Operators in the same box
group left to right (except for comparisons, including tests, which all
have the same precedence and chain from left to right — see section
*note Comparisons: 7dc. — and exponentiation, which groups from right to
left).

Operator                                            Description
                                                    
----------------------------------------------------------------------------------------------
                                                    
*note lambda: 403.                                  Lambda expression
                                                    
                                                    
*note if: 42c. – *note else: 532.                   Conditional expression
                                                    
                                                    
*note or: 7e4.                                      Boolean OR
                                                    
                                                    
*note and: 7e3.                                     Boolean AND
                                                    
                                                    
*note not: 7e5. ‘x’                                 Boolean NOT
                                                    
                                                    
*note in: 428, *note not in: 72c, *note is: 6eb,    Comparisons, including membership tests
*note is not: 7dd, ‘<’, ‘<=’, ‘>’, ‘>=’, ‘<>’,      and identity tests
‘!=’, ‘==’                                          

‘|’                                                 Bitwise OR
                                                    
                                                    
‘^’                                                 Bitwise XOR
                                                    
                                                    
‘&’                                                 Bitwise AND
                                                    
                                                    
‘<<’, ‘>>’                                          Shifts
                                                    
                                                    
‘+’, ‘-’                                            Addition and subtraction
                                                    
                                                    
‘*’, ‘/’, ‘//’, ‘%’                                 Multiplication, division, remainder (1)
                                                    
                                                    
‘+x’, ‘-x’, ‘~x’                                    Positive, negative, bitwise NOT
                                                    
                                                    
‘**’                                                Exponentiation (2)
                                                    
                                                    
‘x[index]’, ‘x[index:index]’, ‘x(arguments...)’,    Subscription, slicing, call, attribute
‘x.attribute’                                       reference
                                                    
                                                    
‘(expressions...)’, ‘[expressions...]’, ‘{key:      Binding or tuple display, list display,
value...}’, ‘`expressions...`’                      dictionary display, string conversion
                                                    

   ---------- Footnotes ----------

   (1) The ‘%’ operator is also used for string formatting; the same
precedence applies.

   (2) The power operator ‘**’ binds less tightly than an arithmetic or
bitwise unary operator on its right, that is, ‘2**-1’ is ‘0.5’.


File: python.info,  Node: Simple statements,  Next: Compound statements,  Prev: Expressions,  Up: The Python Language Reference

4.6 Simple statements
=====================

Simple statements are comprised within a single logical line.  Several
simple statements may occur on a single line separated by semicolons.
The syntax for simple statements is:

     simple_stmt ::= expression_stmt
                     | assert_stmt
                     | assignment_stmt
                     | augmented_assignment_stmt
                     | pass_stmt
                     | del_stmt
                     | print_stmt
                     | return_stmt
                     | yield_stmt
                     | raise_stmt
                     | break_stmt
                     | continue_stmt
                     | import_stmt
                     | global_stmt
                     | exec_stmt


* Menu:

* Expression statements:: 
* Assignment statements:: 
* The assert statement:: 
* The pass statement:: 
* The del statement: The del statement<2>. 
* The print statement:: 
* The return statement:: 
* The yield statement:: 
* The raise statement:: 
* The break statement:: 
* The continue statement:: 
* The import statement:: 
* The global statement:: 
* The exec statement:: 


File: python.info,  Node: Expression statements,  Next: Assignment statements,  Up: Simple statements

4.6.1 Expression statements
---------------------------

Expression statements are used (mostly interactively) to compute and
write a value, or (usually) to call a procedure (a function that returns
no meaningful result; in Python, procedures return the value ‘None’).
Other uses of expression statements are allowed and occasionally useful.
The syntax for an expression statement is:

     expression_stmt ::= expression_list


  An expression statement evaluates the expression list (which may be a
single expression).

  In interactive mode, if the value is not ‘None’, it is converted to a
string using the built-in *note repr(): 145. function and the resulting
string is written to standard output (see section *note The print
statement: 4e0.) on a line by itself.  (Expression statements yielding
‘None’ are not written, so that procedure calls do not cause any
output.)


File: python.info,  Node: Assignment statements,  Next: The assert statement,  Prev: Expression statements,  Up: Simple statements

4.6.2 Assignment statements
---------------------------

Assignment statements are used to (re)bind names to values and to modify
attributes or items of mutable objects:

     assignment_stmt ::= (target_list "=")+ (expression_list | yield_expression)
     target_list     ::= target ("," target)* [","]
     target          ::= identifier
                         | "(" target_list ")"
                         | "[" target_list "]"
                         | attributeref
                         | subscription
                         | slicing


  (See section *note Primaries: 7a7. for the syntax definitions for the
last three symbols.)

  An assignment statement evaluates the expression list (remember that
this can be a single expression or a comma-separated list, the latter
yielding a tuple) and assigns the single resulting object to each of the
target lists, from left to right.

  Assignment is defined recursively depending on the form of the target
(list).  When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must ultimately
perform the assignment and decide about its validity, and may raise an
exception if the assignment is unacceptable.  The rules observed by
various types and the exceptions raised are given with the definition of
the object types (see section *note The standard type hierarchy: 6ed.).

  Assignment of an object to a target list is recursively defined as
follows.

   * If the target list is a single target: The object is assigned to
     that target.

   * If the target list is a comma-separated list of targets: The object
     must be an iterable with the same number of items as there are
     targets in the target list, and the items are assigned, from left
     to right, to the corresponding targets.

  Assignment of an object to a single target is recursively defined as
follows.

   * If the target is an identifier (name):

        * If the name does not occur in a *note global: 543. statement
          in the current code block: the name is bound to the object in
          the current local namespace.

        * Otherwise: the name is bound to the object in the current
          global namespace.

     The name is rebound if it was already bound.  This may cause the
     reference count for the object previously bound to the name to
     reach zero, causing the object to be deallocated and its destructor
     (if it has one) to be called.

   * If the target is a target list enclosed in parentheses or in square
     brackets: The object must be an iterable with the same number of
     items as there are targets in the target list, and its items are
     assigned, from left to right, to the corresponding targets.

   * If the target is an attribute reference: The primary expression in
     the reference is evaluated.  It should yield an object with
     assignable attributes; if this is not the case, *note TypeError:
     218. is raised.  That object is then asked to assign the assigned
     object to the given attribute; if it cannot perform the assignment,
     it raises an exception (usually but not necessarily *note
     AttributeError: 1f8.).  Note: If the object is a class instance and
     the attribute reference occurs on both sides of the assignment
     operator, the RHS expression, ‘a.x’ can access either an instance
     attribute or (if no instance attribute exists) a class attribute.
     The LHS target ‘a.x’ is always set as an instance attribute,
     creating it if necessary.  Thus, the two occurrences of ‘a.x’ do
     not necessarily refer to the same attribute: if the RHS expression
     refers to a class attribute, the LHS creates a new instance
     attribute as the target of the assignment:

          class Cls:
              x = 3             # class variable
          inst = Cls()
          inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3

     This description does not necessarily apply to descriptor
     attributes, such as properties created with *note property(): 487.

   * If the target is a subscription: The primary expression in the
     reference is evaluated.  It should yield either a mutable sequence
     object (such as a list) or a mapping object (such as a dictionary).
     Next, the subscript expression is evaluated.

     If the primary is a mutable sequence object (such as a list), the
     subscript must yield a plain integer.  If it is negative, the
     sequence’s length is added to it.  The resulting value must be a
     nonnegative integer less than the sequence’s length, and the
     sequence is asked to assign the assigned object to its item with
     that index.  If the index is out of range, *note IndexError: 4e1.
     is raised (assignment to a subscripted sequence cannot add new
     items to a list).

     If the primary is a mapping object (such as a dictionary), the
     subscript must have a type compatible with the mapping’s key type,
     and the mapping is then asked to create a key/datum pair which maps
     the subscript to the assigned object.  This can either replace an
     existing key/value pair with the same key value, or insert a new
     key/value pair (if no key with the same value existed).

   * If the target is a slicing: The primary expression in the reference
     is evaluated.  It should yield a mutable sequence object (such as a
     list).  The assigned object should be a sequence object of the same
     type.  Next, the lower and upper bound expressions are evaluated,
     insofar they are present; defaults are zero and the sequence’s
     length.  The bounds should evaluate to (small) integers.  If either
     bound is negative, the sequence’s length is added to it.  The
     resulting bounds are clipped to lie between zero and the sequence’s
     length, inclusive.  Finally, the sequence object is asked to
     replace the slice with the items of the assigned sequence.  The
     length of the slice may be different from the length of the
     assigned sequence, thus changing the length of the target sequence,
     if the object allows it.

*CPython implementation detail:* In the current implementation, the
syntax for targets is taken to be the same as for expressions, and
invalid syntax is rejected during the code generation phase, causing
less detailed error messages.

  WARNING: Although the definition of assignment implies that overlaps
between the left-hand side and the right-hand side are ’safe’ (for
example ‘a, b = b, a’ swaps two variables), overlaps _within_ the
collection of assigned-to variables are not safe!  For instance, the
following program prints ‘[0, 2]’:

     x = [0, 1]
     i = 0
     i, x[i] = 1, 2
     print x

* Menu:

* Augmented assignment statements:: 


File: python.info,  Node: Augmented assignment statements,  Up: Assignment statements

4.6.2.1 Augmented assignment statements
.......................................

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

     augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
     augtarget                 ::= identifier | attributeref | subscription | slicing
     augop                     ::= "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
                                   | ">>=" | "<<=" | "&=" | "^=" | "|="


  (See section *note Primaries: 7a7. for the syntax definitions for the
last three symbols.)

  An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression list,
performs the binary operation specific to the type of assignment on the
two operands, and assigns the result to the original target.  The target
is only evaluated once.

  An augmented assignment expression like ‘x += 1’ can be rewritten as
‘x = x + 1’ to achieve a similar, but not exactly equal effect.  In the
augmented version, ‘x’ is only evaluated once.  Also, when possible, the
actual operation is performed _in-place_, meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

  With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment statements
is handled the same way as normal assignments.  Similarly, with the
exception of the possible _in-place_ behavior, the binary operation
performed by augmented assignment is the same as the normal binary
operations.

  For targets which are attribute references, the same *note caveat
about class and instance attributes: 803. applies as for regular
assignments.


File: python.info,  Node: The assert statement,  Next: The pass statement,  Prev: Assignment statements,  Up: Simple statements

4.6.3 The ‘assert’ statement
----------------------------

Assert statements are a convenient way to insert debugging assertions
into a program:

     assert_stmt ::= "assert" expression ["," expression]


  The simple form, ‘assert expression’, is equivalent to

     if __debug__:
        if not expression: raise AssertionError

  The extended form, ‘assert expression1, expression2’, is equivalent to

     if __debug__:
        if not expression1: raise AssertionError(expression2)

  These equivalences assume that *note __debug__: 80b. and *note
AssertionError: 80c. refer to the built-in variables with those names.
In the current implementation, the built-in variable *note __debug__:
80b. is ‘True’ under normal circumstances, ‘False’ when optimization is
requested (command line option -O). The current code generator emits no
code for an assert statement when optimization is requested at compile
time.  Note that it is unnecessary to include the source code for the
expression that failed in the error message; it will be displayed as
part of the stack trace.

  Assignments to *note __debug__: 80b. are illegal.  The value for the
built-in variable is determined when the interpreter starts.


File: python.info,  Node: The pass statement,  Next: The del statement<2>,  Prev: The assert statement,  Up: Simple statements

4.6.4 The ‘pass’ statement
--------------------------

     pass_stmt ::= "pass"


  *note pass: 53f. is a null operation — when it is executed, nothing
happens.  It is useful as a placeholder when a statement is required
syntactically, but no code needs to be executed, for example:

     def f(arg): pass    # a function that does nothing (yet)

     class C: pass       # a class with no methods (yet)


File: python.info,  Node: The del statement<2>,  Next: The print statement,  Prev: The pass statement,  Up: Simple statements

4.6.5 The ‘del’ statement
-------------------------

     del_stmt ::= "del" target_list


  Deletion is recursively defined very similar to the way assignment is
defined.  Rather than spelling it out in full details, here are some
hints.

  Deletion of a target list recursively deletes each target, from left
to right.

  Deletion of a name removes the binding of that name from the local or
global namespace, depending on whether the name occurs in a *note
global: 543. statement in the same code block.  If the name is unbound,
a *note NameError: 3a3. exception will be raised.

  It is illegal to delete a name from the local namespace if it occurs
as a free variable in a nested block.

  Deletion of attribute references, subscriptions and slicings is passed
to the primary object involved; deletion of a slicing is in general
equivalent to assignment of an empty slice of the right type (but even
this is determined by the sliced object).


File: python.info,  Node: The print statement,  Next: The return statement,  Prev: The del statement<2>,  Up: Simple statements

4.6.6 The ‘print’ statement
---------------------------

     print_stmt ::= "print" ([expression ("," expression)* [","]]
                    | ">>" expression [("," expression)+ [","]])


  *note print: 4e0. evaluates each expression in turn and writes the
resulting object to standard output (see below).  If an object is not a
string, it is first converted to a string using the rules for string
conversions.  The (resulting or original) string is then written.  A
space is written before each object is (converted and) written, unless
the output system believes it is positioned at the beginning of a line.
This is the case (1) when no characters have yet been written to
standard output, (2) when the last character written to standard output
is a whitespace character except ‘' '’, or (3) when the last write
operation on standard output was not a *note print: 4e0. statement.  (In
some cases it may be functional to write an empty string to standard
output for this reason.)

     Note: Objects which act like file objects but which are not the
     built-in file objects often do not properly emulate this aspect of
     the file object’s behavior, so it is best not to rely on this.

  A ‘'\n'’ character is written at the end, unless the *note print: 4e0.
statement ends with a comma.  This is the only action if the statement
contains just the keyword *note print: 4e0.

  Standard output is defined as the file object named ‘stdout’ in the
built-in module *note sys: 16d.  If no such object exists, or if it does
not have a ‘write()’ method, a *note RuntimeError: 39b. exception is
raised.

  *note print: 4e0. also has an extended form, defined by the second
portion of the syntax described above.  This form is sometimes referred
to as "*note print: 4e0. chevron."  In this form, the first expression
after the ‘>>’ must evaluate to a "file-like" object, specifically an
object that has a ‘write()’ method as described above.  With this
extended form, the subsequent expressions are printed to this file
object.  If the first expression evaluates to ‘None’, then ‘sys.stdout’
is used as the file for output.


File: python.info,  Node: The return statement,  Next: The yield statement,  Prev: The print statement,  Up: Simple statements

4.6.7 The ‘return’ statement
----------------------------

     return_stmt ::= "return" [expression_list]


  *note return: 2f4. may only occur syntactically nested in a function
definition, not within a nested class definition.

  If an expression list is present, it is evaluated, else ‘None’ is
substituted.

  *note return: 2f4. leaves the current function call with the
expression list (or ‘None’) as return value.

  When *note return: 2f4. passes control out of a *note try: 395.
statement with a *note finally: 396. clause, that *note finally: 396.
clause is executed before really leaving the function.

  In a generator function, the *note return: 2f4. statement is not
allowed to include an *note expression_list: 7a0.  In that context, a
bare *note return: 2f4. indicates that the generator is done and will
cause *note StopIteration: 333. to be raised.


File: python.info,  Node: The yield statement,  Next: The raise statement,  Prev: The return statement,  Up: Simple statements

4.6.8 The ‘yield’ statement
---------------------------

     yield_stmt ::= yield_expression


  The *note yield: 2f7. statement is only used when defining a generator
function, and is only used in the body of the generator function.  Using
a *note yield: 2f7. statement in a function definition is sufficient to
cause that definition to create a generator function instead of a normal
function.

  When a generator function is called, it returns an iterator known as a
generator iterator, or more commonly, a generator.  The body of the
generator function is executed by calling the generator’s *note next():
399. method repeatedly until it raises an exception.

  When a *note yield: 2f7. statement is executed, the state of the
generator is frozen and the value of *note expression_list: 7a0. is
returned to *note next(): 399.’s caller.  By "frozen" we mean that all
local state is retained, including the current bindings of local
variables, the instruction pointer, and the internal evaluation stack:
enough information is saved so that the next time *note next(): 399. is
invoked, the function can proceed exactly as if the *note yield: 2f7.
statement were just another external call.

  As of Python version 2.5, the *note yield: 2f7. statement is now
allowed in the *note try: 395. clause of a *note try: 395. ...  *note
finally: 396. construct.  If the generator is not resumed before it is
finalized (by reaching a zero reference count or by being garbage
collected), the generator-iterator’s ‘close()’ method will be called,
allowing any pending *note finally: 396. clauses to execute.

  For full details of *note yield: 2f7. semantics, refer to the *note
Yield expressions: 79d. section.

     Note: In Python 2.2, the *note yield: 2f7. statement was only
     allowed when the ‘generators’ feature has been enabled.  This
     ‘__future__’ import statement was used to enable the feature:

          from __future__ import generators

See also
........

PEP 0255(1) - Simple Generators

     The proposal for adding generators and the *note yield: 2f7.
     statement to Python.

PEP 0342(2) - Coroutines via Enhanced Generators

     The proposal that, among other generator enhancements, proposed
     allowing *note yield: 2f7. to appear inside a *note try: 395. ...
     *note finally: 396. block.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0255

   (2) http://www.python.org/dev/peps/pep-0342


File: python.info,  Node: The raise statement,  Next: The break statement,  Prev: The yield statement,  Up: Simple statements

4.6.9 The ‘raise’ statement
---------------------------

     raise_stmt ::= "raise" [expression ["," expression ["," expression]]]


  If no expressions are present, *note raise: 5b1. re-raises the last
exception that was active in the current scope.  If no exception is
active in the current scope, a *note TypeError: 218. exception is raised
indicating that this is an error (if running under IDLE, a *note
Queue.Empty: 819. exception is raised instead).

  Otherwise, *note raise: 5b1. evaluates the expressions to get three
objects, using ‘None’ as the value of omitted expressions.  The first
two objects are used to determine the _type_ and _value_ of the
exception.

  If the first object is an instance, the type of the exception is the
class of the instance, the instance itself is the value, and the second
object must be ‘None’.

  If the first object is a class, it becomes the type of the exception.
The second object is used to determine the exception value: If it is an
instance of the class, the instance becomes the exception value.  If the
second object is a tuple, it is used as the argument list for the class
constructor; if it is ‘None’, an empty argument list is used, and any
other object is treated as a single argument to the constructor.  The
instance so created by calling the constructor is used as the exception
value.

  If a third object is present and not ‘None’, it must be a traceback
object (see section *note The standard type hierarchy: 6ed.), and it is
substituted instead of the current location as the place where the
exception occurred.  If the third object is present and not a traceback
object or ‘None’, a *note TypeError: 218. exception is raised.  The
three-expression form of *note raise: 5b1. is useful to re-raise an
exception transparently in an except clause, but *note raise: 5b1. with
no expressions should be preferred if the exception to be re-raised was
the most recently active exception in the current scope.

  Additional information on exceptions can be found in section *note
Exceptions: 76c, and information about handling exceptions is in section
*note The try statement: 395.


File: python.info,  Node: The break statement,  Next: The continue statement,  Prev: The raise statement,  Up: Simple statements

4.6.10 The ‘break’ statement
----------------------------

     break_stmt ::= "break"


  *note break: 53a. may only occur syntactically nested in a *note for:
2f0. or *note while: 52b. loop, but not nested in a function or class
definition within that loop.

  It terminates the nearest enclosing loop, skipping the optional *note
else: 532. clause if the loop has one.

  If a *note for: 2f0. loop is terminated by *note break: 53a, the loop
control target keeps its current value.

  When *note break: 53a. passes control out of a *note try: 395.
statement with a *note finally: 396. clause, that *note finally: 396.
clause is executed before really leaving the loop.


File: python.info,  Node: The continue statement,  Next: The import statement,  Prev: The break statement,  Up: Simple statements

4.6.11 The ‘continue’ statement
-------------------------------

     continue_stmt ::= "continue"


  *note continue: 53c. may only occur syntactically nested in a *note
for: 2f0. or *note while: 52b. loop, but not nested in a function or
class definition or *note finally: 396. clause within that loop.  It
continues with the next cycle of the nearest enclosing loop.

  When *note continue: 53c. passes control out of a *note try: 395.
statement with a *note finally: 396. clause, that *note finally: 396.
clause is executed before really starting the next loop cycle.


File: python.info,  Node: The import statement,  Next: The global statement,  Prev: The continue statement,  Up: Simple statements

4.6.12 The ‘import’ statement
-----------------------------

     import_stmt     ::= "import" module ["as" name] ( "," module ["as" name] )*
                         | "from" relative_module "import" identifier ["as" name]
                         ( "," identifier ["as" name] )*
                         | "from" relative_module "import" "(" identifier ["as" name]
                         ( "," identifier ["as" name] )* [","] ")"
                         | "from" module "import" "*"
     module          ::= (identifier ".")* identifier
     relative_module ::= "."* module | "."+
     name            ::= identifier


  Import statements are executed in two steps: (1) find a module, and
initialize it if necessary; (2) define a name or names in the local
namespace (of the scope where the *note import: 1f4. statement occurs).
The statement comes in two forms differing on whether it uses the *note
from: 81f. keyword.  The first form (without *note from: 81f.) repeats
these steps for each identifier in the list.  The form with *note from:
81f. performs step (1) once, and then performs step (2) repeatedly.

  To understand how step (1) occurs, one must first understand how
Python handles hierarchical naming of modules.  To help organize modules
and provide a hierarchy in naming, Python has a concept of packages.  A
package can contain other packages and modules while modules cannot
contain other modules or packages.  From a file system perspective,
packages are directories and modules are files.  The original
specification for packages(1) is still available to read, although minor
details have changed since the writing of that document.

  Once the name of the module is known (unless otherwise specified, the
term "module" will refer to both packages and modules), searching for
the module or package can begin.  The first place checked is *note
sys.modules: 824, the cache of all modules that have been imported
previously.  If the module is found there then it is used in step (2) of
import.

  If the module is not found in the cache, then *note sys.meta_path:
825. is searched (the specification for *note sys.meta_path: 825. can be
found in PEP 302(2)).  The object is a list of *note finder: 826.
objects which are queried in order as to whether they know how to load
the module by calling their ‘find_module()’ method with the name of the
module.  If the module happens to be contained within a package (as
denoted by the existence of a dot in the name), then a second argument
to ‘find_module()’ is given as the value of the ‘__path__’ attribute
from the parent package (everything up to the last dot in the name of
the module being imported).  If a finder can find the module it returns
a *note loader: 827. (discussed later) or returns ‘None’.

  If none of the finders on *note sys.meta_path: 825. are able to find
the module then some implicitly defined finders are queried.
Implementations of Python vary in what implicit meta path finders are
defined.  The one they all do define, though, is one that handles *note
sys.path_hooks: 828, *note sys.path_importer_cache: 829, and *note
sys.path: 57f.

  The implicit finder searches for the requested module in the "paths"
specified in one of two places ("paths" do not have to be file system
paths).  If the module being imported is supposed to be contained within
a package then the second argument passed to ‘find_module()’, ‘__path__’
on the parent package, is used as the source of paths.  If the module is
not contained in a package then *note sys.path: 57f. is used as the
source of paths.

  Once the source of paths is chosen it is iterated over to find a
finder that can handle that path.  The dict at *note
sys.path_importer_cache: 829. caches finders for paths and is checked
for a finder.  If the path does not have a finder cached then *note
sys.path_hooks: 828. is searched by calling each object in the list with
a single argument of the path, returning a finder or raises *note
ImportError: 370.  If a finder is returned then it is cached in *note
sys.path_importer_cache: 829. and then used for that path entry.  If no
finder can be found but the path exists then a value of ‘None’ is stored
in *note sys.path_importer_cache: 829. to signify that an implicit,
file-based finder that handles modules stored as individual files should
be used for that path.  If the path does not exist then a finder which
always returns ‘None’ is placed in the cache for the path.

  If no finder can find the module then *note ImportError: 370. is
raised.  Otherwise some finder returned a loader whose ‘load_module()’
method is called with the name of the module to load (see PEP 302(3) for
the original definition of loaders).  A loader has several
responsibilities to perform on a module it loads.  First, if the module
already exists in *note sys.modules: 824. (a possibility if the loader
is called outside of the import machinery) then it is to use that module
for initialization and not a new module.  But if the module does not
exist in *note sys.modules: 824. then it is to be added to that dict
before initialization begins.  If an error occurs during loading of the
module and it was added to *note sys.modules: 824. it is to be removed
from the dict.  If an error occurs but the module was already in *note
sys.modules: 824. it is left in the dict.

  The loader must set several attributes on the module.  ‘__name__’ is
to be set to the name of the module.  ‘__file__’ is to be the "path" to
the file unless the module is built-in (and thus listed in *note
sys.builtin_module_names: 82a.) in which case the attribute is not set.
If what is being imported is a package then ‘__path__’ is to be set to a
list of paths to be searched when looking for modules and packages
contained within the package being imported.  ‘__package__’ is optional
but should be set to the name of package that contains the module or
package (the empty string is used for module not contained in a
package).  ‘__loader__’ is also optional but should be set to the loader
object that is loading the module.

  If an error occurs during loading then the loader raises *note
ImportError: 370. if some other exception is not already being
propagated.  Otherwise the loader returns the module that was loaded and
initialized.

  When step (1) finishes without raising an exception, step (2) can
begin.

  The first form of *note import: 1f4. statement binds the module name
in the local namespace to the module object, and then goes on to import
the next identifier, if any.  If the module name is followed by *note
as: 2f8, the name following *note as: 2f8. is used as the local name for
the module.

  The *note from: 81f. form does not bind the module name: it goes
through the list of identifiers, looks each one of them up in the module
found in step (1), and binds the name in the local namespace to the
object thus found.  As with the first form of *note import: 1f4, an
alternate local name can be supplied by specifying "*note as: 2f8.
localname".  If a name is not found, *note ImportError: 370. is raised.
If the list of identifiers is replaced by a star (‘'*'’), all public
names defined in the module are bound in the local namespace of the
*note import: 1f4. statement..

  The _public names_ defined by a module are determined by checking the
module’s namespace for a variable named ‘__all__’; if defined, it must
be a sequence of strings which are names defined or imported by that
module.  The names given in ‘__all__’ are all considered public and are
required to exist.  If ‘__all__’ is not defined, the set of public names
includes all names found in the module’s namespace which do not begin
with an underscore character (‘'_'’).  ‘__all__’ should contain the
entire public API. It is intended to avoid accidentally exporting items
that are not part of the API (such as library modules which were
imported and used within the module).

  The *note from: 81f. form with ‘*’ may only occur in a module scope.
If the wild card form of import — ‘import *’ — is used in a function and
the function contains or is a nested block with free variables, the
compiler will raise a *note SyntaxError: 498.

  When specifying what module to import you do not have to specify the
absolute name of the module.  When a module or package is contained
within another package it is possible to make a relative import within
the same top package without having to mention the package name.  By
using leading dots in the specified module or package after *note from:
81f. you can specify how high to traverse up the current package
hierarchy without specifying exact names.  One leading dot means the
current package where the module making the import exists.  Two dots
means up one package level.  Three dots is up two levels, etc.  So if
you execute ‘from . import mod’ from a module in the ‘pkg’ package then
you will end up importing ‘pkg.mod’.  If you execute ‘from ..subpkg2
import mod’ from within ‘pkg.subpkg1’ you will import ‘pkg.subpkg2.mod’.
The specification for relative imports is contained within PEP 328(4).

  *note importlib.import_module(): 271. is provided to support
applications that determine which modules need to be loaded dynamically.

* Menu:

* Future statements:: 

   ---------- Footnotes ----------

   (1) http://www.python.org/doc/essays/packages.html

   (2) http://www.python.org/dev/peps/pep-0302

   (3) http://www.python.org/dev/peps/pep-0302

   (4) http://www.python.org/dev/peps/pep-0328


File: python.info,  Node: Future statements,  Up: The import statement

4.6.12.1 Future statements
..........................

A _future statement_ is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python.  The future statement
is intended to ease migration to future versions of Python that
introduce incompatible changes to the language.  It allows use of the
new features on a per-module basis before the release in which the
feature becomes standard.

     future_statement ::= "from" "__future__" "import" feature ["as" name]
                          ("," feature ["as" name])*
                          | "from" "__future__" "import" "(" feature ["as" name]
                          ("," feature ["as" name])* [","] ")"
     feature          ::= identifier
     name             ::= identifier


  A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.

  The features recognized by Python 2.6 are ‘unicode_literals’,
‘print_function’, ‘absolute_import’, ‘division’, ‘generators’,
‘nested_scopes’ and ‘with_statement’.  ‘generators’, ‘with_statement’,
‘nested_scopes’ are redundant in Python version 2.6 and above because
they are always enabled.

  A future statement is recognized and treated specially at compile
time: Changes to the semantics of core constructs are often implemented
by generating different code.  It may even be the case that a new
feature introduces new incompatible syntax (such as a new reserved
word), in which case the compiler may need to parse the module
differently.  Such decisions cannot be pushed off until runtime.

  For any given release, the compiler knows which feature names have
been defined, and raises a compile-time error if a future statement
contains a feature not known to it.

  The direct runtime semantics are the same as for any import statement:
there is a standard module *note __future__: 1, described later, and it
will be imported in the usual way at the time the future statement is
executed.

  The interesting runtime semantics depend on the specific feature
enabled by the future statement.

  Note that there is nothing special about the statement:

     import __future__ [as name]

  That is not a future statement; it’s an ordinary import statement with
no special semantics or syntax restrictions.

  Code compiled by an *note exec: 404. statement or calls to the
built-in functions *note compile(): 1fb. and *note execfile(): 436. that
occur in a module ‘M’ containing a future statement will, by default,
use the new syntax or semantics associated with the future statement.
This can, starting with Python 2.2 be controlled by optional arguments
to *note compile(): 1fb. — see the documentation of that function for
details.

  A future statement typed at an interactive interpreter prompt will
take effect for the rest of the interpreter session.  If an interpreter
is started with the *note -i: 476. option, is passed a script name to
execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is executed.

See also
........

PEP 236(1) - Back to the __future__

     The original proposal for the __future__ mechanism.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0236


File: python.info,  Node: The global statement,  Next: The exec statement,  Prev: The import statement,  Up: Simple statements

4.6.13 The ‘global’ statement
-----------------------------

     global_stmt ::= "global" identifier ("," identifier)*


  The *note global: 543. statement is a declaration which holds for the
entire current code block.  It means that the listed identifiers are to
be interpreted as globals.  It would be impossible to assign to a global
variable without *note global: 543, although free variables may refer to
globals without being declared global.

  Names listed in a *note global: 543. statement must not be used in the
same code block textually preceding that *note global: 543. statement.

  Names listed in a *note global: 543. statement must not be defined as
formal parameters or in a *note for: 2f0. loop control target, *note
class: 33d. definition, function definition, or *note import: 1f4.
statement.

*CPython implementation detail:* The current implementation does not
enforce the latter two restrictions, but programs should not abuse this
freedom, as future implementations may enforce them or silently change
the meaning of the program.

  *Programmer’s note:* the *note global: 543. is a directive to the
parser.  It applies only to code parsed at the same time as the *note
global: 543. statement.  In particular, a *note global: 543. statement
contained in an *note exec: 404. statement does not affect the code
block _containing_ the *note exec: 404. statement, and code contained in
an *note exec: 404. statement is unaffected by *note global: 543.
statements in the code containing the *note exec: 404. statement.  The
same applies to the *note eval(): 360, *note execfile(): 436. and *note
compile(): 1fb. functions.


File: python.info,  Node: The exec statement,  Prev: The global statement,  Up: Simple statements

4.6.14 The ‘exec’ statement
---------------------------

     exec_stmt ::= "exec" or_expr ["in" expression ["," expression]]


  This statement supports dynamic execution of Python code.  The first
expression should evaluate to either a Unicode string, a _Latin-1_
encoded string, an open file object, a code object, or a tuple.  If it
is a string, the string is parsed as a suite of Python statements which
is then executed (unless a syntax error occurs).  (1) If it is an open
file, the file is parsed until EOF and executed.  If it is a code
object, it is simply executed.  For the interpretation of a tuple, see
below.  In all cases, the code that’s executed is expected to be valid
as file input (see section *note File input: 834.).  Be aware that the
*note return: 2f4. and *note yield: 2f7. statements may not be used
outside of function definitions even within the context of code passed
to the *note exec: 404. statement.

  In all cases, if the optional parts are omitted, the code is executed
in the current scope.  If only the first expression after ‘in’ is
specified, it should be a dictionary, which will be used for both the
global and the local variables.  If two expressions are given, they are
used for the global and local variables, respectively.  If provided,
_locals_ can be any mapping object.  Remember that at module level,
globals and locals are the same dictionary.  If two separate objects are
given as _globals_ and _locals_, the code will be executed as if it were
embedded in a class definition.

  The first expression may also be a tuple of length 2 or 3.  In this
case, the optional parts must be omitted.  The form ‘exec(expr,
globals)’ is equivalent to ‘exec expr in globals’, while the form
‘exec(expr, globals, locals)’ is equivalent to ‘exec expr in globals,
locals’.  The tuple form of ‘exec’ provides compatibility with Python 3,
where ‘exec’ is a function rather than a statement.

  Changed in version 2.4: Formerly, _locals_ was required to be a
dictionary.

  As a side effect, an implementation may insert additional keys into
the dictionaries given besides those corresponding to variable names set
by the executed code.  For example, the current implementation may add a
reference to the dictionary of the built-in module *note __builtin__: 0.
under the key ‘__builtins__’ (!).

  *Programmer’s hints:* dynamic evaluation of expressions is supported
by the built-in function *note eval(): 360.  The built-in functions
*note globals(): 835. and *note locals(): 33c. return the current global
and local dictionary, respectively, which may be useful to pass around
for use by *note exec: 404.

   ---------- Footnotes ----------

   (1) Note that the parser only accepts the Unix-style end of line
convention.  If you are reading the code from a file, make sure to use
*note universal newlines: 315. mode to convert Windows or Mac-style
newlines.


File: python.info,  Node: Compound statements,  Next: Top-level components,  Prev: Simple statements,  Up: The Python Language Reference

4.7 Compound statements
=======================

Compound statements contain (groups of) other statements; they affect or
control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

  The *note if: 42c, *note while: 52b. and *note for: 2f0. statements
implement traditional control flow constructs.  *note try: 395.
specifies exception handlers and/or cleanup code for a group of
statements.  Function and class definitions are also syntactically
compound statements.

  Compound statements consist of one or more ’clauses.’ A clause
consists of a header and a ’suite.’ The clause headers of a particular
compound statement are all at the same indentation level.  Each clause
header begins with a uniquely identifying keyword and ends with a colon.
A suite is a group of statements controlled by a clause.  A suite can be
one or more semicolon-separated simple statements on the same line as
the header, following the header’s colon, or it can be one or more
indented statements on subsequent lines.  Only the latter form of suite
can contain nested compound statements; the following is illegal, mostly
because it wouldn’t be clear to which *note if: 42c. clause a following
*note else: 532. clause would belong:

     if test1: if test2: print x

  Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
*note print: 4e0. statements are executed:

     if x < y < z: print x; print y; print z

  Summarizing:

     compound_stmt ::= if_stmt
                       | while_stmt
                       | for_stmt
                       | try_stmt
                       | with_stmt
                       | funcdef
                       | classdef
                       | decorated
     suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
     statement     ::= stmt_list NEWLINE | compound_stmt
     stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]


  Note that statements always end in a ‘NEWLINE’ possibly followed by a
‘DEDENT’.  Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the ’dangling *note else: 532.’ problem is solved in Python
by requiring nested *note if: 42c. statements to be indented).

  The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.
* Menu:

* The if statement:: 
* The while statement:: 
* The for statement:: 
* The try statement:: 
* The with statement:: 
* Function definitions:: 
* Class definitions:: 


File: python.info,  Node: The if statement,  Next: The while statement,  Up: Compound statements

4.7.1 The ‘if’ statement
------------------------

The *note if: 42c. statement is used for conditional execution:

     if_stmt ::= "if" expression ":" suite
                 ( "elif" expression ":" suite )*
                 ["else" ":" suite]


  It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *note Boolean
operations: 7e2. for the definition of true and false); then that suite
is executed (and no other part of the *note if: 42c. statement is
executed or evaluated).  If all expressions are false, the suite of the
*note else: 532. clause, if present, is executed.


File: python.info,  Node: The while statement,  Next: The for statement,  Prev: The if statement,  Up: Compound statements

4.7.2 The ‘while’ statement
---------------------------

The *note while: 52b. statement is used for repeated execution as long
as an expression is true:

     while_stmt ::= "while" expression ":" suite
                    ["else" ":" suite]


  This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time it
is tested) the suite of the *note else: 532. clause, if present, is
executed and the loop terminates.

  A *note break: 53a. statement executed in the first suite terminates
the loop without executing the *note else: 532. clause’s suite.  A *note
continue: 53c. statement executed in the first suite skips the rest of
the suite and goes back to testing the expression.


File: python.info,  Node: The for statement,  Next: The try statement,  Prev: The while statement,  Up: Compound statements

4.7.3 The ‘for’ statement
-------------------------

The *note for: 2f0. statement is used to iterate over the elements of a
sequence (such as a string, tuple or list) or other iterable object:

     for_stmt ::= "for" target_list "in" expression_list ":" suite
                  ["else" ":" suite]


  The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the ‘expression_list’.
The suite is then executed once for each item provided by the iterator,
in the order of ascending indices.  Each item in turn is assigned to the
target list using the standard rules for assignments, and then the suite
is executed.  When the items are exhausted (which is immediately when
the sequence is empty), the suite in the *note else: 532. clause, if
present, is executed, and the loop terminates.

  A *note break: 53a. statement executed in the first suite terminates
the loop without executing the *note else: 532. clause’s suite.  A *note
continue: 53c. statement executed in the first suite skips the rest of
the suite and continues with the next item, or with the *note else: 532.
clause if there was no next item.

  The suite may assign to the variable(s) in the target list; this does
not affect the next item assigned to it.

  The target list is not deleted when the loop is finished, but if the
sequence is empty, it will not have been assigned to at all by the loop.
Hint: the built-in function *note range(): 2d9. returns a sequence of
integers suitable to emulate the effect of Pascal’s ‘for i := a to b
do’; e.g., ‘range(3)’ returns the list ‘[0, 1, 2]’.

     Note: 
     There is a subtlety when the sequence is being modified by the loop
     (this can only occur for mutable sequences, i.e.  lists).  An
     internal counter is used to keep track of which item is used next,
     and this is incremented on each iteration.  When this counter has
     reached the length of the sequence the loop terminates.  This means
     that if the suite deletes the current (or a previous) item from the
     sequence, the next item will be skipped (since it gets the index of
     the current item which has already been treated).  Likewise, if the
     suite inserts an item in the sequence before the current item, the
     current item will be treated again the next time through the loop.
     This can lead to nasty bugs that can be avoided by making a
     temporary copy using a slice of the whole sequence, e.g.,

          for x in a[:]:
              if x < 0: a.remove(x)


File: python.info,  Node: The try statement,  Next: The with statement,  Prev: The for statement,  Up: Compound statements

4.7.4 The ‘try’ statement
-------------------------

The *note try: 395. statement specifies exception handlers and/or
cleanup code for a group of statements:

     try_stmt  ::= try1_stmt | try2_stmt
     try1_stmt ::= "try" ":" suite
                   ("except" [expression [("as" | ",") target]] ":" suite)+
                   ["else" ":" suite]
                   ["finally" ":" suite]
     try2_stmt ::= "try" ":" suite
                   "finally" ":" suite


  Changed in version 2.5: In previous versions of Python, *note try:
395...*note except: 397...*note finally: 396. did not work.  *note try:
395...*note except: 397. had to be nested in *note try: 395...*note
finally: 396.

  The *note except: 397. clause(s) specify one or more exception
handlers.  When no exception occurs in the *note try: 395. clause, no
exception handler is executed.  When an exception occurs in the *note
try: 395. suite, a search for an exception handler is started.  This
search inspects the except clauses in turn until one is found that
matches the exception.  An expression-less except clause, if present,
must be last; it matches any exception.  For an except clause with an
expression, that expression is evaluated, and the clause matches the
exception if the resulting object is "compatible" with the exception.
An object is compatible with an exception if it is the class or a base
class of the exception object, or a tuple containing an item compatible
with the exception.

  If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
(1)

  If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and a
search starts for the new exception in the surrounding code and on the
call stack (it is treated as if the entire *note try: 395. statement
raised the exception).

  When a matching except clause is found, the exception is assigned to
the target specified in that except clause, if present, and the except
clause’s suite is executed.  All except clauses must have an executable
block.  When the end of this block is reached, execution continues
normally after the entire try statement.  (This means that if two nested
handlers exist for the same exception, and the exception occurs in the
try clause of the inner handler, the outer handler will not handle the
exception.)

  Before an except clause’s suite is executed, details about the
exception are assigned to three variables in the *note sys: 16d. module:
‘sys.exc_type’ receives the object identifying the exception;
‘sys.exc_value’ receives the exception’s parameter; ‘sys.exc_traceback’
receives a traceback object (see section *note The standard type
hierarchy: 6ed.) identifying the point in the program where the
exception occurred.  These details are also available through the *note
sys.exc_info(): 2f3. function, which returns a tuple ‘(exc_type,
exc_value, exc_traceback)’.  Use of the corresponding variables is
deprecated in favor of this function, since their use is unsafe in a
threaded program.  As of Python 1.5, the variables are restored to their
previous values (before the call) when returning from a function that
handled an exception.

  The optional *note else: 532. clause is executed if and when control
flows off the end of the *note try: 395. clause.  (2) Exceptions in the
*note else: 532. clause are not handled by the preceding *note except:
397. clauses.

  If *note finally: 396. is present, it specifies a ’cleanup’ handler.
The *note try: 395. clause is executed, including any *note except: 397.
and *note else: 532. clauses.  If an exception occurs in any of the
clauses and is not handled, the exception is temporarily saved.  The
*note finally: 396. clause is executed.  If there is a saved exception,
it is re-raised at the end of the *note finally: 396. clause.  If the
*note finally: 396. clause raises another exception or executes a *note
return: 2f4. or *note break: 53a. statement, the saved exception is
discarded:

     >>> def f():
     ...     try:
     ...         1/0
     ...     finally:
     ...         return 42
     ...
     >>> f()
     42

  The exception information is not available to the program during
execution of the *note finally: 396. clause.

  When a *note return: 2f4, *note break: 53a. or *note continue: 53c.
statement is executed in the *note try: 395. suite of a *note try:
395...*note finally: 396. statement, the *note finally: 396. clause is
also executed ’on the way out.’ A *note continue: 53c. statement is
illegal in the *note finally: 396. clause.  (The reason is a problem
with the current implementation — this restriction may be lifted in the
future).

  The return value of a function is determined by the last *note return:
2f4. statement executed.  Since the *note finally: 396. clause always
executes, a *note return: 2f4. statement executed in the *note finally:
396. clause will always be the last one executed:

     >>> def foo():
     ...     try:
     ...         return 'try'
     ...     finally:
     ...         return 'finally'
     ...
     >>> foo()
     'finally'

  Additional information on exceptions can be found in section *note
Exceptions: 76c, and information on using the *note raise: 5b1.
statement to generate exceptions may be found in section *note The raise
statement: 5b1.

   ---------- Footnotes ----------

   (1) The exception is propagated to the invocation stack unless there
is a *note finally: 396. clause which happens to raise another
exception.  That new exception causes the old one to be lost.

   (2) Currently, control "flows off the end" except in the case of an
exception or the execution of a *note return: 2f4, *note continue: 53c,
or *note break: 53a. statement.


File: python.info,  Node: The with statement,  Next: Function definitions,  Prev: The try statement,  Up: Compound statements

4.7.5 The ‘with’ statement
--------------------------

New in version 2.5.

  The *note with: 1c0. statement is used to wrap the execution of a
block with methods defined by a context manager (see section *note With
Statement Context Managers: 760.).  This allows common *note try:
395...*note except: 397...*note finally: 396. usage patterns to be
encapsulated for convenient reuse.

     with_stmt ::= "with" with_item ("," with_item)* ":" suite
     with_item ::= expression ["as" target]


  The execution of the *note with: 1c0. statement with one "item"
proceeds as follows:

  1. The context expression (the expression given in the *note
     with_item: 849.) is evaluated to obtain a context manager.

  2. The context manager’s *note __exit__(): 200. is loaded for later
     use.

  3. The context manager’s *note __enter__(): 1ff. method is invoked.

  4. If a target was included in the *note with: 1c0. statement, the
     return value from *note __enter__(): 1ff. is assigned to it.

          Note: The *note with: 1c0. statement guarantees that if the
          *note __enter__(): 1ff. method returns without an error, then
          *note __exit__(): 200. will always be called.  Thus, if an
          error occurs during the assignment to the target list, it will
          be treated the same as an error occurring within the suite
          would be.  See step 6 below.

  5. The suite is executed.

  6. The context manager’s *note __exit__(): 200. method is invoked.  If
     an exception caused the suite to be exited, its type, value, and
     traceback are passed as arguments to *note __exit__(): 200.
     Otherwise, three *note None: 39a. arguments are supplied.

     If the suite was exited due to an exception, and the return value
     from the *note __exit__(): 200. method was false, the exception is
     reraised.  If the return value was true, the exception is
     suppressed, and execution continues with the statement following
     the *note with: 1c0. statement.

     If the suite was exited for any reason other than an exception, the
     return value from *note __exit__(): 200. is ignored, and execution
     proceeds at the normal location for the kind of exit that was
     taken.

  With more than one item, the context managers are processed as if
multiple *note with: 1c0. statements were nested:

     with A() as a, B() as b:
         suite

  is equivalent to

     with A() as a:
         with B() as b:
             suite

     Note: In Python 2.5, the *note with: 1c0. statement is only allowed
     when the ‘with_statement’ feature has been enabled.  It is always
     enabled in Python 2.6.

  Changed in version 2.7: Support for multiple context expressions.

See also
........

PEP 0343(1) - The "with" statement

     The specification, background, and examples for the Python *note
     with: 1c0. statement.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Function definitions,  Next: Class definitions,  Prev: The with statement,  Up: Compound statements

4.7.6 Function definitions
--------------------------

A function definition defines a user-defined function object (see
section *note The standard type hierarchy: 6ed.):

     decorated      ::= decorators (classdef | funcdef)
     decorators     ::= decorator+
     decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
     funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite
     dotted_name    ::= identifier ("." identifier)*
     parameter_list ::= (defparameter ",")*
                        (  "*" identifier ["," "**" identifier]
                        | "**" identifier
                        | defparameter [","] )
     defparameter   ::= parameter ["=" expression]
     sublist        ::= parameter ("," parameter)* [","]
     parameter      ::= identifier | "(" sublist ")"
     funcname       ::= identifier


  A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object (a
wrapper around the executable code for the function).  This function
object contains a reference to the current global namespace as the
global namespace to be used when the function is called.

  The function definition does not execute the function body; this gets
executed only when the function is called.  (1)

  A function definition may be wrapped by one or more *note decorator:
856. expressions.  Decorator expressions are evaluated when the function
is defined, in the scope that contains the function definition.  The
result must be a callable, which is invoked with the function object as
the only argument.  The returned value is bound to the function name
instead of the function object.  Multiple decorators are applied in
nested fashion.  For example, the following code:

     @f1(arg)
     @f2
     def func(): pass

  is equivalent to:

     def func(): pass
     func = f1(arg)(f2(func))

  When one or more top-level *note parameters: 7c6. have the form
_parameter_ ‘=’ _expression_, the function is said to have "default
parameter values."  For a parameter with a default value, the
corresponding *note argument: 7c0. may be omitted from a call, in which
case the parameter’s default value is substituted.  If a parameter has a
default value, all following parameters must also have a default value —
this is a syntactic restriction that is not expressed by the grammar.

  *Default parameter values are evaluated when the function definition
is executed.*  This means that the expression is evaluated once, when
the function is defined, and that the same "pre-computed" value is used
for each call.  This is especially important to understand when a
default parameter is a mutable object, such as a list or a dictionary:
if the function modifies the object (e.g.  by appending an item to a
list), the default value is in effect modified.  This is generally not
what was intended.  A way around this is to use ‘None’ as the default,
and explicitly test for it in the body of the function, e.g.:

     def whats_on_the_telly(penguin=None):
         if penguin is None:
             penguin = []
         penguin.append("property of the zoo")
         return penguin

  Function call semantics are described in more detail in section *note
Calls: 6f7.  A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form "‘*identifier’"
is present, it is initialized to a tuple receiving any excess positional
parameters, defaulting to the empty tuple.  If the form "‘**identifier’"
is present, it is initialized to a new dictionary receiving any excess
keyword arguments, defaulting to a new empty dictionary.

  It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *note Lambdas: 403.  Note that the
lambda expression is merely a shorthand for a simplified function
definition; a function defined in a "*note def: 3f4." statement can be
passed around or assigned to another name just like a function defined
by a lambda expression.  The "*note def: 3f4." form is actually more
powerful since it allows the execution of multiple statements.

  *Programmer’s note:* Functions are first-class objects.  A "‘def’"
form executed inside a function definition defines a local function that
can be returned or passed around.  Free variables used in the nested
function can access the local variables of the function containing the
def.  See section *note Naming and binding: 768. for details.

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the function
body is transformed into the function’s ‘__doc__’ attribute and
therefore the function’s *note docstring: 855.


File: python.info,  Node: Class definitions,  Prev: Function definitions,  Up: Compound statements

4.7.7 Class definitions
-----------------------

A class definition defines a class object (see section *note The
standard type hierarchy: 6ed.):

     classdef    ::= "class" classname [inheritance] ":" suite
     inheritance ::= "(" [expression_list] ")"
     classname   ::= identifier


  A class definition is an executable statement.  It first evaluates the
inheritance list, if present.  Each item in the inheritance list should
evaluate to a class object or class type which allows subclassing.  The
class’s suite is then executed in a new execution frame (see section
*note Naming and binding: 768.), using a newly created local namespace
and the original global namespace.  (Usually, the suite contains only
function definitions.)  When the class’s suite finishes execution, its
execution frame is discarded but its local namespace is saved.  (1) A
class object is then created using the inheritance list for the base
classes and the saved local namespace for the attribute dictionary.  The
class name is bound to this class object in the original local
namespace.

  *Programmer’s note:* Variables defined in the class definition are
class variables; they are shared by all instances.  To create instance
variables, they can be set in a method with ‘self.name = value’.  Both
class and instance variables are accessible through the notation
"‘self.name’", and an instance variable hides a class variable with the
same name when accessed in this way.  Class variables can be used as
defaults for instance variables, but using mutable values there can lead
to unexpected results.  For *note new-style class: 5d1.es, descriptors
can be used to create instance variables with different implementation
details.

  Class definitions, like function definitions, may be wrapped by one or
more *note decorator: 856. expressions.  The evaluation rules for the
decorator expressions are the same as for functions.  The result must be
a class object, which is then bound to the class name.

   ---------- Footnotes ----------

   (1) A string literal appearing as the first statement in the class
body is transformed into the namespace’s ‘__doc__’ item and therefore
the class’s *note docstring: 855.


File: python.info,  Node: Top-level components,  Next: Full Grammar specification,  Prev: Compound statements,  Up: The Python Language Reference

4.8 Top-level components
========================

The Python interpreter can get its input from a number of sources: from
a script passed to it as standard input or as program argument, typed in
interactively, from a module source file, etc.  This chapter gives the
syntax used in these cases.

* Menu:

* Complete Python programs:: 
* File input:: 
* Interactive input:: 
* Expression input:: 


File: python.info,  Node: Complete Python programs,  Next: File input,  Up: Top-level components

4.8.1 Complete Python programs
------------------------------

While a language specification need not prescribe how the language
interpreter is invoked, it is useful to have a notion of a complete
Python program.  A complete Python program is executed in a minimally
initialized environment: all built-in and standard modules are
available, but none have been initialized, except for *note sys: 16d.
(various system services), *note __builtin__: 0. (built-in functions,
exceptions and ‘None’) and *note __main__: 2.  The latter is used to
provide the local and global namespace for execution of the complete
program.

  The syntax for a complete Python program is that for file input,
described in the next section.

  The interpreter may also be invoked in interactive mode; in this case,
it does not read and execute a complete program but reads and executes
one statement (possibly compound) at a time.  The initial environment is
identical to that of a complete program; each statement is executed in
the namespace of *note __main__: 2.

  Under Unix, a complete program can be passed to the interpreter in
three forms: with the *note -c: 27b. _string_ command line option, as a
file passed as the first command line argument, or as standard input.
If the file or standard input is a tty device, the interpreter enters
interactive mode; otherwise, it executes the file as a complete program.


File: python.info,  Node: File input,  Next: Interactive input,  Prev: Complete Python programs,  Up: Top-level components

4.8.2 File input
----------------

All input read from non-interactive files has the same form:

     file_input ::= (NEWLINE | statement)*


  This syntax is used in the following situations:

   * when parsing a complete Python program (from a file or from a
     string);

   * when parsing a module;

   * when parsing a string passed to the *note exec: 404. statement;


File: python.info,  Node: Interactive input,  Next: Expression input,  Prev: File input,  Up: Top-level components

4.8.3 Interactive input
-----------------------

Input in interactive mode is parsed using the following grammar:

     interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE


  Note that a (top-level) compound statement must be followed by a blank
line in interactive mode; this is needed to help the parser detect the
end of the input.


File: python.info,  Node: Expression input,  Prev: Interactive input,  Up: Top-level components

4.8.4 Expression input
----------------------

There are two forms of expression input.  Both ignore leading
whitespace.  The string argument to *note eval(): 360. must have the
following form:

     eval_input ::= expression_list NEWLINE*


  The input line read by *note input(): 3bf. must have the following
form:

     input_input ::= expression_list NEWLINE


  Note: to read ’raw’ input line without interpretation, you can use the
built-in function *note raw_input(): 869. or the *note readline(): 144.
method of file objects.


File: python.info,  Node: Full Grammar specification,  Prev: Top-level components,  Up: The Python Language Reference

4.9 Full Grammar specification
==============================

This is the full Python grammar, as it is read by the parser generator
and used to parse Python source files:

     # Grammar for Python

     # Note:  Changing the grammar specified in this file will most likely
     #        require corresponding changes in the parser module
     #        (../Modules/parsermodule.c).  If you can't make the changes to
     #        that module yourself, please co-ordinate the required changes
     #        with someone who can; ask around on python-dev for help.  Fred
     #        Drake <fdrake@acm.org> will probably be listening there.

     # NOTE WELL: You should also follow all the steps listed in PEP 306,
     # "How to Change Python's Grammar"

     # Start symbols for the grammar:
     #       single_input is a single interactive statement;
     #       file_input is a module or sequence of commands read from an input file;
     #       eval_input is the input for the eval() and input() functions.
     # NB: compound_stmt in single_input is followed by extra NEWLINE!
     single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
     file_input: (NEWLINE | stmt)* ENDMARKER
     eval_input: testlist NEWLINE* ENDMARKER

     decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
     decorators: decorator+
     decorated: decorators (classdef | funcdef)
     funcdef: 'def' NAME parameters ':' suite
     parameters: '(' [varargslist] ')'
     varargslist: ((fpdef ['=' test] ',')*
                   ('*' NAME [',' '**' NAME] | '**' NAME) |
                   fpdef ['=' test] (',' fpdef ['=' test])* [','])
     fpdef: NAME | '(' fplist ')'
     fplist: fpdef (',' fpdef)* [',']

     stmt: simple_stmt | compound_stmt
     simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
     small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |
                  import_stmt | global_stmt | exec_stmt | assert_stmt)
     expr_stmt: testlist (augassign (yield_expr|testlist) |
                          ('=' (yield_expr|testlist))*)
     augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                 '<<=' | '>>=' | '**=' | '//=')
     # For normal assignments, additional restrictions enforced by the interpreter
     print_stmt: 'print' ( [ test (',' test)* [','] ] |
                           '>>' test [ (',' test)+ [','] ] )
     del_stmt: 'del' exprlist
     pass_stmt: 'pass'
     flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
     break_stmt: 'break'
     continue_stmt: 'continue'
     return_stmt: 'return' [testlist]
     yield_stmt: yield_expr
     raise_stmt: 'raise' [test [',' test [',' test]]]
     import_stmt: import_name | import_from
     import_name: 'import' dotted_as_names
     import_from: ('from' ('.'* dotted_name | '.'+)
                   'import' ('*' | '(' import_as_names ')' | import_as_names))
     import_as_name: NAME ['as' NAME]
     dotted_as_name: dotted_name ['as' NAME]
     import_as_names: import_as_name (',' import_as_name)* [',']
     dotted_as_names: dotted_as_name (',' dotted_as_name)*
     dotted_name: NAME ('.' NAME)*
     global_stmt: 'global' NAME (',' NAME)*
     exec_stmt: 'exec' expr ['in' test [',' test]]
     assert_stmt: 'assert' test [',' test]

     compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
     if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
     while_stmt: 'while' test ':' suite ['else' ':' suite]
     for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
     try_stmt: ('try' ':' suite
                ((except_clause ':' suite)+
                 ['else' ':' suite]
                 ['finally' ':' suite] |
                'finally' ':' suite))
     with_stmt: 'with' with_item (',' with_item)*  ':' suite
     with_item: test ['as' expr]
     # NB compile.c makes sure that the default except clause is last
     except_clause: 'except' [test [('as' | ',') test]]
     suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

     # Backward compatibility cruft to support:
     # [ x for x in lambda: True, lambda: False if x() ]
     # even while also allowing:
     # lambda x: 5 if x else 2
     # (But not a mix of the two)
     testlist_safe: old_test [(',' old_test)+ [',']]
     old_test: or_test | old_lambdef
     old_lambdef: 'lambda' [varargslist] ':' old_test

     test: or_test ['if' or_test 'else' test] | lambdef
     or_test: and_test ('or' and_test)*
     and_test: not_test ('and' not_test)*
     not_test: 'not' not_test | comparison
     comparison: expr (comp_op expr)*
     comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
     expr: xor_expr ('|' xor_expr)*
     xor_expr: and_expr ('^' and_expr)*
     and_expr: shift_expr ('&' shift_expr)*
     shift_expr: arith_expr (('<<'|'>>') arith_expr)*
     arith_expr: term (('+'|'-') term)*
     term: factor (('*'|'/'|'%'|'//') factor)*
     factor: ('+'|'-'|'~') factor | power
     power: atom trailer* ['**' factor]
     atom: ('(' [yield_expr|testlist_comp] ')' |
            '[' [listmaker] ']' |
            '{' [dictorsetmaker] '}' |
            '`' testlist1 '`' |
            NAME | NUMBER | STRING+)
     listmaker: test ( list_for | (',' test)* [','] )
     testlist_comp: test ( comp_for | (',' test)* [','] )
     lambdef: 'lambda' [varargslist] ':' test
     trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
     subscriptlist: subscript (',' subscript)* [',']
     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
     sliceop: ':' [test]
     exprlist: expr (',' expr)* [',']
     testlist: test (',' test)* [',']
     dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |
                       (test (comp_for | (',' test)* [','])) )

     classdef: 'class' NAME ['(' [testlist] ')'] ':' suite

     arglist: (argument ',')* (argument [',']
                              |'*' test (',' argument)* [',' '**' test]
                              |'**' test)
     # The reason that keywords are test nodes instead of NAME is that using NAME
     # results in an ambiguity. ast.c makes sure it's a NAME.
     argument: test [comp_for] | test '=' test

     list_iter: list_for | list_if
     list_for: 'for' exprlist 'in' testlist_safe [list_iter]
     list_if: 'if' old_test [list_iter]

     comp_iter: comp_for | comp_if
     comp_for: 'for' exprlist 'in' or_test [comp_iter]
     comp_if: 'if' old_test [comp_iter]

     testlist1: test (',' test)*

     # not used in grammar, but may appear in "node" passed from Parser to Compiler
     encoding_decl: NAME

     yield_expr: 'yield' [testlist]



File: python.info,  Node: The Python Standard Library,  Next: Extending and Embedding the Python Interpreter,  Prev: The Python Language Reference,  Up: Top

5 The Python Standard Library
*****************************

While *note The Python Language Reference: 4f9. describes the exact
syntax and semantics of the Python language, this library reference
manual describes the standard library that is distributed with Python.
It also describes some of the optional components that are commonly
included in Python distributions.

  Python’s standard library is very extensive, offering a wide range of
facilities as indicated by the long table of contents listed below.  The
library contains built-in modules (written in C) that provide access to
system functionality such as file I/O that would otherwise be
inaccessible to Python programmers, as well as modules written in Python
that provide standardized solutions for many problems that occur in
everyday programming.  Some of these modules are explicitly designed to
encourage and enhance the portability of Python programs by abstracting
away platform-specifics into platform-neutral APIs.

  The Python installers for the Windows platform usually includes the
entire standard library and often also include many additional
components.  For Unix-like operating systems Python is normally provided
as a collection of packages, so it may be necessary to use the packaging
tools provided with the operating system to obtain some or all of the
optional components.

  In addition to the standard library, there is a growing collection of
several thousand components (from individual programs and modules to
packages and entire application development frameworks), available from
the Python Package Index(1).

* Menu:

* Introduction: Introduction<5>. 
* Built-in Functions:: 
* Non-essential Built-in Functions:: 
* Built-in Constants:: 
* Built-in Types:: 
* Built-in Exceptions:: 
* String Services:: 
* Data Types:: 
* Numeric and Mathematical Modules:: 
* File and Directory Access:: 
* Data Persistence:: 
* Data Compression and Archiving:: 
* File Formats:: 
* Cryptographic Services:: 
* Generic Operating System Services:: 
* Optional Operating System Services:: 
* Interprocess Communication and Networking:: 
* Internet Data Handling:: 
* Structured Markup Processing Tools:: 
* Internet Protocols and Support:: 
* Multimedia Services:: 
* Internationalization:: 
* Program Frameworks:: 
* Graphical User Interfaces with Tk:: 
* Development Tools:: 
* Debugging and Profiling:: 
* Python Runtime Services:: 
* Custom Python Interpreters:: 
* Restricted Execution:: 
* Importing Modules:: 
* Python Language Services:: 
* Python compiler package:: 
* Miscellaneous Services:: 
* MS Windows Specific Services:: 
* Unix Specific Services:: 
* Mac OS X specific services:: 
* MacPython OSA Modules:: 
* SGI IRIX Specific Services:: 
* SunOS Specific Services:: 
* Undocumented Modules:: 

   ---------- Footnotes ----------

   (1) http://pypi.python.org/pypi


File: python.info,  Node: Introduction<5>,  Next: Built-in Functions,  Up: The Python Standard Library

5.1 Introduction
================

The "Python library" contains several different kinds of components.

  It contains data types that would normally be considered part of the
"core" of a language, such as numbers and lists.  For these types, the
Python language core defines the form of literals and places some
constraints on their semantics, but does not fully define the semantics.
(On the other hand, the language core does define syntactic properties
like the spelling and priorities of operators.)

  The library also contains built-in functions and exceptions — objects
that can be used by all Python code without the need of an *note import:
1f4. statement.  Some of these are defined by the core language, but
many are not essential for the core semantics and are only described
here.

  The bulk of the library, however, consists of a collection of modules.
There are many ways to dissect this collection.  Some modules are
written in C and built in to the Python interpreter; others are written
in Python and imported in source form.  Some modules provide interfaces
that are highly specific to Python, like printing a stack trace; some
provide interfaces that are specific to particular operating systems,
such as access to specific hardware; others provide interfaces that are
specific to a particular application domain, like the World Wide Web.
Some modules are available in all versions and ports of Python; others
are only available when the underlying system supports or requires them;
yet others are available only when a particular configuration option was
chosen at the time when Python was compiled and installed.

  This manual is organized "from the inside out:" it first describes the
built-in data types, then the built-in functions and exceptions, and
finally the modules, grouped in chapters of related modules.  The
ordering of the chapters as well as the ordering of the modules within
each chapter is roughly from most relevant to least important.

  This means that if you start reading this manual from the start, and
skip to the next chapter when you get bored, you will get a reasonable
overview of the available modules and application areas that are
supported by the Python library.  Of course, you don’t _have_ to read it
like a novel — you can also browse the table of contents (in front of
the manual), or look for a specific function, module or term in the
index (in the back).  And finally, if you enjoy learning about random
subjects, you choose a random page number (see module *note random:
142.) and read a section or two.  Regardless of the order in which you
read the sections of this manual, it helps to start with chapter *note
Built-in Functions: 7c7, as the remainder of the manual assumes
familiarity with this material.

  Let the show begin!


File: python.info,  Node: Built-in Functions,  Next: Non-essential Built-in Functions,  Prev: Introduction<5>,  Up: The Python Standard Library

5.2 Built-in Functions
======================

The Python interpreter has a number of functions built into it that are
always available.  They are listed here in alphabetical order.

                                              Built-in Functions
                                              
--------------------------------------------------------------------------------------------------------------------
                                                                                           
*note abs(): 5bf.       *note divmod():       *note input(): 3bf.    *note open(): 2d6.    *note staticmethod():
                        73d.                                                               3f5.
                                                                                           
                                                                                           
*note all(): 3af.       *note enumerate():    *note int(): 1f2.      *note ord(): 6f3.     *note str(): 1ea.
                        427.                                                               
                        
                                                                                           
*note any(): 3ae.       *note eval(): 360.    *note isinstance():    *note pow(): 4b5.     *note sum(): 426.
                                              31e.                                         
                                              
                                                                                           
*note basestring():     *note execfile():     *note issubclass():    *note print(): 30b.   *note super(): 37d.
458.                    436.                  31f.                                         
                                              
                                                                                           
*note bin(): 2ea.       *note file(): 1f9.    *note iter(): 320.     *note property():     *note tuple(): 408.
                                                                     487.                  
                                                                     
                                                                                           
*note bool(): 43c.      *note filter():       *note len(): 520.      *note range(): 2d9.   *note type(): 490.
                        409.                                                               
                        
                                                                                           
*note bytearray():      *note float(): 1eb.   *note list(): 3bc.     *note raw_input():    *note unichr(): 495.
1f7.                                                                 869.                  
                                                                     
                                                                                           
*note callable():       *note format():       *note locals(): 33c.   *note reduce():       *note unicode(): 1f5.
873.                    1ef.                                         2e9.                  
                                                                     
                                                                                           
*note chr(): 6f2.       *note frozenset():    *note long(): 1f3.     *note reload():       *note vars(): 598.
                        874.                                         57a.                  
                                                                     
                                                                                           
*note classmethod():    *note getattr():      *note map(): 304.      *note repr(): 876.    *note xrange(): 45b.
3f6.                    875.                                                               
                        
                                                                                           
*note cmp(): 4be.       *note globals():      *note max(): 225.      *note reversed():     *note zip(): 405.
                        835.                                         3f8.                  
                                                                     
                                                                                           
*note compile(): 1fb.   *note hasattr():      *note memoryview():    *note round(): 1c5.   *note __import__():
                        330.                  877.                                         37e.
                                                                                           
                                                                                           
*note complex(): 1ec.   *note hash(): 70b.    *note min(): 224.      *note set(): 878.     *note apply(): 303.
                                                                                           
                                                                                           
*note delattr(): 879.   *note help(): 49a.    *note next(): 399.     *note setattr():      *note buffer(): 316.
                                                                     87a.                  
                                                                     
                                                                                           
*note dict(): 87b.      *note hex(): 334.     *note object(): 1f1.   *note slice(): 450.   *note coerce(): 75e.
                                                                                           
                                                                                           
*note dir(): 33a.       *note id(): 3b2.      *note oct(): 325.      *note sorted():       *note intern(): 87c.
                                                                     223.                  
                                                                     

 -- Function: abs (x)

     Return the absolute value of a number.  The argument may be a plain
     or long integer or a floating point number.  If the argument is a
     complex number, its magnitude is returned.

 -- Function: all (iterable)

     Return ‘True’ if all elements of the _iterable_ are true (or if the
     iterable is empty).  Equivalent to:

          def all(iterable):
              for element in iterable:
                  if not element:
                      return False
              return True

     New in version 2.5.

 -- Function: any (iterable)

     Return ‘True’ if any element of the _iterable_ is true.  If the
     iterable is empty, return ‘False’.  Equivalent to:

          def any(iterable):
              for element in iterable:
                  if element:
                      return True
              return False

     New in version 2.5.

 -- Function: basestring ()

     This abstract type is the superclass for *note str: 1ea. and *note
     unicode: 1f5.  It cannot be called or instantiated, but it can be
     used to test whether an object is an instance of *note str: 1ea. or
     *note unicode: 1f5.  ‘isinstance(obj, basestring)’ is equivalent to
     ‘isinstance(obj, (str, unicode))’.

     New in version 2.3.

 -- Function: bin (x)

     Convert an integer number to a binary string.  The result is a
     valid Python expression.  If _x_ is not a Python *note int: 1f2.
     object, it has to define an *note __index__(): 25f. method that
     returns an integer.

     New in version 2.6.

 -- Function: bool ([x])

     Convert a value to a Boolean, using the standard truth testing
     procedure.  If _x_ is false or omitted, this returns *note False:
     3b1.; otherwise it returns *note True: 3b0.  *note bool: 43c. is
     also a class, which is a subclass of *note int: 1f2.  Class *note
     bool: 43c. cannot be subclassed further.  Its only instances are
     *note False: 3b1. and *note True: 3b0.

     New in version 2.2.1.

     Changed in version 2.3: If no argument is given, this function
     returns *note False: 3b1.

 -- Function: bytearray ([source[, encoding[, errors]]])

     Return a new array of bytes.  The *note bytearray: 1f7. type is a
     mutable sequence of integers in the range 0 <= x < 256.  It has
     most of the usual methods of mutable sequences, described in *note
     Mutable Sequence Types: 87d, as well as most methods that the *note
     str: 1ea. type has, see *note String Methods: 522.

     The optional _source_ parameter can be used to initialize the array
     in a few different ways:

        * If it is a _string_, you must also give the _encoding_ (and
          optionally, _errors_) parameters; *note bytearray(): 1f7. then
          converts the string to bytes using *note str.encode(): 652.

        * If it is an _integer_, the array will have that size and will
          be initialized with null bytes.

        * If it is an object conforming to the _buffer_ interface, a
          read-only buffer of the object will be used to initialize the
          bytes array.

        * If it is an _iterable_, it must be an iterable of integers in
          the range ‘0 <= x < 256’, which are used as the initial
          contents of the array.

     Without an argument, an array of size 0 is created.

     New in version 2.6.

 -- Function: callable (object)

     Return *note True: 3b0. if the _object_ argument appears callable,
     *note False: 3b1. if not.  If this returns true, it is still
     possible that a call fails, but if it is false, calling _object_
     will never succeed.  Note that classes are callable (calling a
     class returns a new instance); class instances are callable if they
     have a *note __call__(): 6fa. method.

 -- Function: chr (i)

     Return a string of one character whose ASCII code is the integer
     _i_.  For example, ‘chr(97)’ returns the string ‘'a'’.  This is the
     inverse of *note ord(): 6f3.  The argument must be in the range
     [0..255], inclusive; *note ValueError: 236. will be raised if _i_
     is outside that range.  See also *note unichr(): 495.

 -- Function: classmethod (function)

     Return a class method for _function_.

     A class method receives the class as implicit first argument, just
     like an instance method receives the instance.  To declare a class
     method, use this idiom:

          class C(object):
              @classmethod
              def f(cls, arg1, arg2, ...):
                  ...

     The ‘@classmethod’ form is a function *note decorator: 856. – see
     the description of function definitions in *note Function
     definitions: 6f8. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.  If a class method is called for a derived class, the
     derived class object is passed as the implied first argument.

     Class methods are different than C++ or Java static methods.  If
     you want those, see *note staticmethod(): 3f5. in this section.

     For more information on class methods, consult the documentation on
     the standard type hierarchy in *note The standard type hierarchy:
     6ed.

     New in version 2.2.

     Changed in version 2.4: Function decorator syntax added.

 -- Function: cmp (x, y)

     Compare the two objects _x_ and _y_ and return an integer according
     to the outcome.  The return value is negative if ‘x < y’, zero if
     ‘x == y’ and strictly positive if ‘x > y’.

 -- Function: compile (source, filename, mode[, flags[, dont_inherit]])

     Compile the _source_ into a code or AST object.  Code objects can
     be executed by an *note exec: 404. statement or evaluated by a call
     to *note eval(): 360.  _source_ can either be a Unicode string, a
     _Latin-1_ encoded string or an AST object.  Refer to the *note ast:
     f. module documentation for information on how to work with AST
     objects.

     The _filename_ argument should give the file from which the code
     was read; pass some recognizable value if it wasn’t read from a
     file (‘'<string>'’ is commonly used).

     The _mode_ argument specifies what kind of code must be compiled;
     it can be ‘'exec'’ if _source_ consists of a sequence of
     statements, ‘'eval'’ if it consists of a single expression, or
     ‘'single'’ if it consists of a single interactive statement (in the
     latter case, expression statements that evaluate to something other
     than ‘None’ will be printed).

     The optional arguments _flags_ and _dont_inherit_ control which
     future statements (see PEP 236(1)) affect the compilation of
     _source_.  If neither is present (or both are zero) the code is
     compiled with those future statements that are in effect in the
     code that is calling compile.  If the _flags_ argument is given and
     _dont_inherit_ is not (or is zero) then the future statements
     specified by the _flags_ argument are used in addition to those
     that would be used anyway.  If _dont_inherit_ is a non-zero integer
     then the _flags_ argument is it – the future statements in effect
     around the call to compile are ignored.

     Future statements are specified by bits which can be bitwise ORed
     together to specify multiple statements.  The bitfield required to
     specify a given feature can be found as the ‘compiler_flag’
     attribute on the ‘_Feature’ instance in the *note __future__: 1.
     module.

     This function raises *note SyntaxError: 498. if the compiled source
     is invalid, and *note TypeError: 218. if the source contains null
     bytes.

          Note: When compiling a string with multi-line code in
          ‘'single'’ or ‘'eval'’ mode, input must be terminated by at
          least one newline character.  This is to facilitate detection
          of incomplete and complete statements in the *note code: 62.
          module.

     Changed in version 2.3: The _flags_ and _dont_inherit_ arguments
     were added.

     Changed in version 2.6: Support for compiling AST objects.

     Changed in version 2.7: Allowed use of Windows and Mac newlines.
     Also input in ‘'exec'’ mode does not have to end in a newline
     anymore.

 -- Function: complex ([real[, imag]])

     Create a complex number with the value _real_ + _imag_*j or convert
     a string or number to a complex number.  If the first parameter is
     a string, it will be interpreted as a complex number and the
     function must be called without a second parameter.  The second
     parameter can never be a string.  Each argument may be any numeric
     type (including complex).  If _imag_ is omitted, it defaults to
     zero and the function serves as a numeric conversion function like
     *note int(): 1f2, *note long(): 1f3. and *note float(): 1eb.  If
     both arguments are omitted, returns ‘0j’.

          Note: When converting from a string, the string must not
          contain whitespace around the central ‘+’ or ‘-’ operator.
          For example, ‘complex('1+2j')’ is fine, but ‘complex('1 +
          2j')’ raises *note ValueError: 236.

     The complex type is described in *note Numeric Types — int, float,
     long, complex: 87e.

 -- Function: delattr (object, name)

     This is a relative of *note setattr(): 87a.  The arguments are an
     object and a string.  The string must be the name of one of the
     object’s attributes.  The function deletes the named attribute,
     provided the object allows it.  For example, ‘delattr(x, 'foobar')’
     is equivalent to ‘del x.foobar’.

 -- Function: dict (**kwarg)

 -- Function: dict (mapping, **kwarg)

 -- Function: dict (iterable, **kwarg)

     Create a new dictionary.  The *note dict: 305. object is the
     dictionary class.  See *note dict: 305. and *note Mapping Types —
     dict: 54c. for documentation about this class.

     For other containers see the built-in *note list: 3bc, *note set:
     36a, and *note tuple: 408. classes, as well as the *note
     collections: 65. module.

 -- Function: dir ([object])

     Without arguments, return the list of names in the current local
     scope.  With an argument, attempt to return a list of valid
     attributes for that object.

     If the object has a method named ‘__dir__()’, this method will be
     called and must return the list of attributes.  This allows objects
     that implement a custom *note __getattr__(): 331. or *note
     __getattribute__(): 33b. function to customize the way *note dir():
     33a. reports their attributes.

     If the object does not provide ‘__dir__()’, the function tries its
     best to gather information from the object’s ‘__dict__’ attribute,
     if defined, and from its type object.  The resulting list is not
     necessarily complete, and may be inaccurate when the object has a
     custom *note __getattr__(): 331.

     The default *note dir(): 33a. mechanism behaves differently with
     different types of objects, as it attempts to produce the most
     relevant, rather than complete, information:

        * If the object is a module object, the list contains the names
          of the module’s attributes.

        * If the object is a type or class object, the list contains the
          names of its attributes, and recursively of the attributes of
          its bases.

        * Otherwise, the list contains the object’s attributes’ names,
          the names of its class’s attributes, and recursively of the
          attributes of its class’s base classes.

     The resulting list is sorted alphabetically.  For example:

          >>> import struct
          >>> dir()   # show the names in the module namespace
          ['__builtins__', '__doc__', '__name__', 'struct']
          >>> dir(struct)   # show the names in the struct module
          ['Struct', '__builtins__', '__doc__', '__file__', '__name__',
           '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
           'unpack', 'unpack_from']
          >>> class Shape(object):
                  def __dir__(self):
                      return ['area', 'perimeter', 'location']
          >>> s = Shape()
          >>> dir(s)
          ['area', 'perimeter', 'location']

          Note: Because *note dir(): 33a. is supplied primarily as a
          convenience for use at an interactive prompt, it tries to
          supply an interesting set of names more than it tries to
          supply a rigorously or consistently defined set of names, and
          its detailed behavior may change across releases.  For
          example, metaclass attributes are not in the result list when
          the argument is a class.

 -- Function: divmod (a, b)

     Take two (non complex) numbers as arguments and return a pair of
     numbers consisting of their quotient and remainder when using long
     division.  With mixed operand types, the rules for binary
     arithmetic operators apply.  For plain and long integers, the
     result is the same as ‘(a // b, a % b)’.  For floating point
     numbers the result is ‘(q, a % b)’, where _q_ is usually
     ‘math.floor(a / b)’ but may be 1 less than that.  In any case ‘q *
     b + a % b’ is very close to _a_, if ‘a % b’ is non-zero it has the
     same sign as _b_, and ‘0 <= abs(a % b) < abs(b)’.

     Changed in version 2.3: Using *note divmod(): 73d. with complex
     numbers is deprecated.

 -- Function: enumerate (sequence, start=0)

     Return an enumerate object.  _sequence_ must be a sequence, an
     *note iterator: 87f, or some other object which supports iteration.
     The ‘next()’ method of the iterator returned by *note enumerate():
     427. returns a tuple containing a count (from _start_ which
     defaults to 0) and the values obtained from iterating over
     _sequence_:

          >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
          >>> list(enumerate(seasons))
          [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
          >>> list(enumerate(seasons, start=1))
          [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

     Equivalent to:

          def enumerate(sequence, start=0):
              n = start
              for elem in sequence:
                  yield n, elem
                  n += 1

     New in version 2.3.

     Changed in version 2.6: The _start_ parameter was added.

 -- Function: eval (expression[, globals[, locals]])

     The arguments are a Unicode or _Latin-1_ encoded string and
     optional globals and locals.  If provided, _globals_ must be a
     dictionary.  If provided, _locals_ can be any mapping object.

     Changed in version 2.4: formerly _locals_ was required to be a
     dictionary.

     The _expression_ argument is parsed and evaluated as a Python
     expression (technically speaking, a condition list) using the
     _globals_ and _locals_ dictionaries as global and local namespace.
     If the _globals_ dictionary is present and lacks ’__builtins__’,
     the current globals are copied into _globals_ before _expression_
     is parsed.  This means that _expression_ normally has full access
     to the standard *note __builtin__: 0. module and restricted
     environments are propagated.  If the _locals_ dictionary is omitted
     it defaults to the _globals_ dictionary.  If both dictionaries are
     omitted, the expression is executed in the environment where *note
     eval(): 360. is called.  The return value is the result of the
     evaluated expression.  Syntax errors are reported as exceptions.
     Example:

          >>> x = 1
          >>> print eval('x+1')
          2

     This function can also be used to execute arbitrary code objects
     (such as those created by *note compile(): 1fb.).  In this case
     pass a code object instead of a string.  If the code object has
     been compiled with ‘'exec'’ as the _mode_ argument, *note eval():
     360.’s return value will be ‘None’.

     Hints: dynamic execution of statements is supported by the *note
     exec: 404. statement.  Execution of statements from a file is
     supported by the *note execfile(): 436. function.  The *note
     globals(): 835. and *note locals(): 33c. functions returns the
     current global and local dictionary, respectively, which may be
     useful to pass around for use by *note eval(): 360. or *note
     execfile(): 436.

     See *note ast.literal_eval(): 880. for a function that can safely
     evaluate strings with expressions containing only literals.

 -- Function: execfile (filename[, globals[, locals]])

     This function is similar to the *note exec: 404. statement, but
     parses a file instead of a string.  It is different from the *note
     import: 1f4. statement in that it does not use the module
     administration — it reads the file unconditionally and does not
     create a new module.  (2)

     The arguments are a file name and two optional dictionaries.  The
     file is parsed and evaluated as a sequence of Python statements
     (similarly to a module) using the _globals_ and _locals_
     dictionaries as global and local namespace.  If provided, _locals_
     can be any mapping object.  Remember that at module level, globals
     and locals are the same dictionary.  If two separate objects are
     passed as _globals_ and _locals_, the code will be executed as if
     it were embedded in a class definition.

     Changed in version 2.4: formerly _locals_ was required to be a
     dictionary.

     If the _locals_ dictionary is omitted it defaults to the _globals_
     dictionary.  If both dictionaries are omitted, the expression is
     executed in the environment where *note execfile(): 436. is called.
     The return value is ‘None’.

          Note: The default _locals_ act as described for function *note
          locals(): 33c. below: modifications to the default _locals_
          dictionary should not be attempted.  Pass an explicit _locals_
          dictionary if you need to see effects of the code on _locals_
          after function *note execfile(): 436. returns.  *note
          execfile(): 436. cannot be used reliably to modify a
          function’s locals.

 -- Function: file (name[, mode[, buffering]])

     Constructor function for the *note file: 1f9. type, described
     further in section *note File Objects: 643.  The constructor’s
     arguments are the same as those of the *note open(): 2d6. built-in
     function described below.

     When opening a file, it’s preferable to use *note open(): 2d6.
     instead of invoking this constructor directly.  *note file: 1f9. is
     more suited to type testing (for example, writing ‘isinstance(f,
     file)’).

     New in version 2.2.

 -- Function: filter (function, iterable)

     Construct a list from those elements of _iterable_ for which
     _function_ returns true.  _iterable_ may be either a sequence, a
     container which supports iteration, or an iterator.  If _iterable_
     is a string or a tuple, the result also has that type; otherwise it
     is always a list.  If _function_ is ‘None’, the identity function
     is assumed, that is, all elements of _iterable_ that are false are
     removed.

     Note that ‘filter(function, iterable)’ is equivalent to ‘[item for
     item in iterable if function(item)]’ if function is not ‘None’ and
     ‘[item for item in iterable if item]’ if function is ‘None’.

     See *note itertools.ifilter(): 881. and *note
     itertools.ifilterfalse(): 882. for iterator versions of this
     function, including a variation that filters for elements where the
     _function_ returns false.

 -- Function: float ([x])

     Convert a string or a number to floating point.  If the argument is
     a string, it must contain a possibly signed decimal or floating
     point number, possibly embedded in whitespace.  The argument may
     also be [+|-]nan or [+|-]inf.  Otherwise, the argument may be a
     plain or long integer or a floating point number, and a floating
     point number with the same value (within Python’s floating point
     precision) is returned.  If no argument is given, returns ‘0.0’.

          Note: 
          When passing in a string, values for NaN and Infinity may be
          returned, depending on the underlying C library.  Float
          accepts the strings nan, inf and -inf for NaN and positive or
          negative infinity.  The case and a leading + are ignored as
          well as a leading - is ignored for NaN. Float always
          represents NaN and infinity as nan, inf or -inf.

     The float type is described in *note Numeric Types — int, float,
     long, complex: 87e.

 -- Function: format (value[, format_spec])

     Convert a _value_ to a "formatted" representation, as controlled by
     _format_spec_.  The interpretation of _format_spec_ will depend on
     the type of the _value_ argument, however there is a standard
     formatting syntax that is used by most built-in types: *note Format
     Specification Mini-Language: 883.

          Note: ‘format(value, format_spec)’ merely calls
          ‘value.__format__(format_spec)’.

     New in version 2.6.

 -- Function: frozenset ([iterable])

     Return a new *note frozenset: 36b. object, optionally with elements
     taken from _iterable_.  ‘frozenset’ is a built-in class.  See *note
     frozenset: 36b. and *note Set Types — set, frozenset: 884. for
     documentation about this class.

     For other containers see the built-in *note set: 36a, *note list:
     3bc, *note tuple: 408, and *note dict: 305. classes, as well as the
     *note collections: 65. module.

     New in version 2.4.

 -- Function: getattr (object, name[, default])

     Return the value of the named attribute of _object_.  _name_ must
     be a string.  If the string is the name of one of the object’s
     attributes, the result is the value of that attribute.  For
     example, ‘getattr(x, 'foobar')’ is equivalent to ‘x.foobar’.  If
     the named attribute does not exist, _default_ is returned if
     provided, otherwise *note AttributeError: 1f8. is raised.

 -- Function: globals ()

     Return a dictionary representing the current global symbol table.
     This is always the dictionary of the current module (inside a
     function or method, this is the module where it is defined, not the
     module from which it is called).

 -- Function: hasattr (object, name)

     The arguments are an object and a string.  The result is ‘True’ if
     the string is the name of one of the object’s attributes, ‘False’
     if not.  (This is implemented by calling ‘getattr(object, name)’
     and seeing whether it raises an exception or not.)

 -- Function: hash (object)

     Return the hash value of the object (if it has one).  Hash values
     are integers.  They are used to quickly compare dictionary keys
     during a dictionary lookup.  Numeric values that compare equal have
     the same hash value (even if they are of different types, as is the
     case for 1 and 1.0).

 -- Function: help ([object])

     Invoke the built-in help system.  (This function is intended for
     interactive use.)  If no argument is given, the interactive help
     system starts on the interpreter console.  If the argument is a
     string, then the string is looked up as the name of a module,
     function, class, method, keyword, or documentation topic, and a
     help page is printed on the console.  If the argument is any other
     kind of object, a help page on the object is generated.

     This function is added to the built-in namespace by the *note site:
     158. module.

     New in version 2.2.

 -- Function: hex (x)

     Convert an integer number (of any size) to a lowercase hexadecimal
     string prefixed with "0x", for example:

          >>> hex(255)
          '0xff'
          >>> hex(-42)
          '-0x2a'
          >>> hex(1L)
          '0x1L'

     If x is not a Python *note int: 1f2. or *note long: 1f3. object, it
     has to define an __index__() method that returns an integer.

     See also *note int(): 1f2. for converting a hexadecimal string to
     an integer using a base of 16.

          Note: To obtain a hexadecimal string representation for a
          float, use the *note float.hex(): 885. method.

     Changed in version 2.4: Formerly only returned an unsigned literal.

 -- Function: id (object)

     Return the "identity" of an object.  This is an integer (or long
     integer) which is guaranteed to be unique and constant for this
     object during its lifetime.  Two objects with non-overlapping
     lifetimes may have the same *note id(): 3b2. value.

     *CPython implementation detail:* This is the address of the object
     in memory.

 -- Function: input ([prompt])

     Equivalent to ‘eval(raw_input(prompt))’.

     This function does not catch user errors.  If the input is not
     syntactically valid, a *note SyntaxError: 498. will be raised.
     Other exceptions may be raised if there is an error during
     evaluation.

     If the *note readline: 144. module was loaded, then *note input():
     3bf. will use it to provide elaborate line editing and history
     features.

     Consider using the *note raw_input(): 869. function for general
     input from users.

 -- Function: int (x=0)

 -- Function: int (x, base=10)

     Convert a number or string _x_ to an integer, or return ‘0’ if no
     arguments are given.  If _x_ is a number, it can be a plain
     integer, a long integer, or a floating point number.  If _x_ is
     floating point, the conversion truncates towards zero.  If the
     argument is outside the integer range, the function returns a long
     object instead.

     If _x_ is not a number or if _base_ is given, then _x_ must be a
     string or Unicode object representing an *note integer literal:
     6cb. in radix _base_.  Optionally, the literal can be preceded by
     ‘+’ or ‘-’ (with no space in between) and surrounded by whitespace.
     A base-n literal consists of the digits 0 to n-1, with ‘a’ to ‘z’
     (or ‘A’ to ‘Z’) having values 10 to 35.  The default _base_ is 10.
     The allowed values are 0 and 2-36.  Base-2, -8, and -16 literals
     can be optionally prefixed with ‘0b’/‘0B’, ‘0o’/‘0O’/‘0’, or
     ‘0x’/‘0X’, as with integer literals in code.  Base 0 means to
     interpret the string exactly as an integer literal, so that the
     actual base is 2, 8, 10, or 16.

     The integer type is described in *note Numeric Types — int, float,
     long, complex: 87e.

 -- Function: isinstance (object, classinfo)

     Return true if the _object_ argument is an instance of the
     _classinfo_ argument, or of a (direct, indirect or *note virtual:
     886.) subclass thereof.  Also return true if _classinfo_ is a type
     object (new-style class) and _object_ is an object of that type or
     of a (direct, indirect or *note virtual: 886.) subclass thereof.
     If _object_ is not a class instance or an object of the given type,
     the function always returns false.  If _classinfo_ is neither a
     class object nor a type object, it may be a tuple of class or type
     objects, or may recursively contain other such tuples (other
     sequence types are not accepted).  If _classinfo_ is not a class,
     type, or tuple of classes, types, and such tuples, a *note
     TypeError: 218. exception is raised.

     Changed in version 2.2: Support for a tuple of type information was
     added.

 -- Function: issubclass (class, classinfo)

     Return true if _class_ is a subclass (direct, indirect or *note
     virtual: 886.) of _classinfo_.  A class is considered a subclass of
     itself.  _classinfo_ may be a tuple of class objects, in which case
     every entry in _classinfo_ will be checked.  In any other case, a
     *note TypeError: 218. exception is raised.

     Changed in version 2.3: Support for a tuple of type information was
     added.

 -- Function: iter (o[, sentinel])

     Return an *note iterator: 87f. object.  The first argument is
     interpreted very differently depending on the presence of the
     second argument.  Without a second argument, _o_ must be a
     collection object which supports the iteration protocol (the *note
     __iter__(): 321. method), or it must support the sequence protocol
     (the *note __getitem__(): 44f. method with integer arguments
     starting at ‘0’).  If it does not support either of those
     protocols, *note TypeError: 218. is raised.  If the second
     argument, _sentinel_, is given, then _o_ must be a callable object.
     The iterator created in this case will call _o_ with no arguments
     for each call to its *note next(): 5d9. method; if the value
     returned is equal to _sentinel_, *note StopIteration: 333. will be
     raised, otherwise the value will be returned.

     One useful application of the second form of *note iter(): 320. is
     to read lines of a file until a certain line is reached.  The
     following example reads a file until the *note readline(): 887.
     method returns an empty string:

          with open('mydata.txt') as fp:
              for line in iter(fp.readline, ''):
                  process_line(line)

     New in version 2.2.

 -- Function: len (s)

     Return the length (the number of items) of an object.  The argument
     may be a sequence (such as a string, bytes, tuple, list, or range)
     or a collection (such as a dictionary, set, or frozen set).

 -- Function: list ([iterable])

     Return a list whose items are the same and in the same order as
     _iterable_’s items.  _iterable_ may be either a sequence, a
     container that supports iteration, or an iterator object.  If
     _iterable_ is already a list, a copy is made and returned, similar
     to ‘iterable[:]’.  For instance, ‘list('abc')’ returns ‘['a', 'b',
     'c']’ and ‘list( (1, 2, 3) )’ returns ‘[1, 2, 3]’.  If no argument
     is given, returns a new empty list, ‘[]’.

     *note list: 3bc. is a mutable sequence type, as documented in *note
     Sequence Types — str, unicode, list, tuple, bytearray, buffer,
     xrange: 521.  For other containers see the built in *note dict:
     305, *note set: 36a, and *note tuple: 408. classes, and the *note
     collections: 65. module.

 -- Function: locals ()

     Update and return a dictionary representing the current local
     symbol table.  Free variables are returned by *note locals(): 33c.
     when it is called in function blocks, but not in class blocks.

          Note: The contents of this dictionary should not be modified;
          changes may not affect the values of local and free variables
          used by the interpreter.

 -- Function: long (x=0)

 -- Function: long (x, base=10)

     Convert a string or number to a long integer.  If the argument is a
     string, it must contain a possibly signed number of arbitrary size,
     possibly embedded in whitespace.  The _base_ argument is
     interpreted in the same way as for *note int(): 1f2, and may only
     be given when _x_ is a string.  Otherwise, the argument may be a
     plain or long integer or a floating point number, and a long
     integer with the same value is returned.  Conversion of floating
     point numbers to integers truncates (towards zero).  If no
     arguments are given, returns ‘0L’.

     The long type is described in *note Numeric Types — int, float,
     long, complex: 87e.

 -- Function: map (function, iterable, ...)

     Apply _function_ to every item of _iterable_ and return a list of
     the results.  If additional _iterable_ arguments are passed,
     _function_ must take that many arguments and is applied to the
     items from all iterables in parallel.  If one iterable is shorter
     than another it is assumed to be extended with ‘None’ items.  If
     _function_ is ‘None’, the identity function is assumed; if there
     are multiple arguments, *note map(): 304. returns a list consisting
     of tuples containing the corresponding items from all iterables (a
     kind of transpose operation).  The _iterable_ arguments may be a
     sequence or any iterable object; the result is always a list.

 -- Function: max (iterable[, key])

 -- Function: max (arg1, arg2, *args[, key])

     Return the largest item in an iterable or the largest of two or
     more arguments.

     If one positional argument is provided, _iterable_ must be a
     non-empty iterable (such as a non-empty string, tuple or list).
     The largest item in the iterable is returned.  If two or more
     positional arguments are provided, the largest of the positional
     arguments is returned.

     The optional _key_ argument specifies a one-argument ordering
     function like that used for ‘list.sort()’.  The _key_ argument, if
     supplied, must be in keyword form (for example,
     ‘max(a,b,c,key=func)’).

     Changed in version 2.5: Added support for the optional _key_
     argument.

 -- Function: memoryview (obj)

     Return a "memory view" object created from the given argument.  See
     *note memoryview type: 888. for more information.

 -- Function: min (iterable[, key])

 -- Function: min (arg1, arg2, *args[, key])

     Return the smallest item in an iterable or the smallest of two or
     more arguments.

     If one positional argument is provided, _iterable_ must be a
     non-empty iterable (such as a non-empty string, tuple or list).
     The smallest item in the iterable is returned.  If two or more
     positional arguments are provided, the smallest of the positional
     arguments is returned.

     The optional _key_ argument specifies a one-argument ordering
     function like that used for ‘list.sort()’.  The _key_ argument, if
     supplied, must be in keyword form (for example,
     ‘min(a,b,c,key=func)’).

     Changed in version 2.5: Added support for the optional _key_
     argument.

 -- Function: next (iterator[, default])

     Retrieve the next item from the _iterator_ by calling its *note
     next(): 5d9. method.  If _default_ is given, it is returned if the
     iterator is exhausted, otherwise *note StopIteration: 333. is
     raised.

     New in version 2.6.

 -- Function: object ()

     Return a new featureless object.  *note object: 1f1. is a base for
     all new style classes.  It has the methods that are common to all
     instances of new style classes.

     New in version 2.2.

     Changed in version 2.3: This function does not accept any
     arguments.  Formerly, it accepted arguments but ignored them.

 -- Function: oct (x)

     Convert an integer number (of any size) to an octal string.  The
     result is a valid Python expression.

     Changed in version 2.4: Formerly only returned an unsigned literal.

 -- Function: open (name[, mode[, buffering]])

     Open a file, returning an object of the *note file: 1f9. type
     described in section *note File Objects: 643.  If the file cannot
     be opened, *note IOError: 1fa. is raised.  When opening a file,
     it’s preferable to use *note open(): 2d6. instead of invoking the
     *note file: 1f9. constructor directly.

     The first two arguments are the same as for ‘stdio’’s ‘fopen()’:
     _name_ is the file name to be opened, and _mode_ is a string
     indicating how the file is to be opened.

     The most commonly-used values of _mode_ are ‘'r'’ for reading,
     ‘'w'’ for writing (truncating the file if it already exists), and
     ‘'a'’ for appending (which on _some_ Unix systems means that _all_
     writes append to the end of the file regardless of the current seek
     position).  If _mode_ is omitted, it defaults to ‘'r'’.  The
     default is to use text mode, which may convert ‘'\n'’ characters to
     a platform-specific representation on writing and back on reading.
     Thus, when opening a binary file, you should append ‘'b'’ to the
     _mode_ value to open the file in binary mode, which will improve
     portability.  (Appending ‘'b'’ is useful even on systems that don’t
     treat binary and text files differently, where it serves as
     documentation.)  See below for more possible values of _mode_.

     The optional _buffering_ argument specifies the file’s desired
     buffer size: 0 means unbuffered, 1 means line buffered, any other
     positive value means use a buffer of (approximately) that size (in
     bytes).  A negative _buffering_ means to use the system default,
     which is usually line buffered for tty devices and fully buffered
     for other files.  If omitted, the system default is used.  (3)

     Modes ‘'r+'’, ‘'w+'’ and ‘'a+'’ open the file for updating (reading
     and writing); note that ‘'w+'’ truncates the file.  Append ‘'b'’ to
     the mode to open the file in binary mode, on systems that
     differentiate between binary and text files; on systems that don’t
     have this distinction, adding the ‘'b'’ has no effect.

     In addition to the standard ‘fopen()’ values _mode_ may be ‘'U'’ or
     ‘'rU'’.  Python is usually built with *note universal newlines:
     315. support; supplying ‘'U'’ opens the file as a text file, but
     lines may be terminated by any of the following: the Unix
     end-of-line convention ‘'\n'’, the Macintosh convention ‘'\r'’, or
     the Windows convention ‘'\r\n'’.  All of these external
     representations are seen as ‘'\n'’ by the Python program.  If
     Python is built without universal newlines support a _mode_ with
     ‘'U'’ is the same as normal text mode.  Note that file objects so
     opened also have an attribute called ‘newlines’ which has a value
     of ‘None’ (if no newlines have yet been seen), ‘'\n'’, ‘'\r'’,
     ‘'\r\n'’, or a tuple containing all the newline types seen.

     Python enforces that the mode, after stripping ‘'U'’, begins with
     ‘'r'’, ‘'w'’ or ‘'a'’.

     Python provides many file handling modules including *note
     fileinput: cc, *note os: 128, *note os.path: 129, *note tempfile:
     173, and *note shutil: 154.

     Changed in version 2.5: Restriction on first letter of mode string
     introduced.

 -- Function: ord (c)

     Given a string of length one, return an integer representing the
     Unicode code point of the character when the argument is a unicode
     object, or the value of the byte when the argument is an 8-bit
     string.  For example, ‘ord('a')’ returns the integer ‘97’,
     ‘ord(u'\u2020')’ returns ‘8224’.  This is the inverse of *note
     chr(): 6f2. for 8-bit strings and of *note unichr(): 495. for
     unicode objects.  If a unicode argument is given and Python was
     built with UCS2 Unicode, then the character’s code point must be in
     the range [0..65535] inclusive; otherwise the string length is two,
     and a *note TypeError: 218. will be raised.

 -- Function: pow (x, y[, z])

     Return _x_ to the power _y_; if _z_ is present, return _x_ to the
     power _y_, modulo _z_ (computed more efficiently than ‘pow(x, y) %
     z’).  The two-argument form ‘pow(x, y)’ is equivalent to using the
     power operator: ‘x**y’.

     The arguments must have numeric types.  With mixed operand types,
     the coercion rules for binary arithmetic operators apply.  For int
     and long int operands, the result has the same type as the operands
     (after coercion) unless the second argument is negative; in that
     case, all arguments are converted to float and a float result is
     delivered.  For example, ‘10**2’ returns ‘100’, but ‘10**-2’
     returns ‘0.01’.  (This last feature was added in Python 2.2.  In
     Python 2.1 and before, if both arguments were of integer types and
     the second argument was negative, an exception was raised.)  If the
     second argument is negative, the third argument must be omitted.
     If _z_ is present, _x_ and _y_ must be of integer types, and _y_
     must be non-negative.  (This restriction was added in Python 2.2.
     In Python 2.1 and before, floating 3-argument ‘pow()’ returned
     platform-dependent results depending on floating-point rounding
     accidents.)

 -- Function: print (*objects, sep=' ', end='\n', file=sys.stdout)

     Print _objects_ to the stream _file_, separated by _sep_ and
     followed by _end_.  _sep_, _end_ and _file_, if present, must be
     given as keyword arguments.

     All non-keyword arguments are converted to strings like *note
     str(): 1ea. does and written to the stream, separated by _sep_ and
     followed by _end_.  Both _sep_ and _end_ must be strings; they can
     also be ‘None’, which means to use the default values.  If no
     _objects_ are given, *note print(): 30b. will just write _end_.

     The _file_ argument must be an object with a ‘write(string)’
     method; if it is not present or ‘None’, *note sys.stdout: 889. will
     be used.  Output buffering is determined by _file_.  Use
     ‘file.flush()’ to ensure, for instance, immediate appearance on a
     screen.

          Note: This function is not normally available as a built-in
          since the name ‘print’ is recognized as the *note print: 4e0.
          statement.  To disable the statement and use the *note
          print(): 30b. function, use this future statement at the top
          of your module:

               from __future__ import print_function

     New in version 2.6.

 -- Function: property ([fget[, fset[, fdel[, doc]]]])

     Return a property attribute for *note new-style class: 5d1.es
     (classes that derive from *note object: 1f1.).

     _fget_ is a function for getting an attribute value, likewise
     _fset_ is a function for setting, and _fdel_ a function for
     del’ing, an attribute.  Typical use is to define a managed
     attribute ‘x’:

          class C(object):
              def __init__(self):
                  self._x = None

              def getx(self):
                  return self._x
              def setx(self, value):
                  self._x = value
              def delx(self):
                  del self._x
              x = property(getx, setx, delx, "I'm the 'x' property.")

     If then _c_ is an instance of _C_, ‘c.x’ will invoke the getter,
     ‘c.x = value’ will invoke the setter and ‘del c.x’ the deleter.

     If given, _doc_ will be the docstring of the property attribute.
     Otherwise, the property will copy _fget_’s docstring (if it
     exists).  This makes it possible to create read-only properties
     easily using *note property(): 487. as a *note decorator: 856.:

          class Parrot(object):
              def __init__(self):
                  self._voltage = 100000

              @property
              def voltage(self):
                  """Get the current voltage."""
                  return self._voltage

     turns the ‘voltage()’ method into a "getter" for a read-only
     attribute with the same name.

     A property object has ‘getter’, ‘setter’, and ‘deleter’ methods
     usable as decorators that create a copy of the property with the
     corresponding accessor function set to the decorated function.
     This is best explained with an example:

          class C(object):
              def __init__(self):
                  self._x = None

              @property
              def x(self):
                  """I'm the 'x' property."""
                  return self._x

              @x.setter
              def x(self, value):
                  self._x = value

              @x.deleter
              def x(self):
                  del self._x

     This code is exactly equivalent to the first example.  Be sure to
     give the additional functions the same name as the original
     property (‘x’ in this case.)

     The returned property also has the attributes ‘fget’, ‘fset’, and
     ‘fdel’ corresponding to the constructor arguments.

     New in version 2.2.

     Changed in version 2.5: Use _fget_’s docstring if no _doc_ given.

     Changed in version 2.6: The ‘getter’, ‘setter’, and ‘deleter’
     attributes were added.

 -- Function: range (stop)

 -- Function: range (start, stop[, step])

     This is a versatile function to create lists containing arithmetic
     progressions.  It is most often used in *note for: 2f0. loops.  The
     arguments must be plain integers.  If the _step_ argument is
     omitted, it defaults to ‘1’.  If the _start_ argument is omitted,
     it defaults to ‘0’.  The full form returns a list of plain integers
     ‘[start, start + step, start + 2 * step, ...]’.  If _step_ is
     positive, the last element is the largest ‘start + i * step’ less
     than _stop_; if _step_ is negative, the last element is the
     smallest ‘start + i * step’ greater than _stop_.  _step_ must not
     be zero (or else *note ValueError: 236. is raised).  Example:

          >>> range(10)
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
          >>> range(1, 11)
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          >>> range(0, 30, 5)
          [0, 5, 10, 15, 20, 25]
          >>> range(0, 10, 3)
          [0, 3, 6, 9]
          >>> range(0, -10, -1)
          [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
          >>> range(0)
          []
          >>> range(1, 0)
          []

 -- Function: raw_input ([prompt])

     If the _prompt_ argument is present, it is written to standard
     output without a trailing newline.  The function then reads a line
     from input, converts it to a string (stripping a trailing newline),
     and returns that.  When EOF is read, *note EOFError: 88a. is
     raised.  Example:

          >>> s = raw_input('--> ')
          --> Monty Python's Flying Circus
          >>> s
          "Monty Python's Flying Circus"

     If the *note readline: 144. module was loaded, then *note
     raw_input(): 869. will use it to provide elaborate line editing and
     history features.

 -- Function: reduce (function, iterable[, initializer])

     Apply _function_ of two arguments cumulatively to the items of
     _iterable_, from left to right, so as to reduce the iterable to a
     single value.  For example, ‘reduce(lambda x, y: x+y, [1, 2, 3, 4,
     5])’ calculates ‘((((1+2)+3)+4)+5)’.  The left argument, _x_, is
     the accumulated value and the right argument, _y_, is the update
     value from the _iterable_.  If the optional _initializer_ is
     present, it is placed before the items of the iterable in the
     calculation, and serves as a default when the iterable is empty.
     If _initializer_ is not given and _iterable_ contains only one
     item, the first item is returned.  Roughly equivalent to:

          def reduce(function, iterable, initializer=None):
              it = iter(iterable)
              if initializer is None:
                  try:
                      initializer = next(it)
                  except StopIteration:
                      raise TypeError('reduce() of empty sequence with no initial value')
              accum_value = initializer
              for x in it:
                  accum_value = function(accum_value, x)
              return accum_value

 -- Function: reload (module)

     Reload a previously imported _module_.  The argument must be a
     module object, so it must have been successfully imported before.
     This is useful if you have edited the module source file using an
     external editor and want to try out the new version without leaving
     the Python interpreter.  The return value is the module object (the
     same as the _module_ argument).

     When ‘reload(module)’ is executed:

        * Python modules’ code is recompiled and the module-level code
          reexecuted, defining a new set of objects which are bound to
          names in the module’s dictionary.  The ‘init’ function of
          extension modules is not called a second time.

        * As with all other objects in Python the old objects are only
          reclaimed after their reference counts drop to zero.

        * The names in the module namespace are updated to point to any
          new or changed objects.

        * Other references to the old objects (such as names external to
          the module) are not rebound to refer to the new objects and
          must be updated in each namespace where they occur if that is
          desired.

     There are a number of other caveats:

     If a module is syntactically correct but its initialization fails,
     the first *note import: 1f4. statement for it does not bind its
     name locally, but does store a (partially initialized) module
     object in ‘sys.modules’.  To reload the module you must first *note
     import: 1f4. it again (this will bind the name to the partially
     initialized module object) before you can *note reload(): 57a. it.

     When a module is reloaded, its dictionary (containing the module’s
     global variables) is retained.  Redefinitions of names will
     override the old definitions, so this is generally not a problem.
     If the new version of a module does not define a name that was
     defined by the old version, the old definition remains.  This
     feature can be used to the module’s advantage if it maintains a
     global table or cache of objects — with a *note try: 395. statement
     it can test for the table’s presence and skip its initialization if
     desired:

          try:
              cache
          except NameError:
              cache = {}

     It is legal though generally not very useful to reload built-in or
     dynamically loaded modules, except for *note sys: 16d, *note
     __main__: 2. and *note __builtin__: 0.  In many cases, however,
     extension modules are not designed to be initialized more than
     once, and may fail in arbitrary ways when reloaded.

     If a module imports objects from another module using *note from:
     81f. ...  *note import: 1f4. ..., calling *note reload(): 57a. for
     the other module does not redefine the objects imported from it —
     one way around this is to re-execute the *note from: 81f.
     statement, another is to use *note import: 1f4. and qualified names
     (_module_.*name*) instead.

     If a module instantiates instances of a class, reloading the module
     that defines the class does not affect the method definitions of
     the instances — they continue to use the old class definition.  The
     same is true for derived classes.
 -- Function: repr (object)

     Return a string containing a printable representation of an object.
     This is the same value yielded by conversions (reverse quotes).  It
     is sometimes useful to be able to access this operation as an
     ordinary function.  For many types, this function makes an attempt
     to return a string that would yield an object with the same value
     when passed to *note eval(): 360, otherwise the representation is a
     string enclosed in angle brackets that contains the name of the
     type of the object together with additional information often
     including the name and address of the object.  A class can control
     what this function returns for its instances by defining a *note
     __repr__(): 486. method.

 -- Function: reversed (seq)

     Return a reverse *note iterator: 87f.  _seq_ must be an object
     which has a *note __reversed__(): 72b. method or supports the
     sequence protocol (the *note __len__(): 40a. method and the *note
     __getitem__(): 44f. method with integer arguments starting at ‘0’).

     New in version 2.4.

     Changed in version 2.6: Added the possibility to write a custom
     *note __reversed__(): 72b. method.

 -- Function: round (number[, ndigits])

     Return the floating point value _number_ rounded to _ndigits_
     digits after the decimal point.  If _ndigits_ is omitted, it
     defaults to zero.  The result is a floating point number.  Values
     are rounded to the closest multiple of 10 to the power minus
     _ndigits_; if two multiples are equally close, rounding is done
     away from 0 (so.  for example, ‘round(0.5)’ is ‘1.0’ and
     ‘round(-0.5)’ is ‘-1.0’).

          Note: The behavior of *note round(): 1c5. for floats can be
          surprising: for example, ‘round(2.675, 2)’ gives ‘2.67’
          instead of the expected ‘2.68’.  This is not a bug: it’s a
          result of the fact that most decimal fractions can’t be
          represented exactly as a float.  See *note Floating Point
          Arithmetic; Issues and Limitations: 624. for more information.

 -- Function: set ([iterable])

     Return a new *note set: 36a. object, optionally with elements taken
     from _iterable_.  ‘set’ is a built-in class.  See *note set: 36a.
     and *note Set Types — set, frozenset: 884. for documentation about
     this class.

     For other containers see the built-in *note frozenset: 36b, *note
     list: 3bc, *note tuple: 408, and *note dict: 305. classes, as well
     as the *note collections: 65. module.

     New in version 2.4.

 -- Function: setattr (object, name, value)

     This is the counterpart of *note getattr(): 875.  The arguments are
     an object, a string and an arbitrary value.  The string may name an
     existing attribute or a new attribute.  The function assigns the
     value to the attribute, provided the object allows it.  For
     example, ‘setattr(x, 'foobar', 123)’ is equivalent to ‘x.foobar =
     123’.

 -- Function: slice (stop)

 -- Function: slice (start, stop[, step])

     Return a *note slice: 88c. object representing the set of indices
     specified by ‘range(start, stop, step)’.  The _start_ and _step_
     arguments default to ‘None’.  Slice objects have read-only data
     attributes ‘start’, ‘stop’ and ‘step’ which merely return the
     argument values (or their default).  They have no other explicit
     functionality; however they are used by Numerical Python and other
     third party extensions.  Slice objects are also generated when
     extended indexing syntax is used.  For example:
     ‘a[start:stop:step]’ or ‘a[start:stop, i]’.  See *note
     itertools.islice(): 3c1. for an alternate version that returns an
     iterator.

 -- Function: sorted (iterable[, cmp[, key[, reverse]]])

     Return a new sorted list from the items in _iterable_.

     The optional arguments _cmp_, _key_, and _reverse_ have the same
     meaning as those for the ‘list.sort()’ method (described in section
     *note Mutable Sequence Types: 87d.).

     _cmp_ specifies a custom comparison function of two arguments
     (iterable elements) which should return a negative, zero or
     positive number depending on whether the first argument is
     considered smaller than, equal to, or larger than the second
     argument: ‘cmp=lambda x,y: cmp(x.lower(), y.lower())’.  The default
     value is ‘None’.

     _key_ specifies a function of one argument that is used to extract
     a comparison key from each list element: ‘key=str.lower’.  The
     default value is ‘None’ (compare the elements directly).

     _reverse_ is a boolean value.  If set to ‘True’, then the list
     elements are sorted as if each comparison were reversed.

     In general, the _key_ and _reverse_ conversion processes are much
     faster than specifying an equivalent _cmp_ function.  This is
     because _cmp_ is called multiple times for each list element while
     _key_ and _reverse_ touch each element only once.  Use *note
     functools.cmp_to_key(): 222. to convert an old-style _cmp_ function
     to a _key_ function.

     For sorting examples and a brief sorting tutorial, see Sorting
     HowTo(4).

     New in version 2.4.

 -- Function: staticmethod (function)

     Return a static method for _function_.

     A static method does not receive an implicit first argument.  To
     declare a static method, use this idiom:

          class C(object):
              @staticmethod
              def f(arg1, arg2, ...):
                  ...

     The ‘@staticmethod’ form is a function *note decorator: 856. – see
     the description of function definitions in *note Function
     definitions: 6f8. for details.

     It can be called either on the class (such as ‘C.f()’) or on an
     instance (such as ‘C().f()’).  The instance is ignored except for
     its class.

     Static methods in Python are similar to those found in Java or C++.
     Also see *note classmethod(): 3f6. for a variant that is useful for
     creating alternate class constructors.

     For more information on static methods, consult the documentation
     on the standard type hierarchy in *note The standard type
     hierarchy: 6ed.

     New in version 2.2.

     Changed in version 2.4: Function decorator syntax added.

 -- Function: str (object='')

     Return a string containing a nicely printable representation of an
     object.  For strings, this returns the string itself.  The
     difference with ‘repr(object)’ is that ‘str(object)’ does not
     always attempt to return a string that is acceptable to *note
     eval(): 360.; its goal is to return a printable string.  If no
     argument is given, returns the empty string, ‘''’.

     For more information on strings see *note Sequence Types — str,
     unicode, list, tuple, bytearray, buffer, xrange: 521. which
     describes sequence functionality (strings are sequences), and also
     the string-specific methods described in the *note String Methods:
     522. section.  To output formatted strings use template strings or
     the ‘%’ operator described in the *note String Formatting
     Operations: 524. section.  In addition see the *note String
     Services: 88d. section.  See also *note unicode(): 1f5.

 -- Function: sum (iterable[, start])

     Sums _start_ and the items of an _iterable_ from left to right and
     returns the total.  _start_ defaults to ‘0’.  The _iterable_’s
     items are normally numbers, and the start value is not allowed to
     be a string.

     For some use cases, there are good alternatives to *note sum():
     426.  The preferred, fast way to concatenate a sequence of strings
     is by calling ‘''.join(sequence)’.  To add floating point values
     with extended precision, see *note math.fsum(): 34d.  To
     concatenate a series of iterables, consider using *note
     itertools.chain(): 88e.

     New in version 2.3.

 -- Function: super (type[, object-or-type])

     Return a proxy object that delegates method calls to a parent or
     sibling class of _type_.  This is useful for accessing inherited
     methods that have been overridden in a class.  The search order is
     same as that used by *note getattr(): 875. except that the _type_
     itself is skipped.

     The *note __mro__: 88f. attribute of the _type_ lists the method
     resolution search order used by both *note getattr(): 875. and
     *note super(): 37d.  The attribute is dynamic and can change
     whenever the inheritance hierarchy is updated.

     If the second argument is omitted, the super object returned is
     unbound.  If the second argument is an object, ‘isinstance(obj,
     type)’ must be true.  If the second argument is a type,
     ‘issubclass(type2, type)’ must be true (this is useful for
     classmethods).

          Note: *note super(): 37d. only works for *note new-style
          class: 5d1.es.

     There are two typical use cases for _super_.  In a class hierarchy
     with single inheritance, _super_ can be used to refer to parent
     classes without naming them explicitly, thus making the code more
     maintainable.  This use closely parallels the use of _super_ in
     other programming languages.

     The second use case is to support cooperative multiple inheritance
     in a dynamic execution environment.  This use case is unique to
     Python and is not found in statically compiled languages or
     languages that only support single inheritance.  This makes it
     possible to implement "diamond diagrams" where multiple base
     classes implement the same method.  Good design dictates that this
     method have the same calling signature in every case (because the
     order of calls is determined at runtime, because that order adapts
     to changes in the class hierarchy, and because that order can
     include sibling classes that are unknown prior to runtime).

     For both use cases, a typical superclass call looks like this:

          class C(B):
              def method(self, arg):
                  super(C, self).method(arg)

     Note that *note super(): 37d. is implemented as part of the binding
     process for explicit dotted attribute lookups such as
     ‘super().__getitem__(name)’.  It does so by implementing its own
     *note __getattribute__(): 33b. method for searching classes in a
     predictable order that supports cooperative multiple inheritance.
     Accordingly, *note super(): 37d. is undefined for implicit lookups
     using statements or operators such as ‘super()[name]’.

     Also note that *note super(): 37d. is not limited to use inside
     methods.  The two argument form specifies the arguments exactly and
     makes the appropriate references.

     For practical suggestions on how to design cooperative classes
     using *note super(): 37d, see guide to using super()(5).

     New in version 2.2.

 -- Function: tuple ([iterable])

     Return a tuple whose items are the same and in the same order as
     _iterable_’s items.  _iterable_ may be a sequence, a container that
     supports iteration, or an iterator object.  If _iterable_ is
     already a tuple, it is returned unchanged.  For instance,
     ‘tuple('abc')’ returns ‘('a', 'b', 'c')’ and ‘tuple([1, 2, 3])’
     returns ‘(1, 2, 3)’.  If no argument is given, returns a new empty
     tuple, ‘()’.

     *note tuple: 408. is an immutable sequence type, as documented in
     *note Sequence Types — str, unicode, list, tuple, bytearray,
     buffer, xrange: 521.  For other containers see the built in *note
     dict: 305, *note list: 3bc, and *note set: 36a. classes, and the
     *note collections: 65. module.

 -- Function: type (object)

 -- Function: type (name, bases, dict)

     With one argument, return the type of an _object_.  The return
     value is a type object.  The *note isinstance(): 31e. built-in
     function is recommended for testing the type of an object.

     With three arguments, return a new type object.  This is
     essentially a dynamic form of the *note class: 33d. statement.  The
     _name_ string is the class name and becomes the *note __name__:
     890. attribute; the _bases_ tuple itemizes the base classes and
     becomes the *note __bases__: 6fc. attribute; and the _dict_
     dictionary is the namespace containing definitions for class body
     and becomes the *note __dict__: 6fe. attribute.  For example, the
     following two statements create identical *note type: 490. objects:

          >>> class X(object):
          ...     a = 1
          ...
          >>> X = type('X', (object,), dict(a=1))

     New in version 2.2.

 -- Function: unichr (i)

     Return the Unicode string of one character whose Unicode code is
     the integer _i_.  For example, ‘unichr(97)’ returns the string
     ‘u'a'’.  This is the inverse of *note ord(): 6f3. for Unicode
     strings.  The valid range for the argument depends how Python was
     configured – it may be either UCS2 [0..0xFFFF] or UCS4
     [0..0x10FFFF]. *note ValueError: 236. is raised otherwise.  For
     ASCII and 8-bit strings see *note chr(): 6f2.

     New in version 2.0.

 -- Function: unicode (object='')

 -- Function: unicode (object[, encoding[, errors]])

     Return the Unicode string version of _object_ using one of the
     following modes:

     If _encoding_ and/or _errors_ are given, ‘unicode()’ will decode
     the object which can either be an 8-bit string or a character
     buffer using the codec for _encoding_.  The _encoding_ parameter is
     a string giving the name of an encoding; if the encoding is not
     known, *note LookupError: 891. is raised.  Error handling is done
     according to _errors_; this specifies the treatment of characters
     which are invalid in the input encoding.  If _errors_ is ‘'strict'’
     (the default), a *note ValueError: 236. is raised on errors, while
     a value of ‘'ignore'’ causes errors to be silently ignored, and a
     value of ‘'replace'’ causes the official Unicode replacement
     character, ‘U+FFFD’, to be used to replace input characters which
     cannot be decoded.  See also the *note codecs: 63. module.

     If no optional parameters are given, ‘unicode()’ will mimic the
     behaviour of ‘str()’ except that it returns Unicode strings instead
     of 8-bit strings.  More precisely, if _object_ is a Unicode string
     or subclass it will return that Unicode string without any
     additional decoding applied.

     For objects which provide a *note __unicode__(): 1f6. method, it
     will call this method without arguments to create a Unicode string.
     For all other objects, the 8-bit string version or representation
     is requested and then converted to a Unicode string using the codec
     for the default encoding in ‘'strict'’ mode.

     For more information on Unicode strings see *note Sequence Types —
     str, unicode, list, tuple, bytearray, buffer, xrange: 521. which
     describes sequence functionality (Unicode strings are sequences),
     and also the string-specific methods described in the *note String
     Methods: 522. section.  To output formatted strings use template
     strings or the ‘%’ operator described in the *note String
     Formatting Operations: 524. section.  In addition see the *note
     String Services: 88d. section.  See also *note str(): 1ea.

     New in version 2.0.

     Changed in version 2.2: Support for *note __unicode__(): 1f6.
     added.

 -- Function: vars ([object])

     Return the *note __dict__: 6fe. attribute for a module, class,
     instance, or any other object with a ‘__dict__’ attribute.

     Objects such as modules and instances have an updateable ‘__dict__’
     attribute; however, other objects may have write restrictions on
     their ‘__dict__’ attributes (for example, new-style classes use a
     dictproxy to prevent direct dictionary updates).

     Without an argument, *note vars(): 598. acts like *note locals():
     33c.  Note, the locals dictionary is only useful for reads since
     updates to the locals dictionary are ignored.

 -- Function: xrange (stop)

 -- Function: xrange (start, stop[, step])

     This function is very similar to *note range(): 2d9, but returns an
     *note xrange object: 892. instead of a list.  This is an opaque
     sequence type which yields the same values as the corresponding
     list, without actually storing them all simultaneously.  The
     advantage of *note xrange(): 45b. over *note range(): 2d9. is
     minimal (since *note xrange(): 45b. still has to create the values
     when asked for them) except when a very large range is used on a
     memory-starved machine or when all of the range’s elements are
     never used (such as when the loop is usually terminated with *note
     break: 53a.).  For more information on xrange objects, see *note
     XRange Type: 892. and *note Sequence Types — str, unicode, list,
     tuple, bytearray, buffer, xrange: 521.

     *CPython implementation detail:* *note xrange(): 45b. is intended
     to be simple and fast.  Implementations may impose restrictions to
     achieve this.  The C implementation of Python restricts all
     arguments to native C longs ("short" Python integers), and also
     requires that the number of elements fit in a native C long.  If a
     larger range is needed, an alternate version can be crafted using
     the *note itertools: fa. module: ‘islice(count(start, step),
     (stop-start+step-1+2*(step<0))//step)’.

 -- Function: zip ([iterable, ...])

     This function returns a list of tuples, where the _i_-th tuple
     contains the _i_-th element from each of the argument sequences or
     iterables.  The returned list is truncated in length to the length
     of the shortest argument sequence.  When there are multiple
     arguments which are all of the same length, *note zip(): 405. is
     similar to *note map(): 304. with an initial argument of ‘None’.
     With a single sequence argument, it returns a list of 1-tuples.
     With no arguments, it returns an empty list.

     The left-to-right evaluation order of the iterables is guaranteed.
     This makes possible an idiom for clustering a data series into
     n-length groups using ‘zip(*[iter(s)]*n)’.

     *note zip(): 405. in conjunction with the ‘*’ operator can be used
     to unzip a list:

          >>> x = [1, 2, 3]
          >>> y = [4, 5, 6]
          >>> zipped = zip(x, y)
          >>> zipped
          [(1, 4), (2, 5), (3, 6)]
          >>> x2, y2 = zip(*zipped)
          >>> x == list(x2) and y == list(y2)
          True

     New in version 2.0.

     Changed in version 2.4: Formerly, *note zip(): 405. required at
     least one argument and ‘zip()’ raised a *note TypeError: 218.
     instead of returning an empty list.

 -- Function: __import__ (name[, globals[, locals[, fromlist[,
          level]]]])

          Note: This is an advanced function that is not needed in
          everyday Python programming, unlike *note
          importlib.import_module(): 271.

     This function is invoked by the *note import: 1f4. statement.  It
     can be replaced (by importing the *note __builtin__: 0. module and
     assigning to ‘__builtin__.__import__’) in order to change semantics
     of the *note import: 1f4. statement, but nowadays it is usually
     simpler to use import hooks (see PEP 302(6)).  Direct use of *note
     __import__(): 37e. is rare, except in cases where you want to
     import a module whose name is only known at runtime.

     The function imports the module _name_, potentially using the given
     _globals_ and _locals_ to determine how to interpret the name in a
     package context.  The _fromlist_ gives the names of objects or
     submodules that should be imported from the module given by _name_.
     The standard implementation does not use its _locals_ argument at
     all, and uses its _globals_ only to determine the package context
     of the *note import: 1f4. statement.

     _level_ specifies whether to use absolute or relative imports.  The
     default is ‘-1’ which indicates both absolute and relative imports
     will be attempted.  ‘0’ means only perform absolute imports.
     Positive values for _level_ indicate the number of parent
     directories to search relative to the directory of the module
     calling *note __import__(): 37e.

     When the _name_ variable is of the form ‘package.module’, normally,
     the top-level package (the name up till the first dot) is returned,
     _not_ the module named by _name_.  However, when a non-empty
     _fromlist_ argument is given, the module named by _name_ is
     returned.

     For example, the statement ‘import spam’ results in bytecode
     resembling the following code:

          spam = __import__('spam', globals(), locals(), [], -1)

     The statement ‘import spam.ham’ results in this call:

          spam = __import__('spam.ham', globals(), locals(), [], -1)

     Note how *note __import__(): 37e. returns the toplevel module here
     because this is the object that is bound to a name by the *note
     import: 1f4. statement.

     On the other hand, the statement ‘from spam.ham import eggs,
     sausage as saus’ results in

          _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
          eggs = _temp.eggs
          saus = _temp.sausage

     Here, the ‘spam.ham’ module is returned from *note __import__():
     37e.  From this object, the names to import are retrieved and
     assigned to their respective names.

     If you simply want to import a module (potentially within a
     package) by name, use *note importlib.import_module(): 271.

     Changed in version 2.5: The level parameter was added.

     Changed in version 2.5: Keyword support for parameters was added.

   ---------- Footnotes ----------

   (1) http://www.python.org/dev/peps/pep-0236

   (2) It is used relatively rarely so does not warrant being made into
a statement.

   (3) Specifying a buffer size currently has no effect on systems that
don’t have ‘setvbuf()’.  The interface to specify the buffer size is not
done using a method that calls ‘setvbuf()’, because that may dump core
when called after any I/O has been performed, and there’s no reliable
way to determine whether this is the case.

   (4) http://wiki.python.org/moin/HowTo/Sorting/

   (5) 
http://rhettinger.wordpress.com/2011/05/26/super-considered-super/

   (6) http://www.python.org/dev/peps/pep-0302

