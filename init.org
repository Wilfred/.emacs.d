* Introduction
This file is a literate programming document. To generate init.el, run
`M-x org-babel-tangle'. To generate init.html, run `M-x org-export-as-html'.

By default, all the sections in this document are collapsed. You can
expand a header by pressing `<TAB>' when point is on that header. You
can expand all headers by pressing `C-u C-u C-u <TAB>'.

You can edit any code block by putting point inside the block and
pressing `C-c '' (press `C-c '' again to escape). 
* Installing locally

This repository seeks to be as self-contained as possible. However, you will require:

** Emacs 24

I use this repository with Emacs 24. Most code works with Emacs 23 but
I don't test it often.

** Python

I use pyflakes, which is available on PyPI. You can install it with:

#+BEGIN_SRC sh
  sudo pip install pyflakes
#+END_SRC

I also use Jedi, which has some dependencies you can install with:

#+BEGIN_SRC sh
  pip install -r elpa/jedi*/requirements.txt
#+END_SRC

** JavaScript

I use JSHint, which requires you to have node.js installed. To
install JSHint, run:

#+BEGIN_SRC sh
  sudo npm install -g jshint
#+END_SRC

** Less

I use lessc to check the syntax of `.less' files. You can install it
with:

#+BEGIN_SRC sh
  sudo npm install -g less
#+END_SRC

* Contents

** Folder Structure

Code I've written lives in user-lisp. This includes packages that I
haven't polished enough to release yet, small convenience functions,
and package customisations.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/user-lisp/")
#+END_SRC

Code that I haven't written lives in third-party-lisp. This directory
should ultimately disappear once all these packages live in MELPA.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/third-party-lisp/")
#+END_SRC

** Packages

I use ELPA packages heavily for functionality, primarily the MELPA
repository. We initalize all the packages here, so we can use them
later.
  
#+BEGIN_SRC emacs-lisp :tangle yes
  ; marmalade is a third party repo that anyone can submit to, so has
  ; many more packages
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  
  (package-initialize)
#+END_SRC

When a package is installed, it's byte-compiled. However, git is set
up to ignore .elc files (see the .gitignore file). The system that
installs the file therefore has .elc files, but other systems need to
byte-compile those directories.

To make matters worse, we can't just compile on startup any package
files that aren't compiled already, since some files fail compilation
every time. Instead, we compile directories that don't contain any
.elc files.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; load the packages we've installed on another system but pulled in with git, so they aren't compiled
  (eval-when-compile '(require 'cl))
  (require 'dash)
  (require 's)
  
  (defun was-compiled-p (path)
    "Does the directory at PATH contain any .elc files?"
    (--any-p (s-ends-with-p ".elc" it) (directory-files path)))
  
  (defun no-dot-directories (directories)
    "Exclude the . and .. directory from a list."
    (--remove (or (string= "." (file-name-nondirectory it))
                  (string= ".." (file-name-nondirectory it)))
              directories))
  
  (defun ensure-packages-compiled ()
    "If any packages installed with package.el aren't compiled yet, compile them."
    (let* ((package-files (no-dot-directories (directory-files package-user-dir t)))
           (package-directories (-filter 'file-directory-p package-files)))
      (dolist (directory package-directories)
        (unless (was-compiled-p directory)
          (byte-recompile-directory directory 0)))))
  
  (ensure-packages-compiled)
  
  ;; todo: clean up orphaned .elc files
#+END_SRC

** Paths

We set up Emacs' exec-path based on PATH in a shell. This is primarily
for OS X, where starting Emacs in GUI mode doesn't inherit the shell's
environment. This ensures that any command we can call from a shell,
we can call inside Emacs.

Note this function comes from the package `exec-path-from-shell.el'.
  
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; set exec-path according to the system's PATH
  (exec-path-from-shell-initialize)
  
#+END_SRC

** UI

*** Theme

I like the tangotango theme, which depends on color-theme. In Emacs
24, this isn't necessary (todo: update this).

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/third-party-lisp/color-theme")
  (require 'color-theme)
  
  (require 'color-theme-tangotango)
  ;; load theme when we are started with $ emacsclient -c
  (add-hook 'after-make-frame-functions
            '(lambda (f)
               (with-selected-frame f
                 (when (window-system f)
                   (color-theme-tangotango)))))
  ;; load theme when we are started with $ emacs
  (when window-system
    (color-theme-tangotango))
  
#+END_SRC

*** Hiding and Showing

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; hide toolbar and scrollbar
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  
  ;; show x-position (ie column number) for point in buffer
  (column-number-mode 1)
#+END_SRC

** Moving Around

*** By Symbol

It's extremely useful to be able to move between different occurrences
of the same symbol.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-n") 'highlight-symbol-next)
  (global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+END_SRC

Jumping to the first occurrence of the symbol is handy for finding
where a symbol was imported.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun highlight-symbol-first ()
    "Jump to the first location of symbol at point."
    (interactive)
    (push-mark)
    (eval
     `(progn
        (goto-char (point-min))
        (search-forward-regexp
         (rx symbol-start ,(thing-at-point 'symbol) symbol-end)
         nil t)
        (beginning-of-thing 'symbol))))
  
  (global-set-key (kbd "M-P") 'highlight-symbol-first)
#+END_SRC

*** By indentation

`C-a' normally moves us to the beginning of the line
unconditionally. This version is more useful, as it moves to the
first non-whitespace character if we're already at the beginning of
the line. Repeated use of `C-a' toggles between these two positions.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun beginning-of-line-dwim ()
    "Toggles between moving point to the first non-whitespace character, and
  the start of the line."
    (interactive)
    (let ((start-position (point)))
      ;; see if going to the beginning of the line changes our position
      (move-beginning-of-line nil)
  
      (when (= (point) start-position)
          ;; we're already at the beginning of the line, so go to the
          ;; first non-whitespace character
          (back-to-indentation))))
  
  (global-set-key (kbd "C-a") 'beginning-of-line-dwim)
#+END_SRC
    
*** By Character

Vim has a handy command where you can type `f' to jump to the next
occurrence of a character on a line.

We can do this with `jump-char' without the constraint that the
character must be on the current line. This command needs to be
accessible with a short shortcut, so we use `M-m'. `M-m' is bound to
`back-to-indentation' by default, but our `C-a' behaviour makes it
redundant.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'jump-char)
  
  (global-set-key [(meta m)] 'jump-char-forward)
  (global-set-key [(shift meta m)] 'jump-char-backward)
  
#+END_SRC


** Killing

It's handy to also delete the trailing newline when using `C-k'.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice kill-line (around kill-line-remove-newline activate)
    (let ((kill-whole-line t))
      ad-do-it))
#+END_SRC

I sometimes want to simply delete a region, rather than
saving it to the kill-ring. I've added a function that allows me to
type `C-u C-w' to delete the region, whilst `C-w' works as normal.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun kill-or-delete-region (beg end prefix)
    "Delete the region, storing it in the kill-ring.
  If a prefix argument is given, don't change the kill-ring."
    (interactive "r\nP")
    (if prefix
        (delete-region beg end)
      (kill-region beg end)))
  
  (global-set-key (kbd "C-w") 'kill-or-delete-region)
  
#+END_SRC

** Files

*** Opening

It's useful to be able to quickly open files that we opened before. We
define a function for this:

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'recentf)
  
  ;; offer recently accessed files from the menu
  (recentf-mode t)
  
  ;; remember this many files
  (setq recentf-max-saved-items 200)
  
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
#+END_SRC

We bind this to `C-x C-r' (mnemonic: recent). By default, `C-x C-r' is bound to
`find-file-read-only', which isn't very useful. (You can set any file
as read only with `read-only-mode', mapped to `C-x C-q'.)

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
#+END_SRC

Most of the time though, it's helpful to be able to pick a file in the
same source code repository as the current buffer. There are several
tools to do this. The best I've found is `find-file-in-repository'.

`find-file-in-repository' uses command line commands to find out the
contents of your repository. For example, for git, it uses `git
ls-files` (see elisp:ffir-repository types for the full list). This
makes it very fast, and ensures that files ignored by git are ignored.

Alternatives worth mentioning are `projectile' and
`find-file-in-project'. Todo: say why.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'find-file-in-repository)
  
  (defadvice find-file-in-repository (around disable-ido-flex-matching activate)
    (let ((ido-enable-flex-matching nil)
          (ido-case-fold t))
      ad-do-it))
  
  (global-set-key (kbd "C-x C-g") 'find-file-in-repository)
  
  
#+END_SRC



*** Dired

Dired isn't very colourful by default, but `dired+' has helpful
highlighting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired+)
#+END_SRC

*** Deleting and Backups

When we delete a file, it should go to the recycle bin rather than
just acting like shell:rm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq delete-by-moving-to-trash t)
#+END_SRC

Emacs' backup behaviour is helpful, so we increase the number of
backups. However, rather than writing foo~1~ files everywhere, we
store all our backups in `~/.saves`.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq
     backup-by-copying t      ; don't clobber symlinks
     backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
     delete-old-versions t
     kept-new-versions 6
     kept-old-versions 2
     version-control t)       ; use versioned backups
#+END_SRC

** Flymake

(Note that there's language-specific flymake configuration too.)

It's really useful to be able to move between flymake errors, so we
bind F8 and F9 for this. Since there's a gap between these two keys,
they're easy to find.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'flymake)
  (global-set-key (kbd "<f8>") 'flymake-goto-prev-error)
  (global-set-key (kbd "<f9>") 'flymake-goto-next-error)
#+END_SRC

When the cursor (point) is on a line, we want to show the error on
that line in the minibuffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flymake-error-at-point ()
    "Show the flymake error in the minibuffer when point is on an invalid line."
    (when (get-char-property (point) 'flymake-overlay)
      (let ((help (get-char-property (point) 'help-echo)))
        (if help (message "%s" help)))))
  
  (add-hook 'post-command-hook 'flymake-error-at-point)
#+END_SRC

I prefer my error underlined.

#+BEGIN_SRC emacs-lisp :tangle yes
  (custom-set-faces
   '(flymake-errline ((((class color)) (:underline "Red"))))
   '(flymake-warnline ((((class color)) (:underline "Orange")))))
#+END_SRC
    
** Undoing

Emacs' undo facility is excellent, but undo-tree is even better.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'undo-tree)
  (global-undo-tree-mode)
#+END_SRC

** Python

Having brackets and quotation marks closed is very useful in
Python. Paredit isn't well suited for Python, and `electric-pair-mode`
isn't very smart. Autopair works nicely.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'autopair)
  (require 'python)
  (setq autopair-autowrap t)
  (add-hook 'python-mode-hook 'autopair-mode)
#+END_SRC

Python is too dynamic for a perfect autocomplete, but Jedi is an
excellent static analysis tool that gets us close. It gives us
autocompletion and a pop-up showing docstrings and arguments for
functions it knows about.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq jedi:setup-keys t)
  (require 'jedi)
  (setq jedi:server-command
        (list "python2" jedi:server-script))
  (add-hook 'python-mode-hook 'jedi:setup)
#+END_SRC

We use pyflakes with flymake to check for coding errors.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'flymake-python-pyflakes)
  (setq flymake-python-pyflakes-executable "pyflakes")
  (add-hook 'python-mode-hook 'flymake-python-pyflakes-load)
#+END_SRC

I prefer to write docstrings with example usage that aren't quite
valid doctests, so we switch off doctest checks.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setenv "PYFLAKES_NODOCTEST" "y")
#+END_SRC

** Less (CSS)

The less compiler doesn't give much feedback, but it does gives us a
syntax check.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'less-css-mode)
  (add-hook 'less-css-mode-hook 'flymake-mode)
#+END_SRC

** Org-mode

We often use code snippets in org-mode files, so syntax highlight
them.

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC


** Undocumented

#+BEGIN_SRC emacs-lisp :tangle yes
  ; always close the minibuffer on C-x o:
  ; <jlf> wilfredh: you could before-advise other-window to quit first
  ; if the minibuffer is active.. but it would be better to break that
  ; habit :)
  
  (require 'ui-customisations)
  
  (require 'file-customisations)
  (require 'editing-customisations)
  (require 'kill-ring-customisations)
  
  (if (eq system-type 'darwin)
      (require 'os-x-fixes))
  
  (defun start-scratch-file (file-name)
    "Create a file in ~/scratch for the given file name."
    (interactive "sName of scratch file: ")
    (let ((path (expand-file-name (format "~/scratch/%s" file-name))))
      ;; create directories as necessary
      (when (s-contains-p "/" file-name)
        (make-directory (file-name-directory path) t))
      (find-file path)))
  
  ; TODO: increase kill ring size
  
  (require 'ido-customisations)
  
  ;; make re-builder use the same regexp format as regexp-replace (no double escaping)
  (setq reb-re-syntax 'string)
  
  ;; treat space charcters as matching space characters, not like PCRE's '\s+'
  (setq search-whitespace-regexp nil)
  
  (require 'completion-customisations)
  (require 'structured-text-customisations)
  (require 'isearch-customisations)
  (require 'html-customisations)
  (require 'css-customisations)
  (require 'python-customisations)
  (require 'javascript-customisations)
  (require 'xml-customisations)
  (require 'lisp-customisations)
  (require 'haskell-customisations)
  (require 'c-customisations)
  (require 'sh-customisations)
  (require 'coffee-customisations)
  
  (require 'startup-customisations)
  
  (require 'editd-customisations)
  
  (require 'git-customisations)
  
  ;; stolen from http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/
  (defun narrow-to-region-indirect (start end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (let ((buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region start end))
      (switch-to-buffer buf)))
  
  (setq ag-highlight-search 't)
  (global-set-key (kbd "<f5>") 'ag-project-at-point)
  
  ;; stolen from http://whattheemacsd.com/setup-dired.el-02.html
  (defun dired-back-to-top ()
    (interactive)
    (beginning-of-buffer)
    (dired-next-line (if dired-omit-mode 2 4)))
  
  (define-key dired-mode-map
    (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)
  
  (defun dired-jump-to-bottom ()
    (interactive)
    (end-of-buffer)
    (dired-next-line -1))
  
  (define-key dired-mode-map
    (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
  
  (require 'conflicts)
  
  (require 'tags-utils)
  
  ;; crontab mode for files named
  (require 'crontab-mode)
  (add-to-list 'auto-mode-alist '("crontab.*?\\'" . crontab-mode))
  
  (require 'wiki)
  (setq major-mode 'text-mode)
  (setq wiki-directories (list (expand-file-name "~/Dropbox/Wiki/")))
  
  (setq ring-bell-function 'ignore)
  
  ; suspend seems to crash on Gnome 3, and I don't use it anyway, so just disable it
  (setq cannot-suspend t)
  (defun suspend-emacs (&rest)
    (interactive))
  (defun suspend-frame (&rest)
    (interactive))
  
  ;; windmove allows S-<right> and S-<right> to switch between windows
  ;; instead of `C-x o'
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
  
  (custom-set-variables
    ;; custom-set-variables was added by Custom.
    ;; If you edit it by hand, you could mess it up, so be careful.
    ;; Your init file should contain only one such instance.
    ;; If there is more than one, they won't work right.
   '(frame-background-mode (quote dark)))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(ahs-plugin-defalt-face ((t nil)))
   '(ethan-wspace-face ((t (:background "#2e3434"))))
   '(flymake-errline ((((class color)) (:underline "Red"))))
   '(flymake-warnline ((((class color)) (:underline "Orange"))))
   '(hl-line ((t (:background "gray14"))))
   '(hl-sexp-face ((t (:background "gray14"))))
   '(js2-function-param-face ((((class color)) (:foreground "Green"))))
   '(smerge-refined-change ((t (:background "black")))))
  
  ;; (require 'timing)
  ;; (message "Spent %.2f seconds executing .emacs.d/init.el."
  ;;          (time-difference *emacs-load-start* (current-time)))
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
