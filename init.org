* Emacs Configuration
** Introduction
This file is a literate programming document. To generate init.el, run
`M-x org-babel-tangle'. To generate init.html, run `M-x org-export-as-html'.

By default, all the sections in this document are collapsed. You can
expand a header by pressing `<TAB>' when point is on that header. You
can expand all headers by pressing `C-u C-u C-u <TAB>'.

You can edit any code block by putting point inside the block and
pressing `C-c '' (press `C-c '' again to escape). To use normal code
highlighting in the Org buffer, evaluate:

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

** Installing locally

This repository seeks to be as self-contained as possible. However, you will require:

*** Emacs 24

I use this repository with Emacs 24. Most code works with Emacs 23 but
I don't test it often.

*** Python

We include a copy of pyflakes. This copy requires `python2' to be available
on `$PATH'. This is from this fork of pyflakes:
https://github.com/kevinw/pyflakes since it's less prone to crashing
on invalid syntax (`{foo}' was a particular nuisance).

I also use Jedi, which has some dependencies you can install with:

#+BEGIN_SRC sh
  pip install -r elpa/jedi*/requirements.txt
#+END_SRC

*** JavaScript

I use JSHint, which requires you to have node.js installed. To
install JSHint, run:

#+BEGIN_SRC sh
  sudo npm install -g jshint
#+END_SRC

** Contents

*** Timing
To keep Emacs startup fast, it's helpful to measure how fast it is.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq *emacs-load-start* (current-time))
#+END_SRC

See the end of this document for where we use this data.

*** Folder Structure

Code I've written lives in user-lisp. This includes packages that I
haven't polished enough to release yet, small convenience functions,
and package customisations.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/user-lisp/")
#+END_SRC

Code that I haven't written lives in third-party-lisp. This directory
should ultimately disappear once all these packages live in MELPA.

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/third-party-lisp/")
#+END_SRC

*** Packages

I use ELPA packages heavily for functionality, primarily the MELPA
repository. We initalize all the packages here, so we can use them
later.
  
#+BEGIN_SRC emacs-lisp :tangle yes
  ; marmalade is a third party repo that anyone can submit to, so has
  ; many more packages
  (require 'package)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
  
  (package-initialize)
#+END_SRC

When a package is installed, it's byte-compiled. However, git is set
up to ignore .elc files (see the .gitignore file). The system that
installs the file therefore has .elc files, but other systems need to
byte-compile those directories.

To make matters worse, we can't just compile on startup any package
files that aren't compiled already, since some files fail compilation
every time. Instead, we compile directories that don't contain any
.elc files.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; load the packages we've installed on another system but pulled in with git, so they aren't compiled
  (eval-when-compile '(require 'cl))
  (require 'dash)
  (require 's)
  
  (defun was-compiled-p (path)
    "Does the directory at PATH contain any .elc files?"
    (--any-p (s-ends-with-p ".elc" it) (directory-files path)))
  
  (defun no-dot-directories (directories)
    "Exclude the . and .. directory from a list."
    (--remove (or (string= "." (file-name-nondirectory it))
                  (string= ".." (file-name-nondirectory it)))
              directories))
  
  (defun ensure-packages-compiled ()
    "If any packages installed with package.el aren't compiled yet, compile them."
    (let* ((package-files (no-dot-directories (directory-files package-user-dir t)))
           (package-directories (-filter 'file-directory-p package-files)))
      (dolist (directory package-directories)
        (unless (was-compiled-p directory)
          (byte-recompile-directory directory 0)))))
  
  (ensure-packages-compiled)
  
  ;; todo: clean up orphaned .elc files
#+END_SRC

*** Paths

We set up Emacs' exec-path based on PATH in a shell. This is primarily
for OS X, where starting Emacs in GUI mode doesn't inherit the shell's
environment. This ensures that any command we can call from a shell,
we can call inside Emacs.

Note this function comes from the package `exec-path-from-shell.el'.
  
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; set exec-path according to the system's PATH
  (exec-path-from-shell-initialize)
  
#+END_SRC

*** UI

**** Theme

I like the tangotango theme, which depends on color-theme. In Emacs
24, this isn't necessary (todo: update this).

#+BEGIN_SRC emacs-lisp :tangle yes
  (add-to-list 'load-path "~/.emacs.d/third-party-lisp/color-theme")
  (require 'color-theme)
  
  (require 'color-theme-tangotango)
  ;; load theme when we are started with $ emacsclient -c
  (add-hook 'after-make-frame-functions
            '(lambda (f)
               (with-selected-frame f
                 (when (window-system f)
                   (color-theme-tangotango)))))
  ;; load theme when we are started with $ emacs
  (when window-system
    (color-theme-tangotango))
  
#+END_SRC

**** Hiding and Showing

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; hide toolbar and scrollbar
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  
  ;; show x-position (ie column number) for point in buffer
  (column-number-mode 1)
#+END_SRC

*** Moving Around

**** By Symbol

It's extremely useful to be able to move between different occurrences
of the same symbol.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "M-n") 'highlight-symbol-next)
  (global-set-key (kbd "M-p") 'highlight-symbol-prev)
#+END_SRC

Jumping to the first occurrence of the symbol is handy for finding
where a symbol was imported.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun highlight-symbol-first ()
    "Jump to the first location of symbol at point."
    (interactive)
    (eval
     `(progn
        (goto-char (point-min))
        (search-forward-regexp
         (rx symbol-start ,(thing-at-point 'symbol) symbol-end)
         nil t)
        (beginning-of-thing 'symbol))))
  
  (global-set-key (kbd "M-S-p") 'highlight-symbol-first)
#+END_SRC

**** By Character

Vim has a handy command where you can type `f' to jump to the next
occurrence of a character on a line.

We can do this with `iy-go-to-char' without the constraint that the
character must be on the current line. This command needs to be
accessible with a short shortcut, so we use keychords. The keys may be
typed in either order, (i.e. `df' and `fd' both work), so we've chosen
letter combinations that occur rarely, and are easily typed.

#+BEGIN_SRC emacs-lisp :tangle yes
  (key-chord-mode 1)
  (key-chord-define-global "df" 'iy-go-to-char-backward)
  (key-chord-define-global "jk" 'iy-go-to-char)
#+END_SRC

Out of the box, `iy-go-to-char' is case-insensitive. It also puts
point after the mark, which is less helpful. We fix those
shortcomings.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice iy-go-to-char (around go-to-char-point-before activate)
    "Go to the next character case sensitively, and put point before the character."
    (let ((case-fold-search nil))
      (forward-char)
      ad-do-it
      (backward-char)))
#+END_SRC


*** Files

**** Opening

It's useful to be able to quickly open files that we opened before. We
define a function for this:

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'recentf)
  
  ;; offer recently accessed files from the menu
  (recentf-mode t)
  
  ;; remember this many files
  (setq recentf-max-saved-items 200)
  
  (defun ido-recentf-open ()
    "Use `ido-completing-read' to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file...")
      (message "Aborting")))
#+END_SRC

We bind this to `C-x C-r' (mnemonic: recent). By default, `C-x C-r' is bound to
`find-file-read-only', which isn't very useful. (You can set any file
as read only with `read-only-mode', mapped to `C-x C-q'.)

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)
#+END_SRC

Most of the time though, it's helpful to be able to pick a file in the
same source code repository as the current buffer. There are several
tools to do this. The best I've found is `find-file-in-repository'.

`find-file-in-repository' uses command line commands to find out the
contents of your repository. For example, for git, it uses `git
ls-files` (see elisp:ffir-repository types for the full list). This
makes it very fast, and ensures that files ignored by git are ignored.

Alternatives worth mentioning are `projectile' and
`find-file-in-project'. Todo: say why.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'find-file-in-repository)
  
  (defadvice find-file-in-repository (around disable-ido-flex-matching activate)
    (let ((ido-enable-flex-matching nil)
          (ido-case-fold t))
      ad-do-it))
  
  (global-set-key (kbd "C-x C-g") 'find-file-in-repository)
  
  
#+END_SRC



**** Dired

Dired isn't very colourful by default, but `dired+' has helpful
highlighting.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'dired+)
#+END_SRC

**** Deleting and Backups

When we delete a file, it should go to the recycle bin rather than
just acting like shell:rm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq delete-by-moving-to-trash t)
#+END_SRC

Emacs' backup behaviour is helpful, so we increase the number of
backups. However, rather than writing foo~1~ files everywhere, we
store all our backups in `~/.saves`.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq
     backup-by-copying t      ; don't clobber symlinks
     backup-directory-alist
      '(("." . "~/.saves"))    ; don't litter my fs tree
     delete-old-versions t
     kept-new-versions 6
     kept-old-versions 2
     version-control t)       ; use versioned backups
#+END_SRC

*** Flymake

(Note that there's language-specific flymake configuration too.)

It's really useful to be able to move between flymake errors, so we
bind F8 and F9 for this. Since there's a gap between these two keys,
they're easy to find.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'flymake)
  (global-set-key (kbd "<f8>") 'flymake-goto-prev-error)
  (global-set-key (kbd "<f9>") 'flymake-goto-next-error)
#+END_SRC

When the cursor (point) is on a line, we want to show the error on
that line in the minibuffer.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun flymake-error-at-point ()
    "Show the flymake error in the minibuffer when point is on an invalid line."
    (when (get-char-property (point) 'flymake-overlay)
      (let ((help (get-char-property (point) 'help-echo)))
        (if help (message "%s" help)))))
  
  (add-hook 'post-command-hook 'flymake-error-at-point)
#+END_SRC

I prefer my error underlined.

#+BEGIN_SRC emacs-lisp :tangle yes
  (custom-set-faces
   '(flymake-errline ((((class color)) (:underline "Red"))))
   '(flymake-warnline ((((class color)) (:underline "Orange")))))
#+END_SRC
    
*** Undoing

Emacs' undo facility is excellent, but undo-tree is even better.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'undo-tree)
  (global-undo-tree-mode)
#+END_SRC


*** Undocumented

#+BEGIN_SRC emacs-lisp :tangle yes
  ; always close the minibuffer on C-x o:
  ; <jlf> wilfredh: you could before-advise other-window to quit first
  ; if the minibuffer is active.. but it would be better to break that
  ; habit :)
  
  (require 'ui-customisations)
  (require 'startup-customisations)
  
  (require 'file-customisations)
  (require 'editing-customisations)
  (require 'kill-ring-customisations)
  
  (if (eq system-type 'darwin)
      (require 'os-x-fixes))
  
  (defun start-scratch-file (file-name)
    "Create a file in ~/scratch for the given file name."
    (interactive "sName of scratch file: ")
    (let ((path (expand-file-name (format "~/scratch/%s" file-name))))
      ;; create directories as necessary
      (when (s-contains-p "/" file-name)
        (make-directory (file-name-directory path) t))
      (find-file path)))
  
  ; TODO: increase kill ring size
  
  (require 'ido-customisations)
  
  ;; make re-builder use the same regexp format as regexp-replace (no double escaping)
  (setq reb-re-syntax 'string)
  
  ;; treat space charcters as matching space characters, not like PCRE's '\s+'
  (setq search-whitespace-regexp nil)
  
  (require 'completion-customisations)
  (require 'structured-text-customisations)
  (require 'isearch-customisations)
  (require 'html-customisations)
  (require 'css-customisations)
  (require 'python-customisations)
  (require 'javascript-customisations)
  (require 'xml-customisations)
  (require 'lisp-customisations)
  (require 'haskell-customisations)
  (require 'c-customisations)
  (require 'sh-customisations)
  (require 'coffee-customisations)
  
  (require 'editd-customisations)
  
  (require 'git-customisations)
  
  ;; stolen from http://demonastery.org/2013/04/emacs-narrow-to-region-indirect/
  (defun narrow-to-region-indirect (start end)
    "Restrict editing in this buffer to the current region, indirectly."
    (interactive "r")
    (let ((buf (clone-indirect-buffer nil nil)))
      (with-current-buffer buf
        (narrow-to-region start end))
      (switch-to-buffer buf)))
  
  (setq ag-highlight-search 't)
  (global-set-key (kbd "<f5>") 'ag-project-at-point)
  
  ;; stolen from http://whattheemacsd.com/setup-dired.el-02.html
  (defun dired-back-to-top ()
    (interactive)
    (beginning-of-buffer)
    (dired-next-line (if dired-omit-mode 2 4)))
  
  (define-key dired-mode-map
    (vector 'remap 'beginning-of-buffer) 'dired-back-to-top)
  
  (defun dired-jump-to-bottom ()
    (interactive)
    (end-of-buffer)
    (dired-next-line -1))
  
  (define-key dired-mode-map
    (vector 'remap 'end-of-buffer) 'dired-jump-to-bottom)
  
  (require 'conflicts)
  
  (require 'tags-utils)
  
  ;; crontab mode for files named
  (require 'crontab-mode)
  (add-to-list 'auto-mode-alist '("crontab.*?\\'" . crontab-mode))
  
  (require 'wiki)
  (setq major-mode 'text-mode)
  (setq wiki-directories (list (expand-file-name "~/Dropbox/Wiki/")))
  
  (setq ring-bell-function 'ignore)
  
  ; suspend seems to crash on Gnome 3, and I don't use it anyway, so just disable it
  (setq cannot-suspend t)
  (defun suspend-emacs (&rest)
    (interactive))
  (defun suspend-frame (&rest)
    (interactive))
  
  ;; windmove allows S-<right> and S-<right> to switch between windows
  ;; instead of `C-x o'
  (when (fboundp 'windmove-default-keybindings)
    (windmove-default-keybindings))
  
  (custom-set-variables
    ;; custom-set-variables was added by Custom.
    ;; If you edit it by hand, you could mess it up, so be careful.
    ;; Your init file should contain only one such instance.
    ;; If there is more than one, they won't work right.
   '(frame-background-mode (quote dark)))
  (custom-set-faces
   ;; custom-set-faces was added by Custom.
   ;; If you edit it by hand, you could mess it up, so be careful.
   ;; Your init file should contain only one such instance.
   ;; If there is more than one, they won't work right.
   '(ahs-plugin-defalt-face ((t nil)))
   '(ethan-wspace-face ((t (:background "#2e3434"))))
   '(flymake-errline ((((class color)) (:underline "Red"))))
   '(flymake-warnline ((((class color)) (:underline "Orange"))))
   '(hl-line ((t (:background "gray14"))))
   '(hl-sexp-face ((t (:background "gray14"))))
   '(js2-function-param-face ((((class color)) (:foreground "Green"))))
   '(smerge-refined-change ((t (:background "black")))))
  
  ;; (require 'timing)
  ;; (message "Spent %.2f seconds executing .emacs.d/init.el."
  ;;          (time-difference *emacs-load-start* (current-time)))
  (put 'narrow-to-region 'disabled nil)
#+END_SRC
